<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>复杂度分析</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="时间复杂度与空间复杂度"><a href="#时间复杂度与空间复杂度" class="headerlink" title="时间复杂度与空间复杂度"></a>时间复杂度与空间复杂度</h2><p>复杂度描述的是算法执行时间或者占用空间与数据规模的增长关系。  </p>
<h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><p>代码执行时间随数据规模增长的变化趋势，叫作渐进时间复杂度（asymptotic time complexity），简称<strong>时间复杂度</strong>。  </p>
<p>所有代码的执行时间T(n)与每行代码的执行次数成正比  </p>
<p><code>T(n) = O(f(n))</code>  </p>
<blockquote>
<p>其中T(n)表示算法执行的总时间，f(n)表示每行代码执行总次数，而n往往表示数据的规模。常量阶、低阶、系数对增长趋势不产生决定性影响，在做复杂度分析时可忽略这些项。</p>
</blockquote>
<h4 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h4><ol>
<li>单段代码看高频：比如循环。</li>
<li>多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。</li>
<li>嵌套代码求乘积：比如递归、多重循环等。</li>
<li>多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这是就取二者复杂度相加。</li>
</ol>
<h4 id="级别"><a href="#级别" class="headerlink" title="级别"></a>级别</h4><p><em>多项式量级</em>  随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。</p>
<ol>
<li>常量阶 O(1)  </li>
<li>对数阶 O(logn)  </li>
<li>线性阶 O(n)  </li>
<li>线性对数阶 O(nlogn)  </li>
<li>O(n<sup>2</sup>)平方阶、O(n<sup>3</sup>)立方阶……</li>
</ol>
<p><em>非多项式量级</em>  随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法的性能极差</p>
<ol start="6">
<li>指数阶 O(2<sup>n</sup>)  </li>
<li>阶乘阶 O(n!)  </li>
</ol>
<h3 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h3><p><strong>空间复杂度</strong>全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。  </p>
<p>类似于时间复杂度</p>
<h3 id="其他复杂度"><a href="#其他复杂度" class="headerlink" title="其他复杂度"></a>其他复杂度</h3><ol>
<li><p>最好情况时间复杂度（best case time complexity）  </p>
<blockquote>
<p>在最理想的情况下，执行这段代码的时间复杂度  </p>
</blockquote>
</li>
<li><p>最坏情况时间复杂度（worst case time complexity）</p>
<blockquote>
<p>在最糟糕的情况下，执行这段代码的时间复杂度  </p>
</blockquote>
</li>
<li><p>平均情况时间复杂度（average case time complexity）</p>
<blockquote>
<p>加权平均时间复杂度/期望时间复杂度<br>用代码在所有情况下执行的次数的加权平均值表示</p>
</blockquote>
</li>
<li><p>均摊时间复杂度（amortized time complexity）</p>
<blockquote>
<p>摊还分析、平摊分析。一种特殊的平均时间复杂度。<br>在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果等于低级别复杂度。（重点1、高级别少数2、低高出现具有时序规律）</p>
</blockquote>
</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>时间复杂度</tag>
        <tag>空间复杂度</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>链表的内存结构是不连续的内存空间，将一组零散的内存块串联起来进行数据存储的数据结构。</p>
<p>引子：缓存淘汰策略</p>
<blockquote>
<ul>
<li>先进先出FITO(First In,First Out)</li>
<li>最少使用LFU(Least Frequently Used)</li>
<li>最近最少使用LRU(Least Recently Used)</li>
</ul>
</blockquote>
<h4 id="常见链表结构"><a href="#常见链表结构" class="headerlink" title="常见链表结构"></a>常见链表结构</h4><ol>
<li>单链表  <blockquote>
<p>-&gt;(数据+后继指针next)-&gt;<br>首结点地址表示整条链表，尾结点的后继指针指向空地址null </p>
</blockquote>
</li>
<li>双向链表<blockquote>
<p>-&gt;(前驱指针prev+数据+后继指针next)-&gt;<br>首结点的前驱指针prev和尾结点的后继指针均指向空地址null</p>
<ul>
<li>给定数据值删除对应结点,需要从头到尾遍历时间复杂度O(n);  </li>
<li>给定结点地址删除结点,单链表需要从头到尾遍历前驱结点时间复杂度O(n),双向链表可以直接找到前驱结点时间复杂度O(1)。</li>
</ul>
</blockquote>
</li>
<li>循环链表<blockquote>
<p>尾结点的后继指针指向链表的首结点的地址</p>
</blockquote>
</li>
<li>双向循环链表</li>
</ol>
<h4 id="实现链表"><a href="#实现链表" class="headerlink" title="实现链表"></a>实现链表</h4><ol>
<li>理解指针或引用的含义(所指或引用对象的内存地址)<br>将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针；指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。</li>
<li>警惕指针丢失和内存泄漏<br>插入结点时，一定要注意操作的顺序；删除结点时，一定要记得手动释放内存空间。</li>
<li>利用哨兵简化实现难度<br>针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。利用哨兵解决边界问题，不直接参与业务逻辑。<br>引入哨兵结点，在任何时候，不管链表是不是空，head指针都会一直指向这个哨兵结点，哨兵结点不存储数据。</li>
<li>重点留意边界条件处理<br>链表为空、链表只包含一个结点、链表只包含两个结点、代码逻辑在处理头结点和尾结点等情况时，是否能正常工作。</li>
<li>举例画图，辅助思考  </li>
<li>多写多练，没有捷径<br>单链表反转、链表中环的检测、两个有序的链表合并、删除链表倒数第n个结点、求链表的中间结点</li>
</ol>
<h4 id="链表or数组"><a href="#链表or数组" class="headerlink" title="链表or数组"></a>链表or数组</h4><table>
<thead>
<tr>
<th>时间复杂度</th>
<th>数组</th>
<th>链表</th>
</tr>
</thead>
<tbody><tr>
<td>插入操作</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>随机访问</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
</tbody></table>
<p>与数组相比，链表除了存储数据，需要消耗更多的内存空间，存储后继指针。<br>对链表进行频繁的插入和删除操作，会导致频繁的内存申请和释放，容易造成内存碎片。</p>
<p>数组需要连续的内存空间。有利有弊，便于借助CPU缓冲机制于都数组中的数据；不能充分利用不连续的内存空间。<br>数组大小固定，若存储空间不足需要进行扩容，一旦扩容需要进行数据复制，非常耗时。</p>
<h4 id="链表实现LRU算法"><a href="#链表实现LRU算法" class="headerlink" title="链表实现LRU算法"></a>链表实现LRU算法</h4><p>维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有有一个新的数据被访问时，从链表头开始顺序遍历链表。  </p>
<blockquote>
<ol>
<li>数据之前已经被缓存在链表中了，将遍历得到的对应结点从原来的位置删除，然后再插入到链表的头部。</li>
<li>数据没有在缓存链表中，若缓存未满，将结点直接插入到链表的头部；若缓存已满，将链表尾结点删除，将新数据结点插入链表的头部。</li>
</ol>
</blockquote>
<h4 id="数组实现LRU算法"><a href="#数组实现LRU算法" class="headerlink" title="数组实现LRU算法"></a>数组实现LRU算法</h4><p>维护一个有序数组，越靠近数组尾部的元素是越早访问的，当有一个新的数据被访问时，从数组第一个元素开始遍历数组</p>
<blockquote>
<ol>
<li>数据在数组中，将当前数据对应元素前的元素后移一位，并将当前数据放入头部。</li>
<li>数据不在数组中，若缓存未满，将当前数组所有元素后移一位，将数据放入头部；若缓存已满，先删除数组最后一个元素，将数组所有元素后移一位，将数据放入头部。</li>
</ol>
</blockquote>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>单链表判断回文字符串</p>
<blockquote>
<p>快慢指针，链表反转</p>
</blockquote>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>队列</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>队列也是一种操作受限的线性表数据结构，具有先进者先出的特性。  </p>
<h4 id="实现队列"><a href="#实现队列" class="headerlink" title="实现队列"></a>实现队列</h4><p>队列主要包含两个操作：入队enqueue(),放一个数据到队列尾部；出队dequeue(),从队列头部取一个元素。<br>用数组实现的队列-<strong>顺序队列</strong>，多为有界队列。<br>队列需要两个指针：1指向队头的head指针；2指向队尾的tail指针。<br>顺序队列实现优化，出队时不搬移数据，入队时如果没有空闲空间集中触发一次数据的搬移操作。更进一步，循环队列可以避免数据搬移操作。<br>用链表实现的队列-<strong>链式队列</strong>，多为无界队列。<br>入队：tail-&gt;next=new_node,tail=tail-&gt;next(tail=new_node);<br>出队：head=head-&gt;next.</p>
<h4 id="特殊队列"><a href="#特殊队列" class="headerlink" title="特殊队列"></a>特殊队列</h4><ul>
<li>循环队列(基于数组)<br>与普通队列的区别关键在于队空和队满的判定条件<br>普通队列：队空<strong>head==tail</strong>,队满<strong>tail==n</strong>;<br>循环队列：队空<strong>head==tail</strong>,队满<strong>(tail+1)%n==head</strong>.  <blockquote>
<p>tail指向的位置没有存储数据，循环队列会浪费一个数组的存储空间。为了区分队空和队满。<br>普通队列队满的时候tail指向n，而不是n-1，不会浪费空间，数组中所有的位置都有数据。  </p>
</blockquote>
</li>
<li>阻塞队列（生产者-消费者模型）<br>在队列的基础上增加了阻塞操作：在队列为空的时候，从对头取数据会被阻塞；如果队列已满，插入数组的操作会被阻塞。  </li>
<li>并发队列<br>线程安全的队列<br>在入队、出队操作方法上加锁，锁粒度大并发度低。<br>基于数组的循环队列，利用CAS原子操作实现高效的并发队列。  </li>
</ul>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>资源有限场景中，没有空闲资源时，通过队列来实现请求排队。<br>线程池、数据库连接池等</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>数组</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>数组是一种<strong>线性表</strong>结构。它用一组<strong>连续的内存空间</strong>，来存储一组具有<strong>相同类型的数据</strong>。</p>
<h4 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h4><ol>
<li>线性表<blockquote>
<p>数组、链表、队列、栈  </p>
</blockquote>
</li>
<li>非线性表<blockquote>
<p>二叉树、堆、图  </p>
</blockquote>
</li>
</ol>
<h4 id="连续的内存空间和相同类型的数据-1"><a href="#连续的内存空间和相同类型的数据-1" class="headerlink" title="连续的内存空间和相同类型的数据  1"></a>连续的内存空间和相同类型的数据  <a href="#refer-anchor-1"><sup>1</sup></a></h4><p>寻址公式（数组下标从0开始 ，减少计算内存地址时的减法运算）</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">a[i]_address</span> = base_address + i * data_type_size</span><br></pre></td></tr></table></figure>
<ol>
<li>数组支持随机访问，根据下标随机访问的时间复杂度为O(1)。排好序的数组二分查找的时间复杂度为O(logn)</li>
<li>插入操作 大量数据搬移保证连续性<br>最好O(1)在数组末尾插入元素，不需要移动数据；<br>最坏O(n)在数组开头插入元素，所有数据都需要依次往后移动一位。<br>在每个位置插入元素的概率是一样的，平均时间复杂度为”(1+2+…n)/n=O(n)”；<br>优化：数组中存储的数据没有规律，只是作为一个存储数据的集合，避免大规模的数据搬移，在将某个数据插入到第k个位置时，直接将第k位的数据搬移到数组元素的最后，把新的元素直接放入第k个位置。<blockquote>
<p>快速排序的思想</p>
</blockquote>
</li>
<li>删除操作(大量数据搬移保证连续性)的平均时间复杂度为O(n)，最好O(1)，最坏O(n)<br>优化：先记录下已经删除的数据。每次的删除操作并不是真正的搬移数据，只是记录数据已经被删除了，当数组没有更多空间存储数据时，再触发执行一次真正的删除操作，从而大大减少删除操作导致的数据搬移。  <blockquote>
<p>JVM标记清除垃圾回收算法的核心思想</p>
</blockquote>
</li>
</ol>
<h4 id="数组or容器"><a href="#数组or容器" class="headerlink" title="数组or容器"></a>数组or容器</h4><p>容器：<br>将很多数组操作的细节封装起来，比如搬移数据；支持动态扩容。<br>数组：<br>存储基本类型，避免自动装箱拆箱的性能消耗；<br>数组大小事先已知、对数据的操作简单；<br>表示多维数组比较直观；<br>注重性能的底层开发。 </p>
<h4 id="参考-amp-扩展"><a href="#参考-amp-扩展" class="headerlink" title="参考&amp;扩展"></a>参考&amp;扩展</h4><div id="refer-anchor-1"></div>

<ul>
<li>[1] <a href="https://mp.weixin.qq.com/s/E-c41h2v_AfffrlAQpkyLg" target="_blank" rel="noopener">详解数据结构中的“数组”与编程语言中的“数组”的区别和联系</a> </li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>栈</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%88/</url>
    <content><![CDATA[<p>从栈的操作特性上看，栈是一种”操作受限”的线性表，只允许在一端插入和删除数据。并且满足先进后出、后进先出的特性。</p>
<h4 id="实现栈"><a href="#实现栈" class="headerlink" title="实现栈"></a>实现栈</h4><p>栈主要包含两个操作：入栈push()，在栈顶插入一个数据；出栈pop()，从栈顶删除一个数据。<br>用数组实现的栈-<strong>顺序栈</strong>。<br>用链表实现的栈-<strong>链式栈</strong>。<br>空间复杂度为O(1)<br>时间复杂度为O(1)<br>动态扩容的顺序栈的入栈操作的均摊时间复杂度为O(1)</p>
<h4 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h4><ul>
<li>函数调用栈<br>操作系统给每个线程分配了一块独立的内存空间，用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成返回之后，将这个函数对应的栈帧出栈。  </li>
<li>表达式求值<br>通过两个栈实现，其中一个保存操作数的栈，另一个是保存运算符的栈。从左向右遍历表达式，遇到数字就压入操作数栈；遇到操作符与运算符栈的栈顶元素进行比较，<br>比运算符栈顶元素的优先级高，将当前运算符压入栈；<br>比运算符栈顶元素的优先级低或者相同，从运算符中取栈顶运算符，从操作数栈顶取两个操作数，进行计算，把计算结果压入操作数栈。  </li>
<li>匹配括号<br>用栈保存未匹配的左括号，从左到右依次扫描字符串。扫描到左括号压入栈；扫描到右括号，从栈顶取出一个左括号进行匹配。</li>
<li>浏览器前进&amp;后退<br>两个栈实现，浏览页面依次压入栈X，后退时，从栈X中出栈，压入栈Y;前进时，从栈Y中出栈，压入栈X.</li>
</ul>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>JVM内存管理中堆栈</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>冒泡排序、插入排序、选择排序</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E3%80%81%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h4 id="排序算法分析方法"><a href="#排序算法分析方法" class="headerlink" title="排序算法分析方法"></a>排序算法分析方法</h4><ol>
<li>分析排序算法的执行效率  <ul>
<li>最好情况、最坏情况、平均情况时间复杂度以及原始数据的有序度(有序度不同对排序的执行时间有影响)</li>
<li>时间复杂度反应的是大规模数据的增长趋势，实际中规模小需要考虑系数、常数、低阶</li>
<li>元素比较次数和交换/移动次数（基于比较的排序算法）  </li>
</ul>
</li>
<li>排序算法的内存消耗（空间复杂度）  <ul>
<li><strong>原地排序</strong>算法：空间复杂度为O(1)的排序算法。</li>
</ul>
</li>
<li>排序算法的稳定性    <ul>
<li>稳定性：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。稳定的排序算法||不稳定的排序算法  </li>
</ul>
</li>
</ol>
<p>插入排序和冒泡排序的时间复杂度相同，都是O(n<sup>2</sup>)</p>
<a id="more"></a>

<h4 id="冒泡排序-1"><a href="#冒泡排序-1" class="headerlink" title="冒泡排序 1"></a>冒泡排序 <a href="#refer-anchor-1"><sup>1</sup></a></h4><p>冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求，如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复n次，就完成了n个数据的排序工作。<br>优化：当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。  </p>
<ol>
<li><p>冒泡过程只涉及相邻数据的交换操作，只需要常量级的临时空间，空间复杂度为O(1)，属于<strong>原地排序算法</strong>。</p>
</li>
<li><p>冒泡排序中只有交换才改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，不做交换，相同大小的数据在排序前后不会改变顺序，属于<strong>稳定的排序算法</strong>。</p>
</li>
<li><p>时间复杂度  </p>
<ul>
<li><strong>最好情况时间复杂度是O(n)</strong>，数据有序，进行一次冒泡操作;</li>
<li><strong>最坏情况时间复杂度O(n<sup>2</sup>)</strong>，数据倒序，进行n次冒泡操作。</li>
<li><strong>平均时间复杂度</strong>：对于包含n个数据的数组，这n个数据有n!种排序方式。不同的排列方式，冒泡排序执行的时间不同。用概率论方法定量分析平均时间复杂度较复杂。  </li>
</ul>
<p><strong>有序度</strong>：数组中具有有序关系的元素对的个数。有序元素对：a[i] &lt;= a[j];i&lt;j。<br>倒序排列的数组，有序度为0;<br>完全有序的数组，有序度n<em>(n-1)/2. 满有序度。<br>*</em>逆序度**。逆序元素对：a[i] &gt; a[j];i&lt;j。<br>逆序度 = 满有序度 - 有序度。排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度。  </p>
<p>冒泡排序包含两个操作原子，<strong>比较&amp;交换</strong>。每交换一次，有序度加1，交换次数是确定的，为逆序度：n<em>(n-1)/2 - 初始有序度。<br>对于包含n个数据的数组进行冒泡排序，最坏情况下，初始状态的有序度是0，要进行n</em>(n-1)/2次交换；最好情况下，初始状态的有序度是n<em>(n-1)/2，不需要进行交换。取中间值n</em>(n-1)/4来表示初始有序度。平均情况下要进行n<em>(n-1)/4次交换操作，比较操作比交换操作多，复杂度的上限是O(n<sup>2</sup>)，所以*</em>平均情况下的时间复杂度是O(n<sup>2</sup>)**。</p>
</li>
</ol>
<h4 id="插入排序-2"><a href="#插入排序-2" class="headerlink" title="插入排序 2"></a>插入排序 <a href="#refer-anchor-2"><sup>2</sup></a></h4><p>动态的往有序集合中添加数据，遍历数组找到数据应该插入的位置进行插入，保持集合中的数据一直有序。  </p>
<p>将数组中的数据分为两个区间：<strong>已排序区间&amp;未排序区间</strong>。初始已排序区间只有一个元素-数组的第一个元素。插入排序的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。  </p>
<p>插入排序包含两种操作：<strong>元素的比较</strong>，<strong>元素的移动</strong>。将一个数据a插入到已排序区间时，需要拿a与已排序区间的元素一次比较大小，找到合适的插入位置。找到插入点之后，需要将插入点之后的元素往后移动一位，腾出位置给元素a插入。 不同的查找插入点方法（从头到尾、从尾到头），元素的比较次数是有区别的，但对于一个给定的初始序列，移动操作的次数是固定等于逆序度。  </p>
<ol>
<li>插入排序算法的运行并不需要额外的存储空间，空间复杂度是O(1)，属于<strong>原地排序算法</strong>。</li>
<li>在插入排序中，对值相同的元素，可以选择将后面出现的元素，插入到前面出现元素的后面，这样可以保证原有的前后顺序不变，插入排序是<strong>稳定的排序算法</strong>。</li>
<li>时间复杂度<ul>
<li><strong>最好时间复杂度O(n)</strong>，数据有序，不需要搬移任何数据。如果从尾到头在有序数组里面查找插入位置，每次只需要比较一个数据（当前元素与其前一个元素比较，当前大不小于不用动）就能确定插入的位置。（内层循环只执行一次就break）</li>
<li><strong>最坏时间复杂度O(n<sup>2</sup>)</strong>，数据倒序，每次插入都相当于在数据的第一个位置插入新的数据，需要移动大量的数据。</li>
<li><strong>平均时间复杂度</strong>：在数组中插入一个数据的平均时间复杂度是O(n)（详见数组篇）。对于插入排序，每次插入操作都相当于在数组中插入一个数据，循环执行n次插入操作，<strong>平均时间复杂度为O(n<sup>2</sup>)</strong>。  </li>
</ul>
</li>
</ol>
<h4 id="选择排序-3"><a href="#选择排序-3" class="headerlink" title="选择排序  3"></a>选择排序  <a href="#refer-anchor-3"><sup>3</sup></a></h4><p>选择排序类似插入排序，分为已排序区间&amp;未排序区间。选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。  </p>
<ol>
<li>空间复杂度为O(1)，<strong>原地排序算法</strong>。</li>
<li>时间复杂度：<strong>最好、最坏、平均时间复杂度都为O(n<sup>2</sup>)</strong>。</li>
<li>选择排序是一种<strong>不稳定的排序算法</strong>。选择排序每次都要找到剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。  </li>
</ol>
<h4 id="插入与冒泡对比"><a href="#插入与冒泡对比" class="headerlink" title="插入与冒泡对比"></a>插入与冒泡对比</h4><p>冒泡跟插入不管怎么优化，元素移动的次数是一个固定值，等于原始数据的逆序度。<br>冒泡的数据交换要比插入的数据移动复杂，3个赋值操作&gt;1个赋值操作。</p>
<h4 id="参考-amp-扩展"><a href="#参考-amp-扩展" class="headerlink" title="参考&amp;扩展"></a>参考&amp;扩展</h4><div id="refer-anchor-1"></div>
- [1] 冒泡排序：  

<pre><code>public void bubbleSort(int[] a) {
    int n = a.length;
    if(n &lt;= 1) return;
    //未排序区间+已排序区间
    for (int i = 0; i &lt; n; i++) {
        boolean flag = false;
        //从第一个元素开始进行比较，选出前面剩余未排序区间（n-i-1）元素的最大值
        for(int j = 0; j &lt; n - i -1; j++) {
            //当前元素大于下一个元素值，交换两个元素位置
            if(a[j] &gt; a[j+1]) {
                int temp = a[j];
                a[j] = a[j+1];
                a[j+1] = temp;
                //有数据交换交换需要继续进行
                flag = true;
            }
        }
        if(!flag) break;
    }
    for (int i : a)
        System.out.print(i);
}  </code></pre><div id="refer-anchor-2"></div>  
- [2]插入排序：  

<pre><code>public void insertionSort(int[] a) {
    int n = a.length;
    if(n &lt;= 1) return;
    //已排序区间+未排序区间
    for (int i = 1; i &lt; n; i++) {
        //当前要排序（插入）的元素值
        int temp = a[i];
        //从已排序区间(i-1)元素最大下标，倒着一一进行比较
        int j = i - 1;
        for (; j &gt;= 0; j--) {
            if (a[j] &gt; temp) {
                //已排序区间目前元素值大于当前元素值，则交换位置，继续与前一个元素值比较
                a[j+1] = a[j];
            } else {
                break;
            }
        }
        //for循环中与j--之后的元素比较后break，最终移入的下标应为j++
        a[j+1] = temp;
    }
    for (int i : a)
        System.out.println(i);
}  </code></pre><div id="refer-anchor-3"></div>  
- [3]选择排序：

<pre><code>public void selectSort(int[] a) {
    int n = a.length;
    if(n &lt;= 1) return;
    //已排序区间+未排序区间
    for(int i=0;i&lt;n;i++){
         int min=i;
         //查找未排序区间最小元素的下标值
         for(int j=i+1;j&lt;n;j++){
              if(a[j] &lt; a[min]) min=j;
         }
         //将最小元素放到当前已排序区间的最后一位
         if(min != i){
              int temp=a[i];
              a[i]=a[min];
              a[min]=temp;
         }
    }
    for (int i : a)
        System.out.println(i);
}</code></pre><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>递归</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<p>方法或者函数调用自身的方式称为递归调用，调用称为递，返回称为归。<br>用栈的数据结构加上简单的逻辑算法实现业务功能。  </p>
<h4 id="递归特点"><a href="#递归特点" class="headerlink" title="递归特点"></a>递归特点</h4><ul>
<li>一个问题的解可以分解为几个子问题的解</li>
<li>原问题与分解后的子问题，除了数据规模不同，求解思路完全一样</li>
<li>存在递归终止条件</li>
</ul>
<p>关键：<br>找到如何将大问题分解为小问题的规律，基于此写出递推公式，推敲终止条件，最后将递推公式和终止条件翻译成代码。<br>遇到递归，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤，把它抽象成一个递推公式。</p>
<h4 id="递归问题"><a href="#递归问题" class="headerlink" title="递归问题"></a>递归问题</h4><ul>
<li>栈溢出<a href="#refer-anchor-1"><sup>1</sup></a><br>函数调用会使用栈来保存临时变量，每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时才出栈。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有栈溢出的风险。<br>解决：1.最大深度比较小的情况，在代码中限制递归调用的最大深度。2.数据规模较大的情况，用非递归-循环代码实现。</li>
<li>重复计算<br>解决：通过一个数据结构（散列表）来保存已经求解过的f(k)，当递归调用到f(k)时，先看下是否已经求解过。如果是则直接从散列表中取值返回，不需要重复计算。</li>
<li>时间空间成本</li>
</ul>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>所有的递归代码都可以改为迭代循环的非递归写法</p>
<blockquote>
<p>递归本身依然是借助栈实现的。抽象出递推公式、初始值、边界条件，用迭代循环实现。</p>
</blockquote>
<p>递归代码的调试方法</p>
<blockquote>
<p>日志中打印递归值<br>添加条件语句进行断点调试  </p>
</blockquote>
<p>检测递归中环的存在</p>
<blockquote>
<p>通过散列表保存已计算完成的数据，每次递归调用，先去散列表中查询，没有查到的话就加入，如果存在则表示存在环。  </p>
</blockquote>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><div id="refer-anchor-1"></div>

<ul>
<li>[1] <a href="https://mp.weixin.qq.com/s/Ki3WN2AJ5HhxxmaQ0lVh3Q" target="_blank" rel="noopener">还有程序员天真地以为”尾递归“真的可以避免堆栈溢出！</a> </li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>线性排序</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>时间复杂度为O(n)的线性排序算法：桶排序、计数排序、基数排序。<br>算法是非基于比较的排序算法（主排序是非比较的），不涉及元素之间的比较操作。对要排序的数据要求比较苛刻。  </p>
<h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><ul>
<li><p>原理<br>核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。</p>
</li>
<li><p>时间复杂度<br>如果要排序的数据有n个，把他们均匀的划分到m个桶内，每个桶有k=n/m个元素。每个桶内部使用快速排序，时间复杂度为O(k<em>logk)。m个桶排序的时间复杂度为O(m</em>k<em>logk)。因为k=n/m，所以整个桶排序的时间复杂度为O(n</em>log(n/m))。当桶的个数m接近数据个数n时，log(n/m)为一个非常小的常量，这时桶排序的时间复杂度接近O(n)。  </p>
</li>
<li><p>适用场景<br>排序的数据需要很容易就能划分为m个桶，桶与桶之间有着天然的大小顺序，每个桶内的数据都排序完成之后，桶与桶之间的数据不需要再进行排序。<br>数据再各个桶之间的分布是比较均匀的。如果数据经过桶的划分之后，有的桶数据非常多，有的非常少，那桶内数据排序的时间复杂度就不是常量级了。在极端情况下，如果数据都被划分到一个桶里，那就退化为O(nlogn)的排序算法了。  </p>
<p>桶排序适合用在外部排序中。数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。  </p>
</li>
</ul>
<h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><ul>
<li><p>时间复杂度<br>计数排序是桶排序的一种特殊情况。当要排序的n个数据，所处的范围并不大的时候，比如最大值为k，可以把数据划分成k个桶，每个桶内的数据值都是相同的，省去了桶内排序的时间。只涉及扫描遍历操作，时间复杂度为O(n)。  </p>
</li>
<li><p>原理<br>计数排序用一个数据范围大小的统计数组C[k+1]（原数组A中元素取值范围为0-k），下标k等于原数组A中元素的值，遍历原数组A将各个元素值出现的次数存储在统计数组C对应下标中c[k]（即C[k]存储的是原数组A等于k的元素的个数）。然后对统计数组C顺序求和，各个下标处C[k]存储的是小于等于k的元素个数。<br>扫描原数组A（从后面开始遍历-保证稳定性），依次取出元素的值如a作为统计数组C的下标得到统计数组C对应的值C[a]，说明到目前为止，原数组A中小于等于a的值还有C[a]个，元素a是排好序的新数组R中的第C[a]个元素(放在新数组R下标为C[a]-1的位置)，将其a放入新数组R后，原数组A小于等于a的元素剩下C[a]-1个，则统计数组C[a]=C[a]-1，类推取原数组A下一个元素值。（从后往前做减法，确定该值可以放的最大下标）</p>
</li>
<li><p>适用场景<br>计数排序只能用在数据范围不大的场景中，如果数据范围k比要排序的数据n大很多，就不适合用计数排序。而且计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。  </p>
</li>
</ul>
<h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><ul>
<li><p>原理<br>以11位手机号排序为例，如果前面几位中，其中一个数据已经比较大了，那么后几位就不用看了。先按照最后一位排序，再按照倒数第二位排序，以此类推，最后按照第一位排序，经过11次排序后，手机号有序。要求按照每位来排序的排序算法是稳定的。  </p>
</li>
<li><p>时间复杂度<br>根据每位来排序，可以用桶排序或者计数排序，时间复杂度可以做到O(n)。如果要排序的数据有k位，那么需要进行k次桶排序或者计数排序，总的时间复杂度是O(k*n)。当k不大时，基数排序的时间复杂度就近似于O(n)。  </p>
</li>
<li><p>适用场景<br>基数排序要求要排序的数据可以分割出独立的“位”来比较，而且位之间有递进关系-数据可以划分成高低位。比较两个数只需要比较高位，高位相同再比较低位。<br>每一位的数据范围不能太大，要借助线性排序算法-桶排序/计数排序来完成每一位的排序工作，否则计数排序的时间复杂度无法做到O(n)。  </p>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>桶排序：分桶-快排/归并<br>计数排序：分桶-计数-统计<br>基数排序：高位桶排序-低位桶排序</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序、快速排序</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>归并排序和快速排序的时间复杂度为O(nlogn)。利用分治思想将大问题分解成小问题解决；利用递归代码实现归并排序。  </p>
<h4 id="归并排序1"><a href="#归并排序1" class="headerlink" title="归并排序1"></a>归并排序<a href="#refer-anchor-1"><sup>1</sup></a></h4><p>先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起。  </p>
<ul>
<li>递推公式:<br>merge_sort(p…r) = merge(merge_sort(p…q),merge_sort(q+1…r))  </li>
<li>终止条件：<br>p = r 不用再继续分解  <blockquote>
<p>merge_sort(p…r)表示给下标从p到r之间的数组排序。将此问题转化为了两个子问题：merge(merge_sort(p…q),merge_sort(q+1…r))，其中下标q等于p和r的中间位置(p+r)/2。当下标从p到q和从q+1到r这两个子数组都排好序之后，再将两个有序的子数组合并在一起，那么下标从p到r之间的数据也就排好序了。<br>合并函数merge([p…r],[p…q],[q+1…r])，申请一个临时数组temp,大小与数组[p…r]相同。用两个游标i和j，分别指向[p…q]和[q+1…r]的第一个元素。比较这两个元素[i]、[j]的大小，将较小的元素放入到临时数组temp中，并将相应的游标后移一位。  </p>
</blockquote>
</li>
</ul>
<ol>
<li><p>归并排序是一个<strong>稳定的排序算法</strong>，合并数组时，遇到值相同的元素，现将[p…q]区间的元素放入到临时数组temp中，保证值相同的元素在合并前后的先后顺序不变。  </p>
</li>
<li><p>最好、最坏、平均情况时间复杂度都是<strong>O(nlogn)</strong>。  </p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line"><span class="built_in">T</span>(<span class="number">1</span>) = C；   <span class="built_in">n</span>=<span class="number">1</span>时，只需要常量级的执行时间，所以表示为C。</span><br><span class="line"><span class="built_in">T</span>(<span class="built_in">n</span>) = <span class="number">2</span>*<span class="built_in">T</span>(<span class="built_in">n</span>/<span class="number">2</span>) + <span class="built_in">n</span>； <span class="built_in">n</span>&gt;<span class="number">1</span></span><br><span class="line">     = <span class="number">2</span>*(<span class="number">2</span>*<span class="built_in">T</span>(<span class="built_in">n</span>/<span class="number">4</span>) + <span class="built_in">n</span>/<span class="number">2</span>) + <span class="built_in">n</span> = <span class="number">4</span>*<span class="built_in">T</span>(<span class="built_in">n</span>/<span class="number">4</span>) + <span class="number">2</span>*<span class="built_in">n</span></span><br><span class="line">     = <span class="number">4</span>*(<span class="number">2</span>*<span class="built_in">T</span>(<span class="built_in">n</span>/<span class="number">8</span>) + <span class="built_in">n</span>/<span class="number">4</span>) + <span class="number">2</span>*<span class="built_in">n</span> = <span class="number">8</span>*<span class="built_in">T</span>(<span class="built_in">n</span>/<span class="number">8</span>) + <span class="number">3</span>*<span class="built_in">n</span></span><br><span class="line">     = <span class="number">8</span>*(<span class="number">2</span>*<span class="built_in">T</span>(<span class="built_in">n</span>/<span class="number">16</span>) + <span class="built_in">n</span>/<span class="number">8</span>) + <span class="number">3</span>*<span class="built_in">n</span> = <span class="number">16</span>*<span class="built_in">T</span>(<span class="built_in">n</span>/<span class="number">16</span>) + <span class="number">4</span>*<span class="built_in">n</span></span><br><span class="line">     ......</span><br><span class="line">     = <span class="number">2</span>^k * <span class="built_in">T</span>(<span class="built_in">n</span>/<span class="number">2</span>^k) + k * <span class="built_in">n</span></span><br><span class="line">     ......</span><br></pre></td></tr></table></figure>
<p>当T(n/2^k)=T(1)时，k=log<sub>2</sub>n，T(n)=Cn+nlog<sub>2</sub>n  </p>
</li>
<li><p>归并排序<strong>不是原地排序算法</strong>。<br>归并排序在合并两个有序数组为一个有序数组时，需要借助额外的存储空间。每次合并操作都需要申请额外的内存空间，但在合并完成之后，临时开辟的内存空间就被释放掉了。在任意时刻，CPU只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过n个数据的大小，<strong>空间复杂度是O(n)</strong>。  </p>
</li>
</ol>
<h4 id="快速排序2"><a href="#快速排序2" class="headerlink" title="快速排序2"></a>快速排序<a href="#refer-anchor-2"><sup>2</sup></a></h4><p>如果要排序数组中下标从p到r之间的一组数据，选择p到r之间的任意一个数据作为分区点(pivot)。遍历p到r之间的数据，将小于pivot的放到左边，将大于pivot的放到右边，将pivot放到中间。这样数组p到r之间的数据被分成了三个部分，前面p到q-1之间都是小于pivot的，中间是pivot，后面的q+1到r之间是大于pivot的。<br>根据分治、递归的处理思想，可以用递归排序下标从p到q-1之间的数据和下标从q+1到r之间的数据，直到区间缩小为1，就说明所有的数据都有序了。  </p>
<ul>
<li>递推公式：<br>quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1…r)  </li>
<li>终止条件：<br>p = r  <blockquote>
<p>快速排序中的分区函数partition()，随机选择一个元素作为分区点pivot，一般情况下可以选择p到r区间的最后一个元素，对数组进行分区，函数返回分区点pivot的下标。  </p>
</blockquote>
</li>
</ul>
<ol>
<li><p>空间复杂度</p>
<ul>
<li>不考虑空间消耗可以申请两个临时数组X和Y，遍历数组，将小于分区点的元素拷贝到临时数组X，大于分区点的元素拷贝到临时数组Y，最后将数组X、Y中的数据顺序拷贝到原数组中。   </li>
<li>原地分区操作，类似选择排序<br>通过游标i将数组[p…r-1]分成两部分，已处理区间[p…i-1]和未处理区间[i…r-1]，每次从未处理区间中取出一个元素[j]和分区点对比，如果小于，则将其加入到已处理区间的尾部[i]的位置。优化：不搬移数据，交换操作，将a[i]与a[j]交换。</li>
</ul>
</li>
<li><p>涉及交换操作，属于<strong>不稳定的排序算法</strong>。  </p>
</li>
<li><p>时间复杂度<br>分区极其均衡，每次分区操作都能正好把数组分成大小接近相等的两个小区间，<strong>最好时间复杂度为O(nlogn)</strong>。<br>分区极其不均衡，数组正序，需要n次分区操作，每次分区平均要扫描n、2个元素，<strong>最坏时间复杂度为O(n<sup>2</sup>)</strong>。<br>大部分情况下的时间复杂度都可以做到O(nlogn)，只有在极端情况下，才会退化到O(n<sup>2</sup>)。<strong>平均时间复杂度O(nlogn)</strong>。   </p>
</li>
</ol>
<h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p>归并排序的处理过程是由下到上的，先处理子问题，然后再合并。<br>快速排序的处理过程是由上到下的，先分区，然后再处理子问题。</p>
<h4 id="参考-amp-扩展"><a href="#参考-amp-扩展" class="headerlink" title="参考&amp;扩展"></a>参考&amp;扩展</h4><div id="refer-anchor-1"></div>  
[1] 归并排序  

<pre><code>//归并排序
public void mergeSort(int[] a) {
    mergeSortInter(a,0,a.length-1);
}
public void mergeSortInter(int[] a,int start,int end) {
    //终止条件
    if(start==end) return;

    //中间结点
    int mid = (start+end)/2;

    mergeSortInter(a,start,mid);
    mergeSortInter(a,mid+1,end);

    //合并函数
    merge(a,start,mid,end);
}
public void merge(int[] a,int left,int mid,int right) {
    //临时数组，大小为当前分区的大小
    int[] temp = new int[right - left + 1];

    int m = 0, i = left, j = mid + 1;
    while (i &lt;= mid &amp;&amp; j &lt;= right) {
        //取左右区间中元素最小值放入当前位置
        temp[m++] = a[i] &lt;= a[j] ? a[i++] : a[j++];
    }
    //拷贝剩余数据到临时数组
    while (i &lt;= mid)
        temp[m++] = a[i++];
    while (j &lt;= right)
        temp[m++] = a[j++];

    //拷贝临时数据到原数组对应区间
    for (int k=0;k &lt;= right-left;k++)
        a[left+k] = temp[k];
}</code></pre><div id="refer-anchor-2"></div>  
[2] 快速排序  

<pre><code>//快速排序
public void quickSort(int[] a) {
    quickSortInter(a,0,a.length-1);
}

public void quickSortInter(int[] a,int start,int end) {
    //终止条件  start 可能大于end
    if(start&gt;=end) return;

    //分区函数获取分区点
    int p = partition(a,start,end);

    quickSortInter(a,start,p-1);
    quickSortInter(a,p+1,end);
}

public int partition(int[] a,int start,int end) {
    //取当前分区最后一个元素做分区点
    int pivot = a[end];
    //记录下一个小于分区点元素值的元素应放置的下标
    int i = start;
    for(int j = start; j &lt; end; j++) {
        //当前元素与分区点元素值比较，小于则当前元素与上一个小于分区点元素的后一个元素进行交换
        if(a[j] &lt; pivot) {
            if(i != j) {
                int temp = a[i];
                a[i] = a[j];
                a[j] = temp;
            }
            i++;
        }
    }

    //分区点元素值与最后一个小于分区点元素的后一个元素进行交换
    int temp = a[i];
    a[i] =a[end];
    a[end] = temp;

    return i;
}</code></pre><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>排序优化</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>算法</th>
<th>时间复杂度</th>
<th>稳定</th>
<th>原地</th>
</tr>
</thead>
<tbody><tr>
<td>冒泡</td>
<td>O(n<sup>2</sup>)</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>插入</td>
<td>O(n<sup>2</sup>)</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>选择</td>
<td>O(n<sup>2</sup>)</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>归并</td>
<td>O(nlogn)</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>快速</td>
<td>O(nlogn)</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>桶</td>
<td>O(n)</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>计数</td>
<td>O(n+k) k是数据范围</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>基数</td>
<td>O(dn) d是维度</td>
<td>Y</td>
<td>N</td>
</tr>
</tbody></table>
<h4 id="优化快排"><a href="#优化快排" class="headerlink" title="优化快排"></a>优化快排</h4><p>最坏情况下快排的时间复杂度是O(n<sup>2</sup>)，如果数据本来就是有序的或者接近有序的，每次分区点都选择最后一个数据，那快速排序算法的时间复杂度就会退化为O(n<sup>2</sup>)。主要愿意是分区点选的不够合理。  </p>
<p>最理想的分区点是：被分区点分开的两个分区中，数据的数量差不多。</p>
<ul>
<li>三数取中法<br>从区间的首、尾、中间分别取出一个数，然后对比大小，取这3个数的中间值作为分区点。如果要排序的数组比较大，可以使用五数取中、十数取中。  </li>
<li>随机法<br>每次从要排序的区间中，随机选择一个元素作为分区点。不能保证每次分区点都选择的比较好，但是从概率的角度来看，也不大可能出现每次分区点都选的很差的情况，平均情况下，这样选的分区点是比较好的。  </li>
</ul>
<p>快排是用递归来实现的，递归要警惕堆栈溢出。避免递归过深而堆栈过小，导致堆栈溢出。  </p>
<ul>
<li>限制递归深度，一旦递归过深，超过了设定的阈值就停止递归。  </li>
<li>在堆上模拟实现一个函数调用栈，手动模拟递归压栈、出栈的过程，这样就没有了系统栈大小的限制。(将递归调用改写为循环非递归方式)  </li>
</ul>
<p>时间复杂度代表的是一个增长趋势。大O复杂度表示法中，会省略低阶、系数、常数。在小规模数据面前，O(n<sup>2</sup>)时间复杂度的算法并不一定比O(nlogn)的算法执行时间长。</p>
<h4 id="排序函数"><a href="#排序函数" class="headerlink" title="排序函数"></a>排序函数</h4><p>Java<br>基础数据类型：<br>Arrays.sort() -&gt; DualPivotQuicksort.sort()  </p>
<ul>
<li>元素个数&lt;47，插入排序</li>
<li>元素个数47-286，快速排序</li>
<li>元素个数&gt;286，归并排序（类似TimSort）  </li>
</ul>
<p>对象类型：<br>Collections.sort() -&gt; Arrays.sort() -&gt; TimSort  </p>
<ul>
<li><p>元素个数&lt;32，采用二分查找插入排序Binary Sort；  </p>
</li>
<li><p>元素个数&gt;=32，采用归并排序，归并的核心是分区Run;  </p>
</li>
<li><p>找连续升或者降的序列作为分区，分区最终被调整为升序后压入栈；  </p>
</li>
<li><p>如果分区长度太小，通过二分插入排序扩充分区长度到分区最小阈值minrun；  </p>
</li>
<li><p>每次压入栈，都要检查栈内已存在的分区是否满足合并条件，满足则进行合并；  </p>
</li>
<li><p>最终栈内分区被全部合并，得到一个排序好的数组。  </p>
<blockquote>
<p>TimSort合并：<br>  找出左分区最后一个元素在右分区的位置；<br>  找出右分区第一个元素在左分区的位置；<br>  仅对这两个位置之间的元素进行合并，之外的元素本身就是有序的。  </p>
</blockquote>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>散列表</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%A3%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<h4 id="散列思想"><a href="#散列思想" class="headerlink" title="散列思想"></a>散列思想</h4><p>散列表用的数组支持按照下标随机访问数据的特性，是数组的一种扩展，由数组演化而来。没有数组，就没有散列表。   </p>
<p>键/key/关键字–标识唯一数据<br>散列函数/Hash函数/哈希函数–将键转化为数组下标的映射方法<br>散列值/Hash值/哈希值–散列函数计算得到的值    </p>
<p>通过散列函数把元素的键值映射为下标（取模），然后将数据存储在数组中对应下标的位置。按照键值查询元素时，用同样的散列函数，将键值转化为数组下标，从对应的数组下标的位置取数据。  </p>
<h4 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h4><p>散列函数–<strong>hash(key)</strong>，其中key表示元素的键值，hash(key)的值表示经过散列函数计算得到的散列值。  </p>
<p>散列函数设计的基本要求：  </p>
<ul>
<li>散列函数计算得到的散列值是一个非负整数；</li>
<li>如果key1=key2，那hash(key1) == hash(key2)；</li>
<li>如果key1!=key2，那hash(key1) != hash(key2)；<blockquote>
<p>数组的存储空间有限，找到一个不同的key对应的散列值都不一样的散列函数，几乎是不可能的。必然存在散列冲突。   </p>
</blockquote>
</li>
</ul>
<h4 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h4><p>再好的散列函数也无法避免散列冲突，常用的散列冲突解决方法有两类：开放寻址法、链表法。  </p>
<ol>
<li><p>开放寻址法<br>如果出现散列冲突，就重新探测一个空闲位置，将其插入。  </p>
<ul>
<li><p>线性探测<br>往散列表中<strong>插入</strong>数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。<br>在散列表中<strong>查找</strong>元素的过程类似插入过程。通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，则说明就是我们要找的元素；否则就顺序往后依次查找。如果遍历到数组中的空闲位置，还没有找到，就说明要查找的元素并没有在散列表中。<br>使用线性探测法解决冲突的散列表，不能单纯的把要<strong>删除</strong>的元素设置为空。在查找的时候，一旦通过线性探测方法，找到一个空闲位置，可以认定散列表中不存在这个数据。但是如果这个空闲位置是我们后来删除的，就会导致原来的查找算法失效。本来存在的数据会被认定为不存在。解决方案，将删除的元素特殊标记为deleted，当线性探测查找的时候，遇到标记为deleted的空间，并不是停下来，而是继续往下探测。  </p>
<p>缺陷：当散列表中插入的数据越来越多时，散列冲突发生的可能性会越来越大，空闲位置会越来越少，线性探测的时间会越来越久，极端情况下，可能需要探测整个散列表，所以最坏情况下的时间复杂度为O(n)。在删除和查找时也可能会探测整张散列表，才只能找到要查找或者删除的数据。  </p>
</li>
<li><p>二次探测<br>类似线性探测，线性探测每次探测的步长是1，探测的下标序列是hash(key)+0,hash(key)+1,hash(key)+2…二次探测的步长变成了原来的“二次方”，探测的下标序列是hash(key)+0,hash(key)+1<sup>2</sup>,hash(key)+2<sup>2</sup>…  </p>
</li>
<li><p>双重散列<br>不仅仅使用一个散列函数。使用一组散列函数hash1(key),hash2(key),hash3(key)…先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。  </p>
</li>
</ul>
<p>不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，尽可能保证散列表中有一定比列的空槽位置。用<strong>装载因子</strong>来表示空位的多少。<br>计算公式：  </p>
<blockquote>
<p>散列表的装载因子=填入表中的元素个数/散列表的长度   </p>
</blockquote>
<p>装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。  </p>
</li>
<li><p>链表法<br>在散列表中，每个“桶”或者“槽”会对应一条链表，所有散列值相同的元素都放到相同槽位对应的链表中。<br>当插入的时候，只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，所以插入的时间复杂度是O(1)。当查找/删除一个元素时，同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除。查找、删除的时间复杂度跟链表的长度k成正比O(k)。对于散列比较均匀的散列函数来说，k=n/m，其中n表示散列中数据的个数，m表示散列表中“槽”的个数。  </p>
</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>散列表</tag>
      </tags>
  </entry>
  <entry>
    <title>位图</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BD%8D%E5%9B%BE/</url>
    <content><![CDATA[<h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><p>将网页链接存储在散列表中。散列表需维持较小的装载因子，保证不会出现过多的散列冲突，导致操作的性能下降。需要的内存空间过大时，采用分治的思想，用多台机器进行存储。  </p>
<h3 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h3><p>有1千万个整数，整数的范围在1到1亿之间。快速查找某个整数是否在这1千万个整数中。  </p>
<p>申请一个大小为1亿、数据类型为布尔类型(true/false)的数组。将这1千万个整数作为数组下标，将对应的数组设置成true。<br>当查询某个整数K是否在这1千万个整数中的时候，只需要将对应的数组值array[K]取出来，看是否等于true。如果等于true，说明1千万整数中包含这个整数K；相反，就表示不包含这个整数K。  </p>
<p>布尔类型大小是1个字节，只需要一个二进制位(bit)就可以表示true和false两个值。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        位图-借助char类型通过位运算实现
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java中char类型占16bit，也就是2个字节（1字节8bit）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitMap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] bytes;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> nbits;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BitMap</span><span class="params">(<span class="keyword">int</span> nbits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nbits = nbits;</span><br><span class="line">        <span class="keyword">this</span>.bytes = <span class="keyword">new</span> <span class="keyword">char</span>[nbits/<span class="number">16</span>+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k &gt; nbits) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> byteIndex = k/<span class="number">16</span>;</span><br><span class="line">        <span class="keyword">int</span> bitIndex = k%<span class="number">16</span>;</span><br><span class="line">        bytes[byteIndex] |= (<span class="number">1</span> &lt;&lt; bitIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k &gt; nbits) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> byteIndex = k/<span class="number">16</span>;</span><br><span class="line">        <span class="keyword">int</span> bitIndex = k%<span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (bytes[byteIndex] &amp; (<span class="number">1</span> &lt;&lt; bitIndex)) != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<blockquote>
<p>将数字A的第K位设置为1：A = A|(1 &lt;&lt; (k-1));<br>将数字A的第K位设置为0：A = A&amp;~(1 &lt;&lt; (k-1));<br>检测数字A的第k位：A&amp;(1 &lt;&lt; (k-1)) != 0;</p>
</blockquote>
<p>位图通过数组下标来定位数据，访问效率非常高。每个数字用一个二进制位来表示，在数字范围不大的情况下，所需要的内存空间非常节省。  </p>
<h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>布隆过滤器是对位图的一种改进，针对数据范围较大的数据。  </p>
<p>数据个数是1千万，数据的范围是1到10亿。仍然使用一个1亿个二进制大小的位图，然后通过哈希函数，对数字进行处理，让它落在这1到1亿范围内。  </p>
<p>一个哈希函数可能会存在冲突，用多个哈希函数一块定位一个数据。<br>使用K个哈希函数，对同一个数字进行求哈希值，会得到K个不同的哈希值，分别记作X<sub>1</sub>,X<sub>2</sub>,X<sub>3</sub>,…,X<sub>k</sub>。把k个数字作为位图中的下标，将对应的BitMap[X<sub>1</sub>],BitMap[X<sub>2</sub>],BitMap[X<sub>3</sub>],…,BitMap[X<sub>k</sub>]都设置成true，也就是用k个二进制位，来表示一个数字的存在。  </p>
<p>当要查询某个数字是否存在的时候，用同样的K个哈希函数，对这个数字求哈希值，分别得到Y<sub>1</sub>,Y<sub>2</sub>,Y<sub>3</sub>,…,Y<sub>k</sub>。看这k个哈希值，对应位图中的数值是否都为true，如果都是true，则说明，这个数字存在，如果有其中任意一个不为true，那就说明这个数字不存在。  </p>
<p>对于两个不同的数字来说，经过一个哈希函数处理之后，可能会产生相同的哈希值。但是经过K个哈希函数处理之后，k个哈希值都相同的概率就非常低了。尽管采用k个哈希函数之后，两个数字哈希冲突的概率降低了，但是这种处理方式又带来了新的问题，容易误判。  </p>
<p>布隆过滤器只会对存在的情况有误判。如果某个数字经过布隆过滤器判断不存在，那就说明这个数字真的不存在，不会发生误判；如果某个数字经过布隆过滤器判断存在，可能误判，有可能并不存在。  </p>
<p>布隆过滤器用多个哈希函数对同一个网页链接进行处理，CPU只需要将网页链接从内存中读取一次，进行多次哈希计算，理论上讲这组操作是CPU密集型的。<br>而在散列表的处理方式中，需要读取散列值相同（散列冲突）的多个网页链接，分别跟判重的网页链接，进行字符串匹配，这个操作涉及很多内存数据的读取，是内存密集型的。<br>CPU计算比内存访问更快。  </p>
<p>当布隆过滤器中，数据个数与位图大小的比例超过某个阈值的时候，就重新申请一个新的位图。后面来的新数据，会被放置到新的位图中。如果要判断某个数据是否在布隆过滤器中已经存在，需要查看多个位图。  </p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>Java-BitSet<br>Redis-BitMap<br>Google-Guava-BloomFilter  </p>
<p>[1] <a href="https://mp.weixin.qq.com/s/xxauNrJY9HlVNvLrL5j2hg" target="_blank" rel="noopener">漫画：Bitmap算法 整合版</a> </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>位图</tag>
        <tag>布隆过滤器</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p>二分查找算法-折半查找算法  </p>
<h4 id="二分思想"><a href="#二分思想" class="headerlink" title="二分思想"></a>二分思想</h4><p>二分查找针对的是一个有序的数据集合，查找思想类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为0。  </p>
<h4 id="查找速度O-logn"><a href="#查找速度O-logn" class="headerlink" title="查找速度O(logn)"></a>查找速度O(logn)</h4><p><strong>数组：</strong><br>假设数据大小是n，每次查找后数据都会缩小为原来的一半，也就是除以2。最坏情况下，直到查找区间被缩小为空才停止。被查找区间的大小变化n,n/2,n/4,n/8,…,n/2<sup>k</sup>…为一个等比数列，当n/2<sup>k</sup>=1时，k的值就是总共缩小的次数。而每一次缩小操作只涉及两个数据的大小比较，所以经过了k次区间缩小操作，时间复杂度就是O(k)。通过n/2<sup>k</sup>，可以求得k=log<sub>2</sub>n，所以时间复杂度就是O(logn)。   </p>
<p>对数时间复杂度是一直极其高效的时间复杂度，有的时候甚至常量级时间复杂度的算法还要高效。  </p>
<p><strong>链表：</strong><br>假设链表长度为n，二分查找每次都要找到中间结点：<br>第一次查找中间结点需要移动指针n/2次;<br>第二次，需要移动n/4次；<br>第三次，需要n/8次；<br>。。。<br>以此类推，一直到1次为止。<br>指针一共移动次数k=n/2+n/4+n/8+…+1，等比数列求和为n-1。<br>时间复杂度为O(n)。与顺序查找时间复杂度相同。但二分查找需要进行多余的运算，比顺序查找慢。</p>
<h4 id="递归与非递归实现"><a href="#递归与非递归实现" class="headerlink" title="递归与非递归实现"></a>递归与非递归实现</h4><p>最简单的情况就是有序数组中不存在重复元素，用二分查找值等于给定值的数据。  </p>
<pre><code>//非递归
public int bsearch(int[] a,int value) {
    int low = 0;
    int high = a.length-1;
    while(low &lt;= high) {
        int mid = (low+high) / 2;
        if(a[mid] == value) {
            return mid;
        } else if(a[mid] &lt; value) {
            low = mid + 1;
        } else {
            high = mid -1;
        }
    }
    return -1;
}</code></pre><blockquote>
<p>low、high、mid都是指数组下标，low和high表示当前查找的区间范围，初始low=0,high=n-1。mid表示[low,high]的中间位置，通过a[mid]与value的大小，来更新接下来要查找的区间范围，直到找到或者区间缩小为0就退出。  </p>
</blockquote>
<ul>
<li>循环退出条件<br>low&lt;=high  </li>
<li>mid取值<br>mid=(low+high)/2。<br>low + (high - low) /2;避免low和high比较大时，两者和溢出。<br>将除以2转化成位运算low+((high-low)&gt;&gt;1)。注意位运算优先级  </li>
<li>low和high的更新<br>low=mid+1&amp;high=mid-1。<br>low=mid|high=mid可能发生死循环。  </li>
</ul>
<pre><code>//递归
public int bsearch(int[] a,int value) {
    return bserachInter(a,0,a.length-1,value);
}

private int bserachInter(int[] a,int low,int high,int value) {
    if(low &gt; high) return -1;
    int mid = low + ((high-low)&gt;&gt;1);
    if(a[mid] == value) {
        return mid;
    } else if(a[mid] &lt; value) {
        return bserachInter(a,mid+1,high,value);
    } else {
        return bserachInter(a,low,high+1,value);
    }
}</code></pre><h4 id="应用场景局限性"><a href="#应用场景局限性" class="headerlink" title="应用场景局限性"></a>应用场景局限性</h4><ul>
<li><p>二分查找依赖的是顺序表结构-数组<br>二分查找算法需要按照下标随机访问数组。数组按照下标随机访问数据的时间复杂度是O(1)，链表随机访问的时间复杂度是O(n)。如果数据使用链表存储，二分查找的时间复杂度会变得很高。<br>二分查找只能用在数据是通过顺序表来存储的数据结构上，如果数据是通过其他数据结构存储的，则无法使用二分查找。 </p>
</li>
<li><p>二分查找针对的是有序数据<br>数据必须是有序的。如果数据无序，需要先排序，排序的时间复杂度最低是O(nlogn)。如果针对的是一组静态的数据，没有频繁的插入、删除，可以进行一次排序、多次二分查找。这样排序的成本可被均摊，二分查找的边际成本就会比较低。<br>数据集合有频繁的插入和删除操作，要想用二分查找，要么每次插入、删除操作之后保证数据仍然有序，要么在每次二分查找之前都先进行排序。针对动态数据，无论什么方法，维护有序的成本都很高。(二叉树)  </p>
</li>
<li><p>数据量太小不适合二分查找<br>数据量很小，顺序便利足够。但是数据之间的比较操作非常耗时，不管数据量大小，都推荐二分查找，尽可能的减少比较次数，大大提高性能。  </p>
</li>
<li><p>数据量太大不适合二分查找<br>二分查找底层依赖数组这种数据结构，数组为了支持随机访问特性，要求内存空间连续，对内存的要求比较苛刻。即使拥有更多的内存空间剩余，如果是零散的不连续，依然无法申请相应大小的数组。  </p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>变体二分查找</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8F%98%E4%BD%93%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h4 id="查找第一个值等于给定值的元素"><a href="#查找第一个值等于给定值的元素" class="headerlink" title="查找第一个值等于给定值的元素"></a>查找第一个值等于给定值的元素</h4><pre><code>public int bsearch(int[] a,int value) {
    int low = 0;
    int hight = a.length - 1;
    while(low &lt;= high) {
        int mid = low + ((high - low) &gt;&gt; 1);
        if(a[mid] &gt; value) {
            high = mid + 1;
        }else if(a[mid] &lt; value) {
            low = mid + 1;
        } else {
            if((mid == 0) || (a[mid - 1] != value)) {
                return mid;
            } else {
                high = mid -1;
            }
        }
    }
    return -1;
}</code></pre><p>a[mid]跟目标value的大小关系有三种情况：大于、小于、等于。  </p>
<ul>
<li>对于a[mid] &gt; value的情况，需要更新high=mid-1；  </li>
<li>对于a[mid] &lt; value的情况。需要更新low=mid+1；  </li>
<li>当a[mid] = value时：如果查找的是任意一个值等于给定值的元素，a[mid]就是要找的元素。如果查找的是第一个值等于给定值的元素，需要进一步确认：代码中如果mid=0，那么这个元素已经是数组的第一个元素，那它肯定是要找的元素；如果mid!=0，但a[mid]的前一个元素a[mid-1]!=value，那么a[mid]就是要找的元素；如果经过检查后发现a[mid-1]=value，则a[mid]肯定不是要找的第一个值等于给定值的元素，需要更新high=mid-1，要找的元素肯定出现在[low,mid-1]之间。  </li>
</ul>
<h4 id="查找最后一个值等于给定值的元素"><a href="#查找最后一个值等于给定值的元素" class="headerlink" title="查找最后一个值等于给定值的元素"></a>查找最后一个值等于给定值的元素</h4><pre><code>public int bsearch(int[] a,int value) {
    int low = 0;
    int high = a.length - 1;
    while(low &lt;= high) {
        int mid = low + ((high -low) &gt;&gt; 1);
        if(a[mid] &gt; value) {
            high = mid - 1;
        } else if(a[mid] &lt; value) {
            low = mid + 1;
        } else {
            if((mid == a.length -1) || (a[mid + 1] != value)) {
                return mid;
            } else {
                low = mid + 1;
            }
        }
    }
    return -1;
}  </code></pre><ul>
<li>当a[mid] = value时：如果mid=0，a[mid]已经是数组中最后一个元素，那它肯定是要找的元素；如果a[mid]的后一个元素a[mid+1]!=value，那么a[mid]是要找的元素；如果经过检查后发现a[mid+1]=value，那a[mid]不是最后一个值等于给定值的元素，需要更新low=mid+1，要找的元素肯定出现在[mid+1,high]之间。  </li>
</ul>
<h4 id="查找第一个大于等于给定值的元素"><a href="#查找第一个大于等于给定值的元素" class="headerlink" title="查找第一个大于等于给定值的元素"></a>查找第一个大于等于给定值的元素</h4><pre><code>public int bsearch(int a[],int value) {
    int low = 0;
    int high = a.length -1;
    while(low &lt;= high) {
        int mid = low + ((high -low) &gt;&gt; 1);
        if(a[mid] &gt;= value) {
            if((mid == 0) || (a[mid - 1] &lt; value)) {
                return mid;
            } else {
                high = mid - 1;
            }
        } else {
            low = mid + 1;
        }
    }
    return -1;
}</code></pre><ul>
<li>如果a[mid] &lt; value，那要找的值肯定在[mid+1,high]之间，所以更新low=mid+1；  </li>
<li>对于a[mid] &gt;= value的情况，首先判断a[mid]是不是要找的第一个值大于等于给定值的元素。如果mid=0,a[mid]前面已经没有元素就是第一个元素，那么a[mid]就是要找的元素；或者a[mid]前面的一个元素a[mid-1]小于指定值value，那么a[mid]就是要找的元素。如果a[mid-1]&gt;=value，那么说明要找的元素在[low,mid-1]之间。  </li>
</ul>
<h4 id="查找最后一个小于等于给定值的元素"><a href="#查找最后一个小于等于给定值的元素" class="headerlink" title="查找最后一个小于等于给定值的元素"></a>查找最后一个小于等于给定值的元素</h4><pre><code>public int bsearch(int[] a,int value) {
    int low = 0;
    int high = a.length -1;
    while(low &lt;= high) {
        int mid = low + ((high -low) &gt;&gt; 1);
        if(a[mid] &gt; value) {
            high = mid -1;
        } else {
            if((mid == a.length -1) || (a[mid +1] &gt; value)) {
                return mid;
            } else {
                low = mid + 1;
            }
        }
    }
    return -1;
}</code></pre><h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>凡是用二分查找能解决的，绝大部分更倾向于用散列表或者二叉查找树。二分查找更适合用在“近似”查找问题，用其他数据结构比较难实现。<br>变体二分查找实现注意细节问题：</p>
<ul>
<li>终止条件  </li>
<li>区间上下界更新方法  </li>
<li>返回值选择  </li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>散列表应用</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%A3%E5%88%97%E8%A1%A8%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>散列表支持非常高效的数据插入、删除、查找操作，但是散列表中的数据都是通过散列函数打乱之后无规律的存储的，无法支持按照某种顺序快速地遍历数据。如果希望按照顺序遍历散列表中的数据，需要将散列表中的数据拷贝到数组中，然后排序再遍历。<br>散列表是动态数据结构，不停地有数据的插入、删除，每次希望按顺序遍历散列表中的数据的时候，都需要先排序，效率很低，为了解决这个问题，将散列表和链表（或者跳表）结合在一起使用。  </p>
<h4 id="LRU缓存淘汰算法"><a href="#LRU缓存淘汰算法" class="headerlink" title="LRU缓存淘汰算法"></a>LRU缓存淘汰算法</h4><ul>
<li><p>通过链表实现LRU缓存淘汰算法：维护一个按照访问时间从大到小有序排列的链表结构。因为缓存大小有限，当缓存空间不够，需要淘汰一个数据的时候，直接将链表头部的结点删除。<br>当要缓存某个数据的时候，先在链表中查找这个数据。如果没有找到，则直接将数据放到链表的尾部；如果找到了，就把它移动到链表的尾部。因为查找数据需要遍历链表，所以单纯使用链表实现的LRU缓存淘汰算法的时间复杂度很高为O(n)。  </p>
</li>
<li><p>将散列表和链表两种结构组合使用，可以将添加、删除、查找操作的时间复杂度都降低到O(1)。使用双向链表存储数据，链表中的每个节点除了存储数据data、前驱指针prev、后继指针next之外，还新增了一个特殊的字段hnext。这里的散列表通过链表法解决散列冲突，每个节点会在两条链中。一个链式双向链表，一个是散列表中的拉链。前驱和后继指针将结点串在双向链表中，hnext指针将结点串在散列表的拉链中。  </p>
<blockquote>
<ul>
<li>查找数据，散列表中查找数据的时间复杂度为O(1)。找到数据之后将其移动到双向链表的尾部。  </li>
<li>删除数据，散列表中在O(1)时间复杂度里找到要删除的结点，双向链表中通过前驱指针O(1)时间复杂度获取前驱结点。则删除结点的时间复杂度为O(1)。  </li>
<li>添加数据，先判断数据是否已经在缓存中。如果存在，需要将其移动到双向链表的尾部；如果不存在，判断缓存是否已满，如果已满，则将双向链表头部的结点删除在将数据放到链表的尾部，如果未满，则直接将数据放到链表的尾部。<br>涉及查找操作都通过散列表来完成，其他删除、插入操作通过链表来完成，只需更改指针指向。时间复杂度都为O(1)。  </li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="Redis有序集合"><a href="#Redis有序集合" class="headerlink" title="Redis有序集合"></a>Redis有序集合</h4><p>有序集合中，每个成员对象有两个重要的属性，键值key和分值score，可以通过score查找数据，也可以通过key来查找数据。<br>按照分值将对象组织成跳表的结构<br>按照键值构建一个散列表   </p>
<h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><p>通过散列表和双向链表组合实现。Linked指的是双向链表，并非指用链表法解决散列冲突。<br>不仅支持按照插入顺序遍历数据，还支持按照访问数据遍历数据。  </p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 10是初始大小，0.75是装载因子，true是表示按照访问时间排序</span></span><br><span class="line">HashMap&lt;<span class="built_in">Integer</span>, <span class="built_in">Integer</span>&gt; m = <span class="literal">new</span> LinkedHashMap&lt;&gt;(<span class="number">10</span>, <span class="number">0.75</span>f, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>散列表</tag>
      </tags>
  </entry>
  <entry>
    <title>散列表扩展</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%A3%E5%88%97%E8%A1%A8%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<p>散列函数、装载因子、散列冲突等都会影响散列表的查询效率。<br>极端情况，所有的数据经过散列函数之后，都散列到同一个槽里，如果使用基于链表的冲突解决方法，散列表就会退化为链表，查询的时间复杂度从O(1)急剧退化为O(n)。  </p>
<h4 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h4><p>散列函数设计的好坏，决定了散列表冲突的概率大小，也直接决定了散列表的性能。  </p>
<ul>
<li>散列函数的设计不能太复杂<br>过于复杂的撒捏函数，会消耗很多计算时间，间接影响到散列表的性能。  </li>
<li>散列函数生成的值要尽可能随机并且均匀分布<br>避免或者最小化散列冲突，即便出现冲突，散列到每个槽里的数据也会比较平均，不会出现某个槽内数据特别多的情况。  </li>
<li>考虑关键字的长度、特点、分布、散列表的大小等其他因素  </li>
</ul>
<p>数据分析法<br>直接寻址法<br>平方取中法<br>折叠法<br>随机数法<br>。。。</p>
<h4 id="装载因子"><a href="#装载因子" class="headerlink" title="装载因子"></a>装载因子</h4><p>装载因子越大说明散列表中的元素越多，空闲位置越少，散列冲突的概率就越大。插入数据的过程要多次寻址或者拉很长的链，查找的过程也会变得很慢。  </p>
<ul>
<li>静态数据<br>没有频繁的插入和删除的静态数据集合。  </li>
<li>动态散列表<br>数据集合是频繁变动的，事先无法预估将要加入的数据个数，无法事先申请一个足够大的散列表。随着数据慢慢加入，装载因子就会慢慢变大。当装载因子过大时，需要进行动态扩容。<br>散列表的大小变了，数据的存储位置也变了，需要通过散列函数重新计算每个数据的存储位置。<br>插入一个数据，最好情况下不需要扩容，最好时间复杂度为O(1)；最坏情况下，散列表装载因子过高启动扩容，需要重新申请内存空间，重新计算哈希位置，并且搬移数据，时间复杂度为O(n)。用摊还分析法，均摊情况下，时间复杂度接近最好情况O(1)。<br>随着数据的删除，散列表中的数据会越来越少，空闲空间会越来越多。如果对空间消耗非常敏感，可以在装载因子小于某个值之后，启动动态缩容。<br>装载因子阈值的设置要权衡时间、空间复杂度。同事要避免数据的插入和删除导致频繁的扩容和缩容。  </li>
</ul>
<h4 id="动态扩容"><a href="#动态扩容" class="headerlink" title="动态扩容"></a>动态扩容</h4><p>大部分情况下，动态扩容的散列表插入一个数据都很快，当装载银子啊已经达到阈值，需要先进行扩容，再插入数据，插入数据就会变得很慢。<br>解决一次性扩容耗时过多的情况，可以将扩容操作穿插在插入操作的过程中，分批完成。当装载时因子触达阈值之后，只申请新空间，但并不将老的数据搬移到新散列表中。<br>当新数据要插入时，将新数据插入新散列表中，并从老散列表中拿出一个数据放入到新散列表。每次插入一个数据到散列表，重复上述过程，避免了集中一次性数据搬移。任何情况下，插入一个数据的时间复杂度都是O(1)。<br>查询操作，兼容新、老散列表的数据，先从新散列表中查找，如果没有找到，再去老散列表中查找。  </p>
<h4 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h4><ul>
<li><p>开放寻址法<br>数据量小、装载因子小。ThreadLocalMap  </p>
<p>优点：<br>散列表的数据存储在数组中，可以有效利用CPU缓存加快查询速度，序列化起来比较简单。  </p>
<p>缺点：<br>删除数据比较麻烦，需要特殊标记已经删掉的数据。所有的数据存储在一个数组中，冲突的代价高。装载因子的上限不能太大，浪费内存空间。  </p>
</li>
<li><p>链表法<br>大对象、大数据量。LinkedHashMap  </p>
<p>优点：<br>内存利用率高。链表结点可以在需要的时候再创建，并不需要事先申请好。<br>对大装载因子的容忍度高。只要散列函数的值随机均匀，更大的装载因子也就是链表的长度变长了而已，虽然查找效率有所下降，但是比顺序查找快。  </p>
<p>缺点：<br>链表要存储指针，对于比较小的对象的存储比较消耗内存。如果存储的是大对象，要存储的对象的大小远远大于一个指针的大小（4个字节或者8个字节），指针的内存消耗在大对象面前可以忽略。<br>链表中的结点是零散分布在内存中的，不是连续的，对CPU缓存是不友好的，对执行效率有一定影响。  </p>
<p>将链表法中的链表改造为其他高效的动态数据结构：跳表、红黑树。极端情况下，所有的数据都散列到同一个桶内，查找的时间复杂度为O(logn)，能避免散列碰撞攻击。  </p>
</li>
</ul>
<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><ul>
<li><p>初始大小<br>默认初始大小16。  </p>
</li>
<li><p>装载因子&amp;动态扩容<br>默认0.75。当hashMap中元素个数超过0.75*capacity的时候，就会启动自动扩容，每次扩容都会扩容为原来的两倍大小。  </p>
</li>
<li><p>散列冲突<br>链表法。会出现拉链过长的情况，影响HashMap的性能。<br>JDK1.8中，引入了红黑树，当链表长度太长（TREEIFY_THRESHOLD超过8且数组长度-哈希表容量MIN_TREEIFY_CAPACITY大于64）时，链表就转换为红黑树。当红黑树的结点个数小于6时（UNTREEIFY_THRESHOLD），会将红黑树转化为链表。避免频繁插入/删除导致数据结构频繁转换发生抖动。    </p>
</li>
<li><p>散列函数   </p>
<pre><code>
int hash(Object key) {
    int h = key.hashCode()；
    return (h ^ (h &gt;&gt;&gt; 16)) &amp; (capicity -1); //capicity表示散列表的大小
}

public int hashCode() {
  int var1 = this.hash;
  if(var1 == 0 &amp;&amp; this.value.length &gt; 0) {
    char[] var2 = this.value;
    for(int var3 = 0; var3 &lt; this.value.length; ++var3) {
      var1 = 31 * var1 + var2[var3];
    }
    this.hash = var1;
  }
  return var1;
}</code></pre><p>hashcode是32位整型值，4294967296，获取对象的hashcode后，先进行移位运算，再和自己做异或运算=&gt;hashcode ^ (hashcode &gt;&gt;&gt; 16)，将高16位移到16位，混合原哈希码的高位和低位，计算出来的整型值具有高位和低位的性质，并加大了低位的随机性。<br>用hash表当前的容量减一，再和计算出来的整型值做位于运算A % B = A &amp; (B - 1)，当B是2的指数时等式成立。即(h ^ (h &gt;&gt;&gt; 16)) &amp; (capitity -1) = (h ^ (h &gt;&gt;&gt; 16)) % capitity，即除留余数法保证位置分布均匀。</p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>散列表</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><p>每个元素代表一个结点，相邻节点之间的连线关系，称为父子关系。<br>父节点<br>子节点<br>兄弟节点：节点的父节点是同一个节点<br>根节点：没有父节点的节点<br>叶子节点/叶节点：没有子节点的节点  </p>
<p>节点的高度=节点到叶子节点的最长路径(边数)。起点是0，从下往上<br>节点的深度=根节点到这个所经历的边的个数。起点是0，从上往下<br>节点的层数=节点的深度+1。起点是1，从上往下<br>树的高度=根节点的高度  </p>
<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>每个节点最多有两个叉-两个子节点，分别是左子节点和右子节点。但不要求每个节点都有两个子节点，有的节点只有左子节点，有的节点只有右子节点。<br>满二叉树：叶子节点全部在最底层，除叶子节点之外，每个节点都有左右两个子节点。<br>完全二叉树：叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其它层的节点个数都要达到最大。  </p>
<h4 id="存储-表示一棵二叉树"><a href="#存储-表示一棵二叉树" class="headerlink" title="存储/表示一棵二叉树"></a>存储/表示一棵二叉树</h4><ol>
<li>基于指针或者引用的二叉链式存储法<br>每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针。只要拎住根节点，就可以通过左右子节点的指针，把整棵树都串起来。  </li>
<li>基于数组的顺序存储法<br>把根节点存储在下标i=1的位置，左子节点存储在下标2<em>i=2的位置，右子节点存储在2</em>i+1=3的位置。以此类推。<br>如果节点X存储在数据中下标为i的位置，下标为i<em>2的位置存储的就是左子节点，下标为2</em>i+1的位置存储的就是右子节点。反过来，下标为i/2的位置存储的是它的父节点。只要知道根节点存储的位置(一般为下标为1的位置，便于计算)，可以通过下标计算，把整棵树都串起来。<br>完全二叉树，仅仅浪费了一个下标为0的存储位置，如果是非完全二叉树，会浪费比较多的数组存储空间。如果某棵二叉树是完全二叉树，那用数组存储无疑是最节省内存的一种方式。(堆-完全二叉树)  </li>
</ol>
<h4 id="遍历二叉树-递归1"><a href="#遍历二叉树-递归1" class="headerlink" title="遍历二叉树-递归1"></a>遍历二叉树-递归<a href="#refer-anchor-1"><sup>1</sup></a></h4><ol>
<li><p>前序遍历<br>对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。  </p>
</li>
<li><p>中序遍历<br>对于树中的任意节点来说，先打印它的左子树，再打印它本身，最后打印它的右子树。  </p>
</li>
<li><p>后序遍历<br>对于树中的任意节点来说，先打印它的左子树，再打印它的右子树，最后打印这个节点本身。  </p>
<p> 递推公式：  </p>
 <figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">前序遍历  </span><br><span class="line">preOrder<span class="function"><span class="params">(r)</span> = <span class="title">print</span> <span class="title">r</span> -&gt;</span> preOrder<span class="function"><span class="params">(r-&gt;left)</span> -&gt;</span> preOrder(r-&gt;right)  </span><br><span class="line">中序遍历  </span><br><span class="line">inOrder<span class="function"><span class="params">(r)</span> = <span class="title">inOrder</span><span class="params">(r-&gt;left)</span> -&gt;</span> <span class="built_in">print</span> r<span class="function"> -&gt;</span> inOrder(r-&gt;right)  </span><br><span class="line">后序遍历  </span><br><span class="line">postOrder<span class="function"><span class="params">(r)</span> = <span class="title">postOrder</span><span class="params">(r-&gt;left)</span> -&gt;</span> postOrder<span class="function"><span class="params">(r-&gt;right)</span> -&gt;</span> <span class="built_in">print</span> r</span><br></pre></td></tr></table></figure>

<p> 伪代码：  </p>
 <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line">void pre<span class="constructor">Order(Node<span class="operator">*</span> <span class="params">root</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root<span class="operator"> == </span>null) return;</span><br><span class="line">    print root;</span><br><span class="line">    pre<span class="constructor">Order(<span class="params">root</span> -&gt; <span class="params">left</span>)</span>;</span><br><span class="line">    pre<span class="constructor">Order(<span class="params">root</span> -&gt; <span class="params">right</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line">void <span class="keyword">in</span><span class="constructor">Order(Node<span class="operator">*</span> <span class="params">root</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root<span class="operator"> == </span>null) return;</span><br><span class="line">    <span class="keyword">in</span><span class="constructor">Order(<span class="params">root</span> -&gt; <span class="params">left</span>)</span>;</span><br><span class="line">    print root;</span><br><span class="line">    <span class="keyword">in</span><span class="constructor">Order(<span class="params">root</span> -&gt; <span class="params">right</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line">void post<span class="constructor">Order(Node<span class="operator">*</span> <span class="params">root</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root<span class="operator"> == </span>null) return;</span><br><span class="line">    post<span class="constructor">Order(<span class="params">root</span> -&gt; <span class="params">left</span>)</span>;</span><br><span class="line">    post<span class="constructor">Order(<span class="params">root</span> -&gt; <span class="params">right</span>)</span>;</span><br><span class="line">    print root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>按层遍历<br>借助队列辅助：根节点先入队列，队列不为空，取出对头元素，如果左子存在就入队列，否则什么也不做，如果右子同理，直到队列为空，表示树层次遍历结束。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        按层遍历
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(T x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;TreeNode&gt; <span class="title">floorlevelOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;TreeNode&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//利用队列先进先出的特点实现按层遍历</span></span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">//根节点入队</span></span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="comment">//从队列中弹出各结点数据，直到队列为空，遍历完毕</span></span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//弹出队首元素，放入结果集。并依次将其左右子节点入队(如果存在的话)，进行下一轮循环</span></span><br><span class="line">        TreeNode node = queue.poll();</span><br><span class="line">        result.add(node);</span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>  

</li>
</ol>
<h4 id="二叉树遍历时间复杂度"><a href="#二叉树遍历时间复杂度" class="headerlink" title="二叉树遍历时间复杂度"></a>二叉树遍历时间复杂度</h4><p>每个节点最多会被访问两次，遍历操作的时间复杂度跟节点的个数n成正比，时间复杂度为O(n)。  </p>
<h4 id="参考-amp-扩展"><a href="#参考-amp-扩展" class="headerlink" title="参考&amp;扩展"></a>参考&amp;扩展</h4><div id="refer-anchor-1"></div>

<ul>
<li>[1] <a href="https://mp.weixin.qq.com/s/0b5OsnFLLg18Td4CuR51_Q" target="_blank" rel="noopener">一篇总结二叉树的4种遍历方式（含模板）</a> </li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>堆&amp;堆排序</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%A0%86&amp;%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h4 id="堆的定义"><a href="#堆的定义" class="headerlink" title="堆的定义"></a>堆的定义</h4><ul>
<li><p>堆是一个完全二叉树<br>除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。  </p>
</li>
<li><p>堆中每一个节点的值都必须大于等于(或小于等于)其子树中每个节点的值<br>堆中每个节点的值都大于等于(或者小于等于)其左右子节点的值。  </p>
<blockquote>
<p>二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。  </p>
</blockquote>
<p>大顶堆：每个节点的值都大于等于子树中每个节点值。<br>小顶堆：每个节点的值都小于等于子树中每个节点值。  </p>
</li>
</ul>
<h4 id="堆的存储"><a href="#堆的存储" class="headerlink" title="堆的存储"></a>堆的存储</h4><p>完全二叉树适合用数组存储。节省存储空间，不需要存储左右节点的指针，单纯的通过数组下标就可以找到节点的左右节点和父节点。 </p>
<p>假设堆中的数据从数组下标为1的位置开始存储。<br>数组中下标为i的节点的左子节点就是下标为i<em>2的节点，右子节点就是下标为i</em>2+1的节点，父节点就是下标为i/2的节点。  </p>
<h4 id="堆的操作"><a href="#堆的操作" class="headerlink" title="堆的操作"></a>堆的操作</h4><p>往堆中插入一个元素或者删除堆顶元素后，数据结构不满足堆的特性，对其进行调整让它重新满足堆的特性，该过程称为<strong>堆化</strong>。<br>堆化分为从下往上和从上往下两种。顺着节点所在路径，对比然后交换。  </p>
<ul>
<li><p>插入一个元素-从下往上堆化。<br>将节点放在数组最后，然后让新插入的节点与父节点对比大小。如果不满足自己点小于等于父节点的大小关系，就互换两个节点。一直重复这个过程，直到父子节点之间满足大小关系。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        插入
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heap</span> </span>&#123;</span><br><span class="line">    <span class="comment">//数组，从下标1开始存储数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] a;</span><br><span class="line">    <span class="comment">//堆可以存储的最大数据个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">//堆中已经存储的数据个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Heap</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        a = <span class="keyword">new</span> <span class="keyword">int</span>[capacity + <span class="number">1</span>];</span><br><span class="line">        n = capacity;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//堆满</span></span><br><span class="line">        <span class="keyword">if</span>(count &gt;= n) <span class="keyword">return</span>;</span><br><span class="line">        count++;</span><br><span class="line">        a[count] = data;</span><br><span class="line">        <span class="keyword">int</span> i = count;</span><br><span class="line">        <span class="comment">//自下往上堆化</span></span><br><span class="line">        <span class="keyword">while</span>(i/<span class="number">2</span> &gt; <span class="number">0</span> &amp;&amp; a[i] &gt; a[i/<span class="number">2</span>]) &#123;</span><br><span class="line">            <span class="comment">//交换下标为i和i/2的两个元素</span></span><br><span class="line">            swap(a,i,i/<span class="number">2</span>);</span><br><span class="line">            i = i/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  
</li>
<li><p>删除堆顶元素-从上往下堆化。<br>堆顶元素存储的是堆中数据的最大值或者最小值。  </p>
<p>方法1：当删除堆顶元素之后，把第二大元素放到堆顶，第二大元素必然是左右子节点之一。迭代删除第二大节点，以此类推直到叶子节点被删除。最后堆化出来的堆不满足完全二叉树特性，可能出现空洞。  </p>
<p>方法2：当删除堆顶元素之后，把最后一个元素放到堆顶，然后利用父子节点对比方法，对不满足父子节点大小关系的交换两个节点，重复这个过程，直到父子节点之间满足大小关系为止。移除的是数组最后一个元素，堆化过程中都是交换操作，不会出现数组空洞，满足完全二叉树特性。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        删除
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heap</span> </span>&#123;</span><br><span class="line">    <span class="comment">//数组，从下标1开始存储数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] a;</span><br><span class="line">    <span class="comment">//堆可以存储的最大数据个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">//堆中已经存储的数据个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Heap</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        a = <span class="keyword">new</span> <span class="keyword">int</span>[capacity + <span class="number">1</span>];</span><br><span class="line">        n = capacity;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//堆中没有数据</span></span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        a[<span class="number">1</span>] = a[count];</span><br><span class="line">        count--;</span><br><span class="line">        heapify(a,count,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//自上往下堆化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> n,<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>（<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> maxPos = i;</span><br><span class="line">            <span class="keyword">if</span>(i*<span class="number">2</span> &lt;= n &amp;&amp; a[i] &lt; a[i*<span class="number">2</span>])</span><br><span class="line">                maxPos = i*<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(i*<span class="number">2</span>+<span class="number">1</span> &lt;= n &amp;&amp; a[maxPos] &lt; a[i*<span class="number">2</span>+<span class="number">1</span>])</span><br><span class="line">                maxPos = i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(maxPos == i)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            swap(a,i,maxPos);</span><br><span class="line">            i = maxPos;    </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

</li>
</ul>
<p>包含n个节点的完全二叉树，树的高度不会超过log<sub>2</sub>n。堆化的过程是顺着节点所在路径比较交换的，堆化的时间复杂度跟树的高度成正比，为O(logn)。插入数据和删除堆顶元素的的主要逻辑是堆化，所以往堆中插入一个元素和删除堆顶元素的时间复杂度都是O(logn)。  </p>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>借助堆这种数据结构实现的排序算法称为堆排序。时间复杂度为O(nlogn),原地不稳定排序算法。<br>堆排序的过程分为两个步骤：<strong>建堆、排序</strong>。  </p>
<ol>
<li><p>建堆<br>不借助另一个数组，在原数组上操作建堆。  </p>
<ul>
<li><p>从前往后处理数组数据，从下往上堆化。  </p>
<p>   在堆中插入一个元素的思路。数组中包含n个数据，假设起初堆中只包含一个数据，就是下标为1的数据。然后调用插入操作，将下标从2到n的数据依次插入到堆中最后一个位置，并进行堆化，不符合大小关系就交换位置，重复，最后将包含n个数据的数组组织成了堆。  </p>
</li>
<li><p>从后往前梳理数据，每个数据都是从上往下堆化。  </p>
<p>   从最后一个非叶子节点开始倒序依次堆化，不符合大小关系就交换位置。叶子节点往下堆化只能自己跟自己比较。    </p>
</li>
</ul>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        建堆
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n/<span class="number">2</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        heapify(a,n,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> n,<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>（<span class="keyword">true</span>) &#123;</span><br><span class="line">         <span class="keyword">int</span> maxPos = i;</span><br><span class="line">         <span class="keyword">if</span>(i*<span class="number">2</span> &lt;= n &amp;&amp; a[i] &lt; a[i*<span class="number">2</span>])</span><br><span class="line">             maxPos = i*<span class="number">2</span>;</span><br><span class="line">         <span class="keyword">if</span>(i*<span class="number">2</span>+<span class="number">1</span> &lt;= n &amp;&amp; a[maxPos] &lt; a[i*<span class="number">2</span>+<span class="number">1</span>])</span><br><span class="line">             maxPos = i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">if</span>(maxPos == i)</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">         swap(a,i,maxPos);</span><br><span class="line">         i = maxPos;    </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p>完全二叉树下标n/2 + 1到n的节点是叶子节点不需要堆化，只需对下标从n/2到1的数据进行堆化。<br>每个节点的堆化的时间复杂度是O(logn)，n/2 + 1个节点堆化的总时间复杂度就是O(nlogn)。(粗略)  </p>
<p>叶子节点不需要堆化，需要堆化的的节点从倒数第二层开始，每个节点堆化的过程中，需要比较和交换的节点个数跟这个节点的高度k成正比，将每个节点的高度求和得到建堆的时间复杂度：  </p>
<p>S=1<em>h + 2<sup>1</sup></em>(h-1) + 2<sup>2</sup><em>(h-2) +<br>2<sup>k</sup></em>(h-k) + 2<sup>h-1</sup>*1  </p>
<blockquote>
<p>公式左右乘以2，再错位对齐后与原公式相减，中间是个等比数列</p>
</blockquote>
<p>= -h + 2 + 2<sup>2</sup> + 2<sup>3</sup> + ··· + 2<sup>k</sup> + ··· + 2<sup>h-1</sup> + 2<sup>h</sup><br>= -h + (2<sup>h</sup>-2) + 2<sup>h</sup><br>= 2<sup>h+1</sup> -h -2  </p>
<p>h=log<sub>2</sub>n,S=O(n).</p>
<p>建堆的时间复杂度为O(n)。</p>
</li>
<li><p>排序<br>建堆结束后，数组中的数据已经是按照大顶堆的特性来组织的。数组中的第一个元素就是堆顶，也是最大的元素。<br>将堆顶元素与最后一个元素交换，最大元素就放到了下标为n的位置。类似删除堆顶元素操作。堆顶元素被移除，下标为n的最小元素被放到堆顶，通过堆化的方法将剩下的n-1个元素重新构建成堆；再取堆顶元素(原堆第二大元素)-与n-1位置的元素交换-堆化-重复。直到最后堆中只剩下下标为1的一个元素，排序完成。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        排序
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//n表示数据的个数，数组a中的数据从下标1到n的位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    buildHeap(a,n);</span><br><span class="line">    <span class="keyword">int</span> k = n;</span><br><span class="line">    <span class="keyword">while</span>(k&gt;<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//当前堆尾与堆顶交换</span></span><br><span class="line">        swap(a,<span class="number">1</span>,k);</span><br><span class="line">        k--;</span><br><span class="line">        <span class="comment">//只需要堆化堆顶元素</span></span><br><span class="line">        heapify(a,k,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p>整个堆排序的过程，只需要极个别的临时存储空间，属于<strong>原地排序算法</strong>。<br>堆排序包括建堆和排序两个操作，建堆的时间复杂度是O(n)，排序过程的时间复杂度是O(nlogn)，堆排序整体的<strong>时间复杂度是O(nlogn)</strong>。<br>堆排序过程中，将堆的最后一个节点跟堆顶节点互换，改变了值相同数据的原始相对顺序。堆排序<strong>不是稳定的排序算法</strong>。</p>
</li>
</ol>
<h4 id="对比快排"><a href="#对比快排" class="headerlink" title="对比快排"></a>对比快排</h4><ul>
<li>堆排序数据访问的方式没有快速排序友好。<br>快排数据是顺序访问的，堆排序堆化过程数据是跳着访问的(2的指数)，对CPU缓存不友好。  </li>
<li>同样的数据，在排序过程中，堆排序的数据交换次数多于快速排序。<br>快排数据交换的次数不会比逆序多。堆排序建堆的过程会打乱数据原有的相对先后顺序，导致原数据有序度降低。  </li>
</ul>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>用数组存储表示完全二叉树时，若从下标为0开始存储，如果节点下标是i，则左子节点的下标就是2<em>i+1，右子节点的下标是2</em>i+2，父节点的下标是(i-1)/2。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉查找树</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/</url>
    <content><![CDATA[<p>二叉查找树是二叉树中最常用的一种类型，也叫二叉查找树。<br>二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。  </p>
<h4 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h4><p>先取根节点，如果它等于要查找的数据，直接返回。<br>如果要查找的数据比根节点的值小，那就在左子树中递归查找；<br>如果要查找的数据比根节点的值大，那就在右子树中递归查找。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        查找
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node tree;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">select</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        Node p = tree;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(data &lt; p.data) </span><br><span class="line">                p = p.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (data &gt; p.data)</span><br><span class="line">                p = p.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> data;</span><br><span class="line">        <span class="keyword">private</span> Node left;</span><br><span class="line">        <span class="keyword">private</span> Node right;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>插入类似查找，新插入的数据一般都是在叶子节点上，只需要从根节点开始，依次比较要插入的数据和节点的大小关系。  </p>
<p>如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；<br>如果不为空，就在递归遍历右子树，查找插入位置。<br>同理，如果要插入的数据比节点数据小，并且节点的左子树为空，就将新数据插入到左子节点的位置；<br>如果不为空，就再递归遍历左子树，查找插入位置。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        插入
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node tree;</span><br><span class="line">    <span class="comment">//不考虑插入节点与已有节点相同的情况</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tree == <span class="keyword">null</span>) &#123;</span><br><span class="line">            tree = <span class="keyword">new</span> Node(data);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node p = tree;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(data &gt; p.data) &#123;</span><br><span class="line">                <span class="keyword">if</span>(p.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.right = <span class="keyword">new</span> Node(data);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                p = p.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//data &lt; p.data</span></span><br><span class="line">                <span class="keyword">if</span>(p.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.left = <span class="keyword">new</span> Node(data);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                p = p.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> data;</span><br><span class="line">        <span class="keyword">private</span> Node left;</span><br><span class="line">        <span class="keyword">private</span> Node right;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>针对要删除节点的子节点个数的不同，需要分为三种情况处理：  </p>
<ol>
<li>要删除的节点没有子节点，只需要直接将父节点中，指向要删除节点的指针置为null。  </li>
<li>要删除的节点只有一个子节点(只有左子节点或者右子节点)，只需要更新父节点中，指向要删除节点的指针，让它指向要删除结点的子节点。  </li>
<li>要删除的节点有两个子节点。需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上，然后再删除掉这个最小节点，因为最小节点肯定没有左子节点(如果有左子节点，那就不是最小节点了)，所以可以应用这两条规则来删除这个最小节点。  </li>
</ol>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        删除
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node tree;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//p指向要删除的节点，初始化指向根节点</span></span><br><span class="line">        Node p = tree;</span><br><span class="line">        <span class="comment">//pp记录的是p的父节点</span></span><br><span class="line">        Node pp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span> &amp;&amp; p.data != data) &#123;</span><br><span class="line">            <span class="comment">//更新当前节点为父节点，进而遍历子节点、子子节点</span></span><br><span class="line">            pp = p;</span><br><span class="line">            <span class="keyword">if</span>(data &gt; p.data)</span><br><span class="line">                p = p.right;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//data &lt; p.data</span></span><br><span class="line">                p = p.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有找到</span></span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//要删除的节点有两个子节点</span></span><br><span class="line">        <span class="keyword">if</span>(p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//查找右子树中最小节点</span></span><br><span class="line">            Node minP = p.right;</span><br><span class="line">            <span class="comment">//minPP表示minP的父节点</span></span><br><span class="line">            Node minPP = p;</span><br><span class="line">            <span class="keyword">while</span>(minP.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//更新当前最小节点为当前节点的左子节点</span></span><br><span class="line">                minPP = minP;</span><br><span class="line">                minP = minP.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将minP的数据替换到p中，后续通过minPP(pp)删除原minP</span></span><br><span class="line">            p.data = minP.data;</span><br><span class="line">            p = minP;</span><br><span class="line">            pp = minPP;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除的节点是叶子节点或者仅有一个子节点</span></span><br><span class="line">        Node child;<span class="comment">//p的子节点</span></span><br><span class="line">        <span class="keyword">if</span>(p.left != <span class="keyword">null</span>)</span><br><span class="line">            child = p.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p.right != <span class="keyword">null</span>)</span><br><span class="line">            child = p.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            child = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//通过更新父节点的子节点来删除指定的p</span></span><br><span class="line">        <span class="keyword">if</span>(pp == <span class="keyword">null</span>) <span class="comment">//删除的节点是根节点</span></span><br><span class="line">            tree = child;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pp.left == p)</span><br><span class="line">            pp.left = child;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//pp.right == p</span></span><br><span class="line">            pp.right = child;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> data;</span><br><span class="line">        <span class="keyword">private</span> Node left;</span><br><span class="line">        <span class="keyword">private</span> Node right;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<h4 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h4><p>快速的查找最大节点和最小节点、前驱节点和后继节点。  </p>
<h4 id="重要特性"><a href="#重要特性" class="headerlink" title="重要特性"></a>重要特性</h4><p>中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是O(n)。  </p>
<h4 id="重复数据"><a href="#重复数据" class="headerlink" title="重复数据"></a>重复数据</h4><p>实际开发中，二叉查找树中存储的是包含很多字段的对象，利用对象的某个字段作为键值来构建二叉查找树，对象中的其他字段叫做卫星数据。  </p>
<p>键值相同的两个对象存储解决方案：   </p>
<ol>
<li><p>二叉查找树中每个节点不仅存储一个数据，通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。   </p>
</li>
<li><p>每个节点仍然只存储一个数据。在查找插入位置的过程冲，如果 碰到一个节点的值与要插入数据的值相同，把这个新插入的数据当做大于这个节点的值来处理，将新数据放到这个节点的右子树。  </p>
<p>当要查找数据的时候，遇到值相同的节点，并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点才停止。这样可以把键值等于要查找值的所有节点都找出来。    </p>
<p>对于删除操作，也需要先查找到每个要删除的节点，然后再按之前的删除操作的方法依次删除。   </p>
</li>
</ol>
<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>二叉查找树的插入、删除、查找的时间复杂度都跟树的高度成正比，为O(height)。也就是求包含n个节点的完全二叉树的高度。树的高度等于最大层数减一。  </p>
<p>最坏情况：二叉查找树退化为链表，查找的时间复杂度为O(n)。</p>
<p>最好情况：二叉查找树为完全二叉查找树。<br>包含n个节点的完全二叉树，第一层包含1个节点，第二层包含2个节点，第三层包含4个节点，依次类推，下面一层节点个数是上一层的2倍，第k层包含的节点个数就是2<sup>K-1</sup>。<br>完全二叉树最后一层的节点个数在1个到2<sup>L-1</sup>之间(最大层数为L)。则  </p>
<p>n &gt;= 1+2+4+8+…+2<sup>L-2</sup>+1<br>n &lt;= 1+2+4+8+…+2<sup>L-2</sup>+2<sup>L-1</sup></p>
<p>等比数列求和公式，L的范围是[log<sub>2</sub>(n+1),log<sub>2</sub>n+1]。完全二叉树的层数小于log<sub>2</sub>n+1，完全二叉树的高度小于log<sub>2</sub>n。平衡二叉查找树的高度接近logn，插入、删除、查找操作的时间复杂度稳定为O(logn)。</p>
<h4 id="对比散列表"><a href="#对比散列表" class="headerlink" title="对比散列表"></a>对比散列表</h4><ul>
<li>散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。二叉查找树只需要中序遍历，就可以在O(n)的时间复杂度内输出有序的数据序列。  </li>
<li>散列表扩容耗时多，遇到散列冲突时性能不稳定。二叉查找树的性能不稳定，但平衡二叉查找树的性能非常稳定，时间复杂度稳定在O(logn)。</li>
<li>散列表的查找等操作的时间复杂度是常量级的，但是哈希冲突存在&amp;哈希函数耗时，不一定比平衡二叉查找树的效率高。</li>
<li>散列表的构造比二叉查找树要复杂，需要考虑的额东西很多，散列函数、冲突解决、扩容、缩容等。平衡二叉查找树只需要考虑平衡性。  </li>
<li>为了避免散列冲突，装载因子不能太大，基于开放寻址法解决冲突的散列表，会浪费一定的存储空间。</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>堆的应用</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%A0%86%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h4 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h4><p>在优先级队列中，数据的出队顺序不是先进先出，而是按照优先级来，优先级高的，最先出队。  </p>
<p>优先级队列实现方法有很多，用堆来实现是最直接、最高效的。<strong>一个堆可以看做一个优先级队列</strong>，往优先级队列中插入一个元素，就相当于往堆中插入一个元素；从优先级队列中取出优先级最高的元素，相当于取出堆顶元素。<br>霍夫曼编码、图的最短路径、最小生成树算法。  </p>
<ul>
<li><p>合并有序小文件<br>小文件中存储的都是有序的字符串。从各个小文件中各取出一个字符串，放入到与文件个数等长的小顶堆中，堆顶的元素就是优先级队列队首的元素-最小的字符串。<br>将这个字符串放入到大文件中，并将其从堆中删除。然后再从对应的小文件中取出下一个字符串，放入到堆中。循环。  </p>
<p>删除堆顶数据和往堆中插入数据的时间复杂度都是O(logn)，n表示堆中的数据个数。  </p>
</li>
<li><p>高性能定时器<br>按照任务设定的执行时间，将这些任务存储在优先级队列中，队列首部（小顶堆的堆顶）存储的是最先执行的任务。<br>拿队首任务的执行时间点，与当前时间点相减，得到时间间隔T。表示从当前时间开始，等待多久才会有第一个任务需要被执行。这样定时器就可以设定在T秒之后再来执行任务，从当前时间点到（T-1）秒这段时间里，定时器不需要做任何事情。<br>当T秒过去后，定时器取优先级队列中队首的任务执行。然后再计算新的队首任务的执行时间点与当前时间点的差值，该值是定时器执行下一个任务需要等待的时间。</p>
<p>避免了普通定时器频繁轮训和遍历整个任务列表。  </p>
</li>
</ul>
<h4 id="利用堆求TopK"><a href="#利用堆求TopK" class="headerlink" title="利用堆求TopK"></a>利用堆求TopK</h4><ul>
<li><p>静态数据集合<br>针对包含n个数据的数组，查找前K大元素。先顺序取出数组中前k个元素，维护成一个大小为K的小顶堆，再顺序遍历数组，从数组中取出数据与堆顶元素比较。如果比堆顶元素大，就把堆顶元素删除，并将这个数据插入堆中；如果比堆顶元素小，则不处理。数组中护具都遍历完之后，堆中的数据就是前K大数据。  </p>
<p>遍历数组时间复杂度为O(n)，一次堆化操作时间复杂度为O(logK)，最坏情况下，n个元素都入堆一次，时间复杂度为O(nlogK)。</p>
</li>
<li><p>动态数据集合<br>如果每次询问前K大数据，都基于当前的数据重新计算的话，时间复杂度为O(nlogK)，n表示当前的数据的大小。  </p>
<p>维护一个K大小的小顶堆，当有数据被添加进集合中时，与堆顶元素比较。如果比堆顶元素大，就把堆顶元素删除，并将这个数据插入堆中；如多比堆顶元素小，就不做处理。无论任何时候需要查询当前的前K大数据，都可以立刻返回。  </p>
</li>
</ul>
<h4 id="利用堆求中位数"><a href="#利用堆求中位数" class="headerlink" title="利用堆求中位数"></a>利用堆求中位数</h4><p>中位数，处在中间位置的那个数。如果数据的个数是奇数，把数据从小到大排列，第n/2 + 1个数就是中位数（数据从0开始编号）；如果数据的个数是偶数，处于中间位置的数据有两个，第n/2个和第n/2 + 1个，可以随意取一个作为中位数。  </p>
<ul>
<li><p>静态数据<br>中位数固定，可以先排序，第n/2个数据就是中位数。每次询问中位数直接返回固定值。  </p>
</li>
<li><p>动态数据<br>中位数在不停的变动，不能每次都先排序。  </p>
<p>维护两个堆，一个大顶堆，一个小顶堆。大顶堆存储前半部分数据，小顶堆存储后半部分数据，而且小顶堆中的数据都大于大顶堆中的数据。<br>如果新加入的数据小于等于大顶堆的堆顶元素，就将新数据插入到大顶堆；否则将新数据插入到小顶堆。插入后两个堆中的数据个数不符合约定情况时，从一个堆中将堆顶元素移动到另一个堆。  </p>
<p>插入数据因为需要涉及堆化，时间复杂度为O(logn)，求中位数只需要返回大顶堆的堆顶元素，时间复杂度是O(1)。  </p>
<p>中位数相当于50%，可以扩展到任意百分位数。  </p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>图</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/</url>
    <content><![CDATA[<h3 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h3><p>图是比树更加复杂的非线性表结构。适合存储微博、微信等社交网络中的好友关系。<br><strong>顶点</strong>：图中的元素；用户<br><strong>边</strong>：顶点与任意其它顶点之间的连接关系；好友关系<br><strong>度</strong>：顶点相连接的边的条数；好友个数<br><strong>有向图</strong>：带箭头的边，表示边的方向，有方向的图；关注关系<br><strong>无向图</strong>：边没有方向的图；好友关系<br><strong>度</strong>：无向图中表示一个顶点有多少条边；好友个数<br><strong>入度</strong>：有向图中，表示有多少条边指向这个顶点；粉丝个数<br><strong>出度</strong>：有向图中，表示有多少条边是以这个顶点为起点指向其他顶点；关注人数<br><strong>带权图</strong>：每条边都有一个权重。亲密度  </p>
<h3 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h3><ul>
<li><p>邻接矩阵<br>邻接矩阵-二维数组。<br>无向图，如果顶点i与顶点j之间有边，就将A[i][j]和A[j][i]标记为1；浪费一半的存储空间；<br>有向图，如果顶点i到j之间，有一条箭头从顶点i指向顶点j的边，就将A[i][j]标记为1。如果有一条箭头从顶点j指向顶点i的边，就将A[j][i]标记为1。<br>带权图，数组中就存储相应的权重。<br>稀疏图，顶点很多，但每个顶点的边不多，邻接矩阵的存储方法更加浪费。</p>
<p>优点：<br>存储方式简单、直接，获取顶点关系高效，图计算-矩阵计算方便。</p>
</li>
<li><p>邻接表<br>邻接表-散列表<br>无向图每个顶点对应一条链表，链表中存储的是与这个顶点相连接的其他顶点。<br>有向图，每个顶点对应的链表里，存储其指向的顶点。  </p>
<p>优化；<br>顶点中的链表转换成平衡二叉查找树、红黑树、跳表、散列表、有序动态数组(二分查找)。  </p>
</li>
</ul>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ol>
<li><p>微博-有向图<br>微博操作：  </p>
<ul>
<li>判断用户A是否关注用户B  </li>
<li>判断用户A是否被用户B的关注  </li>
<li>用户A关注用户B  </li>
<li>用户A取消关注用户B  </li>
<li>根据用户名称的首字母排序，分页获取用户的粉丝列表  </li>
<li>根据用户名称的首字母排序，分页获取用户的关注列表  </li>
</ul>
<p>社交关系存储：  </p>
<ul>
<li>内存（数据量大用哈希算法将数据分片）<br>邻接表，存储用户关注了哪些用户；每个顶点的链表中，存储这个顶点指向的顶点。<br>逆邻接表，存储用户被哪些用户关注；每个顶点的链表中，存储指向这个顶点的顶点。  </li>
<li>硬盘<br>两列表。一列用户id，一列关注id。分别建立索引。  </li>
</ul>
</li>
<li><p>微信-无向图<br>微信操作：  </p>
<ul>
<li>判断A、B是否为好友关系  </li>
<li>A删除B，断开与B的好友关系  </li>
<li>展示出A的好友列表，并按名称首字母排序  </li>
</ul>
<p>社交关系存储：  </p>
<ul>
<li>邻接表存储每个人对应的好友列表，好友列表可用红黑树/跳表存储</li>
</ul>
</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>深度优先&amp;广度优先</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88&amp;%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88/</url>
    <content><![CDATA[<p>在社交网络中，通过用户之间的连接关系，可以实现推荐“可能认识的人”的功能。  </p>
<h3 id="“搜索”算法"><a href="#“搜索”算法" class="headerlink" title="“搜索”算法"></a>“搜索”算法</h3><p>大部分涉及搜索的场景都可以抽象成图，深度优先算法和广度优先算法都是基于图这种表达能力很强的数据结构。<br>在图中找出从一个顶点出发，到另一个顶点的路径。简单暴力的深度优先、广度优先；启发式的A<em>、IDA</em>。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        图
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无向图</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="comment">//顶点的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> v;</span><br><span class="line">    <span class="comment">//邻接表（声明一个存储LinkedList链表类型的数组）</span></span><br><span class="line">    <span class="comment">//保存每个顶点的邻接链表</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; adj[];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.v = v;</span><br><span class="line">        adj = <span class="keyword">new</span> LinkedList[v];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;v; i++) &#123;</span><br><span class="line">            adj[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//无向图一条边存两次</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        adj[s].add(t);</span><br><span class="line">        adj[t].add(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<h3 id="广度优先BFS"><a href="#广度优先BFS" class="headerlink" title="广度优先BFS"></a>广度优先BFS</h3><p>类似二叉树按层遍历。  </p>
<p>广度优先搜索Breadth-First-Search，是一种地毯式层层推进的搜索策略，先查找离起始顶点最近的，然后是次近的，依次往外搜索。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        广度优先搜索-借助队列实现
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == t) </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//记录已经被访问的顶点，避免顶点被重复访问，布尔值默认为false</span></span><br><span class="line">    <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[v];</span><br><span class="line">    visited[s] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//存储已经被访问，但是相连的顶点还没有被访问的顶点</span></span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(s);</span><br><span class="line">    <span class="comment">//记录搜索路径（路径最大为v,找到t就可以直接返回）</span></span><br><span class="line">    <span class="keyword">int</span>[] prev = <span class="keyword">new</span> <span class="keyword">int</span>[v];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; i++) &#123;</span><br><span class="line">        prev[i] = -<span class="number">1</span>;<span class="comment">//-1初始化路径</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(queue.size() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//弹出当前顶点</span></span><br><span class="line">        <span class="keyword">int</span> w = queue.poll();</span><br><span class="line">        <span class="comment">//遍历当前顶点的邻接顶点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj[w].size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> q = adj[w].get(i);</span><br><span class="line">            <span class="keyword">if</span>(!visited[q]) &#123;</span><br><span class="line">                <span class="comment">//将当前顶点存入当前邻接顶点的访问路径</span></span><br><span class="line">                prev[q] = w;</span><br><span class="line">                <span class="keyword">if</span>(q == t) &#123;</span><br><span class="line">                    print(prev,s,t);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//当前邻接顶点标记为已访问</span></span><br><span class="line">                visited[q] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//当前邻接顶点入队</span></span><br><span class="line">                queue.add(q);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归打印s-&gt;t的路径</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[] prev, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prev[t] != -<span class="number">1</span> &amp;&amp; t != s) &#123;</span><br><span class="line">        print(prev,s,prev[t]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.print(t + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  
<p><strong>visited</strong>记录已经被访问的顶点，避免顶点被重读访问。<br>如果顶点q被访问，那相应的visited[q]会被设置为true。  </p>
<p><strong>queue</strong>用队列存储已经被访问、但相连的顶点还没有被访问的顶点。<br>只有把k层的顶点都访问完成之后，才能访问第k+1层的顶点。当访问到第k层的顶点时，需要把第k层的顶点记录下来，稍后才能通过第k层的顶点来找第k+1层的顶点。  </p>
<p><strong>prev</strong>记录搜索路径。<br>从顶点s开始，广度优先搜索到顶点t后，prev数组中存储的就是搜索的路径。<br>路径是反向存储的。prev[w]存储的是，顶点w是从哪个前驱顶点遍历过来的。需要递归来打印出正向的路径。  </p>
<p>最坏情况下，终止顶点t离起始顶点s很远，需要遍历完整个图才能找到。每个顶点都要进出一遍队列，每个边都会被访问依次，广度优选搜索的时间复杂度是O(V+E)，V表示顶点的个数，E表示边的个数。<br>对一个连通图来说，图中的所有顶点都是连通的，E&gt;=V-1，广度优先搜索的<strong>时间复杂度</strong>简化为O(E)。<br>广度优先搜索的空间消耗主要在几个辅助变量visited数组、queue队列、prev数组上。存储空间的大小都不会超过顶点的个数，整体<strong>空间复杂度</strong>为O(V)。  </p>
<h3 id="深度优先DFS"><a href="#深度优先DFS" class="headerlink" title="深度优先DFS"></a>深度优先DFS</h3><p>类似二叉树前序遍历。  </p>
<p>深度优先搜索Depth-First-Search，使用回溯思想，解决问题的过程适合用递归来实现。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        深度优先搜索-借助栈实现
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局变量，当找到终止顶点之后，不再递归地继续查找</span></span><br><span class="line"><span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    found = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[v];</span><br><span class="line">    <span class="keyword">int</span>[] prev = <span class="keyword">new</span> <span class="keyword">int</span>[v]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; i++) &#123;</span><br><span class="line">        prev[i] = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    recurDfs(s,t,visited,prev);</span><br><span class="line">    print(prev,s,t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recurDfs</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> t, <span class="keyword">boolean</span>[] visited, <span class="keyword">int</span>[] prev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(found == <span class="keyword">true</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//标记当前顶点为已访问</span></span><br><span class="line">    visited[w] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(w == t) &#123;</span><br><span class="line">        found = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历当前顶点的邻接顶点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj[w].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(found == <span class="keyword">true</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> q = adj[w].get(i);</span><br><span class="line">        <span class="comment">//只递归未被访问的顶点</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[q]) &#123;</span><br><span class="line">            <span class="comment">//将当前顶点记录在当前邻接顶点的访问路径</span></span><br><span class="line">            prev[q] = w;</span><br><span class="line">            <span class="comment">//递归当前邻接顶点</span></span><br><span class="line">            recurDfs(q,r,visited,prev);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  
<p><strong>prev和visited中元素下标与元素值一致。prev[]</strong>  </p>
<p>每条边最多会被访问两次，一次是遍历，一次是回退，深度优先搜索算法的时间复杂度是O(E)，E表示边的个数。  </p>
<p>深度优先搜索算法的内存消耗主要是visited、prev数组和递归调用栈。vixited、prev数组的大小跟顶点的个数V成正比，递归调用栈的最大深度不会超过顶点的个数，整体空间复杂度是O(V)。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>图的搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="贪心算法理解"><a href="#贪心算法理解" class="headerlink" title="贪心算法理解"></a>贪心算法理解</h3><ul>
<li>针对一组数据，定义了限制值和期望值，希望从中选出几个数据，在满足限制值的情况下，期望值最大。这类问题首先要联想到贪心算法。  </li>
<li>每次选择当前情况下，在对限制值同等共享量的情况下，对期望值贡献最大的数据。这种问题可以用贪心算法解决。  </li>
<li>举例验证贪心算法产生的结果是否是最优的。  </li>
</ul>
<p><strong>用贪心算法解决问题的思路，并不总能给出最优解。</strong>  </p>
<p>在一个有权图中，从顶点S开始，找一条到顶点T的最短路径（路径中边的权值和最小）。<br>贪心算法的解决思路是，每次都选择一条跟当前顶点相连的权最小的边，直到找到顶点T。前面的选择，会影响到后面的选择。即便第一步选择最优的走法（边最短），但有可能因为这一步选择，导致后面每一步的选择都很糟糕，最终也就无缘全局最优解了。  </p>
<h3 id="贪心算法实战"><a href="#贪心算法实战" class="headerlink" title="贪心算法实战"></a>贪心算法实战</h3><ol>
<li><p>分糖果<br>m个糖果分给n个孩子，m&lt;n。每个糖果的大小不等，每个孩子对糖果大小的需求也不一样，糖果大小需要&gt;=孩子对糖果大小的需求，最多能满足多少个孩子。  </p>
<p>从需求小的孩子开始分配糖果，然后每次从剩下的孩子中，找出对糖果大小需求最小的，然后发给他剩下的糖果中能满足他的最小的糖果，这样的分配方案是能满足的孩子个数最多的方案。  </p>
</li>
<li><p>钱币找零<br>不同面值的钱币，不同的张数，支付K元，最少需要多少张纸币。  </p>
<p>先用面值最大的来支付，如果不够，就继续用更小一点面值的，以此类推。  </p>
</li>
<li><p>区间覆盖<br>有n个区间，区间的起始端点和结束端点各不相同。从这n个区间中选出一部分区间，这部分区间满足两两不相交。最多能选出多少个区间。（任务调度、教师排课）  </p>
<p>每次选择的时候，左端点跟前面的已经覆盖的区间不重合的，右端点尽量小的，可以让剩下的未覆盖区间尽可能的打，就可以放置更多的区间。  </p>
</li>
</ol>
<h3 id="实现霍夫曼编码"><a href="#实现霍夫曼编码" class="headerlink" title="实现霍夫曼编码"></a>实现霍夫曼编码</h3><p>一个包含1000个字符的文件，每个字符占1个byte(1byte=8bits)，存储这个文件需要8000bits。  </p>
<p>1000个字符中质保函6中不同的字符，分别是a、b、c、d、e、f。三个二进制位（bit）就可以表示8个不同的字符，为了尽量减少存储空间，每个字符用3个二进制位来表示，存储这个文件只需要3000bits。  </p>
<blockquote>
<p>a(000)、b(001)、c(010)、d(011)、e(100)、f(101)  </p>
</blockquote>
<p><strong>霍夫曼编码思想</strong>：  </p>
<ul>
<li>霍夫曼编码不仅考察文本中有多少个不同字符，还会考察每个字符出现的频率，根据频率的不同选择不同长度的编码。霍夫曼编码用这种<strong>不等长的编码方法</strong>，来进一步增加压缩的效率。  </li>
<li>根据贪心的思想，可以把出现频率比较多的字符，用稍微短一些的编码；出现评率比较少的字符，用稍微长一些的编码。  </li>
<li>为了避免解压缩过程中的歧义，霍夫曼编码要求各个字符的编码之间，不会出现某个编码是另一个编码前缀的情况。在解压缩的时候，每次读取尽可能长的可解压的二进制串。  </li>
</ul>
<p><strong>霍夫曼编码实现：</strong>：</p>
<ul>
<li><p>把每个字符看做一个节点，并且辅带着把频率放到优先级队列中。从队列中取出频率最小的两个节点A、B，然后新建一个节点C，把频率设置为两个节点的频率之和，并把新节点C作为A、B的父节点，再把C节点翻入到优先级队列中，重复这个过程，直到队列中没有数据。<br>（构造的优先级队列根据频率的不同，各不相同，极端退化成近似链表的结构，除了最后一层都走一个叉，1、01、001、0001、00001、00000）  </p>
</li>
<li><p>给每一条边加上一个权值，指向左子节点的边标记为0，指向右子节点的边，标记为1，从根节点到叶子节点就是叶子节点对应字符的霍夫曼编码。<br>（最理想情况，完全二叉树00、01、10、11）</p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
        <tag>霍夫曼编码</tag>
        <tag>Huffman Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯算法</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>深度优先搜索利用的是回溯算法思想。<br>回溯算法大部分情况下都是用来解决广义的搜索问题：从一组可能的解中，选出一个满足要求的解。  </p>
<p>回溯算法非常适合用递归来实现，在实现的过程中，剪枝操作是提高回溯效率的一种技巧，利用剪枝，并不需要穷举搜索所有的情况，从未提高搜索效率。  </p>
<h3 id="回溯算法理解"><a href="#回溯算法理解" class="headerlink" title="回溯算法理解"></a>回溯算法理解</h3><p>对比贪心算法，在每次面对岔路口的时候，都做出看起来最优的选择，期望这一组选择是最终的最优解。但是贪心算法并不一定能得到最优解。  </p>
<p>回溯的处理思想，类似枚举搜索。枚举所有的解，找到满足期望的解。为了有规律的枚举所有可能的解，避免遗漏和重复，把问题求解的过程分为多个阶段。每个阶段都有会面对一个岔路口，先随意选一条路走，当发现这条路走不通的时候（不符合期望的解），就退回到上一个岔路口，另选一种走法继续走。  </p>
<h3 id="回溯算法应用"><a href="#回溯算法应用" class="headerlink" title="回溯算法应用"></a>回溯算法应用</h3><p><strong>八皇后问题</strong><a href="#refer-anchor-1"><sup>1</sup></a>  <span id="back-1"></span></p>
<p>有一个8X8的棋盘，希望往里放8个棋子（皇后），每个棋子所在的行、列、对角线都不能有另一个棋子。  </p>
<p>把这个问题分成8个阶段，依次将8个棋子放到第一行、第二行、第三行…第八行。在放置的过程中，不停地检查当前放法，是否满足要求。如果满足，则跳到下一行继续放置棋子；如果不满足，那就再换一种放法，继续尝试。<a href="#refer-anchor-2"><sup>2</sup></a>  <span id="back-2"></span>  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        八皇后
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局变量，下标表示行，值表示queen存在哪一列</span></span><br><span class="line"><span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>];</span><br><span class="line"><span class="comment">//记录目前是第几种解法</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//调用：cal8queens(0)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cal8queens</span><span class="params">(<span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//8个棋子都放置好了，打印结果</span></span><br><span class="line">    <span class="keyword">if</span>(row == <span class="number">8</span>) &#123;</span><br><span class="line">        printQueens(result);</span><br><span class="line">        <span class="comment">//8行棋子都放好了，已经无法再往下递归</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//每一行都有8种放法</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; <span class="number">8</span>; ++column) &#123;</span><br><span class="line">        <span class="comment">//有些放法不满足要求</span></span><br><span class="line">        <span class="keyword">if</span>(isOk(row,column)) &#123;</span><br><span class="line">            <span class="comment">//第row行的棋子放到了column列</span></span><br><span class="line">            result[row] = column;</span><br><span class="line">            <span class="comment">//考察下一行</span></span><br><span class="line">            cal8queens(row + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断row行column列放置是否合适</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isOk</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> column)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当前的左上和右上</span></span><br><span class="line">    <span class="keyword">int</span> leftup = column - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> rightup = column + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//逐行往上考察每一行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = row - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="comment">//1、第i行的column列有棋子么</span></span><br><span class="line">        <span class="keyword">if</span>(result[i] == column) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//2、考察左上对角线，第i行的leftup列有棋子么</span></span><br><span class="line">        <span class="keyword">if</span>(leftup &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(result[i] == leftup) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3、考察右上对角线，第i行rightup列有棋子么</span></span><br><span class="line">        <span class="keyword">if</span>(rightup &lt; <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(result[i] == rightup) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//行互减的绝对值等于列互减的绝对值</span></span><br><span class="line">        --leftup;</span><br><span class="line">        ++rightup;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印一个二维矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printQueens</span><span class="params">(<span class="keyword">int</span>[] result)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"第"</span> + ++count + <span class="string">"种解法："</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; <span class="number">8</span>; ++row) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; <span class="number">8</span>; ++column) &#123;</span><br><span class="line">            <span class="keyword">if</span>(result[row] == column)</span><br><span class="line">                System.out.print(<span class="string">"Q "</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                System.out.print(<span class="string">"* "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p><strong>0-1背包</strong><br>动态规划<br>回溯算法<br>一个背包，背包总的承载重量是Wkg。现在有n个物品，每个物品的重量不等，并且不可分割。期望选择几件物品，装载到背包中，在不超过背包所能装载重量的前提下，让背包中物品的总重量最大。  </p>
<p>对于每个物品来说，都有两种选择，装进背包或者不装进背包。对于n各物品来说，总的装法就有2<sup>n</sup>种，去掉总重量超过Wkg的，从剩下的装法中选择总重量最接近Wkg的。<br>把物品依次排列，整个问题就分解成了n个阶段，每个阶段对应一个物品怎么选择，先对第一个物品进行处理，选择装进去或者不装进去，然后再递归地处理剩下的物品。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        0-1背包
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//存储背包中物品总重量的最大值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> maxW = Integer.MIN_VALUE;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* cw表示当前已经装进去的物品的重量综合；</span></span><br><span class="line"><span class="comment">* i表示考察到哪个物品了；</span></span><br><span class="line"><span class="comment">* w背包重量；</span></span><br><span class="line"><span class="comment">* items表示每个物品的重量；</span></span><br><span class="line"><span class="comment">* n表示物品个数；</span></span><br><span class="line"><span class="comment">* 假设背包可承受重量100，物品个数10，物品重量存储在数组a中，调用方法 f(0,0,a,10,100)</span></span><br><span class="line"><span class="comment">* 借助递归回到上一个状态，装或者不装都只影响递归调用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f01</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> cw, <span class="keyword">int</span>[] items, <span class="keyword">int</span> n, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//cw==w表示装满了；i==n表示已考察完所有的物品</span></span><br><span class="line">        <span class="keyword">if</span>(cw == w || i == n) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cw &gt; maxW)</span><br><span class="line">                maxW = cw;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前物品不装进背包，考虑下一个时（i+1），cw不更新</span></span><br><span class="line">        f01(i+<span class="number">1</span>,cw,items,n,w);</span><br><span class="line">        <span class="keyword">if</span>(cw + items[i] &lt;= w) &#123;</span><br><span class="line">            <span class="comment">//当前物品装进背包，考虑下一个时（i+1），cw通过入参更新为cw+items[i]</span></span><br><span class="line">            f01(i+<span class="number">1</span>,cw+items[i],items,n,w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<p>变体：每个物品重量不同，价值不同，在不超过背包重量的情况下，让背包中的总价值最大。</p>
<p><strong>正则表达式</strong><br>背景假设，正则表达式中只包含“<em>”和“？”这两种通配符，其中“</em>”匹配任意多个（&gt;=0个）任意字符，“？”匹配另个或者一个任意字符。  </p>
<p>依次考察正则表达式中的每个字符，当是非通配符时，就直接跟文本的字符进行匹配，如果相同，则继续往下处理；如果不同，则回溯。<br>如果遇到特殊字符的时候，也就是岔路口，“*”，先随意的选择一种匹配方案，然后继续考察剩下的字符，如果中途发现无法继续匹配下去，就回溯到岔路口，重新选择一种匹配方案，然后再继续匹配剩下的字符。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        正则表达式
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pattern</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> matched = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//正则表达式</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">char</span>[] pattern;</span><br><span class="line">        <span class="comment">//正则表达式长度</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> plen;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Pattern</span><span class="params">(<span class="keyword">char</span>[] pattern,<span class="keyword">int</span> plen)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.pattern = pattern;</span><br><span class="line">            <span class="keyword">this</span>.plen = plen;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//文本串及长度</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>[] text, <span class="keyword">int</span> tlen)</span> </span>&#123;</span><br><span class="line">            matched = <span class="keyword">false</span>;</span><br><span class="line">            rmatch(<span class="number">0</span>,<span class="number">0</span>,text,tlen);</span><br><span class="line">            <span class="keyword">return</span> matched;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rmatch</span><span class="params">(<span class="keyword">int</span> ti, <span class="keyword">int</span> pj, <span class="keyword">char</span>[] text, <span class="keyword">int</span> tlen)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//已经匹配了，不用继续递归</span></span><br><span class="line">            <span class="keyword">if</span>(matched) <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">//正则表达式结束</span></span><br><span class="line">            <span class="keyword">if</span>(pj == plen) &#123;</span><br><span class="line">                <span class="comment">//文本串结束</span></span><br><span class="line">                <span class="keyword">if</span>(ti == tlen)</span><br><span class="line">                    matched = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(pattern[pj] == <span class="string">'*'</span>) &#123;</span><br><span class="line">                <span class="comment">//匹配任意个字符0~tlen-ti</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= tlen-ti; ++k) &#123;</span><br><span class="line">                    rmatch(ti+k,pj+<span class="number">1</span>,text,tlen);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pattern[pj] == <span class="string">'?'</span>) &#123;</span><br><span class="line">                <span class="comment">//匹配0个或者1个字符</span></span><br><span class="line">                rmatch(ti,pj+<span class="number">1</span>,text,tlen);<span class="comment">//0个</span></span><br><span class="line">                rmatch(ti+<span class="number">1</span>,pj+<span class="number">1</span>,text,tlen);<span class="comment">//1个</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ti &lt; tlen &amp;&amp; pattern[pj] == text[ti]) &#123;</span><br><span class="line">                <span class="comment">//纯字符匹配</span></span><br><span class="line">                rmatch(ti+<span class="number">1</span>,pj+<span class="number">1</span>,text,tlen);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><div id="refer-anchor-1"></div>  

<ul>
<li><p>[<a href="#back-1">1</a>] <a href="https://algorithm-visualizer.org/backtracking/n-queens-problem" target="_blank" rel="noopener">N皇后问题-回溯</a>  </p>
<div id="refer-anchor-2"></div>  
</li>
<li><p>[<a href="#back-2">2</a>] <a href="https://www.geeksforgeeks.org/n-queen-problem-backtracking-3/" target="_blank" rel="noopener">回溯算法-N皇后问题</a>  </p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>回溯算法</tag>
        <tag>深度优先</tag>
      </tags>
  </entry>
  <entry>
    <title>分治算法</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>MapReduce、GFS(Google File System)、Bigtable是谷歌大数据处理的三驾马车。<br>MapReduce在倒排索引、PageRank计算、网页分析等搜索引擎相关的技术中有大量的应用。  </p>
<h3 id="分治算法理解"><a href="#分治算法理解" class="headerlink" title="分治算法理解"></a>分治算法理解</h3><p>分治算法的核心思想：分而治之。<br>将原问题划分成n个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后在合并其结果，得到原问题的解。  </p>
<p>分治算法是一种处理问题的思想，递归是一种编程技巧。分治算法一般都比较适合用递归来实现。  </p>
<ul>
<li>分解：将原问题分解成一系列子问题；  </li>
<li>解决：递归地求解各个子问题，若子问题足够小，则直接求解；  </li>
<li>合并：将子问题的结果合并成原问题。  </li>
</ul>
<p>前提条件：  </p>
<ul>
<li>原问题与分解成的小问题具有相同的模式；  </li>
<li>原问题分解成的子问题可以独立求解，子问题之间没有相关性；（分治算法与动态规划的区别）  </li>
<li>具有分解终止条件，当问题足够小时，可以直接求解；  </li>
<li>可以将子问题合并成原问题，合并操作的复杂度不高。  </li>
</ul>
<h3 id="分治算法编程应用"><a href="#分治算法编程应用" class="headerlink" title="分治算法编程应用"></a>分治算法编程应用</h3><p>排序中应用(二分、归并、快排)<br>有序度表示一组数据的有序程度，逆序度表示一组数据的无序程度。<br>n个数据从小到大排列，完全有序的数据（等差数列求和）的有序度就是n(n-1)/2，逆序度等于0；倒序排列的数据的有序度是0，逆序度是n(n-1)/2。<br>其余通过计算有序对/逆序对的个数，表示数据的有序度或逆序度。  </p>
<ul>
<li><p>拿每个数字跟它后面的数据比较，看有几个比它小的，把比它小的数字个数记作k，依次类推，对每个数字对应的k值求和，最后得到的总和就是逆序对个数。时间复杂度是O(n<sup>2</sup>)。  </p>
</li>
<li><p>套用分治的思想求数组的逆序对个数，将数组分成前后两半A1和A2，分别计算A1和A2的逆序对个数K1和K2，然后再计算A1与A2之间的逆序对个数K3。数组A的逆序对个数为K1+K2+K3。  </p>
<p>借助归并排序算法，将两个有序的小数组合并成一个有序的数组的过程中，每次合并操作都计算逆序对个数，把计算出来的逆序对个数求和，就是这个数组的逆序对个数。  </p>
  <div class='spoiler collapsed'>
    <div class='spoiler-title'>
        逆序度
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    num = <span class="number">0</span>;</span><br><span class="line">    mergeSortCounting(a,<span class="number">0</span>,n-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeSortCounting</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//中点</span></span><br><span class="line">    <span class="keyword">int</span> mid = (start+r=end)/<span class="number">2</span>;</span><br><span class="line">    mergeSortCounting(a,start,mid);</span><br><span class="line">    mergeSortCounting(a,mid+<span class="number">1</span>,end);</span><br><span class="line">    <span class="comment">//合并函数</span></span><br><span class="line">    mergeSort(a,start,mid,end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//临时数组，大小为当前分区的大小</span></span><br><span class="line">    <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[right-left+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = left;<span class="comment">//左边起始下标</span></span><br><span class="line">    <span class="keyword">int</span> j = mid+<span class="number">1</span>;<span class="comment">//右边起始下标</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">        <span class="comment">//取左右区间中元素最小值放入当前位置</span></span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt;= a[j]) &#123;</span><br><span class="line">            tmp[k++] = a[i++]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//统计左区间left-mid之间，比右区间当前元素a[j]大的元素个数</span></span><br><span class="line">            num += (mid-i+<span class="number">1</span>);</span><br><span class="line">            tmp[k++] = a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理左区间剩下的</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) &#123;</span><br><span class="line">        tmp[k++] = a[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理右区间剩下的</span></span><br><span class="line">    <span class="keyword">while</span>(j &lt;= right) &#123;</span><br><span class="line">        tmp[k++] = a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从tmp拷贝回原数组a对应区间</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= right-left+<span class="number">1</span>; i++) &#123;</span><br><span class="line">        a[left+i] = tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

</li>
</ul>
<h3 id="分治算法处理海量数据"><a href="#分治算法处理海量数据" class="headerlink" title="分治算法处理海量数据"></a>分治算法处理海量数据</h3><p>利用分治的思想解决数据量大到内存装不下的问题。  </p>
<p>将海量数据集合根据某种方法，划分为几个小的数据集合，每个小的数据集合单独加载到内存来解决，然后再将小数据集合合并成大数据集合。  </p>
<p>利用这种分治的处理思路，能克服内存的限制，还能利用多线程或者多机处理，加快处理的速度。  </p>
<p>MapReduce框架只是一个任务调度器，底层依赖GFS来存储数据，依赖Borg管理及其。从GFS中拿数据，交给Borg中的机器执行，时刻监控机器执行状态并调度。<br>可以处理数据与数据之间存在关系的任务-统计文件中单词出现频率<br>可以处理数据与数据之间没有关系的任务-网页分析、分词  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>分治算法</tag>
        <tag>MapRedue</tag>
      </tags>
  </entry>
  <entry>
    <title>初识动态规划</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%9D%E8%AF%86%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p>动态规划可以非常显著的降低时间复杂度，提高代码的执行效率。  </p>
<h3 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h3><p>对于一组不同重量、不可分割的物品，选择一些装入背包，在满足背包最大重量限制的前提下，背包中物品总重量的最大值。  </p>
<ol>
<li><p>回溯算法<br>穷举所有可能的装法，然后找出 满足条件的最大值。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        0-1背包 回溯算法
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxW = Integer.MIN_VALUE;</span><br><span class="line"><span class="comment">//物品重量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] weight = &#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">//物品个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="comment">//背包承受的最大重量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> w = <span class="number">9</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> cw)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//cw == w表示装满了，i == n表示物品考察完了</span></span><br><span class="line">    <span class="keyword">if</span>(cw == w || i == n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cw &gt; maxW) maxW = cw;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f(i+<span class="number">1</span>, cw);<span class="comment">//不装第i个物品</span></span><br><span class="line">    <span class="keyword">if</span>(cw + wight[i] &lt;= w) &#123;</span><br><span class="line">        <span class="comment">//装第i个物品</span></span><br><span class="line">        f(i+<span class="number">1</span>, cw + weight[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p>将回溯求解过程转换为递归树<br>树中的每个节点表示一种状态，用(i,cw)表示。i表示将要决策第几个物品是否装入背包，cw表示当前背包中物品的总重量。<br>在递归树中，有些子问题的求解是重复的，可以借助递归中的备忘录的解决方式，记录已经计算好的f(i,cw)，当再次计算到重复的f(i,cw)时，直接从备忘录中取出来，避免冗余计算。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        0-1背包 回溯算法+备忘录
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxW = Integer.MIN_VALUE;</span><br><span class="line"><span class="comment">//物品重量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] weight = &#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">//物品个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="comment">//背包承受的最大重量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> w = <span class="number">9</span>;</span><br><span class="line"><span class="comment">//备忘录，默认值false</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[][] mem = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">5</span>][<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> cw)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//cw == w表示装满了，i == n表示物品考察完了</span></span><br><span class="line">    <span class="keyword">if</span>(cw == w || i == n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cw &gt; maxW) maxW = cw;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mem[i][cw]) <span class="keyword">return</span>;<span class="comment">//重复状态</span></span><br><span class="line">    mem[i][cw] = <span class="keyword">true</span>;<span class="comment">//标记（i,cw）这个状态</span></span><br><span class="line">    f(i+<span class="number">1</span>, cw);<span class="comment">//不装第i个物品</span></span><br><span class="line">    <span class="keyword">if</span>(cw + wight[i] &lt;= w) &#123;</span><br><span class="line">        <span class="comment">//装第i个物品</span></span><br><span class="line">        f(i+<span class="number">1</span>, cw + weight[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p>回溯算法解决问题的时间复杂度是O(2<sup>n</sup>)，是指数级的。  </p>
</li>
<li><p>动态规划<br>把整个求解过程分为多个阶段，每个阶段对应一个决策，记录每一阶段可达的状态集合（去掉重复的），通过当前阶段的状态集合，来推导下一阶段的状态集合，动态的往前推进。  </p>
<blockquote>
<p>对应背包问题，把整个求解过程分为n个阶段，每个阶段会决策一个物品是否放到背包中。每个物品决策完之后，背包中的物品的重量会有多种情况，达到多种不同的状态，对应到递归树中，就是很多不同的节点。<br>把每一层重复的状态（节点）合并，只记录不同的状态，然后基于上一层的状态集合，来推导下一层的状态集合。动态的往前推进。  </p>
</blockquote>
<p>通过合并每一层重复的状态，这样保证每一层不同状态的个数都不会超过w个(如背包的承载重量w)，成功避免了每层状态个数的指数级增长。  </p>
<p>最终，只需要在最后一层找一个值为true的最接近w的值，就是背包中物品总重量的最大值。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        0-1背包 动态规划
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//wight物品重量</span></span><br><span class="line"><span class="comment">//n物品个数</span></span><br><span class="line"><span class="comment">//w背包可承载重量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span>[] weight, <span class="keyword">int</span> n, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[][] states = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][w+<span class="number">1</span>];<span class="comment">//默认值false</span></span><br><span class="line">    <span class="comment">//哨兵特殊处理第一行的数据</span></span><br><span class="line">    states[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(weight[<span class="number">0</span>] &lt;= w) &#123;</span><br><span class="line">        states[<span class="number">0</span>][weight[<span class="number">0</span>]] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//动态规划状态转移</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment">//不把第i个物品放入背包</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= w; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(states[i-<span class="number">1</span>][j] == <span class="keyword">true</span>) &#123;</span><br><span class="line">                states[i][j] = states[i-<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把第i个物品放入背包</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= w-weight[i]; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(states[i-<span class="number">1</span>][j]==<span class="keyword">true</span>) &#123;</span><br><span class="line">                states[i][j+weight[i]] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出结果</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = w; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(states[n-<span class="number">1</span>][i] == <span class="keyword">true</span>) </span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p>动态规划代码中，耗时最多的部分就是代码中的两层for循环，时间复杂度是O(n*w)。n表示物品个数，w表示背包可以承载的总重量。<br>代码中，需要额外申请一个n乘以w+1的二维数组，对空间的消耗比较多。动态规划是一种空间换时间的解决思路。  </p>
<p>一维数组优化,只记录当前层选择后的最终结果，节省空间，但是无法倒推放入了哪些物品。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        0-1背包 动态规划-一维数组
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span>[] items, <span class="keyword">int</span> n, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] states = <span class="keyword">new</span> <span class="keyword">boolean</span>[w+<span class="number">1</span>];<span class="comment">//默认值false</span></span><br><span class="line">    <span class="comment">//哨兵特殊处理第一行数据</span></span><br><span class="line">    states[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(items[<span class="number">0</span>] &lt;= w) &#123;</span><br><span class="line">        states[items[<span class="number">0</span>]] =<span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//动态规划</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = w-items[i]; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(states[j] == <span class="keyword">true</span>)</span><br><span class="line">                states[j+items[i]] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出结果，最大重量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = w; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(states[i] == <span class="keyword">true</span>)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p>j从大到小处理，避免for循环重复计算的问题。  </p>
<blockquote>
<p>比如 j = 0, item[i] = 5, w=10，如果正向循环，j=0 时会设置 state[5] = true, 而当遍历至 j=5时，由于 state[5]=true，会设置 state[10] = true，但是实际上将 5 这个重量使用了两次，所以导致了重量的重复使用。  </p>
</blockquote>
</li>
</ol>
<h3 id="0-1背包问题升级版"><a href="#0-1背包问题升级版" class="headerlink" title="0-1背包问题升级版"></a>0-1背包问题升级版</h3><p>引入物品价值变量。<br>对于一组不同重量、不同价值、不可分割的物品，选择将某些物品装入背包，在满足背包最大重量限制的前提下，背包中可装入物品的总价值的最大值。  </p>
<ol>
<li><p>回溯算法  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        0-1背包升级版 回溯算法
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxV = Integer.MIN_VALUE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] items = &#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] value = &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> w = <span class="number">9</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> cw, <span class="keyword">int</span> cv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cw == w || i == n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cv &gt; maxV) &#123;</span><br><span class="line">            maxV = cv;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f(i+<span class="number">1</span>,cw,cv);</span><br><span class="line">    <span class="keyword">if</span>(cw+weight[i] &lt;= w) &#123;</span><br><span class="line">        f(i+<span class="number">1</span>, cw+weight[i], cv+value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p>递归树：<br>在递归树中，每个节点表示一个状态。用三个变量(i,cw,cv)表示一个状态，其中i表示即将要决策第i个物品是否装入背包，cw表示当前背包中物品的总重量，cv表示当前背包中物品的总价值。<br>在递归树中，有些节点的i和cw是完全相同的，在背包中物品总重量一样的情况下，某种状态对应的物品总价值更大，可以舍弃同种状态价值小的状态，沿着价值大的决策路线继续往下决策。<br>对于(i，cw)相同的不同状态，只需要保留cv值最大的状态，继续递归处理，其他状态不予考虑。  </p>
</li>
<li><p>动态规划<br>把整个求解过程分为n个阶段，每个阶段决策一个物品是否放入背包中。每个阶段决策之后，背包中的物品的总重量以及总价值会有多种情况。<br>用一个二维数组states[n][w+1]，来记录每层可以达到的不同状态，数组中存储的是当前状态对应的最大总价值。把每一层中(i,cw)重复的状态节点合并，只记录cv值最大的那个状态，然后基于这些状态来推导下一层的状态。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        0-1背包升级版 动态规划
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span>[] weight, <span class="keyword">int</span>[] value, <span class="keyword">int</span> n, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//n个物品，w+1种重量</span></span><br><span class="line">    <span class="keyword">int</span>[][] states = <span class="keyword">new</span> <span class="keyword">int</span>[n][w+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//初始化states</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;w+<span class="number">1</span>; ++j) &#123;</span><br><span class="line">            states[i][j] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第一行数据特殊处理</span></span><br><span class="line">    states[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(weight[<span class="number">0</span>] &lt;= w) &#123;</span><br><span class="line">        states[<span class="number">0</span>][weight[<span class="number">0</span>]] = value[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//动态规划，状态转移</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; ++i) &#123;</span><br><span class="line">        <span class="comment">//不选择第i个物品，上一行该列的状态转移导致本行该列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=w; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(states[i-<span class="number">1</span>][j] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                states[i][j] = states[i-<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//选择第i个物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=w-weight[i]; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(states[i-<span class="number">1</span>][j] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = states[i-<span class="number">1</span>][j] + value[i];</span><br><span class="line">                <span class="keyword">if</span>(v &gt; states[i][j+weight[i]]) &#123;</span><br><span class="line">                    states[i][j+weight[i]] = v;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找到最大值,必定在最后一行</span></span><br><span class="line">    <span class="keyword">int</span> maxvalue = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=w; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span>(states[n-<span class="number">1</span>][j] &gt; maxvalue) &#123;</span><br><span class="line">            maxvalue = states[n-<span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxvalue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p>时间复杂度为O(n*w),空间复杂度O(n*w)。  </p>
</li>
</ol>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>大部分动态规划能解决的问题，都可以通过回溯算法来解决。<br>回溯算法解决起来效率比较低，时间复杂度是指数级的。<br>动态规划在执行效率方面高很多，但是空间复杂度也提高了。<br>动态规划是一种空间换时间的算法思想。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>0-1背包</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划理论</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<h3 id="一个模型三个特征"><a href="#一个模型三个特征" class="headerlink" title="一个模型三个特征"></a>一个模型三个特征</h3><ul>
<li><p><strong>多阶段决策最优解模型</strong><br>一般用动态规划解决最优问题。解决问题的过程需要经历多个决策阶段，每个决策阶段都对应着一组状态。寻找一组决策序列，经过这组决策序列，能够产生最终期望求解的最优值。  </p>
</li>
<li><p><strong>最优子结构</strong><br>问题的最优解包含子问题的最优解。同样，可以通过子问题的最优解，推导出问题的最优解。对应动态规划问题模型，后面阶段的装填可以通过前面阶段状的状态推导出来。  </p>
</li>
<li><p><strong>无后效性</strong><br>两层含义，第一层含义是，在推导后面阶段的状态的时候，只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。第二层含义是，某阶段状态一旦确定，就不受之后阶段的决策影响。  </p>
</li>
<li><p><strong>重复子问题</strong><br>不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。  </p>
</li>
</ul>
<p>实例解析：<br>一个n乘以n的矩阵w[n][n]。矩阵存储的都是正整数，棋子起始位置在左上角，终止位置在右下角。将棋子从左上角移动到右下角。每次只能向右或者向下移动一位。从左上角到右下角，会有很多不同的路径可以走。把每条路径经过的数字加起来看做路径的长度。求从左上角移动到右下角的最短路径长度。  </p>
<p>从(0,0)走到(n-1.n-1),总共需要走2*(n-1)步，也就对应着2*(n-1)个阶段。每个阶段都有向右走或者向下走两种决策，并且每个阶段都会对应一个状态集合。把状态定义为min_dist(i,j)，其中i表示行，j表示列。min_dist表达式的值表示从(0,0)到达(i,j)的最短路径长度。这个问题是一个多阶段决策最优解问题，符合“动态规划的模型”。  </p>
<p>可以用回溯算法解决问题。递归树中有重复的节点，重复的节点表示，从左上角到节点对应的位置，有多种路线，说明这个问题存在“重复子问题”。  </p>
<p>走到(i,j)这个位置，只能通过(i-1,j)，(i,j-1)这两个位置移动过来。所以计算(i,j)位置对应的状态，只需要关心(i-1,j)，(i,j-1)两个位置对应的状态，并不关心棋子是通过什么样的路线到达这两个位置的。而且，仅仅允许往下和往右移动，不允许后退，前面阶段的状态确定之后，不会被后面阶段的决策所改变，符合“无后效性”。  </p>
<p>定义状态的时候，把从起始位置(0,0)到(i,j)的最小路径，记作min_dist(i,j)。因为只能往右或往下移动，所以只有可能从(i-1,j)或者(i,j-1)两个位置到达(i,j)。到达(i,j)的最短路径肯定包含到达这两个位置的最短路径之一。min_dist(i,j)可以通过min_dist(i,j-1)和min_dist(i-1,j)这两个状态推导出来，这个问题符合“最优子结构”。</p>
<blockquote>
<p>min_dist(i,j) = w[i][j] + min(min_dist(i,j-1),min(i-1,j))</p>
</blockquote>
<h3 id="动态规划解题思路"><a href="#动态规划解题思路" class="headerlink" title="动态规划解题思路"></a>动态规划解题思路</h3><p><strong>一般能用动态规划解决的问题，都可以使用回溯算法的暴力搜索解决</strong>。  </p>
<p>状态转移表法&amp;状态转移方程法  </p>
<ol>
<li><p>状态转移表法<br>思路：回溯算法实现-定义状态-画递归树-找重复子问题-画状态转移表-根据递推关系填表-将填表过程翻译成代码  </p>
<p>先用简单的回溯算法解决，然后定义状态，每个状态表示一个节点，然后对应画出递归树。从递归树中，可以看出来是否存才重复子问题，以及重复子问题是如何产生的。以此来寻找规律，看是够能用动态规划解决。<br>找到重复子问题之后，一种是直接使用<strong>回溯加备忘录</strong>的方法，来避免重复子问题，提高执行效率。一种是使用动态规划的解决方法，<strong>状态转移表法</strong>。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        矩阵最短路径 回溯算法
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> minDist = Integer.MAX_VALUE;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">minDistBT</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> dist, <span class="keyword">int</span>[][] w, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//到达(n-1,n-1)这个位置</span></span><br><span class="line">    <span class="keyword">if</span>(i == n &amp;&amp; j == n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dist &lt; minDist) midDist = dist;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; n) &#123;</span><br><span class="line">        <span class="comment">//往下走，更新i=i+1,j=j</span></span><br><span class="line">        minDistBT(i+<span class="number">1</span>, j, dist+w[i][j], w, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j &lt; n) &#123;</span><br><span class="line">        <span class="comment">//往右走，更新i=i,j=j+1</span></span><br><span class="line">        minDistBT(i, j+<span class="number">1</span>, dist+w[i][j], w, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p>先画出一个状态表，状态表一般是二维的，类似二维数组。其中每个状态包含三个变量，行、列、数组值。根据决策的先后过程，从前往后，根据递推关系，分阶段填充状态表中的每个状态。最后将这个递推填表的过程，翻译成代码，就是动态规划代码。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        矩阵最短路径 状态转移表
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistDP</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] states = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//初始化states的第一行数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">        sum += matrix[<span class="number">0</span>][j];</span><br><span class="line">        states[<span class="number">0</span>][j] = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//初始化states的第一列数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        sum += matrix[i][<span class="number">0</span>];</span><br><span class="line">        states[i][<span class="number">0</span>] = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            states[i][j] + Math.min(states[i][j-<span class="number">1</span>], states[i-<span class="number">1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> states[n-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p>大部分状态表都是二维的，如果状态比较复杂，需要很多变量来表示，那对应的状态表可能是高维的，不适合用状态转移表法解决，  </p>
</li>
<li><p>状态转移方程法<br>思路：找最优子结构-写状态转移方程-将状态转移方程翻译成代码  </p>
<p>状态转移方程法类似递归的解题思路。分析某个问题如何通过子问题来递归求解，即最优子结构。根据最优子结构，写出递归公式，即状态转移方程。状态转移方程式解决动态规划的关键。<br>有了状态转移方程，一种是<strong>递归加备忘录</strong>，一种是<strong>迭代递推</strong>。  </p>
 <div class='spoiler collapsed'>
    <div class='spoiler-title'>
        矩阵最短路径 递归+备忘录
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] matrix = &#123;&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>&#125;,&#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">7</span>&#125;,&#123;<span class="number">6</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">3</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] mem = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDist</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) <span class="keyword">return</span> matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(men[i][j] &gt; <span class="number">0</span>) <span class="keyword">return</span> matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> minLeft = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">if</span>(j-<span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        minLeft = minDeft(i, j-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> minUp = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">if</span>(i-<span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        minUp = minDist(i-<span class="number">1</span>,j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> currMinDist = matrix[i][j] + Math.min(minLeft, minUp);<span class="comment">//状态转移方程</span></span><br><span class="line">    mem[i][j] = currMinDist;</span><br><span class="line">    <span class="keyword">return</span> currMinDist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

 <div class='spoiler collapsed'>
    <div class='spoiler-title'>
        矩阵最短路径 迭代递推
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">参考状态转移表法代码。（代码相同，只是思路不同）</span><br></pre></td></tr></table></figure>
    </div>
</div>  

</li>
</ol>
<h3 id="贪心、分治、回溯、动态规划对比"><a href="#贪心、分治、回溯、动态规划对比" class="headerlink" title="贪心、分治、回溯、动态规划对比"></a>贪心、分治、回溯、动态规划对比</h3><ul>
<li><p><strong>分治算法</strong><br>贪心、回溯、动态规划可以归为一类，解决问题的模型都可以抽象成多阶段决策最优解模型；分治算法解决问题大部分是最优解问题，但是大部分都<strong>不能抽象成多阶段决策模型</strong>（各阶段情况相同，类似二分查找），不能有重复子问题。  </p>
</li>
<li><p><strong>回溯算法</strong><br>回溯算法是个<strong>万金油</strong>。基本上能用动态规划、贪心算法解决的问题，都可以用回溯算法解决。回溯算法相当于<strong>穷举(暴力)搜索</strong>，穷举所有的情况，然后对比得到最优解。回溯算法的时间复杂度 非常高，是指数级别的，只能用来解决<strong>小规模数据</strong>的问题。  </p>
</li>
<li><p><strong>动态规划</strong><br>尽管动态规划比回溯算法高效，但是并不是所有问题都可以用动态规划来解决。能用动态规划解决的问题，需要满足三个特征，最优子结构、无后效性、重复子问题。<strong>多阶段最优解模型</strong>。<br>在重复子问题上，动态规划和分治算法的区分非常明显。分治算法要求分割成的子问题，不能有重复子问题，而动态规划正好相反，动态规划之所以高效，就是因为回溯算法实现中存在大量的重复子问题。  </p>
</li>
<li><p><strong>贪心算法</strong><br>贪心算法实际上是一种<strong>特殊的动态规划</strong>。它解决问题起来更加高效，代码实现也更加简洁，可以解决的问题也更加有限。它能解决的问题需要满足三个条件，最优子结构、无后效性、贪心选择性（不强调重复子问题）。<br>贪心选择性指，<strong>通过局部最优的选择，能产生全局的最优选择</strong>。每一个阶段，都选择当前看起来最优的决策，所有阶段的决策完成之后，最终由这些局部最优解构成全局最优解。（贪心算法的解不一定是全局最优解）  </p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>A*搜索</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/A-%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<p>A*算法是对Dijkstra算法的优化和改造。属于一种<strong>启发式搜索算法</strong>。  </p>
<p>常见的启发式搜索算法：IDA*算法、蚁群算法、遗传算法、模拟退火算法。  </p>
<p>启发式搜索算法利用估价函数，避免“跑偏”，贪心的朝着最有可能到达终点的方向前进。这种算法找出的路线，并不是最短路线。但是能很好的平衡路线质量和执行效率。  </p>
<h3 id="算法解析"><a href="#算法解析" class="headerlink" title="算法解析"></a>算法解析</h3><p>Dijkstra算法类似BFS算法，每次找到跟起点最近的顶点，往外扩展，有些盲目（离起点最近的点可能离终点最远）。<br>在Dijkstra算法的实现思路中，用一个优先级队列，来记录已经遍历到的顶点以及这个顶点与起点的路径长度。顶点与起点路径长度越小，就越先被从优先级队列中取出来扩展。尽管找到是从s到t的路线，但是最先被搜索的路线可能是与期望路线的反方向。  </p>
<p>按照顶点与起点的路径长度的大小，来安排出队列顺序，与起点越近的顶点，就会越早出队列。并没有考虑到这个顶点到终点的距离，所以尽管顶点离起始顶点最近，但离终点却越来越远。  </p>
<p>当遍历到某个顶点的时候，从起点走到这个顶点的路径长度是确定的，记作g(i)(i表示顶点编号)。<br>这个顶点跟终点之间的直线距离-欧几里得距离，可以近似的估计顶点跟 终点的路径长度，记作h(i)(i表示顶点编号)—<strong>启发函数</strong>。更进一步使用两点之间横纵坐标的距离之和-曼哈顿距离来简化。  </p>
<p>原来只是单纯的通过顶点与起点之间的路径长度g(i)，来判断谁先出队列；现在加上顶点到终点的路径长度估计值，通过两者之和f(i)=g(i)+h(i)—<strong>估价函数</strong>。综合两部分，能有效避免跑偏。  </p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>在A*算法的代码实现中，顶点Vertex类的定义，跟Dijkstra算法中的定义相比，多了x,y坐标，以及估价函数f(i)的值。图Graph类的定义跟Dijkstra算法中的定义一样。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        有向有权图
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Edge&gt; adj[];<span class="comment">//邻接表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> v;<span class="comment">//顶点个数</span></span><br><span class="line"></span><br><span class="line">    publicGraph(<span class="keyword">int</span> v) &#123;</span><br><span class="line">        <span class="keyword">this</span>.v = v;</span><br><span class="line">        <span class="keyword">this</span>.adj = <span class="keyword">new</span> LinkedList[v];<span class="comment">//v个链表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) &#123;</span><br><span class="line">            <span class="keyword">this</span>.adj[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();<span class="comment">//每个编号的顶点都存了一个链表</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加一条边</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.add[s].add(<span class="keyword">new</span> Edge(s,t,w));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> sid;<span class="comment">//边的起始顶点编号</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> tid;<span class="comment">//边的终止顶点编号</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> w;<span class="comment">//权重</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">int</span> sid, <span class="keyword">int</span> tid, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.sid = sid;</span><br><span class="line">            <span class="keyword">this</span>.tid = sid;</span><br><span class="line">            <span class="keyword">this</span>.w = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Vertex</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> id;<span class="comment">//顶点编号ID</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> dist;<span class="comment">//从起始顶点到这个顶点的距离</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> f;<span class="comment">//f(i)=g(i)+h(i)</span></span><br><span class="line">        <span class="keyword">public</span> intx,y;<span class="comment">//顶点在地图中的坐标</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Vertex</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            <span class="keyword">this</span>.x = x;</span><br><span class="line">            <span class="keyword">this</span>.y = y;</span><br><span class="line">            <span class="keyword">this</span>.f = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">this</span>.dist = Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Graph类的成员变量，在构造函数中初始化</span></span><br><span class="line">    Vertex[] vertexes = <span class="keyword">new</span> Vertex[<span class="keyword">this</span>.v];</span><br><span class="line">    <span class="comment">//添加顶点的坐标</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addVertex</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        vertexes[id] = <span class="keyword">new</span> Vertex(id,x,y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p>A*算法与Dijkstra算法的区别：  </p>
<ul>
<li>优先级队列的构建方式不同。A*算法是根据f值(f(i)=g(i)+h(i))来构建优先级队列，而Dijkstra算法是根据dist值(g(i))来构建优先级队列。  </li>
<li>A*算法在更新顶点dist值的时候，会同步更新f值。  </li>
<li>循环结束的条件不一样。Dijkstra算法是在终点出队列的时候才结束，A*算法是一旦遍历到终点就结束。  </li>
</ul>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        A*算法
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从顶点s到顶点t的路径</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">astar</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//还原路径</span></span><br><span class="line">    <span class="keyword">int</span>[] predecessor = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.v];</span><br><span class="line">    <span class="comment">//按照vertex的f值构建的小顶堆(Dijkstra按照dist)</span></span><br><span class="line">    PriorityQueue queue = <span class="keyword">new</span> PriorityQueue(<span class="keyword">this</span>.v);</span><br><span class="line">    <span class="comment">//标记是否进入过队列</span></span><br><span class="line">    <span class="keyword">boolean</span>[] inqueue = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="keyword">this</span>.v];</span><br><span class="line">    vertexes[s].dist = <span class="number">0</span>;</span><br><span class="line">    vertexes[s].f = <span class="number">0</span>;</span><br><span class="line">    queue.add(vertexes[s]);</span><br><span class="line">    inqueue[s] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//取堆顶元素并删除</span></span><br><span class="line">        Vertex minVertex = queue.poll();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj[minVertex.id].size(); ++i) &#123;</span><br><span class="line">            <span class="comment">//取出一条minVertex相连的边</span></span><br><span class="line">            Edge e = adj[minVertex.id].get(i);</span><br><span class="line">            <span class="comment">//minVertex --&gt; nextVertex</span></span><br><span class="line">            Vertex nextVertex = vertexes[e.tid];</span><br><span class="line">            <span class="keyword">if</span>(minVertex.dist + e.w &lt; nextVertex.dist) &#123;</span><br><span class="line">                <span class="comment">//更新next的dist,f</span></span><br><span class="line">                nextVertex.dist = minVertex.dist + e.w;</span><br><span class="line">                nextVertex.f = nextVertex.dist + hManhattan(nextVertex, vertexes[t]);</span><br><span class="line">                predecessor[nextVertex.id] = minVertex.id;</span><br><span class="line">                <span class="keyword">if</span>(inqueue[nextVertex.id] == <span class="keyword">true</span>) &#123;</span><br><span class="line">                    queue.update(nextVertex);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    queue.add(nextVertex);</span><br><span class="line">                    inqueue[nextVertex.id] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//只要到达t就可以结束while</span></span><br><span class="line">            <span class="keyword">if</span>(nextVertex.id == t) &#123;</span><br><span class="line">                <span class="comment">//清空queue，才能推出while循环</span></span><br><span class="line">                queue.clear();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出路径</span></span><br><span class="line">    System.out.print(s);</span><br><span class="line">    print(s,t,predecessor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span>[] predecessor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == t) <span class="keyword">return</span>;</span><br><span class="line">    print(s, predecessor[t], predecessor);</span><br><span class="line">    System.out.print(<span class="string">"-&gt;"</span> + t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<h3 id="对比分析"><a href="#对比分析" class="headerlink" title="对比分析"></a>对比分析</h3><p>A*算法可以更加快速的找到从起点到终点的路线，但是它并不能像Dijkstra算法那样，找到最短路线。  </p>
<p>回溯穷举所有从s到达t的不同路径，然后对比找出最短的那个。  </p>
<p>Dijkstra算法在回溯的基础上，利用动态规划的思想，堆回溯搜索进行了剪枝，只保留起点到某个顶点的最短路径，继续往外扩展搜索。动态规划相较于回溯搜索，只是换了一个实现思路，实际上也考察了所有从起点到终点的路线，得到的最优解。  </p>
<p>Dijkstra算法是在终点出队列的时候才结束，A*算法是一旦遍历到终点就结束。对于Dijkstra算法来说，当终点出队列的时候，终点的dist值是优先级队列中所有顶点的最小值，即使再运行下去，终点的dist值也不会再被更新了。对于A*算法来说，一旦遍历到终点，就结束while循环，这个时候，终点的dist值未必是最小值。<br>A*算法利用贪心算法的思路，每次都找f值最小的顶点出队列，一旦搜索到终点就不在继续考察其他顶点和路线了。它并没有考察所有的路线，也就不可能找到最短路径。  </p>
<blockquote>
<p>游戏寻路问题，把地图抽象成图，把岔路口抽象成顶点，把道路抽象成边。  </p>
</blockquote>
<blockquote>
<p>把地图分割成一个个的小方块。在某一个方块上的人物，只能往上下左右四个方向的方块上移动。把每个方块看做一个顶点。两个方块相邻，就在他们之间连两条有向边，并且边的权值都是1。  </p>
</blockquote>
<blockquote>
<p>将问题转化成，在一个有向有权图中，找某一个顶点到另一个顶点的路径问题，将地图抽象成边权值为1的有向图之后，套用A*算法解决人物自动寻路功能。  </p>
</blockquote>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>A*搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划实战</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<p>量化两个字符串之间的相似程度-编辑距离(Edit Distance)<br>编辑距离指的是，将一个字符串转化成另一个字符串，需要的最少编辑操作次数（增加一个字符、删除一个字符、替换一个字符）。编辑距离越大说明两个字符串的相似程度越小；相反编辑距离越小，说明两个字符串的相似程度越大。对于两个完全相同的字符串来说，编辑距离就是0。  </p>
<p>根据所包含的编辑操作种类的不同，编辑距离有多种不同的计算方式：<br><strong>莱文斯坦距离</strong>，允许增加、删除、替换字符，表示两个字符串差异的大小；<br><strong>最长公共子串长度</strong>，允许增加、删除字符，表示两个字符串相似程度的大小。  </p>
<h3 id="莱文斯坦距离"><a href="#莱文斯坦距离" class="headerlink" title="莱文斯坦距离"></a>莱文斯坦距离</h3><p>把一个字符串变成另一个字符串，需要的最少编辑次数。<br>整个求解过程，涉及多个决策阶段，需要依次考察一个字符串中的每个字符，跟另一个字符串中的字符是否匹配，匹配与不匹配分别对应不同的处理方式。符合多阶段决策最优解模型（贪心、回溯、动态规划）。  </p>
<ol>
<li><p>回溯算法-递归处理<br>如果a[i]与b[j]匹配，递归考察a[i+1]和b[j+1]。<br>如果a[i]与b[j]不匹配：  </p>
<ul>
<li>删除a[i]，递归考察a[i+1]和b[j]；</li>
<li>删除b[j]，递归考察a[i]和b[j+1]；</li>
<li>在a[i]前面添加一个跟b[j]相同的字符，然后递归考察a[i]和b[j+1]；</li>
<li>在b[j]前面添加一个跟a[i]相同的字符，然后递归考察a[i+1]和b[j]；</li>
<li>将a[i]替换成b[j]，或者将b[j]替换成a[i]，然后递归考察a[i+1]和b[j+1]。  </li>
</ul>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        莱文斯坦距离 回溯算法
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">char</span>[] a = <span class="string">"mitcmu"</span>.toCharArray();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">char</span>[] b = <span class="string">"mtacnu"</span>.toCharArray();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> m = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> minDist = Integer.MAX_VALUE;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">lwstBT</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> edist)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == n || j == m) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; n) edist += (n-i);</span><br><span class="line">        <span class="keyword">if</span>(j &lt; m) edist += (m-j);</span><br><span class="line">        <span class="keyword">if</span>(edist &lt; minDist) minDist = edist;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a[i] == b[j]) &#123;<span class="comment">//两个字符匹配</span></span><br><span class="line">        lwstBT(i+<span class="number">1</span>, j+<span class="number">1</span>, edist);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//两个字符不匹配</span></span><br><span class="line">        lwstBT(i+<span class="number">1</span>, j, edist+<span class="number">1</span>);<span class="comment">//删除a[i]或者b[j]前添加一个字符</span></span><br><span class="line">        lwstBT(i, j+<span class="number">1</span>, edist+<span class="number">1</span>);<span class="comment">//删除b[j]或者a[i]前添加一个字符</span></span><br><span class="line">        lwstBT(i+<span class="number">1</span>, j+<span class="number">1</span>, edist+<span class="number">1</span>);<span class="comment">//将a[i]和b[j]替换为相同字符</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  
</li>
<li><p>根据回溯算法的代码实现，可以画出递归树，看是否存在重复子问题。<br>如果存在重复子问题，可以考虑是否用动态规划来解决；<br>如果不存在重复子问题，那回溯算法就是最好的解决方法。<br>在递归树中，每个节点代表一个状态，状态包含三个变量(i,j,edist)，其中edist表示处理a[i]和b[j]时，已经执行的编辑操作的次数。  </p>
</li>
<li><p>在递归树中，(i,j)两个变量重复的节点很多。<br>对于(i,j)相同的节点， 只需要保留edist最小的，继续递归处理就可以了，剩下的节点都可以舍弃。所以状态就从(i,j,edist)变成了(i,j,min_edist)，其中min_edist表示处理到a[i]和b[j]已经执行的最小编辑次数。<br>状态(i,j)可能从(i-1,j)、(i,j-1)，(i-1,j-1)三个状态中的任意一个转移过来。  </p>
</li>
<li><p>尝试将状态转移的过程用公式写出来-状态转移方程  </p>
<blockquote>
<p>如果:a[i]!=b[j],那么:min_edist(i,j)就等于:<br>min(min_edist(i-1,j)+1,min_edist(i,j-1)+1,min_edist(i-1,j-1)+1)  </p>
</blockquote>
<blockquote>
<p>如果:a[i]=b[j],那么:min_edist(i,j)就等于:<br>min(min_edist(i-1,j)+1,min_edist(i,j-1)+1,min_edist(i-1,j-1))<br>min表示求三数中的最小值</p>
</blockquote>
</li>
<li><p>了解状态与状态之间的递推关系，画出一个二维状态表，按行依次来填充状态表中的每个值。  </p>
</li>
<li><p>根据状态转移方程和填表过程，翻译成代码：  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        莱文斯坦距离 动态规划
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lwstDP</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> n, <span class="keyword">char</span>[] b, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] minDist = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">    <span class="comment">//初始化第0行：a[0...0]与b[0...j]的编辑距离</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;m; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>] == b[j]) minDist[<span class="number">0</span>][j] = j;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j != <span class="number">0</span>) minDist[<span class="number">0</span>][j] = minDist[<span class="number">0</span>][j-<span class="number">1</span>] +<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> minDist[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化第0列：a[0...i]与b[0...0]的编辑距离</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == b[<span class="number">0</span>]) minDist[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i != <span class="number">0</span>) minDist[i][<span class="number">0</span>] = minDist[i-<span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> minDist[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//按行填表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] == b[j]) minDist[i][j] = min(minDist[i-<span class="number">1</span>][j] + <span class="number">1</span>, minDist[i][j-<span class="number">1</span>] + <span class="number">1</span>, minDist[i-<span class="number">1</span>][j-<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">else</span> minDist[i][j] = min(minDist[i-<span class="number">1</span>][j]+<span class="number">1</span>, minDist[i][j-<span class="number">1</span>]+<span class="number">1</span>, minDist[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minDist[n-<span class="number">1</span>][m-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minv = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; minv) minv = x;</span><br><span class="line">    <span class="keyword">if</span>(y &lt; minv) minv = y;</span><br><span class="line">    <span class="keyword">if</span>(z &lt; minv) minv = z;</span><br><span class="line">    <span class="keyword">return</span> minv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

</li>
</ol>
<h3 id="最长公共子串长度"><a href="#最长公共子串长度" class="headerlink" title="最长公共子串长度"></a>最长公共子串长度</h3><p>解决思路类似莱文斯坦距离<br>每个状态包括三个变量(i,j,max_lcs)，max_lcs表示a[0…i]和b[0…j]的最长公共子串长度。<br>从a[0]和b[0]开始，依次考察两个字符串中的字符是否匹配。  </p>
<ul>
<li>如果a[i]与b[j]互相匹配，将最大公共子串长度加一，并且继续考察a[i+1]和b[j+1]。  </li>
<li>如果a[i]和b[j]不匹配，最长公共子串长度不变，解决思路：<blockquote>
<ul>
<li>删除a[i]，或者在b[j]前面加上一个字符a[i]，然后继续考察a[i+1]和b[j]；  </li>
<li>删除b[j]，或者在a[i]前面加上一个字符b[j]，然后继续考察a[i]和b[j+1]。  </li>
</ul>
</blockquote>
</li>
</ul>
<p>求a[0…i]和b[0…j]的最长公共长度max_lcs[i,j]，只能通过下边三个状态转移过来：  </p>
<ul>
<li>(i-1, j-1, max_lcs)，其中max_lcs表示a[0…i-1]和b[0…j-1]的最长公共子串长度；</li>
<li>(i-1, j, max_lcs)，其中max_lcs表示a[0…i-1]和b[0…j]的最长公共子串长度；  </li>
<li>(i, j-1, max_lcs)，其中max_lcs表示a[0…i]和b[0…j-1]的最长公共子串长度。  </li>
</ul>
<p>状态转移方程：  </p>
<blockquote>
<p>如果：a[i]==b[j]，那么：max_lcs(i,j)就等于：<br>max(max_lcs(i-1,j-1)+1, max_lcs(i-1, j), max_lcs(i, j-1));<br>aba与a的最长公共子串是1不是2；max_lcs(i-1, j)与max_lcs(i, j-1)不需要+1。  </p>
</blockquote>
<blockquote>
<p>如果：a[i]!=b{j}，那么：max_lcs(i,j)就等于：<br>max(max_lcs(i-1,j-1), max_lcs(i-1, j), max(i, j-1));<br>max表示求三个数中的最大值；  </p>
</blockquote>
<p>代码实现：  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        最长公共子串长度 动态规划
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lcs</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> n ,<span class="keyword">char</span>[] b, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] maxlcs = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>] == b[j]) maxlcs[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j != <span class="number">0</span>) maxlcs[<span class="number">0</span>][j] = maxlcs[<span class="number">0</span>][j-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> maxlcs[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == b[<span class="number">0</span>]) maxlcs[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i != <span class="number">0</span>) maxlcs[i][<span class="number">0</span>] = maxlcs[i-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> maxlcs[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] == b[j])</span><br><span class="line">                maxlcs[i][j] = max(maxlcs[i-<span class="number">1</span>][j], maxlcs[i][j-<span class="number">1</span>], maxlcs[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                maxlcs[i][j] = max(maxlcs[i-<span class="number">1</span>][j], maxlcs[i][j-<span class="number">1</span>], maxlcs[i-<span class="number">1</span>][j-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxlcs[n-<span class="number">1</span>][m-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxv = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; maxv) maxv = x;</span><br><span class="line">    <span class="keyword">if</span>(y &gt; maxv) maxv = y;</span><br><span class="line">    <span class="keyword">if</span>(z &gt; maxv) maxv = z;</span><br><span class="line">    <span class="keyword">return</span> maxv; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<h3 id="搜索引擎纠错优化"><a href="#搜索引擎纠错优化" class="headerlink" title="搜索引擎纠错优化"></a>搜索引擎纠错优化</h3><p>纠错效果优化：  </p>
<ul>
<li>取编辑距离最小的TOP10，加上其他参数（如搜索热门程度），决策选择哪个单词作为拼写纠错单词。。  </li>
<li>多种编辑距离计算方法，求交集，用交集的结果继续优化处理。  </li>
<li>统计用户的搜索日志，得到最常被拼错的单词列表，以及对应的拼写正确的单词。搜索引擎找到对应直接返回。  </li>
<li>引入个性化因素，针对每个用户，维护其特有的搜索喜好-常用搜索关键词，当用户输入错误的单词的时候，首先在该用户常用的搜索关键词中，计算编辑距离，查找编辑距离最小的单词。  </li>
</ul>
<p>纠错性能优化：  </p>
<ul>
<li>针对纠错功能的TPS不高，可部署多台机器，每台机器运行一个独立的纠错功能。当有一个纠错请求的时候，通过负载均衡，分配到其中一台机器，开计算编辑距离，得到纠错单词。  </li>
<li>针对纠错系统的响应时间太长，可将纠错的词库分割到多台机器。当有一个纠错请求的时候，将拼写错误的单词同时发送到多台机器上并行处理，分别得到编辑距离最小的单词，然后再对比合并，最终决定一个最优的纠错单词。  </li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路径</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h3 id="算法解析"><a href="#算法解析" class="headerlink" title="算法解析"></a>算法解析</h3><p><strong>建模</strong>：将复杂的场景抽象成具体的数据结构。  </p>
<p>把地图抽象成图。把每个岔路口看做一个顶点，岔路口与岔路口之间的路看作一条边，路的长度就是边的权重。如果路是单行道，就在两个顶点之间画一条有向边；如果路是双行道，就在两个顶点之间画两条方向不同的边。整个地图被抽象成一个有向有权图。  </p>
<p>地图中起点到终点的最短路径问题转化为在一个有向有权图中，求两个顶点间的最短路径。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        有向有权图
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Edge&gt; adj[];<span class="comment">//邻接表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> v;<span class="comment">//顶点个数</span></span><br><span class="line"></span><br><span class="line">    publicGraph(<span class="keyword">int</span> v) &#123;</span><br><span class="line">        <span class="keyword">this</span>.v = v;</span><br><span class="line">        <span class="keyword">this</span>.adj = <span class="keyword">new</span> LinkedList[v];<span class="comment">//v个链表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) &#123;</span><br><span class="line">            <span class="keyword">this</span>.adj[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();<span class="comment">//每个编号的顶点都存了一个链表</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加一条边</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.add[s].add(<span class="keyword">new</span> Edge(s,t,w));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> sid;<span class="comment">//边的起始顶点编号</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> tid;<span class="comment">//边的终止顶点编号</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> w;<span class="comment">//权重</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">int</span> sid, <span class="keyword">int</span> tid, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.sid = sid;</span><br><span class="line">            <span class="keyword">this</span>.tid = sid;</span><br><span class="line">            <span class="keyword">this</span>.w = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Vertex</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> id;<span class="comment">//顶点编号ID</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> dist;<span class="comment">//从起始顶点到这个顶点的距离</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Vertex</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> dist)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            <span class="keyword">this</span>.dist = dist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p>最短路径算法-单源最短路径算法(一个顶点到一个顶点)。  </p>
<blockquote>
<p>将每个顶点到起始顶点的距离初始化为无穷，然后从起始点开始，将其加入一个优先级队列中，从优先级队列中取出到源点距离最小的顶点，然后比较其周围顶点离源点的距离是否大于其到源点的距离+其到周围顶点的距离，如果大于的话，更新周围顶点到源点的距离为较小的值以及其前序节点，并将其加入优先级队列中(如果已经加入过，就更新)，再取出优先级队列中的距离最小值，循环往复，直到取出终止顶点t，或者优先级队列为空。此时倒序输出终止顶点t的前序节点，前序节点的前序节点。。。直到前序节点为起始顶点s，此路径即为最短路径。  </p>
</blockquote>
<p>Dijkstra算法：<br>动态规划算法，求得的解是全局最优解。  </p>
<p>Dijkstra算法类似BFS算法，每次找到跟起点最近的顶点，往外扩展。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Dijkstra算法
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//带更新数据接口的优先级队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据vertex.dist构建小顶堆</span></span><br><span class="line">    <span class="keyword">private</span> Vertex[] nodes;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nodes = <span class="keyword">new</span> Vertex[v+<span class="number">1</span>];<span class="comment">//从下标1开始存数据</span></span><br><span class="line">        <span class="keyword">this</span>.count = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Vertex <span class="title">poll</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Vertex vertex)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">//更新结点的值，并且从下往上堆化，重新符合堆的定义。时间复杂度O(logn)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Vertex vertex)</span> </span>&#123;</span><br><span class="line">        Vertex v = nodes[vertex.id];</span><br><span class="line">        v.dist = vertex.dist;</span><br><span class="line">        <span class="comment">//todo 堆化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从顶点s到顶点t的最短路径</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] predecessor = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.v];<span class="comment">//还原最短路径</span></span><br><span class="line">    Vertex[] vertexes = <span class="keyword">new</span> Vertex[<span class="keyword">this</span>.v];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.v; +=i) &#123;</span><br><span class="line">        vertexes[i] = <span class="keyword">new</span> Vertex(i, Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    PriorityQueue queue = <span class="keyword">new</span> PriorityQueue(<span class="keyword">this</span>.v);<span class="comment">//小顶堆</span></span><br><span class="line">    <span class="keyword">boolean</span>[] inqueue = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="keyword">this</span>.v];<span class="comment">//标记是否进入过队列</span></span><br><span class="line">    vertexes[s].dist = <span class="number">0</span>;</span><br><span class="line">    queue.add(vertexes[s]);</span><br><span class="line">    inqueue[s] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        Vertex minVertex = queue.poll();<span class="comment">//取堆顶元素并删除</span></span><br><span class="line">        <span class="keyword">if</span>(minVertex.id == t) <span class="keyword">break</span>;<span class="comment">//最短路径产生不在循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj[minVertex.id].size(); ++i) &#123;</span><br><span class="line">            Edge e = adj[minVertex.id].get(i);<span class="comment">//取出一条minVertex相连的边</span></span><br><span class="line">            Vertex nextVertex = vertexes[e.tid];<span class="comment">//minVertex-&gt;nextVertex</span></span><br><span class="line">            <span class="keyword">if</span>(minVertex.dist + e.w &lt; nextVertex.dist) &#123;<span class="comment">//更新next的dist</span></span><br><span class="line">                nextVertex.dist = minVertex.dist + e.w;</span><br><span class="line">                predecessor[nextVertex.id] = minVertex.id;</span><br><span class="line">                <span class="keyword">if</span>(inqueue[nextVertex.is] == <span class="keyword">true</span>) &#123;</span><br><span class="line">                    queue.update(nextVertex);<span class="comment">//更新队列中的dist值，自动更新位置(堆化)</span></span><br><span class="line">                    <span class="comment">//queue.remove(nextVertex);</span></span><br><span class="line">                    <span class="comment">//queue.add(nextVertex);</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    queue.add(nextVertex);</span><br><span class="line">                    inqueue[nextVertex.id] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出最短路径</span></span><br><span class="line">    System.out.print(s);</span><br><span class="line">    print(s,t,predecessor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span>[] predecessor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == t) <span class="keyword">return</span>;</span><br><span class="line">    print(s, predecessor[t], predecessor);</span><br><span class="line">    System.out.print(<span class="string">"-&gt;"</span> + t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p>用vertexes数组，记录从起始顶点到每个顶点的距离(dist)。<br>起始将所有顶点的dist都初始化为无穷大(Integer.MAX_VALUE)。把起始顶点的dist值初始化为0，然后将其放到优先级队列中。  </p>
<p>从优先级队列中取出dist最小的顶点minVertex，然后考察这个顶点可达的所有顶点(nextVertex)。如果minVertex的dist值加上minVertex与nextVertex之间边的权重w小于nextVertex。把nextVertex的dist更新为minVertex的dist值加上w。然后把nextVertex加入到优先级队列中。重复这个过程，直到找到终止顶点t或者队列为空。  </p>
<blockquote>
<p>predecessor数组的作用是为了还原最短路径，它记录每个顶点的前驱顶点。最后通过递归的方式，将这个路径打印出来（深度广度优先搜索）。  </p>
</blockquote>
<blockquote>
<p>inqueue数组是为了避免将一个顶点多次添加到优先级队列中。更新了某个顶点的dist值之后，如果这个顶点已经在优先级队列中了，就不再将它重读添加进去。  </p>
</blockquote>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>在代码实现中，最复杂的是while循环嵌套for循环的代码。while循环最多会执行V此(V表示顶点的个数)，而内部的for循环的执行次数不确定，跟每个顶点的相邻边的个数有关，分别记作E0、E1、E2、…、E(V-1)。如果把这V个顶点的边都加起来，最大也不会超过图中所有边的个数E(E表示边的个数)。  </p>
<p>for循环内部的代码涉及从优先级队列取数据、往优先级队列中添加数据、更新优先级队列中的数据，这三个主要的操作。优先级队列是用堆来实现的，堆中的这几个操作，时间复杂度都是O(logV)(堆中的元素个数不会超多顶点的个数V)。  </p>
<p>综合之后，利用乘法原则，整个代码的时间复杂度为O(E*logV)。  </p>
<h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p>实际问题没有必要非得求出个绝对最优解，很多时候为了兼顾执行效率，只需要计算出一个可行的次优解就可以。  </p>
<ol>
<li><p>超级大地图最短路径<br>超级大地图，两点之间的最短路径或者说较好的出行路径，并不会很“发散”，只会出现在两点之间和两点附近的区块内。可以在整个大地图上，划出一个小的区块，这个小的区块恰好可以覆盖住两个点，但是又不会很大，只需要在这个小区块内部运行Dijkstra算法，这样就可以避免遍历整个大图，也就大大提高了执行效率。  </p>
<p>对于两点之间距离较远的路线规划，先规划大的出行路线，然后再细化每个阶段的小路线。  </p>
</li>
<li><p>最少时间<br>在计算最少时间的时候，算法与最短路径相同，只需要把边的权重，从路的长度变成经过这段路所需要的时间。  </p>
</li>
<li><p>最少红绿灯<br>每经过一条边，就要经过一个红绿灯。关于最少红绿灯的出行方案，只需要把每条边的权值改为1即可，算法还是不变，可以使用Dijkstra算法。边的权值为1，相当于无权图，可以使用广度优先搜索算法，广度优先搜索算法计算出来的两点之间的路径，就是两点的最短路径。  </p>
</li>
<li><p>翻译<br>只针对单个词翻译的翻译系统。<br>翻译一整个句子，将句子拆分成一个一个的单词，再丢给翻译系统。针对每个单词，翻译系统会返回一组可选的翻译列表，并且针对每个翻译打一个分，表示这个翻译的可信程度。<br>针对每个单词，从可选列表中，选择其中一个翻译，组合起来就是整个句子的翻译。每个单词的翻译的得分之和，就是真个句子的翻译得分。随意搭配单词的翻译，会得到一个句子的不同翻译。针对整个句子，编程计算出得分最高的前k个翻译结果。  </p>
<ul>
<li><p>回溯算法，穷举所有的排列组合情况，然后选出得分最高的前k个翻译结果。时间复杂度为O(m<sup>n</sup>)，m表示平均每个单词的可选翻译个数，n表示一个句子中包含的单词数量。  </p>
</li>
<li><p>Dijkstra算法，每个单词的可选翻译是按照分数从大到小排列的，a<sub>0</sub>b<sub>0</sub>c<sub>0</sub>肯定是得分最高组合结果。把其及其得分作为一个对象，放入优先级队列中。  </p>
<p>  每次从优先级队列中取出一个得分最高的组合，并给予这个组合进行扩展。扩展的策略是每个单词的翻译分别替换成下一个单词的翻译。a<sub>0</sub>b<sub>0</sub>c<sub>0</sub>扩展后会得到三个组合，a<sub>1</sub>b<sub>0</sub>c<sub>0</sub>、a<sub>0</sub>b<sub>1</sub>c<sub>0</sub>、a<sub>0</sub>b<sub>0</sub>c<sub>1</sub>。把扩展之后的组合，加到优先级队列中。重复这个过程，直到获取到k个翻译组合或者队列为空。  </p>
<p>  时间复杂度，假设句子包含n个单词，每个单词平均有m个可选的翻译，求得分最高的前k个组合结果。每次一个组合出队列，就对应着一个组合结果，希望得到k个，就对应着k次出队操作。每次有一个组合出队列，就有n个组合入队列。优先级队列中出队和入队操作的时间复杂度都是O(logX)，X表示队列中的组合个数。总的时间复杂度就是O(k*n*logX)。<br>  k次出入队列，队列中的总数据不会超过k*n，也就是说，出队、入队操作的时间复杂度是O(log(k*n))。总的时间复杂度为O(k*n*log(k*n))。</p>
</li>
</ul>
</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>最短路径</tag>
        <tag>Dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title>B+树</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/B+%E6%A0%91/</url>
    <content><![CDATA[<h3 id="支持快速查询、插入等操作的数据结构"><a href="#支持快速查询、插入等操作的数据结构" class="headerlink" title="支持快速查询、插入等操作的数据结构"></a>支持快速查询、插入等操作的数据结构</h3><p><strong>散列表</strong><br>散列表的查询性能很好，时间复杂度是O(1)。散列表不能支持按照区间快速查找数据。  </p>
<p><strong>平衡二叉查找树</strong><br>平衡二叉查找树的性能很好，时间复杂度是O(logn)。对树进行中序遍历，可以得到一个从小到大的有序的数据序列，但不足以支持按照区间快速查找数据。  </p>
<p><strong>跳表</strong><br>跳表是在链表之上加上多层索引构成的，支持快速的插入、查找、删除数据，时间复杂度为O(logn)。跳表也支持按照区间快速的查找数据，只需要定位到区间起点值对应在链表中的结点，然后从这个结点开始，顺序遍历链表，直到区间终点对应的结点为止，这期间遍历得到的数据就是满足区间值的数据。  </p>
<p><strong>二叉查找树改造—&gt;B+树</strong><br>解决<strong>区间查找</strong>问题，树中的节点并不存储数据本身，而是只是作为索引。把每个叶子节点串在一条链表上，链表中的数据是从小到大有序的。<br>改造之后，如果要求某个区间的数据，只需要拿区间的起始值，在树中进行查找，当查找到某个叶子节点之后，再顺着链表往后遍历，直到链表中的结点数据值大于区间的终点值位置。所遍历到的数据，就是符合区间值的所有数据。  </p>
<p>解决<strong>内存占用</strong>问题，借助时间换空间的思路，把索引存储在硬盘中。<br>比起内存读写操作，磁盘IO操作非常耗时，尽量减少磁盘IO操作—降低树的高度。构建m叉树。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        m叉树实现B+树索引
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 非叶子节点</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* 假设keywords=[3,5,8,10]</span></span><br><span class="line"><span class="comment">* 4个键值将数据分为5个区间：(-INF,3),[3,5),[5,8),[8,10),[10,inf)</span></span><br><span class="line"><span class="comment">* 5个区间分别对应：children[0]...children[4]</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* m值是事先计算得到的，计算的依据是让所有信息的大小正好等于页的大小：</span></span><br><span class="line"><span class="comment">* PAGE_SIZE = (m-1)*4[keywords大小] + m*8[children大小]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BPlusTreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> m = <span class="number">5</span>;<span class="comment">//5叉树</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] keywords = <span class="keyword">new</span> <span class="keyword">int</span>[m-<span class="number">1</span>];<span class="comment">//键值，用来划分数据区间</span></span><br><span class="line">    <span class="keyword">public</span> BPlusTressNode[] children = <span class="keyword">new</span> BPlusTreeNode[m];<span class="comment">//保存子节点指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 叶子节点</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 叶子节点存储的是值，而非区间</span></span><br><span class="line"><span class="comment">* 每个叶子节点存储3个数据行的键值及地址信息</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* k值是事先计算得到的，计算的依据是让所有信息的大小正好等于页的大小：</span></span><br><span class="line"><span class="comment">* PAGE_SIZE = k*4[keywords大小]+k*8[dataAddress大小]+8[prev大小]+8[next大小]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BPlusTreeLeafNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> k = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] keywords = <span class="keyword">new</span> <span class="keyword">int</span>[k];<span class="comment">//数据的键值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span>[] dataAddress = <span class="keyword">new</span> <span class="keyword">long</span>[k];<span class="comment">//数据地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BPlusTreeLeafNode prev;<span class="comment">//这个结点在链表中的前驱结点</span></span><br><span class="line">    <span class="keyword">public</span> BPlusTreeLeafNode next;<span class="comment">//这个结点在链表中的后继结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p>对于相同个数的数据构建m叉树索引，m叉树中的m越大，树的高度就越小。<br>内存中的数据，以及磁盘中的数据，操作系统都是按页（一页大小通常是4KB，这个值可以通过getconfig PAGE_SIZE命令查看）来读取的，一次会读取一页的数据。如果要读取的数据超过一页的大小，就会触发多次IO操作。所以选择m大小的时候，尽量让每个节点的大小等于一个页的大小。读取一个节点，只需要一次磁盘IO操作。  </p>
<ul>
<li><p>写入数据效率下降<br>  数据的写入过程，会涉及索引的更新，这是索引导致写入变慢的主要原因。  </p>
<p>  对于一个B+树来说，m值是根据页的大小事先计算好的，每个节点最多只能有m个子节点。在往数据库中写入数据的过程中，可能使索引中某些节点的子节点个数超过m，这个节点的大小超过了一个页的大小，读取这样一个节点，就会导致多次IO操作。  </p>
<p>  需要将这个节点分裂成两个节点。节点分裂之后，其上层父节点的子节点个数有可能超过m个。可以用同样的方法，将父节点也分裂成两个节点。这种级联反应会从下往上，一直影响到根节点。  </p>
</li>
<li><p>删除数据效率下降<br>  删除某个数据的时候，也要对应的更新索引节点。处理思路类似跳表中删除数据的处理思路。频繁的数据删除，就会导致某些节点中，子节点的个数变得非常少，长此以往，如果某个节点的子节点都比较少，势必会影响索引的效率。  </p>
<p>  设置一个阈值，在B+树中，这个阈值等于m/2，如果摸一个节点的子节点个数小于m/2，就将它跟相邻的兄弟节点合并。合并之后的子节点个数有可能会超过m。针对这种情况，可以借助插入数据的时候的处理方法，再分裂节点。  </p>
</li>
</ul>
<p>理论上，对跳表稍加改造也可以替代B+树，作为数据库的索引实现。  </p>
<h3 id="B-树特点"><a href="#B-树特点" class="headerlink" title="B+树特点"></a>B+树特点</h3><ul>
<li>每个节点中子节点的个数不能超过m，也不能小于m/2；</li>
<li>根节点的子节点个数可以不超过m/2，这是一个例外；</li>
<li>m叉树只存储索引，并不真正存储数据，这个类似跳表；</li>
<li>通过链表将叶子节点串联在一起，可以方便按区间查找；</li>
<li>一般情况，根节点会被存储在内存中，其他节点存储在磁盘中。</li>
</ul>
<p>B-树就是B树  </p>
<ul>
<li>B+树中的节点不存储数据，只是索引，而B树中的节点存储数据；</li>
<li>B树中的叶子节点并不需要链表来串联。</li>
<li>B树只是一个每个节点的子节点个数不能小于m/2的m叉树。</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>B+树</tag>
      </tags>
  </entry>
  <entry>
    <title>跳表</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%B7%B3%E8%A1%A8/</url>
    <content><![CDATA[<p>二分查找底层依赖的是数组随机访问的特性。只能用数组来实现。  </p>
<p>跳表是一种各方面性能都比较优秀的<strong>动态数据结构</strong>，可以支持快速的插入、删除、查找操作。（类似于链表的二分查找实现）  </p>
<h3 id="理解跳表"><a href="#理解跳表" class="headerlink" title="理解跳表"></a>理解跳表</h3><p>对于一个单链表来讲，即使链表中存储的数据是有序的，如果想在其中查找某个数据，也只能从头到尾遍历链表。查找效率低，时间复杂度高，O(n)。  </p>
<p>对链表建立一级“索引”，提高查找效率。每两个结点提取一个结点到上一级，把抽出来的那一级叫作索引或索引层，down指针指向下一级结点。<br>查找某个结点时，可以先在索引层遍历，当遍历到索引层中目标结点附近，通过索引层结点的down指针，下降到原始链表这一层，继续遍历，找到目标值的结点。<br>加一层索引之后，查找一个结点需要遍历的结点个数减少了，查找次数减少了、效率提高了。<br>类似的，可以在第一级索引的基础之上，每两个结点就抽出一个结点到第二级索引，查询效率进一步提升。  </p>
<p><strong>链表加多级索引的结构，就是跳表</strong>。  </p>
<h3 id="跳表查询时间"><a href="#跳表查询时间" class="headerlink" title="跳表查询时间"></a>跳表查询时间</h3><p>查询数据的时间复杂度推算：</p>
<p>每两个结点抽出一个结点作为上一级索引的结点，第一级索引的结点个数大约为n/2，第二级索引的结点个数大约为n/4，第三极结点个数大约为n/8，以此类推，第k级索引的结点个数是第k-1级索引的结点个数的1/2，第k级索引结点的个数就是n/(2<sup>k</sup>)。  </p>
<p>假设索引有h级，最高级的索引有2个结点。通过公式，可以得到n/(2<sup>h</sup>)=2，求得h=log<sub>2</sub>n-1。如果包含原始链表这一层，整个跳表的高度就是log<sub>2</sub>n。<br>在跳表中查询某个数据的时候，如果每一层都要遍历m个结点，那么在跳表中查询一个数据的时间复杂度为O(m*logn)。  </p>
<p>每一级索引最多只需要遍历m个结点，在跳表中查询任意数据的时间复杂度是O(logn)。与二分查找的时间复杂度相同，等同于基于单链表实现了二分查找。  </p>
<h3 id="跳表空间占用"><a href="#跳表空间占用" class="headerlink" title="跳表空间占用"></a>跳表空间占用</h3><p>比起单纯的单链表，跳表需要存储多级索引，肯定要消耗更多的存储空间。<br>假设原始链表大小为n，每2个结点抽一个作为上一级索引的结点。每上升一级索引，结点个数就减少一半，知道剩下2个结点。每层索引的结点数就是一个等比数列，索引结点总和就是n/2+n/4+n/8+…+4+2=n-1。所以跳表的空间复杂度为O(n)。<br>如果将包含n个结点的单链表构造成跳表，需要额外再用接近n个结点的存储空间。<br>每三个结点抽一个，总的索引结点大约是n/3+n/9+n/27+…+9+3+1=n/2。类推可以减少索引节点存储空间。  </p>
<p>实际开发中，原始链表中存储的可能是很大的对象，索引结点只需要存储关键值和几个指针，并不需要存储对象，所以当对象比索引结点大很多时，索引所占用的额外空间可以忽略。  </p>
<h3 id="跳表插入和删除"><a href="#跳表插入和删除" class="headerlink" title="跳表插入和删除"></a>跳表插入和删除</h3><p>跳表插入、删除操作的时间复杂度为O(logn)。  </p>
<p>在单链表中，一旦定位好要插入的位置，插入结点的时间复杂度是很低的为O(1)。但为了保证原始链表中数据的有序性，需要先查找到要插入的位置，这个查找操作比较耗时。<br>对于纯粹的单链表，需要遍历每个节点来查找到插入的位置。但是对于跳表来说，查找到某个结点的时间复杂度为O(logn)，查找到某个数据应该插入的位置的时间复杂度就为O(logn)。</p>
<p>删除操作，如果要删除的结点在索引中也有出现，除了要删除原始链表中的结点，还要删除索引中的。<br>单链表中的删除操作需要拿到要删除结点的前驱节点，然后通过指针操作完成删除，在查找要删除的结点的时候，要获取前驱节点。双向链表不需要。  </p>
<h3 id="跳表索引动态更新"><a href="#跳表索引动态更新" class="headerlink" title="跳表索引动态更新"></a>跳表索引动态更新</h3><p>当不停的往跳表中插入数据时，如果不更新索引，有可能出现某2个索引结点之间数据非常多的情况。极端情况下，跳表会退化成单链表。  </p>
<p>跳表通过随机函数来维护平衡性。<br>往跳表中插入数据的时候，可以选择同时将数据插入到部分索引层中。<br>如随机函数生成了值K，就将这个结点添加到第一级到第K级这K级索引中。  </p>
<h3 id="跳表与红黑树对比"><a href="#跳表与红黑树对比" class="headerlink" title="跳表与红黑树对比"></a>跳表与红黑树对比</h3><p>插入、删除、查找、迭代输出有序序列的操作，跳表与红黑树的时间复杂度相同。<br>按照区间查找数据操作，红黑树的效率没有跳表高。跳表可以做到O(logn)的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以，非常高效。<br>红黑树在编程语言中一般有现成的实现；跳表没有，需要自己实现再使用。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>跳表</tag>
      </tags>
  </entry>
  <entry>
    <title>拓扑排序</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="算法依赖的数据结构"><a href="#算法依赖的数据结构" class="headerlink" title="算法依赖的数据结构"></a>算法依赖的数据结构</h3><p>一个完整的项目会包含很多代码源文件。编译器在编译整个项目的时候，需要按照依赖关系，依次编译每个源文件。<br>把源文件与源文件之间的依赖关系，抽象成一个有向图。每个源文件对应图中的一个顶点，源文件之间的依赖关系就是顶点之间的边。  </p>
<p>如果a先于b执行，也就是说b依赖于a，那么就在顶点a和顶点b之间，构建一条从a指向b的边。这个图不仅要是有向图，还要是一个有向无环图，不能存在循环依赖关系。图中一旦出现环，拓扑排序就无法工作了。拓扑排序是基于<strong>有向无环图</strong>的算法。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        拓扑排序-数据结构- 图
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> v;<span class="comment">//顶点个数</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; adj[];<span class="comment">//邻接表，存放顶点指向的其他顶点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.v = v;</span><br><span class="line">        adj = <span class="keyword">new</span> LinkedList[v];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) &#123;</span><br><span class="line">            adj[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//s先于t，边 s-&gt;t</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        adj[s].add(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h3 id="算法的实现"><a href="#算法的实现" class="headerlink" title="算法的实现"></a>算法的实现</h3><p>拓扑排序有两种实现方法：<strong>Kahn算法</strong>和<strong>DFS深度优先搜索算法</strong>。  </p>
<ol>
<li><p>Kahn算法<br>Kahn算法实际上用的是贪心算法思想。<br>定义数据结构的时候，如果s需要先于t执行，那就添加一条s指向t的边。如果某个顶点入度为0，表示没有任何顶点必须先于这个顶点执行，那么这个顶点就可以执行了。  </p>
<p>先从图中找出一个入度为0的顶点，将其输出到拓扑排序的结果列中，并且把这个顶点从图中删除（把这个顶点可达的顶点的入度都减一）。循环执行上面的过程，直到所有的顶点都被输出。最后输出的序列，就是满足局部依赖关系的拓扑排序。  </p>
 <div class='spoiler collapsed'>
    <div class='spoiler-title'>
        拓扑排序-Kahn算法
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">topoSortByKahn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//统计每个顶点的入度</span></span><br><span class="line">    <span class="keyword">int</span>[] inDegree = <span class="keyword">new</span> <span class="keyword">int</span>[v];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; adj[i].size(); ++j) &#123;</span><br><span class="line">            <span class="comment">//顶点对应的邻接表，存放着该顶点指向的所有其他顶点（每个顶点的链表独立存储）</span></span><br><span class="line">            <span class="keyword">int</span> w = adj[i].get(j);<span class="comment">//i-&gt;w</span></span><br><span class="line">            inDegree[w]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkedList&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">//将入度为0的顶点加入队列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(inDegree[i] == <span class="number">0</span>) queue.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//从队列中取出一个入度为0的顶点</span></span><br><span class="line">        <span class="keyword">int</span> i = queue.remove();</span><br><span class="line">        System.out.print(<span class="string">"-&gt;"</span>+i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; adj[i].size(); ++j) &#123;</span><br><span class="line">            <span class="comment">//将该顶点指向的所有顶点的入度减1</span></span><br><span class="line">            <span class="keyword">int</span> k = adj[i].get(j);</span><br><span class="line">            inDegree[k]--;</span><br><span class="line">            <span class="comment">//处理后入度为0的顶点加入队列</span></span><br><span class="line">            <span class="keyword">if</span>(inDegree[k] == <span class="number">0</span>) queue.add(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>
</li>
<li><p>DFS算法<br>拓扑排序可以用深度优先搜索来实现。<br>深度优先遍历，遍历图中的所有顶点，并非只是搜索一个顶点到另一个顶点的路径。  </p>
 <div class='spoiler collapsed'>
    <div class='spoiler-title'>
        拓扑排序-DFS算法
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">topoSortByDFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先构建逆邻接表，边s-&gt;表示，s依赖于t，t先于s(与kahn相反)</span></span><br><span class="line">    LinkedList&lt;Integer&gt; inverseAdj[] = <span class="keyword">new</span> LinkedList[v];</span><br><span class="line">    <span class="comment">//申请空间</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) &#123;</span><br><span class="line">        inverseAdj[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++j) &#123;</span><br><span class="line">        <span class="comment">//通过邻接表生成逆邻接表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; adj[i].size(); ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> w = adj[i].get(j);<span class="comment">//i-&gt;w存在一条订单i到顶点w的有向边</span></span><br><span class="line">            inverseAdj[w].add(i);<span class="comment">//w-&gt;i</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[v];</span><br><span class="line">    <span class="comment">//深度优先遍历图</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[i] == <span class="keyword">false</span>) &#123;</span><br><span class="line">            visited[i] = <span class="keyword">true</span>;</span><br><span class="line">            dfs(i, inverseAdj, visited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> vertex, LinkedList&lt;Integer&gt; inverseAdj[], <span class="keyword">boolean</span>[] visited)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inverseAdj[vertex].size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> w = inverseAdj[vertex].get(i);</span><br><span class="line">        <span class="keyword">if</span>(visited[w] == <span class="keyword">true</span>) <span class="keyword">continue</span>;</span><br><span class="line">        visited[w] = <span class="keyword">true</span>;</span><br><span class="line">        dfs(w, inverseAdj, visited);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先把vertex这个顶点可达的所有顶点都打印出来之后，再打印它自己</span></span><br><span class="line">    System.out.print(<span class="string">"-&gt;"</span>+vertex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<p>算法包含两个关键部分<br>第一部分是通过邻接表构造逆邻接表。邻接表中，边s-&gt;t表示s先于t执行，也就是t要依赖s。在逆邻接表中，边s-&gt;t表示s依赖于t，s后于t执行。  </p>
<p>第二部分算法的核心，递归处理每个顶点。对于顶点vertex来说，先输出它可达的所有顶点，也就是先把它依赖的所有的顶点输出了，然后再输出自己。  </p>
</li>
</ol>
<p>时间复杂度分析：<br>Kahn代码中，每个顶点被访问了一次，每个边也被访问了一次，所以，Kahn算法的时间复杂度是O(V+E)（V表示顶点个数，E表示边的个数）。  </p>
<p>DFS算法中，每个顶点被访问两次，每条边被访问依次，时间复杂度为O(V+E)。</p>
<p>图可以是不连通的，有可能是好几个不连通的子图构成，所以E不一定大于V，两者大小关系不确定。在表示时间复杂度的时候，V、E都要考虑在内。  </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>凡是需要通过局部顺序来推导全局顺序的，一般都能用拓扑排序来解决。  </p>
<p>拓扑排序还能检测图中环的存在。<br>在Kahn算法中，如果最后输出出来的顶点个数，少于图中顶点个数，图中还有入度不是0的顶点，那就说明图中存在环。  </p>
<p>递归中，查找最终推荐人。每一次只查找一个用户的最终推荐人，不需要动用拓扑排序算法，只需要纪录已经访问过的用户ID，当用户ID第二次被访问的时候，说明存在环。  </p>
<p>如果求数据库中所有用户之间的推荐关系，有没有存在环的情况。把用户之间的推荐关系，从数据库中加载到内存中，然后构建成有向图数据结构，再利用拓扑排序快速检测出是否存在环。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>拓扑排序</tag>
        <tag>Kahn</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>索引</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h3 id="索引定义"><a href="#索引定义" class="headerlink" title="索引定义"></a>索引定义</h3><p>类比书籍的目录。通过目录，可以快速定位相关知识点的页数，查找的速度有质的提高。  </p>
<h3 id="索引的需求定义"><a href="#索引的需求定义" class="headerlink" title="索引的需求定义"></a>索引的需求定义</h3><ol>
<li><p>功能性需求<br><strong>数据是格式化数据还是非格式化数据</strong>。结构化数据，MySQL中的数据；非结构化数据，搜索引擎中网页。非机构化数据需要做预处理，提取出查询关键词，对关键词构建索引。  </p>
<p><strong>数据是静态数据还是动态数据</strong>。静态数据，不会有数据的增加、删除、更新操作，构建索引时只需奥考虑查询效率。动态数据，在原始数据更新的同时，还需要动态的更新索引。  </p>
<p><strong>索引存储在内存还是硬盘</strong>。存储在内存，查询速度高。原始数据量大，索引很大，内存有限，需要将索引存储在磁盘。一部分存储在内存，一部分存储在磁盘，可以兼顾内存消耗和查询效率。  </p>
<p><strong>单值查找还是区间查找</strong>。单值查找，根据查询关键词等于某个值的数据。区间查找，查找关键词处于某个区间值的所有数据。  </p>
<p><strong>单关键词查找还是多关键词组合查找</strong>。多关键词查询：结构化数据，针对多个关键词的组合建立索引；非结构化数据，针对单个关键词构建索引，然后通过集合操作（并集、交集），计算出多个关键词组合的查询结果。</p>
</li>
<li><p>非功能性需求<br><strong>不管是存储在内存中还是磁盘中，索引对存储空间的消耗不能过大</strong>。索引对存储空间的消耗可能会超过原始数据。  </p>
<p><strong>在考虑索引查询效率的同时，还要考虑索引的维护成本</strong>。在原始数据动态增删改的同时，也需要动态的更新索引，索引的更新势必会影响到增删改操作的性能。  </p>
</li>
</ol>
<h3 id="构建索引常用的数据结构"><a href="#构建索引常用的数据结构" class="headerlink" title="构建索引常用的数据结构"></a>构建索引常用的数据结构</h3><p>散列表、红黑树、跳表、B+树，可以作为动态数据集合的索引，位图、布隆过滤器可作为辅助索引，有序数组可以用来对静态数据构建索引。  </p>
<p><strong>散列表</strong>增删改查的时间复杂度为O(1)，一般构建在内存中。如键值数据库（Redis、Memcache）的索引。  </p>
<p><strong>红黑树</strong>数据插入、删除、查找的时间复杂度为O(logn)，适合构建内存索引。如Ext文件系统中，对磁盘块的索引。  </p>
<p><strong>B+树</strong>相比红黑树，更适合构建存储在磁盘中的索引，需要的磁盘IO次数更少。如关系型数据库MySQL、Oracle的索引。  </p>
<p><strong>跳表</strong>支持快速添加、删除、查找数据，通过灵活调整索引结点个数和数据个数之间的比例，可以很好的平衡索引堆内存的消耗及其查询效率。如Redis中的有序集合的索引。  </p>
<p><strong>位图和布隆过滤器</strong>，辅助存储在磁盘中的索引，加速数据查找的效率。<br>布隆过滤器有一定的判错率。对于判定存在的数据，可能并不存在；对于判定不存在的数据，则肯定不存在。但内存占用非常少。<br>针对数据，构建一个布隆过滤器，存储在内存中，当要查询数据的时候，可以先通过布隆过滤器，判定是否存在。若不存在，则没有必要读磁盘中的索引，对于数据不存在的情况，数据查询更加快速。  </p>
<p><strong>有序数组</strong>。静态数据，没有插入、删除、更新操作，可以把数据查询用的关键词抽取出来，组织成有序数据，然后利用二分查找算法来快速查找数据。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串匹配：BF&amp;RK</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%EF%BC%9ABF&amp;RK/</url>
    <content><![CDATA[<h3 id="BF算法"><a href="#BF算法" class="headerlink" title="BF算法"></a>BF算法</h3><p>Brute Force算法，暴力匹配算法，也叫朴素匹配算法。  </p>
<p>在字符串A中查找字符串B，字符串A为<strong>主串</strong>，字符串B为<strong>模式串</strong>。主串的长度记为n，模式串的长度记作m，主串中查找模式串，n&gt;m。  </p>
<p><strong>算法思想：</strong><br>在主串中，检查起始位置分别是0、1、2…n-m且长度为m的n-m+1个子串，看有没有跟模式串匹配的。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        BF算法
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> main 主串</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> pattern 模式串</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 匹配下标的起始值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexBf</span><span class="params">(<span class="keyword">char</span>[] main,<span class="keyword">char</span>[] pattern)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//最大的首个字符的索引</span></span><br><span class="line">    <span class="keyword">int</span> maxFirst = main.length -pattern.length;</span><br><span class="line">    <span class="keyword">char</span> first = pattern[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= maxFirst; i++) &#123;</span><br><span class="line">        <span class="comment">//第一个匹配的字符</span></span><br><span class="line">        <span class="keyword">while</span>(first != main[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(++i &gt; maxFirst) </span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//子串匹配</span></span><br><span class="line">        <span class="keyword">int</span> m = i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; pattern.length; j++,m++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(main[m] != pattern[j])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//匹配成功</span></span><br><span class="line">        <span class="keyword">if</span>(m -i == pattern.length)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    retuen -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<p><strong>时间复杂度：</strong><br>极端情况下，在“aaaa…aaaa”中查找“aaaab”。每次都对比m个字符，要对比n-m+1次，最坏情况时间复杂度是O(n*m)。  </p>
<ol>
<li>实际软件开发中，模式串和主串长度不会太长，每次模式串与主串中的子串匹配时，中途遇到不能匹配的字符的时候就可以停止，不需要把每个字符都比对一下。  </li>
<li>算法思想简单，代码实现简单，不容易出错，有bug容易暴露和修复。KISS原则。</li>
</ol>
<h3 id="RK算法"><a href="#RK算法" class="headerlink" title="RK算法"></a>RK算法</h3><p>Rabin-Karp算法，BF算法升级版。<br>BF算法中，每次检查主串与子串是否匹配，需要依次对比每个字符，BF算法的时间复杂度比较高为O(n*m)。对其稍加改造，引入哈希算法，时间复杂度立刻降低。  </p>
<p><strong>算法思想：</strong><br>通过哈希算法对主串中的n-m+1个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，说明对应的子串和模式串匹配(暂时忽略哈希冲突)。哈希值是一个数字，数字之间比较是否相等非常快速。<br>计算子串的哈希值时，依然需要遍历子串中的每个字符，模式串与子串的比较效率提高，算法整体的效率并未提高。  </p>
<p>哈希算法设计技巧，假设主串的字符集中只包含K个字符，可用一个K进制数来表示一个子串，这个K进制数转化成十进制数，作为子串的哈希值。<br>比如要处理的字符串只包含a~z这26个小写字符，可以用二十六进制来表示一个字符串。把a~z这26个字符映射到0~25这26个数字，a表示0，b表示1，以此类推，z表示25。一个包含a到z这26个字符的字符串，计算哈希；<br>“cba”=’c’*26<sup>2</sup> + ‘b’*26<sup>1</sup> + ‘a’*26<sup>0</sup><br>=2*26<sup>2</sup> + 1*26<sup>1</sup> + 0*26<sup>0</sup><br>=1353  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        RK算法
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> main 主串</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> pattern 模式串</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 匹配下标的起始值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexRk</span><span class="params">(<span class="keyword">char</span>[] main,<span class="keyword">char</span>[] pattern)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mLen = main.length;</span><br><span class="line">    <span class="keyword">int</span> pLen = pattern.length;</span><br><span class="line">    <span class="keyword">int</span> pHash = hash(pattern,<span class="number">0</span>,pLen);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mLen - pLen +<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pHash == hash(main, i, pLen))</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用[a-z] 对应[0-25] 26进制计算hash值</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> chars 字符数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> start 起始下标</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> len 长度</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 匹配下标的起始值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> start, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; start + len; i++,x++) &#123;</span><br><span class="line">        hash += Math.pow(<span class="number">26</span>, len - x - <span class="number">1</span>) * (chars[i] - <span class="string">"a"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<p>哈希算法特点，在主串中，相邻两个子串的哈希值的计算公式有一定关系：相邻连个子串s[i-1,i+m-2]和s[i,i+m-1] (i表示子串在主串中的其实位置，子串的长度都为m)，对应哈希值计算公式有交集，可以使用s[i-1]的哈希值快速计算出s[i]的哈希值：<br>h[i-1]=26<sup>m-1</sup>*(s[i-1]-‘a’) + 26<sup>m-2</sup>*(s[i]-‘a’)  + 26<sup>0</sup>*(s[i+m-2]-‘a’)<br>h[i]=26<sup>m-1</sup>*(s[i]-‘a’)+   + 26<sup>1</sup>*(s[i+m-2]-‘a’)+ 26<sup>0</sup>*(s[i+m-1]-‘a’)  </p>
<p>B=A<em>26;<br>h[i]=(h[i-1]-26<sup>m-1</sup>\</em>(s[i-1]-‘a’))*26 + 26<sup>0</sup>*(s[i+m-1]-‘a’)  </p>
<p>26<sup>m-1</sup>可以进一步通过查表提高计算效率，事先计算好26<sup>0</sup>、26<sup>1</sup>、26<sup>2</sup>…26<sup>m-1</sup>，并存储在一个长度为m的数组中，公式中的次方就对应数组的下标，需要计算26的x次方的时候，可以直接从数组的下标为x的位置取值，节省重复计算时间。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        RK算法优化
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * rk字符串匹配</span></span><br><span class="line"><span class="comment">     * 改良：</span></span><br><span class="line"><span class="comment">     * 1、可以为所有字符串</span></span><br><span class="line"><span class="comment">     * 2、解决存在hash冲突</span></span><br><span class="line"><span class="comment">     * 3、优化hash函数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexRk2</span><span class="params">(<span class="keyword">char</span>[] main, <span class="keyword">char</span>[] pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mLen = main.length;</span><br><span class="line">        <span class="keyword">int</span> pLen = pattern.length;</span><br><span class="line">        <span class="keyword">int</span> pHash = hashPrime(pattern, <span class="number">0</span>, pLen);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mLen - pLen + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pHash == hashPrime(main, i, pLen)) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = <span class="number">0</span>, k = i;</span><br><span class="line">                <span class="keyword">while</span> (main[k++] != pattern[j++] || j &gt; pLen) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 0-255下所有的质数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">char</span>[] PRIME_NUMBERS = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">41</span>, <span class="number">53</span>, <span class="number">59</span>, <span class="number">61</span>, <span class="number">67</span>, <span class="number">71</span>, <span class="number">73</span>, <span class="number">79</span>, <span class="number">83</span>, <span class="number">89</span>, <span class="number">97</span>,</span><br><span class="line">            <span class="number">101</span>, <span class="number">103</span>, <span class="number">107</span>, <span class="number">109</span>, <span class="number">113</span>,</span><br><span class="line">            <span class="number">127</span>, <span class="number">131</span>, <span class="number">137</span>, <span class="number">139</span>, <span class="number">149</span>, <span class="number">151</span>, <span class="number">157</span>, <span class="number">163</span>, <span class="number">167</span>, <span class="number">173</span>,</span><br><span class="line">            <span class="number">179</span>, <span class="number">181</span>, <span class="number">191</span>, <span class="number">193</span>, <span class="number">197</span>, <span class="number">199</span>, <span class="number">211</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用0-255下所有的质数计算hash值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chars 字符数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 起始下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len   长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashPrime</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> start, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> primeLen = PRIME_NUMBERS.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; start + len; i++) &#123;</span><br><span class="line">            hash += PRIME_NUMBERS[Objects.hashCode(chars[i]) % primeLen];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<p><strong>时间复杂度：</strong><br>整个RK算法包含两个部分，计算子串哈希值和模式串哈希值与子串哈希值之间的比较。<br>第一部分通过设计特殊的哈希算法，只需要扫描一遍主串就能计算所有子串的哈希值，时间复杂度为O(n)。<br>第二部分，与每个子串哈希值比较的时间复杂度为O(1)，总共需要比较n-m+1个子串的哈希值，时间复杂度是O(n)<br>RK算法整体的时间复杂度为O(n)。  </p>
<p>其他哈希算法有散列冲突时，再对比一下子串和模式串本身。极端情况下，每次都要再对比子串和模式串本身，时间复杂度退化成O(n*m)。  </p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>一维字符串-&gt;二位字符串矩阵  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>字符串匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串匹配：BM</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%EF%BC%9ABM/</url>
    <content><![CDATA[<h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p>把模式串和主串的匹配过程，看做模式串在主串中不停地往后滑动。当遇到不匹配的字符时，BF和RK算法的做法是，模式串往后滑动一位，然后从模式串的第一个字符开始重新匹配。  </p>
<p>主串中的某个字符，在模式串中不存在，模式串向后滑动的时候，只要该字符与模式串有重合，肯定无法匹配，可以一次性把模式串往后多滑动几位，跳过一些肯定不会匹配的情况，以此来减少不必要的字符比较，提高匹配的效率。</p>
<h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p>BM算法包含两部分，分别是<strong>坏字符规则</strong>和<strong>好后缀规则</strong>。  </p>
<h4 id="坏字符规则"><a href="#坏字符规则" class="headerlink" title="坏字符规则"></a>坏字符规则</h4><p>BM算法的匹配顺序是按照模式串下标从大到小的顺序，倒着匹配的。<br>从模式串的末尾往前倒着匹配，当发现某个字符没法匹配的时候，把这个没有匹配的字符叫做<strong>坏字符</strong>(主串中的字符)。  </p>
<ol>
<li><p>拿坏字符在模式串中查找，发现模式串中并不存在这个字符，也就是说，主串中该字符与模式串中的任何字符都不可能匹配。这个时候，可以将模式串直接滑动到主串中该字符后面的位置，再从模式串的末尾字符开始比较。  </p>
</li>
<li><p>坏字符在模式串中是存在的。可以将模式串往后移动到坏字符与之匹配的字符对齐的地方，然后再从模式串的末尾字符开始，重新匹配。  </p>
</li>
</ol>
<blockquote>
<p>当发生不匹配的时候，把坏字符对应的模式串中的字符下标记作si。<br>如果坏字符在模式串中存在，把这个坏字符在模式串中的下标记作xi。如果不存在，把xi记作-1。模式串往后移动的位数就等于si-xi。(这里的下标，都是字符在模式串的下标。)<br>如果坏字符在模式串中里多处出现，在计算xi的时候，选择最靠后的那个，不会让模式串滑动过多，导致本来可能匹配的请款被滑动略过。  </p>
</blockquote>
<p>利用坏字符规则，BM算法在最好情况下的时间复杂度为O(n/m)。  </p>
<p>单纯使用坏字符规则，根据si-xi计算出来的移动位数，有可能是负数。不但不会向后滑动模式串，还有可能倒退。  </p>
<h4 id="好后缀规则"><a href="#好后缀规则" class="headerlink" title="好后缀规则"></a>好后缀规则</h4><p>把已经匹配的字符叫做好后缀，记作{u}。拿它在模式串中查找，如果找到了另一个跟{u}相匹配的子串{u<sup>*</sup>}，就将模式串滑动到子串{u<sup>*</sup>}与主串中{u}对齐的位置。<br>如果在模式串中找不到另一个等于{u}的子串，就直接将模式串滑动到主串中{u}的后面。<del>(之前的任何一次往后滑动，都不会有匹配主串中{u}的情况。)</del>  </p>
<p>当模式串中不存在等于{u}的子串时（好后缀在模式串中不存在可匹配的子串），直接将模式串滑动到主串{u}的后面，太过头。尽管在模式串中没有另外一个相匹配的子串{u<sup>*</sup>}，在一步步往后滑动模式串的过程中，只要主串中的{u}与模式串有重合，那肯定就无法完全匹配。但当模式串滑动到<strong>前缀</strong>与主串中{u}的<strong>后缀</strong>有部分重合的时候({u}可能是多个字符)，并且重合的部分相等，就有可能存在完全匹配的情况。  </p>
<p>不仅要看好后缀在模式串中，是否有另一个匹配的子串，还要考察好后缀的后缀子串，是否存在跟模式串的前缀子串匹配的。<br>所谓某个字符串s的后缀子串，就是最后一个字符跟s对齐的子串。<br>所谓前缀子串，就是其实字符跟s对齐的子串。<br>从好后缀的后缀子串中，找一个最长的并且能跟模式串的前缀子串匹配的，然后将模式串滑动到他们重合的位置。  </p>
<h4 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h4><p>档模式串和主串中的某个字符不匹配的时候，可以分别计算好后缀和坏字符往后滑动的位数，然后去两个数中最大的，作为模式串往后滑动的位数。可以避免，值根据坏字符规则，计算得到的往后滑动的位数，有可能是负数的情况。  </p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="坏字符"><a href="#坏字符" class="headerlink" title="坏字符"></a>坏字符</h4><p>拿坏字符在模式串中顺序遍历查找比较低效，将模式串中的每个字符及其下标都存到散列表中。<br>假设字符串的字符集不大，每个字符长度是1字节，用大小为256的数组，记录每个字符在模式串中出现的位置。数组的下标对应字符的ASCII码值，数组中存储这个字符在模式串中出现的位置。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        散列表预处理
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//b模式串，m模式串的长度，bc散列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">256</span>;<span class="comment">//全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">generateBC</span><span class="params">(<span class="keyword">char</span>[] b, <span class="keyword">int</span> m, <span class="keyword">int</span>[] bc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; ++i) &#123;</span><br><span class="line">        bc[i] = -<span class="number">1</span>;<span class="comment">//初始化bc</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> ascii = (<span class="keyword">int</span>)b[i];<span class="comment">//计算b[i]的ASCII值</span></span><br><span class="line">        bc[ascii] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        坏字符
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bm</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> n ,<span class="keyword">char</span>[] b, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bc[] = <span class="keyword">new</span> <span class="keyword">int</span>[SIZE];<span class="comment">//记录模式串中每个字符最后出现的位置</span></span><br><span class="line">    generateBC(b, m, bc);<span class="comment">//构建坏字符哈希表</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">//i表示主串与模式串对齐的第一个字符</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= n-m) &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;<span class="comment">//模式串从后往前匹配</span></span><br><span class="line">            <span class="keyword">if</span>(a[i+j] != b[j]) <span class="keyword">break</span>;<span class="comment">//坏字符对应模式串中的下标是j</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;<span class="comment">//匹配成功，返回主串与模式串第一个匹配的字符的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//相当于将模式串往后滑动j-bc[(int)a[i+j]]位</span></span><br><span class="line">        i = i + (j - bc[(<span class="keyword">int</span>)a[i+j]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<h4 id="好后缀"><a href="#好后缀" class="headerlink" title="好后缀"></a>好后缀</h4><ul>
<li>在模式串中，查找跟好后缀匹配的另一个子串；  </li>
<li>在好后缀的后缀子串中，查找最长的、能跟模式串前缀匹配的后缀子串；  </li>
</ul>
<p>好后缀也是模式串本身的后缀子串，可以在模式串和主串正式匹配之前，通过预处理模式串，预先计算好模式串的每个后缀子串，对应的另一个可匹配子串的位置。<br>后缀子串的最后一个字符的位置是固定的，下标为m-1，只需要纪录长度就可以了。通过长度，可以确定一个唯一的后缀子串。  </p>
<p>引入变量<strong>suffix数组</strong>。suffix数组的下标k，表示后缀子串的长度，下标对应的数组值存储的是，在模式串中跟好后缀(u)相匹配的子串(u*)的起始下标值。<br>如果模式串中有多个(大于1个)子串跟后缀子串{u}匹配，为了避免模式串往后滑动得过头了，suffix数组中存储模式串中最靠后的那个子串的起始位置，也就是下标最大的那个子串的其实位置。(滑动的距离小)  </p>
<p>引入另外一个boolean类型的<strong>prefix数组</strong>，记录模式串的后缀子串是否能匹配模式串的前缀子串。  </p>
<p>计算并填充两个数组的值。<br>拿下标从0到i的子串(i可以是0到m-2)与整个模式串，求公共后缀子串，如果公共后缀子串的长度是k，那就记录suffix[k]=j(j表示公共后缀子串的起始下标)。<br>如果j=0，说明，公共后缀子串也是模式串的前缀子串，记录prefix[k]=true。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        计算suffix与prefix
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//b表示模式串，m表示模式串长度</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">generateGS</span><span class="params">(<span class="keyword">char</span>[] b, <span class="keyword">int</span> m, <span class="keyword">int</span>[] suffix, <span class="keyword">boolean</span>[] predix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;<span class="comment">//初始化</span></span><br><span class="line">        suffix[i] = -<span class="number">1</span>;</span><br><span class="line">        prefix[i] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; m - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;<span class="comment">//公共后缀子串长度</span></span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; b[j] == b[m-<span class="number">1</span>-k]) &#123;<span class="comment">//与b[0,m-1]求公共后缀子串</span></span><br><span class="line">            --j;</span><br><span class="line">            ++k;</span><br><span class="line">            suffix[k] = j+<span class="number">1</span>;<span class="comment">//j+1表示公共后缀子串在b[0,i]中的起始下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j == -<span class="number">1</span>) prefix[k] = <span class="keyword">true</span>;<span class="comment">//如果公共后缀子串也是模式串的前缀子串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p>假设好后缀的长度是k。先拿好后缀在suffix数组中查找其匹配的子串，如果suffix[k]不等于-1(-1表示不存在匹配的子串)，就将模式串往后移动j-suffix[k]+1位(j表示坏字符对应的模式串中的字符下标)。如果suffix[k]等于-1，表示模式串中不存在另一个跟好后缀匹配的子串片段。<br>好后缀的后缀子串b[r,m-1]（r取值从j+2到m-1）的长度k=m-r，如果prefix[k]=true，表示长度为k的后缀子串，有可匹配的前缀子串，可以把模式串后移r位。<br>如果两条规则都没有找到可以匹配好后缀及其后缀子串的子串，就将整个模式串后移m位。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        BM算法
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a,b表示主串和模式串；n,m表示主串和模式串的长度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bm</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> n, <span class="keyword">char</span>[] b, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] bc = <span class="keyword">new</span> <span class="keyword">int</span>[SIZE];<span class="comment">//记录模式串中每个字符最后出现的位置</span></span><br><span class="line">    generateBC(b,m,bc);<span class="comment">//构建坏字符哈希表</span></span><br><span class="line">    <span class="keyword">int</span>[] suffix = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">    <span class="keyword">boolean</span>[] prefix = <span class="keyword">new</span> <span class="keyword">boolean</span>[m];</span><br><span class="line">    generateGS(b,m,suffix,prefix);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">//j表示主串与模式串匹配的第一个字符</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n-m) &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;<span class="comment">//模式串从后往前匹配</span></span><br><span class="line">            <span class="keyword">if</span>(a[i+j] != b[j]) <span class="keyword">break</span>;<span class="comment">//坏字符对应模式串中的下标是j</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;<span class="comment">//匹配成功，返回主串与模式串第一个匹配的字符的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> x = j - bc[(<span class="keyword">int</span>)a[i+j]];</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(j &lt; m-<span class="number">1</span>) &#123;<span class="comment">//如果有好后缀的话</span></span><br><span class="line">            y = moveByGS(j,m,suffix,prefix);</span><br><span class="line">        &#125;</span><br><span class="line">        i = i + Math.max(x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//j表示坏字符对应的模式串中的字符下标;m表示模式串长度</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">moveByGS</span><span class="params">(<span class="keyword">int</span> j, <span class="keyword">int</span> m, <span class="keyword">int</span>[] suffix, <span class="keyword">boolean</span>[] prefix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = m - <span class="number">1</span> -j;<span class="comment">//好后缀长度</span></span><br><span class="line">    <span class="keyword">if</span>(suffix[k] != -<span class="number">1</span>) <span class="keyword">return</span> j-suffix[k]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> r = j+<span class="number">2</span>; r &lt;= m-<span class="number">1</span>; ++r) &#123;</span><br><span class="line">        <span class="keyword">if</span>(prefix[m-r] == <span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<h3 id="性能分析及优化"><a href="#性能分析及优化" class="headerlink" title="性能分析及优化"></a>性能分析及优化</h3><h4 id="内存消耗"><a href="#内存消耗" class="headerlink" title="内存消耗"></a>内存消耗</h4><p>整个算法用到了额外的3个数组，其中bc数组的大小跟字符集大小有关，suffix数组和prefix数组的大小跟模式串长度m有关。  </p>
<p>处理字符集很大的字符串匹配问题，bc数组对内存的消耗会比较多，<strong>好后缀和坏字符规则是独立的</strong>，如果对内存要求苛刻，可以只是用好后缀规则，不使用坏字符规则，可以避免bc数组过多的内存消耗。  </p>
<h4 id="执行效率"><a href="#执行效率" class="headerlink" title="执行效率"></a>执行效率</h4><p>极端情况下，suffix数组、prefix数组的预处理的时间复杂度为O(m<sup>2</sup>)。<br>优化待扩展。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>字符串匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串匹配：KMP</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%EF%BC%9AKMP/</url>
    <content><![CDATA[<h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>KMP核心思想与BM类似，假设主串是a，模式串是b。在模式串与主串匹配的过程中，当遇到不可匹配的字符的时候，找到一些规律，将模式串往后多滑动几位，跳过那些肯定不会匹配的情况。  </p>
<p>在模式串和主串匹配的过程中，把不能匹配的那个字符叫做<strong>坏字符</strong>，把已经匹配的那段字符叫做<strong>好前缀</strong>。<br>当遇到坏字符的时候，把模式串往后滑动，在滑动的过程中，只要模式串和好前缀有上下重合，前面几个字符的比较，就相当于拿好前缀的后缀字符串，跟模式串的前缀子串在比较。  </p>
<p>拿到好前缀本身，在它的后缀子串中，查找最长的那个可以跟好前缀的前缀子串匹配。<br>假设最长的可匹配的那部分前缀子串是{v}，长度是k。把模式串一次性往后滑动j-k位，相当于，每次遇到坏字符的时候，就把j更新为k，i不变，然后继续比较。<br>把好前缀的所有后缀子串中，最长的可匹配前缀子串的那个后缀子串，叫做<strong>最长可匹配后缀子串</strong>；对应的前缀子串，叫做<strong>最长可匹配前缀子串</strong>。</p>
<p>模式串a b a b a c d<br>前缀子串a b a b a c  </p>
<table>
<thead>
<tr>
<th>子串</th>
<th>前缀</th>
<th>后缀</th>
<th>最大公共元素长度</th>
<th>前缀结尾字符下标</th>
<th>最长可匹配前缀子串结尾字符下标</th>
<th>next值</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>空</td>
<td>空</td>
<td>0</td>
<td>0</td>
<td>-1</td>
<td>next[0]=-1</td>
</tr>
<tr>
<td>ab</td>
<td>a</td>
<td>b</td>
<td>0</td>
<td>1</td>
<td>-1</td>
<td>next[1]=-1</td>
</tr>
<tr>
<td>aba</td>
<td><strong>a</strong>,ab</td>
<td><strong>a</strong>,ba</td>
<td>1</td>
<td>2</td>
<td>0</td>
<td>next[2]=0</td>
</tr>
<tr>
<td>abab</td>
<td>a,<strong>ab</strong>,aba</td>
<td>b,<strong>ab</strong>,bab</td>
<td>2</td>
<td>3</td>
<td>1</td>
<td>next[3]=1</td>
</tr>
<tr>
<td>ababa</td>
<td>a,ab,<strong>aba</strong>,abab</td>
<td>a,ba,<strong>aba</strong>,baba</td>
<td>3</td>
<td>4</td>
<td>2</td>
<td>next[4]=2</td>
</tr>
<tr>
<td>ababac</td>
<td>a,ab,aba,abab,ababc</td>
<td>c,ac,bac,abac,babac</td>
<td>0</td>
<td>5</td>
<td>0</td>
<td>next[5]=-1</td>
</tr>
</tbody></table>
<p>提前构建一个数组，用来存储模式串中每个前缀（这些前缀都有可能是好前缀）的最长可匹配前缀子串的结尾字符下标。把这个数组定义为<strong>next数组（失效函数）</strong>。<br>数组的下标是每个前缀结尾字符下标，数组的值是这个前缀的最长可以匹配前缀子串的结尾字符下标（子字符串的前缀集合与后缀集合的交集中最长元素的长度）。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        KMP算法框架
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a,b分别是主串和模式串；n,m分别是主串和模式串的长度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> n, <span class="keyword">char</span>[] b, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] next = getNext(b,m);</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; a[i] != b[j]) &#123;<span class="comment">//一直找到a[i]和b[j]</span></span><br><span class="line">            j = next[j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == b[j]) &#123;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j == m) &#123;<span class="comment">//找到匹配模式串的了</span></span><br><span class="line">            <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<blockquote>
<p>i始终是主串的下标；j始终是模式串的下标。（i是坏字符，j是坏字符对应模式串字符的下标）<br>在匹配中的任何时候，主串下标为i的字符永远和模式串下标为j的字符对齐。  </p>
</blockquote>
<h3 id="失效函数"><a href="#失效函数" class="headerlink" title="失效函数"></a>失效函数</h3><p>按照下标从小到大，依次计算next数组的值，当要计算next[i]的时候，前面的next[0],next[1],…,next[i-1]已经计算出来了，利用已经计算出来的next值，推导next[i]的值。（动态规划的思想）  </p>
<blockquote>
<p>前一个b[i-1]的最长串的下一个字符与最后一个b[i]相等，那next[i]=next[i-1]+1；否则就找前一个的次长串，递归迭代这个过程，直到找到或者完全没有。</p>
</blockquote>
<p>如果next[i-1]=k-1，也就是说，子串b[0,k-1]是b[0,i-1]的最长可匹配前缀子串，如果子串b[0,k-1]的下一个字符b[k]，与b[0,i-1]的下一个字符b[i]匹配，那子串b[0,k]就是b[0,i]的最长可匹配前缀子串。所以next[i]=k。  </p>
<p>如果b[0,k-1]的下一个字符b[k]跟b[0,i-1]的下一个字符b[i]不相等。<br>假设b[0,i]的最长可匹配后缀子串是[r,i]。如果把最后一个字符去掉，那b[r,i-1]肯定是b[0,i-1]的可匹配后缀子串，但不一定是最长可匹配后缀子串。所以，既然b[0,i-1]最长可匹配后缀子串对应的模式串的前缀子串的下一个字符并不等于b[i]，那么就可以考察b[0,i-1]的次长可匹配后缀子串b[x,i-1]对应的可匹配前缀子串b[0,i-1-x]的下一个字符b[i-x]是否等于b[i]。如果等于，那b[x,i]就是b[0,i]的最长可匹配后缀子串。  </p>
<p>次长可匹配后缀子串肯定被包含在最长可匹配后缀子串中，而最长可匹配后缀子串又对应最长可匹配前缀子串b[0,y]。查找b[0,i-1]的次长可匹配后缀子串，转化为查找b[0,y]的最长匹配后缀子串。  </p>
<p>考察完所有的b[0,i-1]的可匹配后缀子串b[y,i-1]，直到找到一个可匹配的后缀子串，它对应的前缀子串的下一个字符等于b[i]，那这个b[y,i]就是b[0,i]的最长可匹配后缀子串。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        失效函数
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getNexts(<span class="keyword">char</span>[] b, <span class="keyword">int</span> m) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(k != -<span class="number">1</span> &amp;&amp; b[k+<span class="number">1</span>] != b[i]) &#123;</span><br><span class="line">            k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b[k+<span class="number">1</span>] == b[i]) &#123;</span><br><span class="line">            ++k;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>KMP算法只需要一个额外的next数组，数组的大小跟模式串相同，空间复杂度为O(m)，m表示模式串的长度。  </p>
<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>KMP算法包含两部分，第一部分是构建next数组，第二部分是借助next数组匹配。  </p>
<p>第一部分，for循环i从1开始一直增加到m，而k并不是每次for循环都会增加，所以k累计增加的值肯定小于m。而while循环里k=next[k]，实际上是在减少k的值，k累积都没有增加超过m，所以while循环里面k=next[k]总的执行次数也不可能超过m。next数组计算的时间复杂度是O(m)。  </p>
<p>第二部分，i从0循环增长到n-1，j的增长量不可能超过i，所以肯定小于n。next[j-1]的值肯定小于j-1，所以while循环中的j=next[j-1]+1实际上也是在让j的值减少。而j总共增长的量都不会超过n，减少的量也不可能超过n，所以while循环中的这条语句总的执行次数也不会超过n。这部分的时间复杂度是O(n)。  </p>
<p>综合两部分的时间复杂度，KMP算法的时间复杂度为O(m+n)。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>字符串匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>Trie树</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Trie%E6%A0%91/</url>
    <content><![CDATA[<h3 id="Trie树定义"><a href="#Trie树定义" class="headerlink" title="Trie树定义"></a>Trie树定义</h3><p>Tire树-字典树。一个树形结构，专门处理字符串匹配的数据结构，用来解决在一组字符串集合中快速查找某个字符串的问题。  </p>
<p>Trie树的本质，利用字符串之间的公共前缀，将重复的前缀合并在一起。<br>根节点不包含任何信息，每个节点表示一个字符串中的字符，从根节点到各个“结尾节点”（不一定都是叶子节点）的一条路径表示一个字符串。  </p>
<p>Trie树的构造过程的每一步都相当于往Trie树中插入一个字符串，当所有字符串都插入完成之后，Trie树就构造好了。<br>在Trie树中查找一个字符串的时候，将要查找的字符串分割成单个的字符，然后从Trie树的根节点开始匹配。  </p>
<h3 id="实现Trie树"><a href="#实现Trie树" class="headerlink" title="实现Trie树"></a>实现Trie树</h3><ol>
<li>将字符串集合构造成Trie树（将字符串插入到Trie树）。<br>Trie树是一个多叉树，借助散列表的思想，通过一个下标与字符一一映射的数组，来存储子节点的指针。<br>假设字符串中只有从a-z这26个小写字母，在数据中下标为0的位置，存储指向子节点a的指针，下标为1的位置存储指向子节点b的指针，以此类推，下标为25的位置，存储的是指向子节点z的指针，如果某个字符的子节点不存在，在对应下标的位置存储null。</li>
<li>在Trie树中查询一个字符串<br>在trie树中查找字符串的时候，通过字符的ASCII码减去“a”的ASCII码，迅速找到匹配的字节点的指针。  </li>
</ol>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        BF算法
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span> data;</span><br><span class="line">    <span class="keyword">public</span> TrieNode[] children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isEndingChar = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">(<span class="keyword">char</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TrieNode root = <span class="keyword">new</span> TrieNode(<span class="string">'/'</span>);</span><br><span class="line">    <span class="comment">//往Trie树中插入一个字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span>[] text)</span> </span>&#123;</span><br><span class="line">        TrieNode p = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; text.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = text[i] - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(p.children[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                TrieNode newNode =<span class="keyword">new</span> TrieNode(text[i]);</span><br><span class="line">                p.children[index] = newNode;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        p.isEndingChar = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在Trie树中查找一个字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">select</span><span class="params">(<span class="keyword">char</span>[] pattern)</span> </span>&#123;</span><br><span class="line">        TrieNode p = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pattern.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = pattern[i] - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(p.children[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p.isEndingChar == <span class="keyword">false</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<p>构建Trie树的过程要扫描所有字符串，时间复杂度为O(n)，n表示虽有字符串的长度和。<br>构建好Trie树后，在其中查找字符串的时间复杂度为O(k)，k表示要查找的字符串的长度。  </p>
<h3 id="Trie树缺点及优化"><a href="#Trie树缺点及优化" class="headerlink" title="Trie树缺点及优化"></a>Trie树缺点及优化</h3><p>用数组存储一个节点的字节点的指针，如果字符串中包含从a到z这26个字符，那每个节点都要存储一个长度为26的数组，并且数组每个元素要存储一个8或者4字节指针。浪费内存。  </p>
<p><strong>优化</strong>：将每个节点的数组换成其他数据结构，来存储一个节点的子节点指针，有序数组、跳表、散列表、红黑树。<br>有序数组中的指针按照所指向的子节点中的字符的大小顺序排列。查询的时候，通过二分查找的方法，快速查找到某个字符应该匹配的子节点的指针。但是在往Trie树中插入一个字符串的时候，需要维护数组中数据的有序性。  </p>
<p><strong>变体</strong>：缩点优化，对于只有一个子节点的节点，而且此节点不是一个串的结束节点，可以将此节点与子节点合并。节省空间增加编码难度。  </p>
<p><strong>扩展</strong>：后缀树、DAT（双数组trie树）。  </p>
<h3 id="Trie树的使用场景"><a href="#Trie树的使用场景" class="headerlink" title="Trie树的使用场景"></a>Trie树的使用场景</h3><p>动态数据高效操作的数据结构：散列表、红黑树、跳表  </p>
<ul>
<li>字符串中包含的字符集不能太大。浪费存储空间。  </li>
<li>字符串的前缀重合比较多。  </li>
<li>需要从零开始实现一个Trie树。  </li>
<li>用到了指针，数据块不连续，堆缓存不友好。  </li>
</ul>
<p>Trie树不适合精确匹配查找（散列表、红黑树），比较适合查找前缀匹配的字符串。搜索引擎提示关键词、输入法自动补全、IDE代码编辑器自动补全、浏览器啊网址输入自动补全、屏蔽字/敏感词检测。  </p>
<h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><ul>
<li>复杂中文实现  </li>
<li>前缀匹配过多，选择展示  </li>
<li>拼写错误，校正提示  </li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>Apache Commons<br>PatriciaTrie<br>AbstractPatriciaTrie  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>AC自动机</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    <content><![CDATA[<h3 id="基于单模式串和Trie树实现"><a href="#基于单模式串和Trie树实现" class="headerlink" title="基于单模式串和Trie树实现"></a>基于单模式串和Trie树实现</h3><p>单模式串匹配算法，是在一个模式串和一个主串之间进行匹配，在一个主串中查找一个模式串。<br>多模式串匹配算法，是在多个模式串和一个主串之间进行匹配，在一个主串中查找多个模式串。  </p>
<p>Trie树是一种多模式串匹配算法。<br>对敏感词字典进行预处理，构建成Trie树结构。预处理操作只需要做一次，敏感词字典动态更新（删除、添加），只需要动态更新一下Trie树。  </p>
<p>当用户输入一个文本内容后，把用户输入的内容作为主串，从第一个字符(假设字符C)开始，在Trie树中匹配。当匹配到Trie树的叶子节点，或者中途遇到不匹配字符的时候，将主串的开始匹配位置后移一位，也就是从字符C的下一个字符开始，重新在Trie树中匹配。  </p>
<p>类似单模式串匹配的BF算法。  </p>
<h3 id="多模式串匹配算法"><a href="#多模式串匹配算法" class="headerlink" title="多模式串匹配算法"></a>多模式串匹配算法</h3><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>AC自动机算法（Aho-Corasick算法）。<br>Trie树跟AC自动机之间的关系，类似于单串匹配中朴素的串匹配算法跟KMP算法之间的关系。<br>AC自动机实际上就是再Trie树之上，加了类似KMP的next数组，只不过此处的next数组时构建在树上罢了。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        AC自动机
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AcNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span> data;</span><br><span class="line">    <span class="keyword">public</span> AcNode[] children = <span class="keyword">new</span> AcNode[<span class="number">26</span>];<span class="comment">//字符集只包含a-z这26个字符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isEndingChar = <span class="keyword">false</span>;<span class="comment">//结尾字符为true</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> length = -<span class="number">1</span>;<span class="comment">//当isEndingChar=true时，记录模式串长度</span></span><br><span class="line">    <span class="keyword">public</span> AcNode fail;<span class="comment">//失败指针</span></span><br><span class="line">    <span class="function">punlic <span class="title">AcNode</span><span class="params">(<span class="keyword">char</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p>AC自动机的构建，包含两个操作：</p>
<ul>
<li>将多个模式串构建成Trie树；</li>
<li>在Trie树上构建失败指针（相当于KMP中的失败函数next数组）。</li>
</ul>
<p>Trie树中的每一个节点都有一个失败指针，它的作用和构建过程，跟KMP算法中的next数组极其相似。  </p>
<p>沿Trie树走到p节点，p的失败指针就是从root走到p节点形成的字符串abc，跟所有模式串前缀匹配的最长可匹配后缀子串。  </p>
<p>字符串abc的后缀子串有两个bc、c，拿它们与其他模式串匹配，如果某个后缀子串可以匹配某个模式串的前缀，就把这个后缀子串叫做<strong>可匹配后缀子串</strong>。  </p>
<p>从匹配后缀子串中，找出最长的一个。将p节点的失败指针指向那个最长匹配后缀子串对应的模式串的前缀的最后一个节点。  </p>
<p>把树中相同深度的节点放到同一层，那么某个节点的失败指针只有可能出现在它所在层的上一层。  </p>
<p>当要求某个节点的失败指针的时候，通过已经求得的、深度更小的那些节点的失败指针来推导。也就是说可以逐层依次来求解每个节点的失败指针。失败指针的构建过程，是一个按层遍历树的过程。  </p>
<h4 id="失败指针"><a href="#失败指针" class="headerlink" title="失败指针"></a>失败指针</h4><p>root的失败指针为NULL，就是指向自己。  </p>
<p>假设节点p的失败指针指向节点q，看节点p的子节点pc对应的字符，是否也可以在节点q的子节点中找到。如果找到了节点q的一个子节点qc，对应的字符跟节点pc对应的字符相同，则将节点pc的失败指针指向节点qc。  </p>
<p>如果节点q中没有子节点的字符等于节点pc包含的字符，则令q=q-&gt;fail(fail表示失败指针)，继续上面的查找，直到q是root为止，如果还没有找到相同字符的子节点，就让节点pc的失败指针指向root。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        失败指针
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildFailurePointer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Queue&lt;AcNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    root.fail = <span class="keyword">null</span>;</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        AcNode p = queue.remove();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            AcNode pc = p.children[i];</span><br><span class="line">            <span class="keyword">if</span>(pc == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(p == root) &#123;</span><br><span class="line">                pc.fail = root;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                AcNode q = p.fail;</span><br><span class="line">                <span class="keyword">while</span>(q != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    AcNode qc = q.children[pc.data - <span class="string">'a'</span>];</span><br><span class="line">                    <span class="keyword">if</span>(qc != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        pc.fail = qc;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    q = q.fail;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(q == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    pc.fail = root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            queue.add(pc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p>按层计算每个节点的子节点的失效指针。  </p>
<h4 id="匹配主串"><a href="#匹配主串" class="headerlink" title="匹配主串"></a>匹配主串</h4><p>在匹配过程中，主串从i=0开始，AC自动机从指针p=root开始，假设模式串是b，主串是a。  </p>
<ul>
<li>如果p指向的节点有一个等于b[i]的子节点x，就更新p指向x，这个时候需要通过失败指针，检测一系列失败指针为结尾的路径是否是模式串。处理完之后，将i加一，继续这两个过程。  </li>
<li>如果p指向的节点没有等于b[i]的子节点，那失败指针就派上用场了，让p=p-&gt;fail，然后继续这两个过程。  </li>
</ul>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        匹配主串
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>[] text)</span> </span>&#123;<span class="comment">//text是主串</span></span><br><span class="line">    <span class="keyword">int</span> n = text.length;</span><br><span class="line">    AcNode p = root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> idx = text[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">while</span>(p.children[idx] == <span class="keyword">null</span> &amp;&amp; p != root) &#123;</span><br><span class="line">            p = p.fail;<span class="comment">//失败指针发挥作用的地方</span></span><br><span class="line">        &#125;</span><br><span class="line">        p = p.children[idx];</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span>) p = root;<span class="comment">//如果没有匹配的，从root开始重新匹配</span></span><br><span class="line">        AcNode tmp = p;</span><br><span class="line">        <span class="keyword">while</span>(tmp != root) &#123;<span class="comment">//打印出可以匹配的模式串</span></span><br><span class="line">            <span class="keyword">if</span>(tmp.isEndingChar == <span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> pos = i - tmp.length + <span class="number">1</span>;</span><br><span class="line">                System.out.println(<span class="string">"匹配起始下标"</span> + pos + <span class="string">"；长度"</span> + tmp.length);</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = tmp.fail;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<h3 id="效率分析"><a href="#效率分析" class="headerlink" title="效率分析"></a>效率分析</h3><h4 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h4><p>将敏感词构建成AC自动机，包括构建Trie树以及构建失败指针。  </p>
<p>Trie树构建的时间复杂度是O(m*len)，其中len表示敏感词的平均长度，m表示敏感词的个数。  </p>
<p>假设Trie树中总的节点个数是k，每个节点构建失败指针的时候，最耗时的环节是while循环中的q=q-&gt;fail，每次运行一次这个语句，q指向节点的深度都会减少1，而树的高度最高也不会超过len，所以每个节点构建失败指针的时间复杂度是O(len)。整个失败指针的构建过程为O(k*len)。  </p>
<p>AC自动机的构建过程都是预先处理好的，构建好之后，并不会频繁的更新，不会影响到敏感词过滤的运行效率。  </p>
<h4 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h4><p>for循环依次遍历主串中的每个字符，for循环内部最耗时的部分也是while循环，这一部分的时间复杂度是O(len)，总的匹配的时间复杂度就是O(n*len)。敏感词一般不长，实际情况近似于O(n)。  </p>
<p>从时间复杂度上看，AC自动机匹配的效率跟Trie树一样。但是失效指针大部分情况下都指向root节点，所以大部分情况下，在AC自动机上做匹配的效率要远高于理论时间复杂度。只有在极端情况边，AC自动机的性能才会退化的根Trie树一样（每个节点的失效指针分别指向自己的父节点）。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>红黑树</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    <content><![CDATA[<p>二叉查找树，支持快速插入、删除、查找操作，各个操作的时间复杂度跟树的高度成正比，理想情况下，时间复杂度是O(logn)。  </p>
<p>二叉查找树在频繁的动态更新过程中，可能会出现树的高度远大于log<sub>2</sub>n的情况，从而导致各个操作的效率下降。极端情况下，二叉树会退化为链表，时间复杂度会退化到O(n)。<br>需要平衡二叉查找树，解决普通二叉查找树在频繁的插入、删除等动态更新的情况下，出现时间复杂度退化的问题。  </p>
<h3 id="平衡二叉查找树定义"><a href="#平衡二叉查找树定义" class="headerlink" title="平衡二叉查找树定义"></a>平衡二叉查找树定义</h3><p>二叉树中任意一个节点得左右子树的高度相差不能大于1。完全二叉查找树、满二叉树都是<strong>平衡二叉树</strong>。平衡二叉查找树还需要满足二叉查找树的特点。AVL树。  </p>
<p>平衡二叉查找树中“平衡”的意思，其实就是让整棵树左右看起来比较“对称”、比较“平衡”，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些。<br>树的高度不比log<sub>2</sub>n很多。  </p>
<h3 id="红黑树定义"><a href="#红黑树定义" class="headerlink" title="红黑树定义"></a>红黑树定义</h3><p>红黑树”Red-Black Tree”，简称R-B Tree。是一种不严格的平衡二叉查找树。  </p>
<p>红黑树中的节点，一类被标记为黑色，一类被标记为红色。  </p>
<ul>
<li>根节点是黑色的；</li>
<li>每个叶子节点都是黑色的空节点(NIL)，叶子节点不存储数据；<blockquote>
<p>主要是为了简化红黑树的代码实现。（共用一个黑色的、空的叶子节点。避免浪费存储空间。）</p>
</blockquote>
</li>
<li>任何相邻的节点都不能同时为红色，红色节点是被黑色节点隔开的；</li>
<li>每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；</li>
</ul>
<blockquote>
<p>红黑树就是用红链接表示3-节点的2-3树。2-节点(包含一个元素，两条子链接)，3-节点(包含两个元素，三条链接)<br>红链接将两个2-节点连接起来构成一个3-节点，黑链接则是2-3树中的普通链接。<br>红色节点标记代表指向其的链接是红链接，黑色标记的节点就是普通的节点。红色节点可以与其父节点合并为一个3-节点。  </p>
<ul>
<li>红链接均为左链接（左倾红黑树）；</li>
<li>没有任何一个结点同时和两条红链接相连；</li>
<li>该树是完美黑色平衡的，任意空链接到根节点的路径上的黑链接数量相同。  </li>
</ul>
</blockquote>
<blockquote>
<p>将红黑树中所有的红色链接放平，那么它所有的叶子节点到根节点的距离都是相同的。如果将由红链接相连的节点合并，得到的就是一棵2-3树。<br>父节点指向的节点是红节点，那么就认为这两个节点其实就是2-3树里面的3节点。如果有一个黑节点连接了连个红节点，那么就认为这是一个4-节点，因为2-3树不允许4-节点，所以要将其提取出来。<br>所谓的旋转，对于2-3树来说节点并没有变化。因为红节点和指向它的节点本来就被认为是一个节点。  </p>
</blockquote>
<h3 id="实现红黑树"><a href="#实现红黑树" class="headerlink" title="实现红黑树"></a>实现红黑树</h3><p>在插入、删除节点的过程中，第三、第四点要求可能会被破坏。<br>平衡调整实际上就是要把被破坏的第三、第四点回复过来。  </p>
<p>左旋(rotate left)围绕某个节点的左旋。逆时针<br>右旋(rotate right)围绕某个节点的右旋。顺时针  </p>
<h4 id="插入操作的平衡调整"><a href="#插入操作的平衡调整" class="headerlink" title="插入操作的平衡调整"></a>插入操作的平衡调整</h4><p>红黑树规定，<strong>插入的节点必须是红色的</strong>。而且，二叉查找树中<strong>新插入的节点都是放在叶子节点上</strong>。  </p>
<ul>
<li>如果插入结点的父节点是黑色的，那什么都不用做，它仍然满足红黑树的定义。  </li>
<li>如果插入的节点是根节点，那么直接改变它的颜色，把它变成黑色就可以了。  </li>
<li>其他情况都会违背红黑树的定义，需要进行调整，调整的过程包含两种基础的操作：<strong>左右旋转和改变颜色</strong>。  </li>
</ul>
<p>红黑树的平衡调整过程是一个迭代的过程。把正在处理的节点叫做关注节点。关注节点会随着不停的迭代处理，而不断发生变化。最开始的关注节点就是新插入的节点。  </p>
<ol>
<li><p>如果关注节点是a，它的叔叔节点d是红色：  </p>
<ul>
<li>将关注节点a的父节点b、叔叔节点d的颜色都设置成黑色；  </li>
<li>将关注节点a的祖父节点c的颜色设置成红色；  </li>
<li>关注节点变成a的祖父节点c;  </li>
<li>跳到情况2或者情况3。  </li>
</ul>
</li>
<li><p>如果关注节点是a，它的叔叔节点d是黑色，关注节点a是其父节点b的右子节点：  </p>
<ul>
<li>关注节点变成节点a的父节点b；  </li>
<li>围绕新的关注节点b左旋；  </li>
<li>跳到情况3。  </li>
</ul>
</li>
<li><p>如果关注节点是a，它的叔叔节点d是黑色，关注节点a是其父节点b的左子节点：  </p>
<ul>
<li>围绕关注节点a的祖父节点c右旋；  </li>
<li>将关注节点a的父节点b、兄弟节点c的颜色互换。  </li>
<li>调整结束</li>
</ul>
</li>
</ol>
<h4 id="删除操作的平衡调整"><a href="#删除操作的平衡调整" class="headerlink" title="删除操作的平衡调整"></a>删除操作的平衡调整</h4><p>删除操作的平衡调整分为两步，第一步是针对删除节点初步调整。初步调整只是保证整棵红黑树在一个节点删除之后，仍然满足最后一条定义的要求，每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；第二部是针对关注节点进行二次调整，让它满足红黑树的第三条定义，即不存在相邻的两个红色节点。  </p>
<p><strong>第一步，针对删除节点初步调整。</strong><br>经过初步调整之后，为了保证满足红黑树定义的最后一条要求，有些节点会被标记成两种颜色，“红-黑”或者“黑-黑”。如果一个节点被标记为了“黑-黑”，在计算黑色节点个数的时候，要算成两个黑色节点。  </p>
<ol>
<li><p>如果要删除的节点是a，它只有一个子节点b：  </p>
<ul>
<li>删除节点a，并且把节点b替换到节点a的位置，此操作跟普通的二叉查找树的删除操作一样；  </li>
<li>节点a只能是黑色，节点b只能是红色，其他情况均不符合红黑树的定义。把节点b改成黑色；  </li>
<li>调整结束，不需要进行二次调整。  </li>
</ul>
</li>
<li><p>如果要删除的节点a有两个非空子节点，并且它的后继节点就是节点a的右子节点c：  </p>
<ul>
<li>如果节点a的后继节点就是右子节点c，那右子节点c肯定没有左子树。把节点a删除，并且将节点c替换到节点a的位置。此操作与二叉查找树的删除操作一样；</li>
<li>然后把节点c的颜色设置为跟节点a相同的颜色；</li>
<li>如果节点c是黑色，为了不违反红黑树的最后一条定义，给节点c的右子节点d多加一个黑色，此时节点d就成了“红-黑”或者“黑-黑”；</li>
<li>关注节点变成节点d，第二步的调整操作就会针对关注节点来做。  </li>
</ul>
</li>
<li><p>如果要删除的是节点a，它有两个非空子节点，并且节点a的后继节点不是右子节点：  </p>
<ul>
<li>找到后继节点d，并将它删除，删除后继节点d的过程参照情况1；  </li>
<li>将节点a替换成后继节点d；  </li>
<li>把节点d的颜色设置为跟节点a相同的颜色；  </li>
<li>如果节点d是黑色，为了不违反红黑树的最后一条定义，给节点d的右子节点c多加一个黑色，此时节点c就成了“红-黑”或者“黑-黑”；  </li>
<li>关注节点变成了节点c，第二步的调整操作就会针对关注节点来做。  </li>
</ul>
</li>
</ol>
<p><strong>第二步，针对关注节点进行二次调整。</strong><br>经过初步调整之后，关注节点变成了“红-黑”或者“黑-黑”节点。针对关注节点的二次调整是为了让红黑树中不存在相邻的红色节点。  </p>
<ol>
<li><p>关注节点是a，它的兄弟节点c是红色的：  </p>
<ul>
<li>围绕关注节点a的父节点b左旋；  </li>
<li>关注节点a的父节点b和祖父节点c交换颜色；  </li>
<li>关注节点不变；  </li>
<li>继续从四种情况中选择适合的规则来调整。  </li>
</ul>
</li>
<li><p>关注节点是a，它的兄弟节点c是黑色的，并且节点c的左右子节点d、e都是黑色的：  </p>
<ul>
<li>将关注节点a的兄弟节点c的颜色变成红色；  </li>
<li>从关注节点a中去掉一个黑色，此时节点a就是单纯的红色或者黑色；  </li>
<li>给关注节点a的父节点b添加一个黑色，此时节点b就变成了“红-黑”或者“黑-黑”；  </li>
<li>关注节点从a变成其父节点b；  </li>
<li>继续从四种情况中选择符合的规则来调整。  </li>
</ul>
</li>
<li><p>关注节点是a，它的兄弟节点c是黑色，c的左子节点d是红色，c的右子节点e是黑色：  </p>
<ul>
<li>围绕关注节点a的兄弟节点c右旋；  </li>
<li>节点c和节点d交换颜色；  </li>
<li>关注节点不变；  </li>
<li>跳转到情况4，继续调整。  </li>
</ul>
</li>
<li><p>关注节点a的兄弟节点c是黑色的，并且c的右子节点是红色的：  </p>
<ul>
<li>围绕关注节点a的父节点b左旋；  </li>
<li>将关注节点a的兄弟节点c的颜色，跟关注节点a的父节点b设置成相同的颜色；  </li>
<li>将关注节点a的父节点b的颜色设置为黑色；  </li>
<li>从关注节点a中去掉一个黑色，节点a就变成了单纯的红色或者黑色；  </li>
<li>将关注节点a的叔叔节点e设置为黑色；  </li>
<li>调整结束。  </li>
</ul>
</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title>递归树</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92%E6%A0%91/</url>
    <content><![CDATA[<h3 id="递归树"><a href="#递归树" class="headerlink" title="递归树"></a>递归树</h3><p>递归的思想，将大问题分解为小问题来求解，然后再将小问题分解为小小问题。这样一层一层的分解，直到问题的数据规模被分解得足够小，不用继续递归分解为止。<br>如果把这个一层一层分解过程画成图，它其实就是一棵树—递归树。  </p>
<p>归并的时间复杂度、快排的最好情况时间复杂度适合用递推公式分析。<br>快排平均时间复杂度适合用递归树分析。<br>二叉树的前中后序遍历都不适合。  </p>
<h3 id="归并排序的时间复杂度"><a href="#归并排序的时间复杂度" class="headerlink" title="归并排序的时间复杂度"></a>归并排序的时间复杂度</h3><p>归并排序每次会将数据规模一分为二。因为每次分解都是一分为二，所以代价很低，把时间上的消耗记作常量l。归并算法中比较耗时的是归并操作，也就是把连个子数组合并为大数组。每一层归并操作消耗的时间总和是一样的，跟要排序的数据规模有关，把每一层归并操作消耗的时间记作n。  </p>
<p>只需要知道这棵树的高度h，用高度h乘以每一层的时间消耗n，就可以得到总的时间复杂度O(n*h)。<br>归并排序递归树是一棵满二叉树，满二叉树的高度大约是log<sub>2</sub>n，归并排序的时间复杂度就是O(nlogn)。  </p>
<h3 id="快速排序的时间复杂度"><a href="#快速排序的时间复杂度" class="headerlink" title="快速排序的时间复杂度"></a>快速排序的时间复杂度</h3><h4 id="递推公式分析时间复杂度"><a href="#递推公式分析时间复杂度" class="headerlink" title="递推公式分析时间复杂度"></a>递推公式分析时间复杂度</h4><p>快速排序在最好情况下，每次分区都能一分为二，此时用递推公式T(n)=2T(n/2)+n，推导出时间复杂度是O(nlogn)。  </p>
<p>平均情况下，每次分区之后，两个分区的大小比例为1:k。当k=9时，如果用递推公式的方法求解时间复杂度，递推公式为T(n)=T(n/10)+T(9n/10)+n。  </p>
<h4 id="递归树分析时间复杂度"><a href="#递归树分析时间复杂度" class="headerlink" title="递归树分析时间复杂度"></a>递归树分析时间复杂度</h4><p>快速排序的过程中，每次分区都要遍历待分区区间的所有数据，每一层分区操作所遍历的数据的个数之和就是n。只要求出递归树的高度h，快排过程遍历的数据个数就是h*n，时间复杂度就是O(h*n)。</p>
<p>每次分区并不是均匀的一分为二，递归树并不是满二叉树。<br>快速排序结束的条件是排序的小区间大小为1，即叶子节点里的数据规模是1。从根节点n到叶子节点1，递归树中最短的一个路径每次都乘以1/10，最长的一个路径每次都乘以9/10。计算后可得，从根节点到叶子节点的最短路径是log<sub>10</sub>n，最长路径是log<sub>10/9</sub>n。<br>遍历数据的个数总和就介于nlog<sub>10</sub>n和nlog<sub>10/9</sub>n之间。根据复杂度的大O表示法，对数复杂度的底数不管是多少，统一写成logn。所以当分区大小比例是1:9时，快速排序的时间复杂度仍然是O(nlogn)。  </p>
<p>只要k的值不随n变化，是一个事先确定的常量，快排的时间复杂度就是O(nlogn)。  </p>
<h3 id="斐波那契数列的时间复杂度"><a href="#斐波那契数列的时间复杂度" class="headerlink" title="斐波那契数列的时间复杂度"></a>斐波那契数列的时间复杂度</h3><p>递推公式f(n)=f(n-1)+f(n-2)。<br>递归代码画成递归树。f(n)分解为f(n-1)和f(n-2)，每次数据规模都是-1或者-2，叶子节点的数据规模是1或者2。所以从根节点走到叶子节点，每条路径是长短不一的。如果每次都是-1，那最长路径大约是n；如果每次都是-2，那最短路径大约是n/2。  </p>
<p>每次分解之后的合并操作只需要一次加法运算，把加法运算的时间消耗记作1。从上往下，第一层的总时间消耗是1，第二层的总时间消耗是2，第三层的总时间消耗是2<sup>2</sup>。依次类推，第k层的时间消耗就是2<sup>k-1</sup>，整个算法的总时间消耗就是每一层时间消耗之和。  </p>
<p>如果路径长度都为n，总和就是2<sup>n</sup>-1。<br>如果路径长度都是n/2，那总和是2<sup>n/2</sup>-1。<br>所以算法的时间复杂度介于O(2<sup>n</sup>)和O(2<sup>n/2</sup>)之间。指数级。  </p>
<h3 id="全排列的时间复杂度"><a href="#全排列的时间复杂度" class="headerlink" title="全排列的时间复杂度"></a>全排列的时间复杂度</h3><p>把n个数据的所有排列都找出来，就是全排列的问题。<br>可以用递归来打印一组数据的所有排列。  </p>
<p>如果确定了最后一位数据，就变成求解剩下n-1个数据的排列问题。最后一个数据可以是n个数据中的任意一个，它的取值有n种情况。“n个数据的排列”问题，可以分解成n个“n-1个数据的排列”的子问题。  </p>
<p>递推公式：<br>f(1,2,…n) = {最后一位是1, f(n-1)} + {最后一位是2, f(n-1)} +…+{最后一位是n, f(n-1)}  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        全排列
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printPermutations</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            System.out.print(data[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = data[i];</span><br><span class="line">        data[i] = data[k-<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        printPermutations(data, n, k-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        tmp = data[i];</span><br><span class="line">        data[i] = data[k-<span class="number">1</span>];</span><br><span class="line">        data[k-<span class="number">1</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p>画出递归树<br>第一层分解有n次交换操作，第二层有n个节点，每个节点分解需要n-1次交换，所以第二层总的交换次数是n<em>(n-1)。第三层有n</em>(n-1)个节点，每个节点分解需要n-2次，所以第三层总的交换次数是n<em>(n-1)</em>(n-2)。  </p>
<p>以此类推，第k层总的交换次数就是n<em>(n-1)</em>(n-2)<em>…</em>(n-k+1)。最后一层的交换次数就是n*(n-1)*(n-2)*…*2*1。每一层的交换次数之和就是总的交换次数。  </p>
<p>n + n*(n-1) + n*(n-1)*(n-2) +… + n*(n-1)(n-2)*…*2*1  </p>
<p>最后一个数等于n!，前面n-1个数都小于最后一个数，总和肯定小于n*n!。全排列的递归算法的时间复杂度在O(n!)与O(n*n!)之间。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>递归树</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希算法</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="哈希算法定义"><a href="#哈希算法定义" class="headerlink" title="哈希算法定义"></a>哈希算法定义</h3><p>散列=哈希<br>将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是<strong>哈希算法</strong>，通过原始数据映射之后得到的二进制值串就是<strong>哈希值</strong>。  </p>
<ul>
<li>从哈希值不能反向推导出原始数据（哈希算法也叫单项哈希算法）；  </li>
<li>对输入数据非常敏感，哪怕原始数据只修改了一个Bit，最后得到的哈希值也大不相同；  </li>
<li>散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小；  </li>
<li>哈希算法的执行效率要尽量高效，针对较长的文本，也能快速的计算出哈希值。  </li>
</ul>
<h3 id="哈希算法应用"><a href="#哈希算法应用" class="headerlink" title="哈希算法应用"></a>哈希算法应用</h3><h4 id="安全加密（数字签名-信息摘要）"><a href="#安全加密（数字签名-信息摘要）" class="headerlink" title="安全加密（数字签名/信息摘要）"></a>安全加密（数字签名/信息摘要）</h4><p>最常用于加密的哈希算法是MD5（MD5 Message-Digest Algorithm，MD5消息摘要算法）和SHA（Secure Hash Algorithm，安全散列算法）。  </p>
<p>其他加密算法（非哈希）DES（Data Encryption Standard，数据加密标准）、AES（Advanced Encryption Standard，高级加密标准）。  </p>
<p>第一很难根据哈希值反向推导出原始数据。<br>第二散列冲突的概率要很小。鸽巢原理（抽屉原理）  </p>
<p>哈希算法产生的哈希值的长度是固定且有限的。基于鸽巢原理，必然会存在哈希值相同的情况。一般情况下，哈希值越长的哈希算法，散列冲突的概率越低。<br>没有绝对安全的加密，越复杂、越难破解的加密算法，需要的计算时间也越长。  </p>
<p>针对字典攻击，可以引入一个盐salt，跟用户密码组合在一起，增加密码的复杂度。拿组合之后的字符串来做哈希算法加密，将它存储到数据库中，进一步增加破解的难度。</p>
<h4 id="唯一标识"><a href="#唯一标识" class="headerlink" title="唯一标识"></a>唯一标识</h4><p>哈希算法可以对大数据做信息摘要，通过一个较短的二进制编码来表示很大的数据。<br>将每一个图片开头、中间、结尾分别取一部分字节，通过哈希算法，得到一个哈希字符串，用它作为图片的额唯一标识。通过这个唯一标识来判定图片是否在图库，可以减少很多工作量。  </p>
<h4 id="数据校验"><a href="#数据校验" class="headerlink" title="数据校验"></a>数据校验</h4><p>校验数据的完整性和正确性。<br>BT协议，将一个大文件分成多块小文件，通过哈希算法，对小文件块分别取哈希值，并保存在种子文件中。当文件块下载完成之后，可以通过相同的哈希算算发，对下载好的文件块逐一求哈希值，然后跟种子文件中保存的哈希值比对。如果不同，说明这个文件块不完整或者被篡改了，需要再重新从其他宿主及其上下载这个文件块。  </p>
<h4 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h4><p>散列函数是涉及一个散列表的关键。它直接决定了散列冲突的概率和散列表的性能。<br>散列函数对于散列算法冲突的要求低很多，即便出现个别散列冲突，只要不是过于严重，都可以通过开放寻址法或者链表法解决。<br>散列函数更加关注散列后的值是否能平均分布，使一组数据能均匀的散列在各个槽中。<br>散列函数用的散列算法一般都比较简单，比较追求效率，注重性能。  </p>
<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>轮询、随机、加权轮询等都属于负载均衡算法。<br>在同一个客户端上，在一次绘画中的所有请求都路由到同一个服务器上。需要会话粘滞的负载均衡算法。  </p>
<ul>
<li><p>维护一张映射关系表，表的内容是客户端IP地址或者会话ID与服务器编号的映射关系，客户端发出的每次请求，都要先在映射表中查找应该路由到的服务器编号，然后再请求编号对应的服务器。  </p>
<blockquote>
<p>客户端很多，映射表很大，比较浪费内存空间；客户端下线、上线，服务器扩容、缩容都会导致映射失败，维护映射表的成本会很大。  </p>
</blockquote>
</li>
<li><p>通过哈希算法，对客户端IP地址或者会话ID计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该被路由道德服务器编号。这样就可以把同一个Ip过来的所有请求都路由到同一个后端服务器上。  </p>
</li>
</ul>
<h4 id="数据分片"><a href="#数据分片" class="headerlink" title="数据分片"></a>数据分片</h4><ol>
<li><p>统计搜索关键词出现的次数<br>1T的日志文件，记录了用户的搜索关键词，要快速的统计出每个关键词被搜索的次数 。<br>先对数据进行分片，然后采用多肽及其处理的方法，来提高处理速度。用n台机器进行处理。从搜索记录的日志文件中，依次读出每个搜索关键词，并且通过哈希函数计算哈希值，然后再跟n取模，最终得到的值，就是应该被分配到的机器编号。<br>哈希值相同的搜索关键词就被分配到了同一个机器上。每个机器分别计算关键词出现的次数，最后合并起来就是最终的结果。  </p>
</li>
<li><p>快速判断图片是否在图库中<br>1亿张图片，在单台机器上构建散列表是行不通的。单台机器的内存有限。<br>对数据进行分片，然后采用多机处理。准备n台及其，让每台机器只维护某一部分图片对应的散列表。每次从图库中读取一个图片，计算唯一标识，然后与机器个数n求余取模，得到的值就对应要分配的机器编号，然后将这个图片的唯一标识和图片路径发往对应的及其构架散列表。<br>当要判断一个图片是否在图库中的时候，通过同样的哈希算法，计算这个图片的唯一标识，然后与机器个数n求余取模。假设得到的值是k，那就去编号k的机器构建的散列表中查找。  </p>
</li>
</ol>
<p>针对海量数据的处理问题，都可以采用多机分布式处理。借助分片的思路，突破单机内存、CPU等资源的限制。  </p>
<h4 id="分布式存储"><a href="#分布式存储" class="headerlink" title="分布式存储"></a>分布式存储</h4><p>为了提高互联网海量用户海量数据的读取、写入能力，采用分布式的方式来存储。<br>用数据分片的思想，采用哈希算法对数据取哈希值，然后对机器个数取模，最终值就是应该存储的缓存机器编号。<br>数据增多扩容时，所有的数据都要重新计算哈希值，然后重新搬移到正确的机器上。相当于缓存中的数据一下子都失效了，所有的数据请求都会穿透缓存，直接去请求数据库，这样可能发生雪崩效应，压垮数据库。  </p>
<p>解决方法，一致性哈希算法。<br>假设有k个机器，数据的哈希值的范围是[0,MAX]。将整个分为划分成m个小区间（m远大于k），每个机器负责m/k个小区间。当有新机器加入的时候，就将某几个小区间的数据，从原来的机器中搬移到新的机器中。这样既不用全部重新哈希、搬移数据，也保持了各个机器上数据数量的均衡。  </p>
<p>一致性哈希一般会借助一个虚拟的环和虚拟节点，更加优美的实现出来。  </p>
<p>把服务器映射到hash环，将需要缓存的对象也映射到hash环上，从对象映射的位置开始，沿顺时针方向遇到的第一个服务器，就是要缓存到的服务器。服务器数量发生改变时，并不是所有的缓存都会失效，只有部分缓存会失效（当前服务器位置与其逆时针前一个位置的缓存失效)。<br>服务器映射到hash环上的时候，很有可能出现hash环偏斜的情况，缓存会极不平衡的分布在各个服务器上。虚拟节点解决分配不均问题。虚拟节点是实际节点在hash环上的复制品，均匀的分布在环上，一个实际节点可以对应多个虚拟节点。虚拟节点越多，hash环上的节点就越多，缓存被均匀分布的概率就越大。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>哈希算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1Redis/</url>
    <content><![CDATA[<h3 id="Redis-数据库介绍"><a href="#Redis-数据库介绍" class="headerlink" title="Redis 数据库介绍"></a>Redis 数据库介绍</h3><p>Redis是一种键值(Key-Value)数据库。相对于关系型数据库(MySQL、Oracle)，Redis也被叫做非关系型数据库。  </p>
<p>Redis中只包含“键”和“值”两部分，只能通过“键”来查询“值”。存储结构简单，读写效率高。Redis主要作为内存数据库使用，数据存储在内存中，同时支持将数据存储在硬盘中。  </p>
<p>Redis键的数据类型是字符串，值得数据类型包括字符串、列表、字典、集合、有序集合。  </p>
<h3 id="字符串（string）"><a href="#字符串（string）" class="headerlink" title="字符串（string）"></a>字符串（string）</h3><p>对应数据结构的<strong>字符串</strong>。  </p>
<h3 id="列表（list）"><a href="#列表（list）" class="headerlink" title="列表（list）"></a>列表（list）</h3><p>列表数据类型支持存储一组数据，两种实现方法：压缩列表（ziplist）、双向循环链表。  </p>
<ol>
<li>压缩列表<br> 列表中存储数据量比较小  </li>
</ol>
<ul>
<li><p>列表中保存的单个数据（可以是字符串类型）小于64字节；  </p>
</li>
<li><p>列表中数据个数小于512个。  </p>
<p>  压缩列表不是基础数据结构。类似数组，通过一片连续的内存空间来存储数据。允许存储的数据大小不同。但压缩列表不支持随笔访问，类似链表。<br>  Redis一般通过key获取整个value的值—整个压缩列表的数据，并不需要随机访问。访问某个元素的时候需要从头开始遍历。  </p>
<p>  压缩列表一方面比较节省内存，另一方面可以支持不同类型数据的存储。  </p>
</li>
</ul>
<ol start="2">
<li><p>双向循环链表<br> 链表的一种。  </p>
 <div class='spoiler collapsed'>
    <div class='spoiler-title'>
        list-Redis
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//额外定义了一个list结构体，组织链表的首、尾指针，以及长度信息</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listnode</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="keyword">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">listNode *head;</span><br><span class="line">listNode *tail;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line"><span class="comment">// ....省略其他定义</span></span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

</li>
</ol>
<h3 id="字典（hash）"><a href="#字典（hash）" class="headerlink" title="字典（hash）"></a>字典（hash）</h3><p>字典类型用来存储一组数据对。每个数据对又包含键值两部分。两种实现方法：压缩列表、散列表。  </p>
<ol>
<li>压缩列表<br> 存储的数据量比较小  </li>
</ol>
<ul>
<li>字典中保存的键和值的大小都要小于64字节；  </li>
<li>字典中键值对的个数要小于512个。  </li>
</ul>
<ol start="2">
<li>散列表<br> Redis使用MurmurHash2这种运行速度快、随机性好的哈希算法作为哈希函数。<br> Redis使用链表法解决哈希冲突问题。<br> Redis支持散列表的动态扩容（装载因子大于1，散列表扩大为原来的2倍左右）、缩容（装载因子小于0.1，缩小为字典中数据个数的大约2倍大小）。<br> 采用渐进式扩容缩容策略，将数据的搬移分批进行，避免大量数据一次性搬移导致的服务停顿。  </li>
</ol>
<h3 id="集合（set）"><a href="#集合（set）" class="headerlink" title="集合（set）"></a>集合（set）</h3><p>集合类型用来存储一组不重复的数据。两种实现方法：有序数组、散列表。  </p>
<ol>
<li>有序数组  </li>
</ol>
<ul>
<li>存储的数据都是整数；  </li>
<li>存储的数据元素个数不超过512个。  </li>
</ul>
<ol start="2">
<li>散列表  </li>
</ol>
<h3 id="有序集合（sortedset）"><a href="#有序集合（sortedset）" class="headerlink" title="有序集合（sortedset）"></a>有序集合（sortedset）</h3><p>有序集合用来存储一组数据。两种实现方式：压缩列表、跳表。  </p>
<ol>
<li>压缩列表  </li>
</ol>
<ul>
<li>所有数据的大小都要小于64字节；</li>
<li>元素个数要小于128个。  </li>
</ul>
<ol start="2">
<li>跳表<br> 每个数据会附带一个得分。通过得分的大小，将数据组织成跳表这样的数据结构，以支持快速的按照得分值、得分区间获取数据。  </li>
</ol>
<h3 id="数据结构持久化（对象持久化）"><a href="#数据结构持久化（对象持久化）" class="headerlink" title="数据结构持久化（对象持久化）"></a>数据结构持久化（对象持久化）</h3><p>Redis常被用作内存数据库，也支持数据落盘，将内存中的数据存储到磁盘中。  </p>
<p>Redis的数据格式由“键”和“值”两部分组成。“值”支持很多数据类型。两种持久化思路：  </p>
<ul>
<li><p>清除原有的存储结构，只将数据存储到磁盘中。当需要从磁盘还原数据到内存的时候，再重新将数据组织成原来的数据结构。数据从硬盘还原到内存的过程，会耗用比较多的时间。（重新构建散列表时，需要重新计算每个数据的哈希值。）</p>
</li>
<li><p>保留原来的存储格式，将数据按照原有的格式存储在磁盘中。将散列表的大小、每个数据被散列到的槽的编号等信息，都保存在磁盘中。从磁盘中将数据还原到内存中的时候，可以避免重新计算哈希值。  </p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>MurmurHash</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索引擎</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/2%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<p>搜索引擎大致可以分为四个部分：搜集、分析、索引、查询。<br>搜集：利用爬虫爬取网页；<br>分析：网页内容抽取、分词，构建临时索引，计算PageRank值；<br>索引：通过分析阶段得到的临时索引，构建倒排索引；<br>查询：响应用户的请求，根据倒排索引获取相关网页，计算网页排名，返回查询结果给用户。  </p>
<h3 id="搜集"><a href="#搜集" class="headerlink" title="搜集"></a>搜集</h3><p>对搜索引擎来说，它事先并不知道网页都在哪里。搜索引擎把整个互联网看做数据结构中的有向图，把每个页面看做一个顶点。如果某个页面中包含另外一个页面的链接，就在两个顶点之间连一条有向边。可以利用图的遍历搜索算法，来遍历整个互联网中的网页。  </p>
<p>搜索引擎采用的是<strong>广度优先搜索策略</strong>。先找一些比较知名的网页（权重比较高）的链接，作为种子网页链接，放入到队列中。爬虫按照广度优先的策略，不停的从队列中取出链接，然后去爬取对应的网页，解析出网页里包含的其他网页链接，再将解析出来的链接添加到队列中。  </p>
<ol>
<li><p>待爬取网页链接文件：links.bin<br> 在广度优先搜索爬取页面的过程中，爬虫会不停的解析页面链接，将其放到队列中。队列中的链接会越来越多，可能会多到内存放不下。用一个存储在磁盘中的文件-links.bin来作为广度优先搜索中的队列。爬虫从links.bin文件中，取出链接去爬取对应的页面。等爬取到网页之后，将解析出来的链接，直接存储到links.bin文件中。  </p>
<p> 用文件存储网页链接的方式，支持断点续爬。当机器断点之后，网页链接不会丢失；当机器重启之后，还可以从之前爬取到的位置继续爬取。  </p>
<p> 把整个页面看做一个大的字符串，然后利用字符串匹配算法，在这个大字符串中，搜索<link>这样一个网页标签，然后顺序读取<link></link>之间的字符串，就是网页链接。  </p>
</li>
<li><p>网页判重文件：bloom_filter.bin<br> 采用位图数据结构，使用布隆过滤器快速并且非常节省内存的实现网页的判重。  </p>
<p> 解决机器宕机重启后，存储在内存中的布隆过滤器被清空的问题（导致已经爬取的网易会被重复爬取）。定期（每个半个小时）将布隆过滤器持久化到磁盘中，存储在bloom_filter.bin文件中。即便出现宕机，也只会丢失布隆过滤器中的部分数据，当机器重启后，可以重新读取磁盘中的bloom_filter.bin文件，将其恢复到内容中。  </p>
</li>
<li><p>原始网页存储文件：doc_raw.bin<br> 爬取到网页之后，需要将其存储下来，以备后面离线分析、索引之用。  </p>
<p> 把多个网页存储在一个文件中(避免一个网页对应一个独立文件造成大量文件。同时一个文件不能太大，每个文件大小超过一定的值就创建新的文件)。每个网页之间，通过一定的表示进行分隔，方便后续读取。（网页编号 \t 网页大小 \t 网页 \r\n\r\n）  </p>
</li>
<li><p>网页链接及其编号的对应文件：doc_id.bin<br> 网页编号就是给每个网页分配一个唯一的ID，方便后续对网页进行分析、索引。  </p>
<p> 可以按照网页被爬取的先后顺序，从小到大依次编号。维护一个中心的计数器，每爬取到一个网页之后，就从计数器中拿一个号码，分配给这个网页，然后计数器加一。在存储网页的同时，将网页链接跟编号之间的对应关系，存储在另一个doc_id.bin文件中。  </p>
</li>
</ol>
<p><strong>搜集阶段得到四个文件：links.bin和bloom_filter.bin是爬虫自身所用。<br>doc_raw.bin和doc_id.bin作为搜集阶段的成果，供后面的分析、索引、查询使用。</strong>  </p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>网页爬取下来之后，需要对网页进行离线分析。分析阶段主要包含两个步骤：抽取网页文本信息、分词并创建临时索引。  </p>
<ol>
<li><p>抽取网页文本信息<br> 网页是半结构化数据，里面夹杂着各种标签、JavaScript代码、CSS样式。对于搜索引擎来说，它只关心网页中的文本信息，也就是网页显示在浏览器中时，能被用户肉眼看到的那部分信息。  </p>
<p> 去掉JavaScript代码、CSS格式以及下拉框中的内容。（script、style、option标签之间的内容，利用AC自动机多模式串匹配算法处理，）  </p>
<p> 去掉所有HTML标签。  </p>
</li>
<li><p>分词并创建临时索引<br> 对于英文网页，只需要通过空格、标点符号等分隔符，将每个电磁分割开来就可以。</p>
<p> 对于中文来说，采用基于字典和规则的分词方法。<br> 字典也叫词库，里面包含大量常用的词语，借助词库并采用最长匹配原则（匹配尽可能长的词语），来对文本进行分词。<br> 将词库中的单词，构建成Trie树结构，然后拿网页文本在Trie树中匹配。  </p>
<p> 每个网页的文本信息在分词完成之后，得到一组单词列表。把单词与网页之间的对应关系，写入到一盒临时索引文件中tmp_index.bin，用来构建倒排索引。（单词编号 \t 网页编号 \r\n）  </p>
<p> 在临时索引文件中，存储的是单词编号term_id，而非单词本身，主要是为了节省存储空间。<br> 给单词编号的方式，跟给网页编号类似。维护一个计数器，每当网页文本信息中分割出一个新的单词的时候，就从计数器中取一个编号，分配给他，然后计数器加一。<br> 在这个过程中使用散列表，记录已经变过号的单词。在对网页文本信息分词的过程中，拿分割出来的单词，先到散列表中查找，如果找到就直接使用已有的编号；如果没有找到，再去计数器中拿号码，并且将这个新单词以及编号添加到散列表中。  </p>
<p> 当所有的网页处理完成之后，再将单词跟编号之间的对应关系，吸入到磁盘文件中，命名为term_id.bin。  </p>
</li>
</ol>
<p><strong>分析阶段得到两个文件：临时索引文件tmp_index.bin和单词编号文件term_id.bin。</strong>  </p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>索引阶段主要负责将分析阶段产生的临时索引，构建成倒排索引—Inverted index。倒排索引中记录了每个单词以及包含它的网页列表。（term_id缩写，单词编号 \t did1,…didx表示包含单词的网页编号列表 \r\n）  </p>
<blockquote>
<p>正排-文档中包含哪些单词<br>倒排-单词被哪些文档包含  </p>
</blockquote>
<p>采用多路归并排序的方法，通过临时索引文件，构建出倒排索引文件。  </p>
<p>先对临时索引文件，按照单词编号的大小进行排序。采用归并排序的处理思想，将其分割成多个小文件，先对每个小文件独立排序，最后再合并在一起。（可直接用MapReduce来处理）  </p>
<p>临时索引文件排序完成之后，相同的单词被排列到了一起。只需要顺序地遍历遍历排好序的临时索引文件，就能将每个单词对应的网页编号列表找出来，然后把他们存储在倒排索引文件中。  </p>
<p>除了倒排文件外，需要一个记录每个单词编号在倒排索引文件中的偏移位置的文件—term_offset.bin。这个文件可以快速的查找某个单词编号在倒排索引中存储的位置，进而快速的从倒排索引中读取单词编号对应的网页编号列表。（单词编号 \t 偏移位置 \r\n）  </p>
<p><strong>索引阶段得到两个文件：倒排索引文件index.bin和记录单词编号在索引文件中的偏移位置的文件term_offset.bin。</strong>  </p>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>利用之前产生的几个文件，实现最终的用户搜索功能。  </p>
<ul>
<li>doc_id.bin:记录网页链接和编号之间的对应关系。  </li>
<li>term_id.bin:记录单词和编号之间的对应关系。  </li>
<li>index.bin:倒排索引文件，记录每个单词编号以及对应包含它的网页编号列表。  </li>
<li>term_offset.bin:记录每个单词编号在倒排索引文件中的偏移位置。  </li>
</ul>
<p>除了倒排索引文件比较大之外其他都比较小。将其他三个文件都加载到内存中，并组织成散列表这种数据结构。  </p>
<p>当用户在搜索框中，输入某个查询文本的时候，先对用户输入的文本进行分词处理。假设分词之后，得到k个单词。  </p>
<p>拿这k个单词，去term_id.bin对应的散列表中，查找对应的单词编号，得到这k个单词对应的单词编号。  </p>
<p>拿这k个单词编号，去term_offset.bin对应的散列表中，查找每个单词编号在倒排索引文件中的偏移位置，得到k个偏移位置。  </p>
<p>拿这k个偏移位置，去倒排索引index.bin中，查找k个单词对应的包含它的网页编号列表，得到k个网页编号列表。  </p>
<p>针对k个网页编号列表，统计每个网页编号出现的次数。对统计结果，按照出现的次数的多少，从小到大排序。出现次数越多，说明包含越多的用户查询单词。  </p>
<p>经过这一系列查询，得到一组排好序的网页编号，拿着网页编号，去doc_id.bin文件中查找对应的网页链接，分页显示给用户。  </p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>计算网页权重PageRank算法<br>计算查询结果排名th-idf模型<br>搜索结果展示摘要信息和网页快照  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>搜索引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务接口鉴权限流</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/4%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3%E9%89%B4%E6%9D%83%E9%99%90%E6%B5%81/</url>
    <content><![CDATA[<p>服务治理，管理微服务，保证平台整体正常、平稳的运行。服务治理涉及鉴权、限流、降级、熔断、监控告警等。  </p>
<h3 id="鉴权"><a href="#鉴权" class="headerlink" title="鉴权"></a>鉴权</h3><p>不同的接口提供给不同的应用，并不是所有应用都可以访问该服务，也不是每个有访问权限的应用都可以访问该服务的所有接口。  </p>
<p>要实现接口鉴权功能，需要事先将应用对接口的访问权限规则设置好。当某个应用访问其中一个接口的时候，可以拿应用的请求URL，在规则中进行匹配。如果匹配成功，就说明允许访问；如果没有可以匹配的规则，那就说明这个应用没有这个接口的访问权限，就拒绝服务。  </p>
<p>接口格式格式：类似Dubbo的RPC接口，类似Spring Cloud的HTTP接口。  </p>
<h4 id="精确匹配规则"><a href="#精确匹配规则" class="headerlink" title="精确匹配规则"></a>精确匹配规则</h4><p>只有当请求URL跟规则中配置的某个接口精确匹配时，这个请求才会被接受、处理。  </p>
<p>不同的应用对应不同的规则集合。可以采用散列表来存储这种对应关系。<br>将每个应用对应的权限规则，存储在一个字符串数组中。当用户请求到来时，拿用户的请求URL，在这个字符串数组中逐一匹配，匹配的算法对应字符串匹配算法（KMP、BM、BF）。  </p>
<p>规则不会经常变动，可以按照字符串的大小给规则排序，把它组织成有序数组这种数据结构，加快匹配速度。当要查找某个URL能否匹配其中某条规则的时候，可以采用二分查找算法，在有序数组中进行匹配。  </p>
<h4 id="前缀匹配规则"><a href="#前缀匹配规则" class="headerlink" title="前缀匹配规则"></a>前缀匹配规则</h4><p>只要某条规则可以匹配请求URL的前缀，这个请求就可以被接受处理。  </p>
<p>不同的应用对应不同的规则集合。同样采用散列表来存储这种对应关系。<br>将每个应用的规则集合，组织成Trie树这种数据结构。Trie树非常适合用来做前缀匹配。Trie树中的每个节点不是存储单个字符，而是存储接口被“/”分割之后的子目录。  </p>
<p>规则并不会经常变动，在Trie树中，可以把每个节点的子节点门，组织成有序数组这种数据结构。当在匹配的过程中，可以利用二分查找算法，决定从一个节点应该跳到哪一个子节点。  </p>
<h4 id="模糊匹配规则"><a href="#模糊匹配规则" class="headerlink" title="模糊匹配规则"></a>模糊匹配规则</h4><p>规则中包含通配符（“**”匹配任意多个子目录，“*”匹配任意一个子目录），只要请求URL可以跟某条规则模糊匹配，就可以被接受处理。  </p>
<p>不同的应用对应不同的规则集合。依然采用散列表来存储这种对应关系。  </p>
<ul>
<li>借助正则表达式的解决思路，采用回溯算法，拿请求URL跟每条规则逐一进行模糊匹配。  </li>
<li>并不是每条规则都包含通配符，包含通配符的只是少数。把不包含通配符的规则和包含通配符的规则分开处理。<br>把不包含通配符的规则，组织成<strong>有序数组或者Trie树</strong>。剩下的少数包含通配符的规则，简单存储在一个<strong>普通数组</strong>中。<br>当接收到一个请求URL之后，可以先在不包含通配符的有序数组或者Trie树中查找。如果能够匹配，就不需要继续在通配符规则中匹配；如果不能匹配，就继续在通配符规则中查找匹配。  </li>
</ul>
<h3 id="限流1"><a href="#限流1" class="headerlink" title="限流1"></a>限流<a href="#refer-anchor-1"><sup>1</sup></a></h3><p><span id="back-1"></span><br>对接口调用的频率进行限制。例如每秒钟不能超过100次调用，超过之后就拒绝服务。  </p>
<p>按照不同的限流粒度，限流可以分为很多种类型。给每个接口限制不同的访问频率；给所有接口限制总的访问频率；限制某个应用对某个接口的访问频率等。  </p>
<h4 id="固定时间窗口限流算法"><a href="#固定时间窗口限流算法" class="headerlink" title="固定时间窗口限流算法"></a>固定时间窗口限流算法</h4><p>首先需要选定一个时间起点，之后每当有接口请求到来，就将计数器加一。如果在当前时间窗口内，根据限流规则，出现累加访问次数超过限流值的情况时，就拒绝后续的访问请求。当进入下一个时间窗口之后，计数器就清零重新计数。  </p>
<p>缺点：限流策略过于粗略，无法应对两个时间窗口临界时间内的突发流量。  </p>
<h4 id="滑动时间窗口限流算法"><a href="#滑动时间窗口限流算法" class="headerlink" title="滑动时间窗口限流算法"></a>滑动时间窗口限流算法</h4><p>限制任意时间窗口内，接口请求数都不能超过某个阈值。从流量曲线上来看会更加平滑。  </p>
<p>假设限流的规则为，在任意1s内，接口的请求次数都不能大于K次。就维护一个大小为K+1的循环队列，用来记录1s内到来的请求。（循环队列的大小等于限流次数加一，循环队列存储数据时浪费一个存储单元）  </p>
<p>当有新的请求到来时，将与这个新请求的时间间隔超过1s的请求，从队列中删除，然后再来开队列中是否有空闲位置，如果有，则把新请求存储在队列尾部（tail指针所指的位置）；如果没有，则说明这1s内的请求次数已经超多了限流值K，这个请求被拒绝服务。  </p>
<p>缺点：滑动时间窗口限流算法，依然不能防止，在细粒度上访问过于集中的问题。  </p>
<p>其他：</p>
<ul>
<li>维护成优先级队列（根据请求时间构建小顶堆），最早的请求时间放在堆顶。当有新的请求进来时相当于在小顶堆内插入数据，判断此时跟堆顶的时间差是否小于1s，并且堆的大小小于请求限制次数。每次插入数据时，删除1s外的数据，重新排序，确定新的堆顶。时间复杂度较高。  </li>
</ul>
<h4 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h4><p>基于时间窗口的限流算法，不管是固定时间窗口还是滑动时间窗口，只能在选定的时间粒度上限流，对选定时间粒度内的更加细粒度的访问频率不做限制。无法应对细时间粒度的突发流量。  </p>
<ol>
<li>接口限制t秒内最大访问次数为n，则每隔t/n秒会放一个token到桶中；  </li>
<li>桶中最多可以存放b个token，如果token到达时令牌桶已经满了，那么这个token会被丢弃；  </li>
<li>接口请求会先从令牌桶中取token，拿到token则处理接口请求，拿不到token则执行限流。  </li>
</ol>
<p>改进思路：</p>
<ul>
<li>预热桶  </li>
<li>一次性放入多个令牌<blockquote>
<p>不需要专门起一个线程每隔固定时间放token到桶中。每次在取token之前，根据上次放入token的时间戳和现在的时间戳，计算出这段时间需要放多少token进去，一次性放进去。  </p>
</blockquote>
</li>
<li>支持一次性取多个令牌</li>
</ul>
<p>缺点：对于没有预热的令牌桶，做否决式限流会导致误杀很多请求。间隔一定时间才向桶中放入一个令牌，但接口的访问在1s内的随机性很强。</p>
<h4 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h4><p>漏桶算法相当于令牌桶算法的改进。<br>对于取令牌的频率也有限制，要按照t/n固定的速度来取令牌。漏桶算法对流量的整形效果更加好，流量更佳平滑，任何突发流量都会被限流。  </p>
<h4 id="总结延伸"><a href="#总结延伸" class="headerlink" title="总结延伸"></a>总结延伸</h4><p>令牌桶和漏桶算法比较适合阻塞式限流，超过最大访问频率后，请求不会被拒绝，而是被阻塞到有令牌后再继续执行。<br>对相应时间比较敏感的限流场景（微服务），适合选择基于时间窗口的否决式限流算法。滑动时间窗口限流算法空间复杂度较高，内存占用较多。固定时间窗口算法适合微服务接口限流场景，简单、性能好、不易出错。  </p>
<div id="refer-anchor-1"></div>  

<p>[<a href="#back-1">1</a>] <a href="https://mp.weixin.qq.com/s?__biz=MzI4MTY5NTk4Ng==&mid=2247488993&amp;idx=1&amp;sn=4b9d5deedd0e626c456744f04b499bbb&source=41#wechat_redirect" target="_blank" rel="noopener">微服务接口限流的设计与思考</a>  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>鉴权</tag>
        <tag>限流</tag>
      </tags>
  </entry>
  <entry>
    <title>高性能队列Disruptor</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/3%E9%AB%98%E6%80%A7%E8%83%BD%E9%98%9F%E5%88%97Disruptor/</url>
    <content><![CDATA[<p>Disruptor是<strong>线程</strong>之间用于消息传递的队列。比另一种内存消息队列ArrayBlockingQueue性能高一个数量级。  </p>
<h3 id="基于循环队列的“生产者-消费者模型”"><a href="#基于循环队列的“生产者-消费者模型”" class="headerlink" title="基于循环队列的“生产者-消费者模型”"></a>基于循环队列的“生产者-消费者模型”</h3><p>生产者生产数据，并将数据放到一个中心存储容器中。<br>消费者从中心存储容器中，取出数据消费。  </p>
<p>实现中心存储容器最常用的数据结构是队列。队列支持数据的先进先出，使得数据被消费的顺序性可以得到保证，早被生产的数据就会早被消费。  </p>
<p>队列有两种实现思路：<br>基于链表实现的<strong>链式队列</strong>。  </p>
<blockquote>
<p><strong>无界队列</strong>，队列的大小事先不确定，理论上可以支持无线大。<br>基于数组实现的<strong>顺序队列</strong>。<br><strong>有界队列</strong>，队列的大小事先确定，当队列中数据满了之后，生产者就需要等待，直到消费者消费了数据，队列有空闲位置的时候，生产者才能将数据放入。<br><strong>循环队列</strong>，特殊的顺序队列。<br>非循环的顺序队列在添加、删除数据的工程中，会涉及数据的搬移操作，导致性能变差。  </p>
</blockquote>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        内存消息队列-循环队列
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long[] data;</span><br><span class="line">    <span class="keyword">private</span> in size = <span class="number">0</span>, head = <span class="number">0</span>, tail = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Queue</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = <span class="keyword">new</span> Long[size];</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Long element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((tail + <span class="number">1</span>) % size == head) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        data[tail] = element;</span><br><span class="line">        tail = (tail + <span class="number">1</span>) % size;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == tail) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">long</span> ret = data[head];</span><br><span class="line">        head = (head + <span class="number">1</span>) % size;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue queue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Queue queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">(<span class="keyword">long</span> data)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!queue.add(data)) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue queue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Queue queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            Long data = queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(data == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//<span class="doctag">TODO:</span>...消费数据的业务逻辑...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<h3 id="基于加锁的并发“生产者-消费者模型”"><a href="#基于加锁的并发“生产者-消费者模型”" class="headerlink" title="基于加锁的并发“生产者-消费者模型”"></a>基于加锁的并发“生产者-消费者模型”</h3><p>多个生产者并发往队列中写入数据，多个消费者并发从队列中消费数据。  </p>
<ul>
<li>多个生产者写入的数据可能会互相覆盖；  </li>
<li>多个消费者可能会读取重复的数据。  </li>
</ul>
<p>两个线程同时往队列中添加数据，相当于两个线程同时执行Queue中的add()函数。add函数中的操作并非原子操作。导致判断后插入数据时被覆盖。<br>消费时同理。  </p>
<p>简单处理方法：给代码加锁，同一时间只允许一个线程执行add()函数。加锁将并行改成串行，导致多个生产者同时生产数据的时候执行效率下降。  </p>
<p>优化处理方法：CAS(compare and swap，比较并交换)，减少加锁的粒度。  </p>
<h3 id="基于无锁的并发“生产者-消费者模型”"><a href="#基于无锁的并发“生产者-消费者模型”" class="headerlink" title="基于无锁的并发“生产者-消费者模型”"></a>基于无锁的并发“生产者-消费者模型”</h3><p>Disruptor采用的是RingBuffer和AvailableBuffer这两个结构实现并发的“生产者-消费者模型”。  </p>
<p>对生产者来说，它往队列中添加数据之前，先申请可用空闲存储单元，并且是批量地申请连续的n个（n&gt;=1）存储单元。当申请到这组连续的存储单元之后，后续往队列中添加元素，就可以不用加锁了，因为这组存储单元是这个线程独享的。不过，申请存储单元的过程是需要加锁的。  </p>
<p>对消费者来说，先去申请一批连续可读的存储单元（这个申请的过程也是需要加锁的），当申请到这批存储单元之后，后续的读取操作就可以不用加锁了。  </p>
<p>如果生产者A申请到了一组连续的存储单元，假设是下标为3-6的存储单元，生产者B紧跟着申请到了下标7-9的存储单元，在3-6没有完全写入数据之前，7-9的数据是无法读取的。  </p>
<p>常见的内存队列通常采用循环队列来实现。<br>Disruptor采用两阶段写入的方法解决并发产生的问题。在写入数据之前，先加锁申请批量的空闲存储单元，之后往队列中写入数据的操作就不需要加锁了，写入的性能提高。在消费数据之前，先加锁申请批量的可读取的存储单元，之后从队列中读取数据的操作也就不需要加锁了，读取的性能提高。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Disruptor</tag>
      </tags>
  </entry>
  <entry>
    <title>开发实践</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h3 id="时间、空间复杂度不能跟性能划等号"><a href="#时间、空间复杂度不能跟性能划等号" class="headerlink" title="时间、空间复杂度不能跟性能划等号"></a>时间、空间复杂度不能跟性能划等号</h3><p>在实际的软件开发中，复杂度不能与性能简单划等号，不能表示执行时间和内存消耗的确切数据量。  </p>
<ul>
<li><p>复杂度不是执行时间和内存消耗的精确值<br>  在用大O表示法表示复杂度的时候，会忽略掉低阶、常数、系数，只保留高阶，并且它的度量单位是语句的执行频度。每条语句的执行时间，并非是相同、确定的。复杂度给出的只能是一个非精确度量值的趋势</p>
</li>
<li><p>代码的执行时间有时不跟时间复杂度成正比<br>  对于小规模数据的处理，算法的执行效率并不一定跟时间复杂度成正比，有时还会跟复杂度成正比。  </p>
</li>
<li><p>对于处理不同问题的不同算法，其复杂度大小没有可比性<br>  复杂度只能用来表征不同算法，在处理同样的问题，以及同样数据类型的情况下的性能表现。对于不同的问题、不同的数据类型，不同算法之间的复杂度大小并没有可比性。  </p>
</li>
</ul>
<h3 id="抛开数据规模谈数据结构和算法都是“耍流氓”"><a href="#抛开数据规模谈数据结构和算法都是“耍流氓”" class="headerlink" title="抛开数据规模谈数据结构和算法都是“耍流氓”"></a>抛开数据规模谈数据结构和算法都是“耍流氓”</h3><p>在数据规模很小的情况下，普通算法和高级算法之间的性能差距会非常小。如果代码执行频率不高，又不是核心代码，这个时候，选择数据结构和算法的主要依据是，其是否简单、容易维护、容易实现。大部分情况下，直接用最简单的存储结构和最暴力的算法就可以了。<br>小数据规模，对于处理时间是毫秒量级敏感的系统来说，高级算法的性能提升并不大，反而会陡增编码的难度，还容易产生bug。  </p>
<h3 id="结合数据特征和访问方式来选择数据结构"><a href="#结合数据特征和访问方式来选择数据结构" class="headerlink" title="结合数据特征和访问方式来选择数据结构"></a>结合数据特征和访问方式来选择数据结构</h3><p>最考验能力的并不是数据结构和算法本身，而是对问题需求的挖掘、抽象、建模。如何将一个背景复杂、开放的问题，通过细致的观察、调研、假设，理清楚要处理数据的特征与访问方式，才是解决问题的重点。将问题转化成合理的数据结构模型，进而找到满足需求的算法。  </p>
<h3 id="区别对待IO密集、内存密集和计算密集"><a href="#区别对待IO密集、内存密集和计算密集" class="headerlink" title="区别对待IO密集、内存密集和计算密集"></a>区别对待IO密集、内存密集和计算密集</h3><p>如果要处理的数据存储在磁盘，那代码的性能瓶颈有可能在磁盘IO，而非算法本身，需要合理的选择数据存储格式和存取方式，减少磁盘IO的次数。  </p>
<p>数据存储在内存中，需要考虑代码时内存密集型的还是CPU密集型的。<br>CPU密集型，从内存中读取一次数据，到CPU缓存或者寄存器之后，会进行多次频繁的CPU计算，CPU计算耗时占大部分。在选择数据结构和算法的时候，要尽量减少逻辑计算的复杂度 ，用位运算道题加减乘除运算。<br>内存密集型，计算比较简单，每次从内存中读取数据之后，只需要进行一次简单的比较操作。内存数据的读取速度，是比较操作的瓶颈。在选择数据结构和算法的时候，要考虑是否能减少数据的读取量，数据是否在内存中连续存储，是否能利用CPU缓存预读。  </p>
<h3 id="善用语言提供的类，避免重复造轮子"><a href="#善用语言提供的类，避免重复造轮子" class="headerlink" title="善用语言提供的类，避免重复造轮子"></a>善用语言提供的类，避免重复造轮子</h3><p>对于大部分常用的数据结构和算法，编程语言都提供了现成的类和函数实现。Java中，HashMap—散列表；TreeMap—红黑树。  </p>
<p>编程语言提供的类和函数，都是经过无数验证付的，不管是正确性、健壮性。  </p>
<h3 id="千万不要漫无目的地过度优化"><a href="#千万不要漫无目的地过度优化" class="headerlink" title="千万不要漫无目的地过度优化"></a>千万不要漫无目的地过度优化</h3><p>对普通情况下的数据规模和性能压力做估算，同时对异常以及将来一段时间内，可能达到的数据规模和性能压力做估算。<br>优化代码时，先做基准测试，避免想当然的换了更高效的算法，但真实情况下，性能反倒下降。  </p>
<img src="/img/数据结构与算法图谱.jpg">

<img src="/img/数据结构与算法学习路线.png"><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>短网址系统</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/5%E7%9F%AD%E7%BD%91%E5%9D%80%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>短网址服务的核心功能，就是把原始的长网址转化成短网址；当用户点击短网址的时候，短网址服务会将浏览器重定向为原始网址。  </p>
<h3 id="哈希算法生成短网址"><a href="#哈希算法生成短网址" class="headerlink" title="哈希算法生成短网址"></a>哈希算法生成短网址</h3><p>哈希算法可以将一个不管多长的字符串，转化成一个长度固定的哈希值。<br>生成短网址，不需要考虑反向解密的难度，只需要关心哈希算法的计算速度和冲突概率。  </p>
<p>MurmurHash算法提供了两种长度的哈希值，一种是32bits，一种是128bits。对原始网址进行hash计算之后，得到的哈希值再品尚短网址服务的域名，就构成最终的短网址。  </p>
<h4 id="让短网址更短"><a href="#让短网址更短" class="headerlink" title="让短网址更短"></a>让短网址更短</h4><p>将10进制的哈希值，转化成更高进制的哈希值。<br>16进制中，用A~E来表示10~15。在网址URL中，常用的合法字符有0~9、a~z、A~Z这样62个字符。so将10进制的哈希值转化成62进制。（10进制除以62取余，余数相应字符）  </p>
<h4 id="解决哈希冲突问题"><a href="#解决哈希冲突问题" class="headerlink" title="解决哈希冲突问题"></a>解决哈希冲突问题</h4><p>一般情况下，保存短网址跟原始网址之间的对应关系（数据库），以便后续用户在访问短网址的时候，可以根据对应关系，查找到原始网址。  </p>
<p>当有一个新的原始网址需要生成短网址的时候，先利用MurmurHash算法生成短网址，然后拿生成的短网址在数据库中查找。如果没有找到相同的短网址，表明此短网址没有冲突，将对应关系存到数据库，并将短网址返回给用户。  </p>
<p>如果在数据库中找到了相同的短网址，将其对应的原始网址也取出来，跟正在处理的原始网址对比，相同则直接用；若不同则说明发生哈希冲突。<br>给原始网址拼接一串特殊的字符（DUPLICATED），重新计算哈希值，极端情况再次出现冲突就继续拼接字符串。最终把哈希值和原始网址拼接了特殊字符串之后的文本分别存在数据库中。  </p>
<p>当用户访问短网址的时候，短网址服务先通过短网址在数据库中查找对应的原始网址。如果原始网址中有凭借特殊字符，就先将特殊字符去掉再返回给浏览器。  </p>
<h4 id="优化哈希算法性能"><a href="#优化哈希算法性能" class="headerlink" title="优化哈希算法性能"></a>优化哈希算法性能</h4><p>给<strong>短网址字段添加B+树索引</strong>。提高通过短网址查询原始网址的速度。  </p>
<p>在短网址生成的过程中，会跟数据库打两次交到，执行两条SQL语句。<br>通过短网址查询短网址与原始网址的对应关系；将新生成的短网址和原始网址之间的对应关系存储到数据库。<br>给数据库中的<strong>短网址字段添加唯一索引</strong>。当有新的原始网址需要生成短网址时，直接将生成的短网址与对应的原始网址尝试存储到数据库中。如果数据库能将数据正常写入，则说明没有违反唯一索引，新生成的短网址没有冲突。如果范围违反唯一索引异常，则按正常的“查询-写入过程”。  </p>
<p>将已经生成的<strong>短网址构建成布隆过滤器</strong>。当有新的短网址生成的时候，先拿短网址在布隆过滤器中查找。如果查找的结果是不存在的，说明没有冲突，只需要执行写入的SQL语句。  </p>
<h3 id="ID生成器生成短网址"><a href="#ID生成器生成短网址" class="headerlink" title="ID生成器生成短网址"></a>ID生成器生成短网址</h3><p>维护一个ID自增生成器，可以生成自增的整数ID。当短网址服务接收到一个原始网址转化成短网址的请求之后，它先从ID生成器中取一个号码，然后将其转化成62进制表示法，拼接到短网址服务的域名后面，就形成了最终的短网址。最后将生成的短网址和对应的原始网址存储到数据库中。  </p>
<h4 id="相同的原始网址可能会对应不同的短网址"><a href="#相同的原始网址可能会对应不同的短网址" class="headerlink" title="相同的原始网址可能会对应不同的短网址"></a>相同的原始网址可能会对应不同的短网址</h4><p>每次新来一个原始网址，就生成一个新的短网址，会导致两个相同的原始网址生成了不同的短网址。解决方案：  </p>
<ul>
<li><p>不做处理。相同的原始网址对应不同的短网址，可以接受。大部分短网址的应用场景中，用户只关心短网址能否正确的跳转到原始网址，并不关心短网址长什么样。同一个原始网址，两次生成的短网址不一样，并不会影响到用户的使用。  </p>
</li>
<li><p>借助哈希算法生成短网址的处理思想。要给一个原始网址生成短网址的时候，先拿原始网址在数据库中查找，看数据库中是否已经存在相同的原始网址。若存在就取出对应的短网址，直接返回给用户。  </p>
<blockquote>
<p>需要给数据库中的短网址和原始网址两个字段都添加索引。</p>
</blockquote>
</li>
</ul>
<h4 id="高性能ID生成器"><a href="#高性能ID生成器" class="headerlink" title="高性能ID生成器"></a>高性能ID生成器</h4><p>低性能：数据库自增字段、计数器等。  </p>
<p>高性能：</p>
<ul>
<li><p>借助Disruptor的思想，给ID生成器装多个前置发号器。批量的给每个前置发号器发送ID号码。当接收到短网址生成请求时，就选择一个前置发号器来取号码，通过多个前置发号器，提高并发发号能力。  </p>
</li>
<li><p>实现多个ID生成器同时服务。为了保证每个ID生成器生成的ID不重复。要求每个ID生成器按照一定的规则，生成ID号码。（第一个ID生成器只能生成尾号为0的ID，第二个只能生成尾号为1的ID，以此类推）。</p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>MurmurHash</tag>
        <tag>短网址</tag>
      </tags>
  </entry>
  <entry>
    <title>日志系统</title>
    <url>/MySQL/2%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>更新语句的执行链路与查询语句类似。多两个日志模块：redo log(重做日志)和binlog(归档日志)。  </p>
<h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><ul>
<li>每一次的更新操作都要写进磁盘，磁盘需要找到对应的那条记录，然后再更新，IO成本、查找成本高。  </li>
<li>WAL技术(Write-Ahead Logging)，先写日志并更新内存（同时），再写磁盘。<blockquote>
<p>将磁盘随机写变成顺序写，避免了数据的随机写。并且可以组提交(合并写)。  </p>
</blockquote>
</li>
</ul>
<p>当有一条记录需要更新的时候，InnoDB引擎先把记录写到redo log里面，并更新数据内存(同时)。InnoDB引擎会在适当的时候(系统比较空闲的时候)，将这个操作记录更新到磁盘中（落盘前的其他查询直接从内存返回最新数据）。  </p>
<blockquote>
<p>数据库更新操作基于内存页，默认大小16K，更新时不直接更新磁盘，内存中存在就直接更新内存页，不存在就从磁盘再取到内存，再更新内存。  </p>
</blockquote>
<img src="/img/MySQL redo log结构图.png">

<p>InnoDB的redo log大小固定，可配置为一组4个文件，每个文件的大小是1G，总共可以记录4GB的操作。从头开始写，写到末尾就又回到开头循环写(环形)。</p>
<p>write pos是当前记录的位置，一边写一边后移，写到3号文件末尾后回到0号文件开头。<br>checkpoint是当前要擦除的位置，往后推移并循环，擦除记录前要把记录更新到数据文件。  </p>
<p>write pos与checkpoint之间的部分空余，用来记录新的操作。如果write pos追上checkpoint，不能再执行新的更新。  </p>
<p>InnoDB通过redo log保证数据库发生异常重启时，之前提交的记录不会丢失。<strong>crash-safe</strong>能力。<br>redo log保证了事务ACID。  </p>
<h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><p>Server层，负责功能层面的事情；引擎层，负责存储相关的事情。<br>redo log是InnoDB引擎特有的日志，Server层的日志称为binlog(归档日志)。  </p>
<p>不同点：  </p>
<ul>
<li>redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。  </li>
<li>redo log是物理日志，记录的是“在某个数据页上作了什么修改”，只能独享；binlog是逻辑日志，记录的是语句的原始逻辑，可以共享(其他数据库，其他引擎)，比如“给ID=2的行的C字段加1”。  <blockquote>
<p>redo log记录这个页“做了什么改动”；binlog两种模式：<strong>statement格式记录sql语句、row格式记录行的内容</strong>(两条：更新前&amp;更新后)。  </p>
</blockquote>
</li>
<li>redo log是循环写的，空间固定会用完；binlog是可以追加写入的。binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。记录所有的逻辑操作。  <blockquote>
<p>set sql_log_bin=0;关闭本线程的binlog日志，只依赖binlog恢复数据不可靠。  </p>
</blockquote>
</li>
</ul>
<p>update语句执行流程：  </p>
<ul>
<li><strong>执行器先找引擎取ID=2这一行</strong>，ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。  </li>
<li><strong>执行器拿到引擎给的行数据，把这个值加1，得到新的一行数据，调用引擎接口写入这行新数据。</strong>  </li>
<li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log中，此时redo log处于prepare状态，然后告知执行器执行完成，随时可以提交事务。  </li>
<li><strong>执行器生成这个操作的binlog，并把binlog写入磁盘</strong>。  </li>
<li><strong>执行器调用引擎的提交事务接口</strong>，引擎把写入的redo log改成commit(提交)状态，更新完成。  <blockquote>
<p>prepare写日志的最后一个512字节，会在commit时被改掉，不是追加写。<br>update语句执行流程，将redo log的写入拆成了两个步骤：prepare和commit。<strong>两阶段提交</strong>。  </p>
</blockquote>
</li>
</ul>
<h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p>两阶段提交，保证两份日志之间的逻辑一致。  </p>
<blockquote>
<p>redo log和binlog都可以用于表示事务的提交状态，两阶段提交让这两个状态保持逻辑上的一致。  </p>
</blockquote>
<p>两阶段提交也是跨系统维持数据逻辑一致性时常用的一个方案。  </p>
<p><strong>恢复数据</strong>：  </p>
<ul>
<li>找到最近一次全量备份，从这个备份恢复到临时库。  </li>
<li>从备份的时间点开始，将备份的binlog依次取出来，重放到指定时刻。  </li>
</ul>
<blockquote>
<p>崩溃恢复时，接受“redo log prepare并且binlog完整的情况。”。一个事务的完整binlog有固定的格式—固定的结尾。<br>如果redo log是完整的包含prepare和commit，直接认为成功，恢复时不需要去判断binlog。(binlog写失败时，让innoDB引擎给 该事务打上rollback标签，不用回滚日志。)  </p>
</blockquote>
<p>假设当前ID=2的行，字段c的值是0，执行update语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了crash。  </p>
<ol>
<li><p>先写redo log后写binlog。<br> redo log写完之后，系统即使崩溃，仍然能够把数据恢复回来，恢复后这一行c的值是1。<br> 由于binlog没写完，没有记录这个update语句，如果需要用到binlog恢复临时库时，临时库就少了这一次更新，恢复出来的这一行c的是0，与原库的值不同。  </p>
</li>
<li><p>先写binlog后写redo log。<br> binlog写完之后crash，redo log还没写完，崩溃恢复之后这个事务无效，这一行的值是0。<br> 由于binlog中已经有update语句记录，之后用binlog恢复时多了一个事务，恢复出来的这一行c的值是1，与原库的值不同。  </p>
</li>
</ol>
<p><strong>备份/扩容</strong>：<br>使用两阶段提交，保证数据库的状态和用它的日志恢复出来的库的状态一致。扩容时可以使用全量备份加上binlog来实现。  </p>
<p><strong>对比</strong>：<br>redo log的crash-safe是崩溃恢复；binlog恢复制造副本。<br>redo log循环使用，会被覆盖，数据不全，不能用作备份、同步等。<br>binlog恢复不了，WAL机制中“已经提交但是还没落盘”的数据。没有crash-safe能力。  </p>
<blockquote>
<p>innodb_flush_log_at_trx_commit=1;（默认值）表示每次事务提交时，redo log都直接持久化到磁盘。<br>innodb_flush_log_at_trx_commit=2;表示每次事务提交都写redo log文件，但是没有持久化，由系统来进行fsync操作。如果数据库宕机，不会丢失redo log；如果服务器宕机，文件系统的缓存还没同步到磁盘中的数据丢失。<br><strong>redolog buffer在事务执行过程中，先把要写的内容在内存中存起来，在commit阶段，一次性写入redolog file。</strong><br>commit时确保redo log持久化到磁盘。  </p>
</blockquote>
<blockquote>
<p>sync_binlog=1;表示每次事务的binlog都持久化到磁盘。N表示事物提交次数。<br>sync_binlog=0;（默认值）由文件系统控制缓存的刷新，系统crash会丢失部分数据。  </p>
</blockquote>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>基础架构</title>
    <url>/MySQL/1%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<img src="/img/MySQL逻辑架构图.png">

<p>MySQL可以分为Server层(连接、鉴权、计算)和存储引擎层(读写、存取数据)两部分。  </p>
<h2 id="Server层"><a href="#Server层" class="headerlink" title="Server层"></a>Server层</h2><p>涵盖MySQL的大多数核心服务功能，以及所有的内置函数（日期、时间、数学、加密），所有跨存储引擎的功能（存储过程、触发器、视图）。  </p>
<h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>管理连接，权限验证  </p>
<p>负责跟客户建立连接、获取权限(从权限表中获取并保存在变量中，供后续查询缓存、优化器、执行器等阶段权限校验时使用)、维持和管理连接。  </p>
<blockquote>
<p>mysql -h$ip -P$port -u$user -p  </p>
</blockquote>
<p>一个用户成功建立连接后，即使用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。只有新建的链接才会使用新的权限设置。  </p>
<blockquote>
<p>show processlist命令可查看当前存在的各连接列表及状态  </p>
</blockquote>
<p>客户端长时间没动静(wait_timeout默认8小时)，连接器会自动断开。  </p>
<blockquote>
<p>wait_timeout是非交互式连接的空闲超时，interactive_timeout是交互式连接的空闲超时。执行时间不计入空闲时间。<br>connect_timeout是连接过程中的等待时间，wait_timeout是连接完成后，使用过程中的等待时间。  </p>
</blockquote>
<p>长连接：连接成功后，客户端持续有请求则一直使用同一个链接。<br>短连接：每次执行完很少的几次查询就断开链接，下次查询再重新建立一个。  </p>
<blockquote>
<p>衡量标准，一次连接持续期内，执行了多少个sql语句。  </p>
</blockquote>
<p>MySQL在执行过程中临时使用的内存是管理在连接对象里面的(大量数据排序、变量、复杂存储过程等)，资源在连接断开时才释放。容易导致OOM。  </p>
<ul>
<li>定期断开长连接。  </li>
<li>执行mysql_reset_connection(为编程语言提供的api，不是sql语句)重新初始化当前链接资源(MySQL5.7以上)，不需要重连和重新做权限验证。  </li>
</ul>
<h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p>一种数据结构<br>命中则直接返回结果(MySQL8.0以上该功能删除)  </p>
<p>MySQL拿到查询请求，先到查询缓存查看是否执行过。之前执行过的语句及其结果以key-value对的形式缓存在内存中。若有则直接返回给客户端。  </p>
<p>查询缓存失效太频繁，对表的更新，会清空该表上所有的查询缓存。只适用于静态表(如系统配置表)。  </p>
<blockquote>
<p>query_cache_type=DEMAND不使用查询缓存。(或者query_cache_size=0)。<br>query_cache_limit单个结果集的大小上限；总量上限query_cache。<br>select SQL_CACHE * from test;显式指定该SQL使用查询缓存。  </p>
</blockquote>
<h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><p>词法分析，语法分析<br>解决做什么的问题  </p>
<p>词法分析：识别SQL语句中的字符串及其代表意义。(关键字验证和解析，查询语句/更新语句/删除语句；表名和字段名验证和解析，此处没有打开表，从information schema中直接读取，不需要打开表)。  </p>
<p>语法分析：依据语法规则，根据词法分析的结果，判断输入的SQL是否满足MySQL语法。  </p>
<blockquote>
<p>You have an error in your SQL syntax;//错误时提示  </p>
</blockquote>
<h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>执行计划生成，索引选择<br>解决怎么做的问题  </p>
<p>多个索引决定使用哪个索引；多表连接决定各个表的连接顺序等。(同一条SQL多次执行，不会重用优化策略，每次都要重新优化)  </p>
<blockquote>
<p>扩展 index_merge(先筛选再join连接，MySQL暂不支持跨表)</p>
</blockquote>
<h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>操作引擎，返回结果  </p>
<p>先判断用户对表的执行权限（命中查询缓存，返回结果时做权限验证；优化器前调用precheck验证权限；涉及触发器权限，只有在执行阶段才知道有哪些触发器）<br>无权限返回没有权限错误；有权限<strong>打开表</strong>(读取表的定义，获取表的结构)获取数据继续执行，根据表的引擎定义，使用对应引擎提供的接口。  </p>
<ul>
<li>调用InnoDB引擎接口取表的第一行，判断where条件中对应字段的值是不是符合，不是则跳过，是则将该行存在结果集中；  </li>
<li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到该表的最后一行；  </li>
<li>执行器将上述遍历过程中所有满足条件的行组成记录集作为结果集返回给客户端，并写入查询缓存。  <blockquote>
<p>存储引擎在找到一行合适的数据后，先返回给server层处理，server层处理完再读下一个。<br>对于使用索引的表，第一次调用“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”接口。  </p>
</blockquote>
</li>
</ul>
<p>数据库慢查询日志rows_examined字段，表示语句执行过程中扫描了多少行。执行器每次调用引擎获取数据行的时候累加。(同步调用)<br>执行器调用一次，在引擎内部可能扫描多行，引擎扫描行数跟rows_examined并不完全相同。  </p>
<h2 id="存储引擎层"><a href="#存储引擎层" class="headerlink" title="存储引擎层"></a>存储引擎层</h2><p>插件式的架构模式，负责数据的存储和提取。<br>不同的存储引擎共用一个Server层（从连接器到执行器部分）。  </p>
<h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>MySQL5.5.5以上默认存储引擎。<br>buffer_pool</p>
<h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>事务隔离</title>
    <url>/MySQL/3%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/</url>
    <content><![CDATA[<p>事务保证一组数据库操作，要么全部成功，要么全部失败。<br>MySQL中，事务支持是在引擎层实现的。InnoDB引擎支持事务。<br>ACID(Atomicity原子性、Consistency一致性、Isolation隔离性、Durability持久性)  </p>
<h3 id="隔离性与隔离级别"><a href="#隔离性与隔离级别" class="headerlink" title="隔离性与隔离级别"></a>隔离性与隔离级别</h3><p>解决数据库上多个事务同时执行的时候，可能出现的脏读direty read、不可重复读non-repeatable read、幻读phantom read问题。  </p>
<p>SQL标准的事务隔离级别：<br>并行性能依次降低，安全性依次提高。  </p>
<ul>
<li>读未提交read uncommitted  <blockquote>
<p>一个事务还没提交时，它做的变更就能被别的事务看到。  </p>
</blockquote>
</li>
<li>读提交read committed  <blockquote>
<p>一个事务提交之后，它做的变更才会被其他事务看到。  </p>
</blockquote>
</li>
<li>可重复读repeatable read  <blockquote>
<p>一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的（事务在执行期间看到的数据前后是一致的）。未提交的变更对其他事务也是不可见的。<strong>事务启动时的视图想当于是静态的，不受其他事务的影响</strong>。  </p>
</blockquote>
</li>
<li>串行化serializable.  <blockquote>
<p>对于同一行记录，写会加写锁，读会加读锁。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。  </p>
</blockquote>
</li>
</ul>
<p>具体实现，数据库会创建一个视图，访问的时候以视图的逻辑结果为准。（建立视图没什么成本的，就是拷贝一个事务数组）<br><strong>视图的创建时间和并发事务的开始时间没关系，和事务首次read的时间有关；</strong>  </p>
<blockquote>
<p>RR下，事务在第一个Read操作时，会建立Read View<br>RC下，事务在每次Read操作时，都会建立Read View<br>在可重复读隔离级别下，这个视图<del>是在事务启动时创建的</del>(实际是<strong>在事务内第一次查询时</strong>被创建)，整个事务存在期间都用这个视图。<br>在读提交隔离级别下，这个视图是在每个<strong>SQL语句开始执行的时候</strong>创建的。<br>读未提交隔离级别下，直接返回记录上的最新值，没有视图概念。<br>串行化隔离级别下，直接用加锁的方式来避免并行访问。  </p>
</blockquote>
<p>Oracle数据库的默认隔离级别是“读提交”。<br>transaction-isolation=READ-COMMITTED。<br>MySQL数据库的默认隔离级别是“可重复度”。<br>transaction-isolation=repeatable-read。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看事务命令，MySQL5.7引入替换tx_isolqtion</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'transaction_isolation'</span>;</span><br></pre></td></tr></table></figure>

<h3 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h3><p>以可重复读为例  </p>
<p>在MySQL中，每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。  </p>
<p>一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录。<br><img src="/img/MySQL回滚日志与事务视图.png"></p>
<p>同一条记录在系统中可以存在多个版本—数据库的<strong>多版本并发控制MVCC</strong>。<br>某一时刻的视图中，要得到它的值，就必须将当前值倒序依次执行该时刻视图之后的各个回滚操作得到（read_view不存数据的值。视图数据也会变动，值不是物理存在的，为了得到视图A,需要执行回滚操作才能得到）。<br>即使当前有另一个事务在改当前值，这个事务跟原视图中对应的事务也不会冲突。  </p>
<p>表结构不在一致性视图的保护里面。  </p>
<hr>
<p>回滚日志在不需要的时候才删除。系统会判断，当没有事务再需要用到这些回滚日志时(当系统里没有比这个回滚日志更早的read-view的时候—更早启动的事务)，回滚日志会被删除（不是完全删除？）。（回滚日志在事务执行期间都会保留，事务提交后就无法回滚了）<br>对于在同一个事务里对同一个字段进行了多次修改，相应的回滚日志是记录多条。  </p>
<p>尽量不要使用长事务。长事务意味着系统里面会存在很老的事务视图。这些事务随时可能访问数据库里面的任何数据，在这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，就会导致大量占用存储空间。(回滚日志跟数据字典一起放在ibdata文件中(MySQL5.5之前版本)，即使长事务最终提交，回滚段被清理(逻辑上这些文件位置可以复用，但是并没有删除文件)，文件也不会变小。)<br>长事务占用锁资源，也可能会拖垮整个库。  </p>
<h3 id="事务的启动方式"><a href="#事务的启动方式" class="headerlink" title="事务的启动方式"></a>事务的启动方式</h3><p>数据库有默认的隔离级别，但是只针对单条语句。<br>多个语句要作为一个原子逻辑需要开启事务。  </p>
<ol>
<li>set autocommit=1，begin/start transaction显示的启动事务，commit提交，rollback回滚。  </li>
</ol>
<blockquote>
<p>autocommit=1的情况下，用begin显式启动的事务，如果执行commit则提交事务。如果执行commit work and chain，则提交事务并自动启动下一个事务，省去了再次执行begin语句的开销。（如果 set autocommit=1;并且没有begin的话，一个语句执行完成后就会直接提交事务）另外begin不是事务启动， 之后第一个DML才是。  </p>
</blockquote>
<ol start="2">
<li>set autocommit=0，关闭当前线程的自动提交，但是自动开启。只要执行了一个select语句，事务就自动启动了，但不会自动提交，这个事务持续存在直到主动执行commit或rollback语句，或者断开链接。  </li>
</ol>
<blockquote>
<p>没有显式开启事务的情况下，每个sql的执行都是一个事务。(不用begin启动事务，但需要手动commit，否则连接保持着可能变成长事务。)  </p>
</blockquote>
<p>start transaction 和 begin语义上是一样的<br>start transaction WITH CONSISTENT SNAPSHOT 才是会直接创建read-view ，也就是快照。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 在information_schema库的innodb_trx表中查询长事务  </span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> information_schema.innodb_trx <span class="keyword">where</span> TIME_TO_SEC(<span class="keyword">timediff</span>(<span class="keyword">now</span>(),trx_started))&gt;<span class="number">60</span>;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>深入浅出索引</title>
    <url>/MySQL/4%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p><a href="/数据结构与算法/索引">数据结构与算法-索引</a></p>
<p>索引的出现是为了提高查询的效率，类似书的目录。对于数据库的表而言，索引就是它的目录。  </p>
<h3 id="索引的常见模型"><a href="#索引的常见模型" class="headerlink" title="索引的常见模型"></a>索引的常见模型</h3><p>哈希表、有序数组、搜索树。  </p>
<h4 id="哈希表-Memcached"><a href="#哈希表-Memcached" class="headerlink" title="哈希表-Memcached"></a>哈希表-Memcached</h4><p>哈希表是一种以键-值(key-value)存储数据的结构，只需要输入待查找的键，就可以找到其对应的值。把值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置。支持随机增删改查，key不是递增有序的，书序读取区间查找速度慢。  </p>
<p>多个key值经过哈希函数的换算，会出现同一个值的情况。哈希冲突，链表/开放寻址。</p>
<p><strong>哈希表适用于只有等值查询的场景。</strong>  </p>
<h4 id="有序数组"><a href="#有序数组" class="headerlink" title="有序数组"></a>有序数组</h4><p>数组按照id递增的顺序保存，在等值查询和范围查询场景中的性能都非常优秀用。二分查找可以快速找到指定id对应的数据时间复杂度为O(logn)。范围查询，先用二分法找到左区间开始位置，然后向后遍历即可。插入数据必须挪动后面所有的记录，成本贵太高。  </p>
<p><strong>有序数组使用于静态存储引擎。</strong>  </p>
<h4 id="二叉搜索树-MySQL"><a href="#二叉搜索树-MySQL" class="headerlink" title="二叉搜索树-MySQL"></a>二叉搜索树-MySQL</h4><p>每个节点的左儿子小于父节点，父节点又小于右儿子。查找指定id对应的数据的时间复杂度为o(logn)。为了维持O(logn)的查询复杂度，需要保持树是平衡二叉树，更新的时间复杂度为O(logn)。  </p>
<p>二叉树，大数据量树高过高，会产生多次磁盘IO。<br>扩展为N叉树，<strong>N叉树中的N取决于数据块的大小。</strong><br>树高取决于叶子树（数据行数）和“N叉树”的N。 而N是由页大小和索引大小决定的。</p>
<blockquote>
<p>N叉树N的值。5.6以后可以通过page的大小（默认16KB）来间接控制。<br>（键为整型4个字节（长整形8个字节）时，加上辅助数据（指针固定6个字节）及其他，差不多每个键key占13字节，16KB/13B，非叶子节点能存储1200个建，1200叉树）  </p>
</blockquote>
<p><strong>N叉树读写性能优良，适配磁盘的访问模式，广泛应用于数据库引擎。</strong>  </p>
<blockquote>
<p>B+树支持顺序扫描。能够很好的配合磁盘的读写特性（局部性原则-缓存），减少单次查询的磁盘访问次数。树根的数据块存储在内存中(少一次磁盘IO)。  </p>
</blockquote>
<p><a href="/数据结构与算法/B+树">数据结构与算法-B+树</a></p>
<h4 id="跳表-Redis"><a href="#跳表-Redis" class="headerlink" title="跳表-Redis"></a>跳表-Redis</h4><p><a href="/数据结构与算法/跳表">数据结构与算法-跳表</a></p>
<h4 id="LSM树-HBase"><a href="#LSM树-HBase" class="headerlink" title="LSM树-HBase"></a>LSM树-HBase</h4><p>牺牲读性能，提高写性能。<br>LSM(Log Structured Merge Tree)将磁盘随机写转化为顺序写。把一棵大树拆分成N棵小树，将对数据的修改增量保存在内存中，达到指定大小限制后批量把数据flush到磁盘中，磁盘中定期做merge操作，合并成一棵大树，以优化读性能。  </p>
<h3 id="InnoDB的索引模型"><a href="#InnoDB的索引模型" class="headerlink" title="InnoDB的索引模型"></a>InnoDB的索引模型</h3><p>在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为<strong>索引组织表</strong>。InnoDB使用了B+树索引模型，数据都是存储在B+树中的（有序）。（树中的节点并不存储数据本身，而是只是作为索引。叶子节点存储数据，把每个叶子节点串在一条链表上，链表中的数据是从小到大有序的。）  </p>
<blockquote>
<p>B+树的每个节点都是一页，最上层的根节点单独一页。<br><strong>B+树的叶子节点存储的是page(页，默认大小16k)，一个页里面可以存多个行。</strong><br>索引只能定位到page，page内部有个有序数组，二分法定位行数据。  </p>
</blockquote>
<p>每一个索引在InnoDB里面对应一棵B+树。一张表可以有多个索引。  </p>
<hr>
<p>根据叶子节点的内容，索引类型分为<strong>主键索引</strong>和<strong>非主键索引</strong>。  </p>
<h4 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h4><p>主键索引的叶子节点value存的是整行数据（一页16K，可以存多行。整张表的数据其实存在主键索引中。是数据不是地址）。在InnoDB里，主键索引也被称为<strong>聚簇索引</strong>(clustered index)。  </p>
<blockquote>
<p>主键查询方式，只需要搜索主键对应的B+树，就可以获得数据。(树节点的key是某行主键，value是该行数据。)  </p>
</blockquote>
<h4 id="非主键索引"><a href="#非主键索引" class="headerlink" title="非主键索引"></a>非主键索引</h4><p>非主键索引的叶子节点内容是主键的值（每个叶子节点是一个数据页，每个数据页16K,存放多个主键值）。在InnoDB里，非主键索引也被称为<strong>二级索引</strong>(secondary index)。  </p>
<blockquote>
<p>普通索引查询方式，需要先搜索普通索引树，得到主键的值，再到主键索引树搜索一次。这个过程称为<strong>回表</strong>。(基于非主键索引的查询多扫描一棵索引树，每条查出的数据都要分别回表。当然只需要主键的值，就不需要回表)  </p>
</blockquote>
<p>InnoDB会把主键字段放在普通索引字段后面，同时会去重。(二级索引中的主键会依次进行排序)  </p>
<blockquote>
<p>当主键是(a,b)的时候，<br>定义为c的索引，实际上是(c,a,b);<br>定义为(c,a)的索引，实际上是(c,a,a,b)–&gt;(c,a,b);<br>定义为(c,b)的索引，实际上是(c,b,a,b)–&gt;(c,b,a);– 回表时自动交换a,b列来查找对应的主键值  </p>
</blockquote>
<h3 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h3><h4 id="页分裂"><a href="#页分裂" class="headerlink" title="页分裂"></a>页分裂</h4><p>B+树为了维护索引有序性，在插入新值的时候需要做必要的维护—移动数据(追加新增递增插入时，不需要移动数据，不会页分裂)。如果原来所在的数据页已经满了，根据B+树的算法，需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为<strong>页分裂</strong>。（每个页面之间是用指针串的。分裂时只需要改指针指向。）  </p>
<p>页分裂操作不仅影响性能，还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约50%。  </p>
<h4 id="页合并"><a href="#页合并" class="headerlink" title="页合并"></a>页合并</h4><p>当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。  </p>
<hr>
<p>没有主键的表，InnoDB会默认创建一个Rowid做主键。  </p>
<h4 id="自增主键"><a href="#自增主键" class="headerlink" title="自增主键"></a>自增主键</h4><p>自增主键的插入数据模式：插入新纪录的时候可以不指定ID的值，系统会获取当前ID最大值加1作为下一条记录的ID值。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。（一个页满了，就申请另外一个页面从左边开始写数据。）  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 自增主键是指自增列上定义的主键。主键天然是索引，不用显示指定index  </span></span><br><span class="line">not null primary key quto_increment</span><br></pre></td></tr></table></figure>

<h4 id="业务逻辑主键"><a href="#业务逻辑主键" class="headerlink" title="业务逻辑主键"></a>业务逻辑主键</h4><p>业务逻辑的字段做主键，不容易保证有序插入，写数据成本高。<br>每个非主键索引的叶子节点上都是主键的值。如果用业务逻辑字段做主键，叶子节点占用空间一般比整型（4字节）或长整型（8字节）自增主键占用的空间大。  </p>
<p>只有一个索引；该索引必须是唯一索引。适合用业务字段直接做主键。<br>典型的KV场景（没有range操作），由于没有其他索引，不用考虑其他索引的叶子节点大小的问题。利用尽量使用主键查询的原则，直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树。  </p>
<hr>
<p>索引可能因为删除、或者页分裂等原因，导致数据页有空洞，重建索引的过程会创建一个新的索引，把数据按顺序插入，这样页面利用率最高，索引更紧凑、更省空间。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 关键字index 与 key无区别</span></span><br><span class="line"><span class="comment">-- 删除并重建普通索引  </span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> T <span class="keyword">drop</span> <span class="keyword">index</span> k;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> T <span class="keyword">add</span> <span class="keyword">index</span>(k);</span><br><span class="line"><span class="comment">-- 删除重建主键索引  </span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> T <span class="keyword">drop</span> primary <span class="keyword">key</span>;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> T <span class="keyword">add</span> primary <span class="keyword">key</span>(<span class="keyword">id</span>);</span><br><span class="line"><span class="comment">-- 删除主键或者创建主键，都会将整个表重建，导致普通索引失效  </span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> T <span class="keyword">engine</span> = <span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>

<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>回到主键索引树搜索的过程，称为<strong>回表</strong>。查询结果所需要的的数据只在主键索引上有，不得不回表。  </p>
<p>在查询里面，要查询的值已经在普通索引树上了，可以直接提供查询结果，不需要回表。普通索引已经“覆盖了”查询需求，称为<strong>覆盖索引</strong>。（select返回部分的列+where条件条件的列）<br>覆盖索引可以减少树的搜索次数，显著提升查询性能，使用覆盖索引是一个常用的性能优化手段。（维护性能下降）  </p>
<p>基于B+树的结构，对于范围查找between and，索引定位到左边界后遍历直到不满足条件。(且对于二级索引边扫描边回表搜索，有mrr(Multi-Range Read Optimization)优化就一起回表)<br>where条件in语句走对应字段的索引，把in里面的条件挨个循环走一遍索引。  </p>
<h3 id="最左前缀原则-联合索引"><a href="#最左前缀原则-联合索引" class="headerlink" title="最左前缀原则-联合索引"></a>最左前缀原则-联合索引</h3><p>B+树这种索引结构，可以利用索引的“最左前缀”，来定位记录。  </p>
<p>不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。<br>最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。  </p>
<p><strong>InnoDB的每个普通索引（叶子节点存的是主键值），都相当于这个索引字段和主键字段的联合索引。联合索引按照联合字段定义的先后顺序，依次进行排序存储。</strong>(避免order by再排序，先排序再回表)<del>非叶子节点只是第一个关键字的索引(所以只有第一个关键字能用到快速定位)</del>。非叶子节点存储的对应联合索引各个字段，叶子节点在非叶子基础上加上主键字段。  </p>
<p>建立联合索引，安排索引内字段顺序的原则：  </p>
<ul>
<li>如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。  </li>
<li>既有联合查询，又有基于各个字段的各自查询，查询条件只有后面字段的查询无法用到联合索引，需要针对后面字段再单独建立索引。联合索引字段的先后顺序，考虑空间占用，字段大的放前面跟小字段建立联合索引，字段小的再建立单字段索引。  </li>
</ul>
<blockquote>
<p><strong>如果查询顺序和联合索引的顺序不一致，优化器会自动做优化。查询语句中的where里面各个判断调换顺序无影响。</strong>  </p>
</blockquote>
<blockquote>
<p>index_merge，合并索引优化，有临时表消耗。</p>
</blockquote>
<hr>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'j'</span> 或 <span class="string">'j%'</span> 或 <span class="string">'%j'</span> 或 <span class="string">'%j%'</span> 使用<span class="keyword">name</span>索引的问题(主键<span class="keyword">id</span>)：</span><br><span class="line">a. 只有 <span class="keyword">id</span> 和 <span class="keyword">name</span> 字段。</span><br><span class="line">b. 添加了 age 字段，即 <span class="keyword">id</span>、<span class="keyword">name</span>、age 字段。</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> <span class="keyword">like</span> <span class="string">'j'</span> 或 <span class="string">'j%'</span> 可以使用<span class="keyword">name</span>索引，并且快速定位记录。</span><br><span class="line"><span class="number">2.</span> <span class="keyword">like</span> <span class="string">'%j'</span> 或 <span class="string">'%j%'</span>，只是在<span class="keyword">name</span>二级索引树上遍历查找记录，并不能快速定位（扫描了整棵索引树）。</span><br><span class="line"><span class="number">3.</span> 只有 <span class="keyword">id</span> 和 <span class="keyword">name</span> 字段时，上述 <span class="number">4</span> 种 <span class="keyword">like</span> 查询，<span class="keyword">name</span> 索引能满足 <span class="keyword">id</span> 和 <span class="keyword">name</span> 的查询情况，不需要回表，所以选择了使用 <span class="keyword">name</span> 的索引树解决问题。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 添加了 age 但无联合索引 (<span class="keyword">name</span>, age) 的情况，如果使用 <span class="keyword">name</span> 索引树，需要回表。再 <span class="keyword">like</span> <span class="string">'%j'</span> 或 <span class="string">'%j%'</span> 直接扫描主键索引树，现象就是没有使用 <span class="keyword">name</span> 索引。</span><br><span class="line"><span class="number">5.</span> 添加了 age 字段，也添加了 (<span class="keyword">name</span>, age) 索引，和第 <span class="number">3</span> 点同理，使用覆盖索引就能满足 <span class="keyword">select</span> * 的字段查询，不需要回表，因此使用了 (<span class="keyword">name</span>, age) 索引树。但是只有 <span class="keyword">like</span> <span class="string">'j'</span> 和 <span class="string">'j%'</span>能快速定位记录，而 <span class="keyword">like</span> <span class="string">'%j'</span> 和 <span class="string">'%j%'</span> 也能使用该索引树，但是不能快速定位，需要顺序遍历。</span><br><span class="line"><span class="comment">-- 针对联合索引，左侧字段的条件必须是=，不能是大于或者小于等范围值、不等于（!= &lt;&gt;）、is null is not null，否则右侧字段用不上。  </span></span><br><span class="line"><span class="comment">-- 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。（不能用索引快速定位）</span></span><br></pre></td></tr></table></figure>

<h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>不符合最左前缀的部分。索引下推（index condition pushdown）需要server层和引擎层配合。<br>联合索引（name,age），查询 name like ‘张%’ and age = 10的记录。  </p>
<ol>
<li>用到联合索引找到张开头的记录。  </li>
<li>判断其他条件<br> 2.1 MySQL5.6之前，只能从得到的‘张’开头的记录开始（根本不看联合索引中其他字段的值），一个个回表，到主键索引上找出数据行，再对比其他字段值。<br> 2.2 MySQL5.6引入索引下推（引擎层）优化(index condition pushdown)，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录（不是快速定位，只是快速过滤），减少回表次数。（索引下推其实是把条件判断提前了）  </li>
</ol>
<blockquote>
<p>扫描行数问题，在引擎内部读取了多条记录，在server层只拿到了符合条件的记录，而扫描行数统计结果以server层的为主了。  </p>
</blockquote>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>全局锁+表锁+行锁</title>
    <url>/MySQL/5%E5%85%A8%E5%B1%80%E9%94%81+%E8%A1%A8%E9%94%81+%E8%A1%8C%E9%94%81/</url>
    <content><![CDATA[<p>根据加锁的范围，MySQL里面的锁大致可以分成全局锁、表锁、行锁三类。<br><strong>全局锁和表锁都是在Server层（基本是在执行器阶段）实现的</strong>，与及具体的存储引擎无关。<br><strong>行锁是在引擎层由各个引擎自己实现的</strong>，并不是所有的引擎都支持行锁。</p>
<h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p>全局锁就是对整个数据库实例加锁。  </p>
<h4 id="1-Flush-tables-with-read-lock-FTWRL"><a href="#1-Flush-tables-with-read-lock-FTWRL" class="headerlink" title="1. Flush tables with read lock;(FTWRL)"></a>1. Flush tables with read lock;(FTWRL)</h4><p>加全局读锁，让整个库处于只读状态，其他线程的：数据更新语句（数据的增删改）、数据定义语句（建表、修改表结构）、更新类事务的提交语句，会被阻塞。(FTWRL前有读写的话，FTWRL会等待读写执行完毕后才执行。)  </p>
<p><strong>全局锁的典型使用场景是，做全库逻辑备份</strong>。（把整库每个表都select出来存成文本）。风险：  </p>
<ul>
<li>在主库上备份，在整个备份期间都不能执行更新，业务基本上就得停摆。</li>
<li>在从库上备份，备份期间从库不能执行主库同步过来的binlog，会导致主从延迟。  </li>
</ul>
<p>不加锁的话，备份系统备份得到的库不是一个逻辑时间点，这个视图是逻辑不一致的。（在可重复读隔离级别下开启一个事务，可以拿到一致性视图。）  </p>
<h4 id="2-mysqldump-–single-transaction"><a href="#2-mysqldump-–single-transaction" class="headerlink" title="2. mysqldump –single-transaction;"></a>2. mysqldump –single-transaction;</h4><p>官方逻辑备份工具mysqldump。导数据之前会启动一个事务，来确保拿到一致性视图。基于MVCC(多版本并发控制)，保证<strong>备份过程中数据可以正常更新</strong>。  </p>
<p>single-transaction只适用于所有的表使用事务引擎的库(InnoDB)。如果有的表使用了不支持事务的引擎(MyISAM)，那么备份就只能通过FTWRL方法。  </p>
<p>表结构不在一致性视图的保护里面，表结构数据不支持一致性读。<br>备份时启动了可持续读的事务，在整个备份过程中都是在这个视图下执行的，其他事务的变更不会影响它的备份。但是master传过来的DDL影响，会得到DDL后的表结构。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        备库用–single-transaction 做逻辑备份
    </div>
    <div class='spoiler-content'>
        <p>从主库的binlog传来一个DDL语句。  </p>
<pre><code class="sql">Q1:<span class="keyword">SET</span> <span class="keyword">SESSION</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> REPEATABLE <span class="keyword">READ</span>; <span class="comment">-- 确保RR（可重复读）隔离级别</span>
Q2:<span class="keyword">START</span> <span class="keyword">TRANSACTION</span>  <span class="keyword">WITH</span> <span class="keyword">CONSISTENT</span> <span class="keyword">SNAPSHOT</span>；<span class="comment">-- 确保得到一个一致性视图</span>
<span class="comment">/* other tables */</span>
Q3:<span class="keyword">SAVEPOINT</span> sp;<span class="comment">-- 设置一个保存点</span>
<span class="comment">/* 时刻 1 */</span>
Q4:<span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> <span class="string">`t1`</span>;<span class="comment">-- 拿到表结构</span>
<span class="comment">/* 时刻 2 */</span>
Q5:<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`t1`</span>;<span class="comment">-- 正式导数据</span>
<span class="comment">/* 时刻 3 */</span>
Q6:<span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> <span class="keyword">SAVEPOINT</span> sp;<span class="comment">-- 回滚到sp---释放t1的MDL锁</span>
<span class="comment">/* 时刻 4 */</span>
<span class="comment">/* other tables */</span></code></pre>
<ol>
<li>如果在 Q4 语句执行之前到达，现象：没有影响，备份拿到的是 DDL 后的表结构。  </li>
<li>如果在“时刻 2”到达，则表结构被改过，Q5 执行的时候，报 Table definition has changed, please retry transaction，现象：mysqldump 终止；  </li>
<li>如果在“时刻 2”和“时刻 3”之间到达，mysqldump 占着 t1 的 MDL 读锁，binlog 被阻塞，现象：主从延迟，直到 Q6 执行完成。  </li>
<li>从“时刻 4”开始，mysqldump 释放了 MDL 读锁，现象：没有影响，备份拿到的是 DDL 前的表结构。</li>
</ol>

    </div>
</div>  


<h4 id="3-set-global-readonly-true"><a href="#3-set-global-readonly-true" class="headerlink" title="3.set global readonly=true;"></a>3.set global readonly=true;</h4><p>让全库进入只读状态。  </p>
<ul>
<li>有些系统中，readonly的值会被用来做其他逻辑：判断一个库是主库还是备库。修改global变量的方式影响面太大。  </li>
<li>在异常处理机制上。执行FTWRL命令后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。将整个库设置成readonly之后，如果客户端发生异常，则数据库会一直保持readonly状态，会导致整个库长时间处于不可写状态，风险较高。  </li>
<li>如果用户有超级权限，readonly是失效的。执行binlog的线程（主从复制）是super权限，不影响主从复制。  </li>
</ul>
<hr>
<p>业务的更新不仅有增删改数据DML(Data Manipulation Language)（select … lock in share mode;select … for update;行锁），还可能有加字段等修改表结构的操作DDL(Data Definition Language)。都会被全局锁锁住。</p>
<h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>MySQL表级别的锁有两种不同维度：表锁、元数据锁(meta data lock,MDL)。  </p>
<h4 id="1-表锁lock-tables-…-read-write"><a href="#1-表锁lock-tables-…-read-write" class="headerlink" title="1. 表锁lock tables … read/write;"></a>1. 表锁lock tables … read/write;</h4><p>与FTWRL类似，可以用unlock tables主动释放锁，也可以在客户端断开的时候自动释放。lock tables语法除了会限制别的线程的读写锁外，也限定了本线程接下来的操作对象。  </p>
<blockquote>
<p>如果在某个线程A中执行了lock tabes t1 read, t2 write;则其他线程写t1、读写t2的语句都会被阻塞。同时，线程A在执行unlock tables之前，也只能执行读t1、读写t2的操作，不允许写t1，更不能访问其他表。  </p>
</blockquote>
<p>InnoDB引擎支持行锁，一般不使用lock tables命令来控制并发，锁住整个表的影响太大。(lock tables&amp;unlock tables–&gt;begin commit)  </p>
<h4 id="2-元数据锁MDL-metadata-lock"><a href="#2-元数据锁MDL-metadata-lock" class="headerlink" title="2. 元数据锁MDL(metadata lock);"></a>2. 元数据锁MDL(metadata lock);</h4><p><strong>MDL不需要显式使用，在访问一个表的时候会被自动加上</strong>。MDL保证读写的正确性。<strong>MDL防止DDL(表结构)和DML(增删改)并发的冲突。</strong>  </p>
<p>MySQL5.5引入MDL锁，当对一个表做增删改查操作的时候(DML)，加MDL读锁；当要对表做数据结构变更操作的时候(DDL)，加MDL写锁。  </p>
<ul>
<li>读锁之间不互斥，可以有多个线程同时对一张表增删改查。(对同一行数据更新导致的互斥是行锁发挥作用)。（InnoDB做数据的增删改查不需要加表锁）  </li>
<li>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完成才能开始执行。  </li>
</ul>
<p><strong>事务中的MDL锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交之后再释放。</strong>  </p>
<p>给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据，加MDL写锁。（加普通字段不用重建全表，加主键要重建）  </p>
<p>一个连接就是一个session，一个连接里可以先后创建多个事务（必须前一个结束才能启动下一个）。事务是无处不在的，大事务会造成额外的处理开销。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        dml与ddl之间交互容易出现不可读写的情况
    </div>
    <div class='spoiler-content'>
        <pre><code class="sql">session A:<span class="keyword">select</span> * <span class="keyword">from</span> t;  
session B:<span class="keyword">select</span> * <span class="keyword">from</span> t;  
session C:<span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> f <span class="built_in">int</span>;  
session D:<span class="keyword">select</span> * <span class="keyword">from</span> t;  </code></pre>
<p>dml与ddl之间交互容易出现不可读写的情况：  </p>
<ol>
<li>session A先启动begin，会对表t加MDL读锁。session B需要的也是MDL读锁，可以正常执行。(不显式begin,不用显式commit,查询完自动释放)  </li>
<li>session C需要的是MDL写锁，session A的读锁还未释放，session C只能被阻塞。  </li>
<li>之后所有要在表t上新申请MDL读锁的请求(session D)会被session C阻塞(锁队列，先来先得，一进去等待时就开始影响后面，申请不到也占着)。所有对表的增删改查操作都需要先申请MDL读锁，都被锁住，整个表t完全不可读写了。  </li>
<li>若表t上的查询语句频繁+客户端重试机制(超时后再起一个新的session再请求)，整个库的线程会很快爆满。  </li>
</ol>

    </div>
</div>  

<p>MySQL5.6支持online ddl(不堵塞增删改查mdl读锁，ddl执行的大部分时间，占着的也是mdl读锁)：  </p>
<blockquote>
<p>1.拿MDL写锁<br>2.降级成MDL读锁<br>3.真正做DDL<br>4.升级成MDL写锁<br>5.释放MDL锁  </p>
</blockquote>
<hr>
<p>安全的给小表加字段：  </p>
<ul>
<li>非热点表：首先解决长事务，事务不提交，就会一直占用MDL锁。在MySQL的information_schema库的innodb_trx表中，可以查到当前执行中的事务。如果要做DDL变更的表有长事务执行，需要先暂停DDL，或者kill掉这个长事务。  </li>
<li>热点表：在alter table语句中设定等待时间。如果在指定的等待时间里面能够拿到MDL写锁就执行，拿不到就不要阻塞后面的业务语句，先放弃。之后再通过重试命令重复这个过程。  </li>
</ul>
<p>MariaDB和AliSQL这两个开源分支都支持DDL NOWWAIT/WAIT N语法（语句级别。对应session级别的lock_wait_timeout）；</p>
<pre><code class="sql"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name NOWWAIT <span class="keyword">add</span> <span class="keyword">column</span> ...;
<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">WAIT</span> N <span class="keyword">add</span> <span class="keyword">column</span> ...;</code></pre>
<p>大表加字段：<br>pt-online-schema-change<br>gh-ost  </p>
<h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><p>行锁是针对数据表中行记录的锁。事务A更新了一行，而这时候事务B也要更新同一行，则必须等事务A的操作完成后才能进行更新。  </p>
<p>MySQL的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁。<strong>不支持行锁意味着并发控制只能使用表锁</strong>，对于(MyISAM)这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。  </p>
<blockquote>
<p>dml语句会产生MDL读锁，MDL锁和表锁是两个不同的结构。<br>在MyISAM表上更新一行，那么会加MDL读锁和表的写锁；同时另外一个线程要更新这个表上另外一行，也要加MDL读锁和表的写锁。第二个线程的MDL读锁能成功加上，但是表写锁堵住。第二个线程要等第一个线程执行完成。  </p>
</blockquote>
<p><strong>InnoDB行级锁是通过锁索引记录来实现的</strong>，如果update的列没建索引，即使只update一条记录也会锁定整张表。InnoDB内部是全表根据主键索引逐行扫描、逐行加锁，事务提交时统一释放。  </p>
<p>InnoDB中没有不开启事务的更新update，没写默认就是单语句事务，语句结束的地方释放锁。insert、delete都是行锁。  </p>
<h4 id="两阶段锁"><a href="#两阶段锁" class="headerlink" title="两阶段锁"></a>两阶段锁</h4><p>在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这就是<strong>两阶段锁协议</strong>。  </p>
<p><strong>如果事务中需要锁多行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</strong>  </p>
<h4 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a>死锁和死锁检测</h4><p>当并发系统中不同线程出现循环资源，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。（多个事务更新同一行，只是锁等待；如果还要更新别的行，可能造成循环依赖，导致死锁。一个事务自己跟自己不会死锁。）<br>一个表有多个索引的话，并发插入，也可能会导致死锁。  </p>
<blockquote>
<p>show engine innodb status;– 查看死锁信息。记录“之后一个死锁”的地方  </p>
</blockquote>
<h5 id="直接进入等待，直到超时。"><a href="#直接进入等待，直到超时。" class="headerlink" title="直接进入等待，直到超时。"></a>直接进入等待，直到超时。</h5><p>超时时间可以通过参数innodb_lock_wait_timeout来设置。  </p>
<p>innoDB中，innodb_lock_wait_timeout的默认值是50s。当出现死锁以后，第一个被锁住的线程要过50s才会超时退出，然后其他线程才有可能继续执行。超时时间设置太短的话，会出现很多误伤。  </p>
<h5 id="发起死锁检测。"><a href="#发起死锁检测。" class="headerlink" title="发起死锁检测。"></a>发起死锁检测。</h5><p>发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on（默认值on），表示开启这个逻辑。  </p>
<p>在发生死锁的时候，是能够快速发现并进行处理的，但是有额外负担–耗费大量的CPU资源。每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。死锁检测的时间复杂度是O(n<sup>2</sup>)，单个事务为O(n)。  </p>
<blockquote>
<p>如果新的事务要加锁访问的行上有锁（一个事务更新一条记录时发现被阻塞了），才会进行死锁检测。1一致性读不会加锁，不需要做死锁检测。2并不是每次死锁检测都要扫描所有事务。  </p>
</blockquote>
<ol>
<li><p><strong>如果能确保业务一定不会出现死锁，可以临时把死锁检测关掉。</strong><br>业务设计的时候一般不会把死锁当做一个严重错误，出现死锁了就回滚，然后通过业务重试一般就没问题了，业务无损。关掉死锁检测意味着可能会出现大量的超时，业务有损。  </p>
</li>
<li><p><strong>控制并发度。</strong><br>在客户端做并发控制。同一行同时最多只有10个线程在更新。若客户端很多，即使每个客户端控制到只有个位数并发线程，汇总到数据库服务端以后，峰值并发数也很高。<br>在服务端做并发控制。如果有中间件，可以考虑在中间件中实现；也可以在MySQL源码里。对于相同行的更新，在进入引擎之前排队。这样在InnoDB内部就不会有大量的死锁检测工作。  </p>
</li>
<li><p><strong>通过将一行改成逻辑上的多行来减少锁冲突。</strong><br>将总账户放在多条记录上，账户总额等于这多条记录的值的总和，每次给账户加金额的时候，随机选其中一条记录来加。冲突概率变成原来的1/n，可以减少锁等待个数，也就减少了死锁检测的CPU消耗。业务复杂度可能大大提高()。  </p>
</li>
</ol>
<hr>
<ol>
<li>直接执行delete fron T limit 10000;<br>单个语句占用时间长，事务相对较长，占用锁的时间较长，会导致其他客户端等待资源时间较长。大事务还会导致主从延迟。  </li>
<li>在一个连接中循环执行20次delete from T limit 500;（默认每次独立提交）<br>串行化执行，将相对长的事务分成多次相对短的事务，则每次事务占用锁的时间相对较短，其他客户端在等待相应资源的时间也较短。这样的操作意味着将资源分片使用(每次使用不同片段的资源)，可以提高并发性。  </li>
<li>在20个连接中同时执行delete from T limit 500;<br>人为制造锁竞争，造成锁冲突，加剧并发量。  </li>
<li>添加主键，根据主键删除。  </li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>隔离事务</title>
    <url>/MySQL/6%E9%9A%94%E7%A6%BB%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<p>可重复读隔离级别，事务T启动的时候（start transaction with consistent snapshot）会创建一个视图read-view，之后事务T执行期间，即使有其他事务修改了数据，事务T看到的仍然跟启动时看到的是一致的，称之为一致性读。（一个在可重复读隔离级别下执行的事务，与世无争，不受外界影响。）  </p>
<p>一个事务要更新一行，如果刚好有另外一个事务拥有这一行的行锁，会被锁住，进入等待状态。  </p>
<h3 id="事务的启动时机"><a href="#事务的启动时机" class="headerlink" title="事务的启动时机"></a>事务的启动时机</h3><p>默认 autocommit = 1;（需要显式的开启事务和提交事务）  </p>
<ol>
<li><strong>begin/start transaction命令并不是一个事务的起点</strong>，在执行到它们之后的第一个操作InnoDB表的语句，事务才真正启动。  </li>
<li>如果想马上启动一个事务，可以使用start transaction with consistent snapshot命令。  </li>
</ol>
<ul>
<li>第一种启动方式，一致性视图是在执行第一个快照读语句时创建的；  </li>
<li>第二种启动方式，一致性视图是在执行start transaction with consistent snapshot时创建的。（可重复读隔离级别下）  </li>
</ul>
<p>在MySQL里有两个“视图”的概念：  </p>
<ul>
<li>一个是view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是create view…，它的查询方法与表一样。  </li>
<li>一个是InnoDB在实现MVCC(多版本并发控制)时用到的<strong>一致性读</strong>视图，即consistent read view，<strong>用于支持RC(Read Committed，读提交)和RR(Repeatable Read，可重复度)隔离级别的实现</strong>。它没有物理结构，作用是事务执行期间用来定义“我能看到什么数据”。  </li>
</ul>
<h3 id="查询-一致性读-“快照”在MVCC里是怎么工作的"><a href="#查询-一致性读-“快照”在MVCC里是怎么工作的" class="headerlink" title="查询-一致性读-“快照”在MVCC里是怎么工作的"></a>查询-一致性读-“快照”在MVCC里是怎么工作的</h3><p>(MVCC一致性读到的数据对于update这种指令不适用。可以看到别人已提交修改后的数据。)<br>在可重复读隔离级别下，事务在启动(begin不是启动)的时候就“拍了个快照”。这个快照是基于整库的所有InnoDB引擎的表。  </p>
<p>InnoDB里面每个事务有一个唯一的事务ID，叫做transaction id。它是在<strong>事务开始的时候</strong>向InnoDB的事务系统申请的（事务启动时），是按申请顺序严格递增的。  </p>
<p><strong>每行数据有多个版本。每次事务更新数据的时候，都会生成一个新的数据版本，</strong>并且把transaction id赋值给这个数据版本的事务ID，记为row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它（新旧版本与id本身自然数大小无关，与事务提交先后有关，没提交也生成版本，但是未提交的，还加着锁）。  </p>
<p>数据表中的一行记录，可能有多个版本(row)，每个版本有自己的row trx_id。每个事务或者语句有自己的一致性视图。下图对应一个记录被多个事务连续更新后的状态。  </p>
<img src="/img/MySQL行状态变更图.png">

<p>数据版本与事务版本</p>
<p>语句更新会生成undo log(回滚日志)，对应图中的三个虚线箭头。V1、V2、V3并不是物理上真实存在的，而是每次需要的时候根据当前版本和undo log计算出来的。需要前面的版本V，就通过当前版本依次执行回滚日志U算出来。  </p>
<p>回滚就是把最新的版本（还没提交）删掉。</p>
<hr>
<p>根据可重复读的定义，一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。  </p>
<p>一个事务只需要在启动的时候声明说，“以我启动的时刻为准，如果一个数据版本是在我启动之前生成并提交的，就认；如果是我启动以后才生成的，就不认，必须要找到它的上一个版本”。如果上一个版本也不可见，那就继续往前找。如果是这个事务自己更新的数据，自己还是要认的。这个事务的快照，相当于是静态的。  </p>
<hr>
<p><strong>视图数组：</strong><br>在实现上，InnoDB为每个事务构造了一个数组（数组不保证是连续自然数，存在已提交的），用来保存这个事务启动瞬间，当前正在“活跃”的所有事务ID(创建事务，到创建事务视图数组，中间可能有别的事务新建或提交)。“活跃”指的就是，启动了但还没提交（比当前事务的ID还小）。  </p>
<p>数组里面事务ID的最小值记为低水位，当前系统里面已经创建过的事务ID的最大值加1记为高水位。  </p>
<p><strong>这个视图数组和高水位，就组成了当前事务的一致性视图(read-view)</strong>。（高水位不在视图数组中）  </p>
<p>数据版本的可见性规则，就是基于数据的row trx_id和这个一致性视图的对比结果得到的。（同一行数据，最新版本的row trx_id是可能会小于旧版本的row trx_id的）  </p>
<blockquote>
<p>可重复读下，开启一个事务时创建一个数组来记录当前所有活跃的事务id。后续有新的事务也不会再更新该数组。<br>读提交，开启事务时也会创建数组来保存事务id，而且之后每个查询都会更新一次这个数组。  </p>
</blockquote>
<p>视图数组把所有的row  trx_id分成了几种不同的情况。  </p>
<img src="/img/MySQL数据版本可见性规则.png">

<p>对于当前事务的启动瞬间来说，一个数据版本的row trx_id，有以下几种可能：  </p>
<ul>
<li>落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；  </li>
<li>落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；  </li>
<li>落在黄色部分，包括两种情况  <ul>
<li>若row trx_id在数组中，表示这个版本是由还没提交的事务生成的，不可见；  </li>
<li>若row trx_id不在数组中，表示这个版本是已经提交了的事务生成的，可见。（一个比低水位大，但是在当前事务启动前就已经提交了的事务）  </li>
</ul>
</li>
</ul>
<p>InnoDB利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。  </p>
<p>一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况：  </p>
<ul>
<li>版本未提交，不可见；  </li>
<li>版本已提交，但是是在视图创建后提交的，不可见；  </li>
<li>版本已提交，而且是在视图创建前提交的，可见。  </li>
</ul>
<h3 id="更新-当前读-加锁读-Locking-reads"><a href="#更新-当前读-加锁读-Locking-reads" class="headerlink" title="更新-当前读-加锁读(Locking reads)"></a>更新-当前读-加锁读(Locking reads)</h3><p><strong>更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”(current read)。</strong>如果有锁，就等待其他事务提交释放锁再读。（总是读取已经提交完成的最新版本，update语句把数据更新后，对应记录上的数据版本id就变成当前事务的id）  </p>
<p>除了update语句外，select语句如果加锁，也是当前读，会访问最新版本并加锁。（普通查询语句是一致性读）  </p>
<pre><code class="sql">mysql&gt; select k from t where id=1 lock in share mode;-- 读锁(S锁，共享锁)
mysql&gt; select k from t where id=1 for update;-- 写锁(X锁，排它锁)</code></pre>
<p>表结构没有对应的行数据，也没有row trx_id，因此只能遵循当前读的逻辑，不支持可重读读。（MySQL8.0可以把表结构放在InnoDB字典里）  </p>
<hr>
<p><strong>可重复读的核心就是一致性读(consistent read)，但可重复读下select … lock in share mode 是当前读；而且事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待，等待其他事务释放锁才能继续当前读。当前读总是读取已经提交完成的最新版本。</strong>  </p>
<p>读提交的逻辑和可重复读的主要区别：  </p>
<ul>
<li>在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；（查询只承认在事务启动前就已经提交完成的数据）  </li>
<li>在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图，每个视图只管自己一个语句。（查询只承认在语句启动前就已经提交完成的数据）  </li>
</ul>
<p>“start transaction with consistent snapshot;”的意思是从这个语句开始，创建一个持续整个事务的一致性快照。在读提交隔离级别下，这个用法失去意义，等效于普通的start transaction（执行第一个快照语句时才创建一致性视图）。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>普通索引和唯一索引</title>
    <url>/MySQL/%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h3 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h3><p>查询语句select * from T where k = 5;在索引树上查找的过程。（表T中id为主键列，字段k上有索引）。<br>先是通过B+树从树根开始，按层搜索到叶子节点-数据页，然后数据页内部通过二分法来定位记录。  </p>
<ul>
<li>对于普通索引来说，查找到满足条件的第一个记录后，需要查找下一个记录，直到碰到第一个不满足k=5条件的记录。  </li>
<li>对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。  </li>
</ul>
<p>InnoDB的数据是按数据页为单位来读写的。当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在InnoDB中，每个数据页的大小默认是16KB。  </p>
<p>因为引擎是按页读写的，所以当找到k=5的记录的时候，它所在的数据页就都在内存里了。对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。（如果k=5这个记录刚好是这个数据页的最后一个记录，那么要取下一个记录，必须读取下一个数据页，这个操作会稍微复杂一些。）  </p>
<p>整体来说，普通索引和唯一索引的查询性能差距微乎其微。  </p>
<h3 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h3><h4 id="change-buffer定义"><a href="#change-buffer定义" class="headerlink" title="change buffer定义"></a>change buffer定义</h4><p>change buffer的主要目的是将对二级索引的数据操作缓存下来（二级索引数据页存储索引和主键信息），以此减少二级索引的随机IO，达到操作合并的效果。</p>
<p>当需要更新一个数据页时：  </p>
<ul>
<li>如果数据页在内存中就直接更新；  </li>
<li>如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InnoDB会将这些更新操作缓存在change buffer中(同时记录新增一条change buffer的redo log)，这样就不需要从磁盘中读入这个数据页了，此时内存中没有这个物理页，不存在脏页。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作（merge，只有merge才会触发更新数据，同时记录数据变更的redo log和change buffer变更的redo log）。通过这种方法就能保证这个数据逻辑的正确性。  </li>
</ul>
<p>数据页没在内存，才能用上change buffer。</p>
<hr>
<p>将change buffer中的操作应用到原数据页，得到最新结果的过程称为merge。(只有merge操作才会更新数据，其余change buffer、redo log只是记录操作)  </p>
<ul>
<li>访问数据页出发merge；  </li>
<li>系统后台线程定期merge；  </li>
<li>数据库正常关闭（shutdown）的过程中执行merge操作。  </li>
</ul>
<p>merge的执行流程：  </p>
<ol>
<li>从磁盘读入数据页到内存（老版本的数据页）；  </li>
<li>从change buffer里找到这个数据页的change buffer记录（可能有多个），<strong>依次</strong>应用，得到新版数据页；  </li>
<li>写redo log。这个redo log包含了数据的变更和change buffer的变更。  </li>
</ol>
<p>merge过程结束。此时数据页（数据表空间）和内存中change buffer对应的磁盘位置（系统表空间）都还没有修改，属于脏页，之后各自刷回自己的物理数据，属于另外一个过程。  </p>
<hr>
<p>change buffer是可以持久化的数据。change buffer在内存中有拷贝，也会被写入到磁盘。<br>change buffer的写盘策略跟数据一样（WAL记日志），内存放不下会触发落盘，还有checkpoint推进的时候也是可能会触发。  </p>
<p>如果能够将更新操作先记录在change buffer，减少读磁盘，语句的执行速度会得到明显的提升。而且数据读入内存是需要占用buffer pool的，所以这种方式还能够避免占用内存，提高内存利用率。（change buffer只是记录了更新过程，占用的内存比数据页读入内存的占用要小的多）  </p>
<h4 id="change-buffer使用条件"><a href="#change-buffer使用条件" class="headerlink" title="change buffer使用条件"></a>change buffer使用条件</h4><ul>
<li>唯一索引，所有的更新操作都要先判断这个操作是否违反唯一性约束。插入记录时，要先判断现在表中是否已经存在索引对应的记录，而这必须要将数据页读入内存才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用change buffer了。<strong>唯一索引的更新不能使用change buffer。</strong>  </li>
<li><strong>只有普通索引可以使用change buffer。</strong>  </li>
</ul>
<p>innodb_change_buffer_max_size参数设置change buffer占用内存的大小，change buffer用的是buffer pool里的内存。</p>
<h4 id="change-buffer插入流程"><a href="#change-buffer插入流程" class="headerlink" title="change buffer插入流程"></a>change buffer插入流程</h4><ol>
<li>这个记录要更新的目标页在内存中：  </li>
</ol>
<ul>
<li>唯一索引，找到内存中相应位置，判断没有冲突，插入这个值，语句执行结束；  </li>
<li>普通索引，找到内存中相应位置，插入这个值，语句执行结束。  </li>
</ul>
<ol start="2">
<li>这个记录要更新的目标页不在内存中：  </li>
</ol>
<ul>
<li>唯一索引，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束；  </li>
<li>普通索引，将更新记录在change buffer，语句执行结束。  </li>
</ul>
<blockquote>
<p>针对同一行记录的多次更改，对应多条change buffer记录，并不是在已有记录上更改。  </p>
</blockquote>
<p>将数据从磁盘读入内存涉及随机IO的访问，是数据库里面成本最高的操作之一。change buffer因为减少了随机磁盘访问，所以对更新性能的提升很明显。  </p>
<p>对于唯一索引，大量更新数据（插入）的操作，引起大量磁盘IO操作，容易使整个系统处于阻塞状态，更新语句全部堵住。  </p>
<h4 id="change-buffer使用场景"><a href="#change-buffer使用场景" class="headerlink" title="change buffer使用场景"></a>change buffer使用场景</h4><p>并不是普通索引的所有场景，使用change buffer都可以起到加速作用。  </p>
<p>merge的时候是真正进行数据更新的时刻，而change buffer的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做merge之前，change buffer记录的变更越多，这个页面上要更新的次数越多，收益就越大。  </p>
<p>对于写多读少的业务，页面在写完以后马上被访问到的概率比较小，此时change buffer的使用效果最好。（账单类、日志类系统）。  </p>
<p>假设一个业务的更新模式是写入之后马上做查询，那么及时满足了条件，将更新先记录在change buffer，但之后由于马上要访问这个数据页，会立即出发merge过程。这样随机访问IO的次数不会减少，反而增加了change buffer的维护代价。反而起到了副作用。  </p>
<h3 id="索引选择"><a href="#索引选择" class="headerlink" title="索引选择"></a>索引选择</h3><p>普通索引和唯一索引，在查询能力上没差别，主要考虑的是对更新性能的影响。尽量选择普通索引（业务代码保证不会写入重复数据）。  </p>
<p>如果所有的更新后面，都马上伴随着对这个记录的查询，那么应该关闭change buffer。而在其他情况下，change buffer都能提升更新性能。  </p>
<p>普通索引和change buffer的配合使用，对于数据量大的表的更新优化很明显。（归档库）  </p>
<h3 id="change-buffer和redo-log"><a href="#change-buffer和redo-log" class="headerlink" title="change buffer和redo log"></a>change buffer和redo log</h3><p>WAL(write-ahead logging)预写日志系统，提升性能的核心机制，是尽量减少随机读写。  </p>
<p><strong>redo log主要节省的是随机写磁盘的IO消耗(顺序写磁盘)，而change buffer主要节省的则是随机读磁盘的IO消耗。</strong>  </p>
<p>change buffer记录索引页的变化，此时内存中是没有对应数据的物理页的；redo log记录内存中数据页的变更（产生脏页），也记录change buffer的变化（只有change buffer的merge操作才会更新数据）。（参考下面的图）  </p>
<p>redo log有几十种类型。redo记录页的变化（WAL将页变化的乱序写转换成顺序写）。页分很多种，B+树索引页、undo页、change buffer页等，这些页被redo记录后就不着急刷盘。所以change buffer也用了WAL机制。  </p>
<hr>
<p>crash safe:<br>虽然只更新内存，但是在事务提交的时候，把change buffer的操作也记录到redo log里了，所以崩溃恢复的时候，change buffer也能找回来。  </p>
<ol>
<li>change buffer更新完成并且相应事务提交的情况下，首先要保证redo log落盘（二阶段提交），若此时掉电重启，则可以根据redo进行恢复。  </li>
<li>若change buffer更新完成但是相应事务未提交的情况下，redo有可能落盘了(redo的组提交)，也有可能未落盘。  </li>
</ol>
<ul>
<li>redo落盘，读取redo发现没有commit标志（还会进行lsn(log sequence number日志序列号)，和binlog对比），则回滚。  </li>
<li>redo未落盘，则不会出现前滚和回滚的情况，数据依旧一致。  </li>
</ul>
<p>服务器掉电重启对change buffer的影响。  </p>
<ol>
<li>如果掉电，持久化的change buffer数据已经merge，不用恢复。  </li>
<li>未持久化的change buffer：  </li>
</ol>
<ul>
<li>change buffer写入，redo log写入但未commit，binlog未同步到磁盘，数据丢失。  </li>
<li>change buffer写入，redo log写入但未commit，binlog已经同步到磁盘，先从binlog恢复redo log，再从redo log恢复change buffer。  </li>
<li>change buffer写入，redo log和binlog都已经同步，那么直接从redo log里恢复。</li>
</ul>
<h4 id="change-buffer写过程"><a href="#change-buffer写过程" class="headerlink" title="change buffer写过程"></a>change buffer写过程</h4><blockquote>
<p>insert into t(id,k) values(id1,k1),(id2,k2);  </p>
</blockquote>
<img src="/img/MySQL带change buffer的写过程.png">

<p>当前索引树的状态，查找到位置后，k1所在的数据页在内存中（InnoDB buffer pool），k2所在的数据页不在内存中。  </p>
<p>插入语句涉及四个部分：<br>内存、redo log(ib_log_fileX)、数据表空间(t.tid)、系统表空间(ibdata1)。  </p>
<ol>
<li>Page1在内存中，直接更新内存；  </li>
<li>Page2没有在内存中，就在内存的change buffer区域，记录下“往Page2插入一行”这个信息；  </li>
<li>将上述两个动作记入redo log中(3,4)。  </li>
</ol>
<p>做完上述操作，事务完成。执行这条语句的成本很低，写了两处内存，写了一处磁盘(两次操作合在一起写了一次磁盘)，而且是顺序写磁盘redolog。两个虚线箭头，系统表和数据表时后台操作，不影响更新的相应时间。  </p>
<blockquote>
<p>insert时，写主键无法使用change buffer（主键唯一），但是同时也会写其它索引，其它索引中的“非唯一索引”可以用到change buffer的优化机制，不用立即更新磁盘上的普通索引。  </p>
</blockquote>
<h4 id="change-buffer读过程"><a href="#change-buffer读过程" class="headerlink" title="change buffer读过程"></a>change buffer读过程</h4><blockquote>
<p>select * from t where k in(k1,k2);  </p>
</blockquote>
<img src="/img/MySQL带change buffer的读过程.png">

<p>如果读语句发生在更新语句后不久，内存中的数据都还在，此时读操作与系统表空间(ibdata1)和redo log(ib_log_fileX)无关。  </p>
<ol>
<li>读Page1的时候，直接从内存返回。虽然磁盘上还是之前的数据，但是直接从内存返回结果，结果是正确的。（此处WAL之后读数据，不需要读盘，不用从redo log里面把数据更新以后再返回）  </li>
<li>读Page2的时候，需要把Page2从磁盘读入内存中，然后应用change buffer里面的操作日志，生成一个正确的版本并返回结果。  </li>
</ol>
<p>直到需要读Page2的时候，这个数据页才会被读入内存。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>索引选择异常及处理</title>
    <url>/MySQL/%E7%B4%A2%E5%BC%95%E9%80%89%E6%8B%A9%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>MySQL中一张表可以支持多个索引。使用哪个索引是由MySQL来确定的。  </p>
<p>explain + sql;查看语句的执行情况。<br>set long_query_time=0;设置慢查询阈值，单位秒。<br>set slow_query_log=1;开启慢查询日志，0表示关闭。<br>slow_query_log_file;慢查询日志存放路径。  </p>
<h3 id="优化器的逻辑"><a href="#优化器的逻辑" class="headerlink" title="优化器的逻辑"></a>优化器的逻辑</h3><p>选择索引是优化器的工作。<br>优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。（扫描行数、临时表、排序等影响）  </p>
<h4 id="扫描行数"><a href="#扫描行数" class="headerlink" title="扫描行数"></a>扫描行数</h4><p>MySQL在真正开始执行语句之前，并不能精确的知道满足这个条件的记录有多少条，只能根据统计信息来估算记录数。  </p>
<p>这个统计信息就是索引的“区分度”。一个索引上不同的值越多，这个索引的区分度就越好。而一个索引上不同的值的个数，称之为“基数”(cardinality)。这个基数越大，索引的区分度越好。  </p>
<blockquote>
<p>show index from t;可以查看一个索引的基数。并不是准确的数字。  </p>
</blockquote>
<hr>
<p>MySQL索引的基数通过采样统计的方法得到。<br>InnoDB默认会选择N个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，得到这个索引的基数。  </p>
<p>数据表会持续更新，索引统计信息也不会固定不变，当变更的数据行数超过1/M的时候，会自动触发重新做一次索引统计。<br><strong>统计信息不会每次更新都重新统计。</strong>  </p>
<p>在MySQL中，有两种存储索引统计的方式，可以通过innodb_stats_persistent的值来选择：  </p>
<ul>
<li>设置为on的时候，表示统计信息会持久化存储。默认的N是20，M是10.  </li>
<li>设置为off的时候，表示统计信息只存储在内存中。默认的N是8，M是16。  </li>
</ul>
<hr>
<p>索引统计只是一个输入，对于一个具体的语句，优化器还要判断，执行这个语句本身要扫描多少行。<br><strong>explain SQL;其中rows字段表示的是预计扫描行数。</strong>真正需要扫描多少行，得执行了才知道。  </p>
<p>使用普通索引，每次从索引上拿到一个值，都要回到主键索引上查出整行数据，这个回表的代价优化器也计算。而如果扫描全部的行，是直接在主键索引上扫描的，没有额外的代价。  </p>
<h3 id="索引选择异常处理"><a href="#索引选择异常处理" class="headerlink" title="索引选择异常处理"></a>索引选择异常处理</h3><p>join、group、order、limit等操作都是在server层执行器中进行。<strong>执行器调用存储层的接口只能获取最原始的数据</strong>。然后一条一条的进行过滤，然后再调引擎层获取下一条。  </p>
<p>1属于索引统计信息不准确<br>234属于优化器误判  </p>
<h4 id="1-analyze-table"><a href="#1-analyze-table" class="headerlink" title="1.analyze table"></a>1.analyze table</h4><p><strong>analyze table t;– 执行过程中会加MDL读锁。</strong><br>修正统计信息，重新统计索引信息。<br>实践中，explain的结果预估的rows值跟实际情况差距比较大，可以采用这个方法处理。  </p>
<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
</tr>
</thead>
<tbody><tr>
<td>start transaction with consistent snapshot</td>
<td></td>
</tr>
<tr>
<td></td>
<td>delete from t;  call idata();– 存储过程，insert十万条数据</td>
</tr>
<tr>
<td></td>
<td>explain select * from t where a between 10000 and 20000;</td>
</tr>
<tr>
<td>commit</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>1.为什么没有session A,session B扫描的行数是1W<br>由于mysql是使用<strong>标记删除</strong>来删除记录的,并不从索引和数据文件中真正的删除（加索引慢，删索引秒删）。<br>如果delete和insert中间的间隔相对较小,merge线程还没有来得及清理该记录。<br>如果主键相同的情况下,新插入的insert会沿用之前删除的delete的记录的空间。（看上去是覆盖了原来的10万行）。<br>由于相同的数据量以及表大小,所以导致了统计信息没有变化。  </p>
</blockquote>
<blockquote>
<p>2.为什么开启了session A,session B扫描行数变成3W<br>由于session A开启了一致性读,目的为了保证session A的可重复读,insert只能另起炉灶,不能占用delete的空间。所以出现的情况就是delete虽然删除了,但是未释放空间,insert又增加了空间。导致统计信息有误。<br>为了保证sessionA的可重复读(未提交)，数据页并没有实际删除，undo log也还没有回收，新的insert又产生了新的数据页，之前的数据每一行数据都有两个版本，旧版本是delete之前的数据，新版本是标记为delete的数据，这样索引a上的数据其实就有两份。索引的统计选择了N个数据页进行采样，这部分数据页不受到前台事务的影响，索引整体统计值会变大，直接影响了索引选择的准确性。  </p>
</blockquote>
<h4 id="2-force-index"><a href="#2-force-index" class="headerlink" title="2.force index"></a>2.force index</h4><p>select * from t force index(a) where …;  </p>
<p>采用force index强行选择一个索引。起到“矫正”的作用。<br>MySQL会根据词法分析的结果分析出可能可以使用的索引作为候选项，然后在候选索引列表中依次判断每个索引需要扫描多少行。如果force index指定的索引在候选索引列表中，就直接选择这个索引，不再评估其他索引的执行代价。（不触发索引重新统计，不会改变explain 中预估扫描行数的值）  </p>
<h4 id="3-修改sql语句"><a href="#3-修改sql语句" class="headerlink" title="3.修改sql语句"></a>3.修改sql语句</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> (a <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">1000</span>)  <span class="keyword">and</span> (b <span class="keyword">between</span> <span class="number">50000</span> <span class="keyword">and</span> <span class="number">100000</span>) <span class="keyword">order</span> <span class="keyword">by</span> b <span class="keyword">limit</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>优化器放弃使用索引a，说明a还不够合适。<br>优化器选择使用索引b，是因为它认为使用索引b可以避免排序(b本身是索引，已经是有序的了，如果选择索引b的话，不需要再做排序，只需要遍历)，所以即使扫描行数多，也判定为代价更小。<br>但是变更不及时。  </p>
<blockquote>
<p>如果使用索引a进行查询，就扫描索引a的1000个值，然后取到对应的主键id，再到主键索引上去查出每一行，然后根据字段b来过滤。  </p>
</blockquote>
<blockquote>
<p>如果索引索引b进行查询，就扫描索引b的50001个值，取到对应的主键id，<strong>依次</strong>回到主键索引上取值再判断。一条过滤完再获取并处理下一条数据。  </p>
</blockquote>
<p>没有order by则<strong>默认按照“查询使用的索引”排序。</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> (a <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">1000</span>)  <span class="keyword">and</span> (b <span class="keyword">between</span> <span class="number">50000</span> <span class="keyword">and</span> <span class="number">100000</span>) <span class="keyword">order</span> <span class="keyword">by</span> b,a <span class="keyword">limit</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>order by b,a;要求按照b,a排序，就意味着使用这两个索引都需要排序。扫描行数成了影响决策的主要条件。<br>但是修改了语句语义。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span>  (<span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> (a <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">1000</span>)  <span class="keyword">and</span> (b <span class="keyword">between</span> <span class="number">50000</span> <span class="keyword">and</span> <span class="number">100000</span>) <span class="keyword">order</span> <span class="keyword">by</span> b <span class="keyword">limit</span> <span class="number">100</span>)<span class="keyword">alias</span> <span class="keyword">limit</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>用limit 100 让优化器意识到，使用b索引的代价很高。??优化器计算代价的细节待补充。<br>不具备通用性。  </p>
<h4 id="4-新建一个更合适的索引-删掉误用的索引"><a href="#4-新建一个更合适的索引-删掉误用的索引" class="headerlink" title="4.新建一个更合适的索引|删掉误用的索引"></a>4.新建一个更合适的索引|删掉误用的索引</h4><p>经过索引优化过的库，再碰到这种bug，找到一个更合适的索引一般比较难。<br>优化器错误选择的索引若没有必要存在，就删掉这个索引。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>字符串加索引</title>
    <url>/MySQL/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> f1, f2 <span class="keyword">from</span> SUser <span class="keyword">where</span> email=<span class="string">'xxx'</span>;</span><br></pre></td></tr></table></figure>

<p>若email字段上没有索引，那么这个语句只能做全表扫描。  </p>
<h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p>MySQL支持前缀索引，可以定义字符串的一部分作为索引。默认的，如果创建索引的语句不指定前缀长度，那么索引就包含整个字符串。  </p>
<blockquote>
<p>取字符串中间部分作为子串来建索引—fulltext索引。like ‘%name%’模糊查询使用全文检索索引。  </p>
</blockquote>
<p>前缀索引占用的空间会更小，但是会增加额外的扫描次数。使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。  </p>
<h4 id="确定前缀长度"><a href="#确定前缀长度" class="headerlink" title="确定前缀长度"></a>确定前缀长度</h4><p>建立索引时关注的是区分度，区分度越高越好。区分度越高，意味着重复的键值越少。通过统计索引上有多少个不同的值来判断要使用多长的前缀。  </p>
<ul>
<li>首先，统计出改列上有多少个不同的值：  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> email) <span class="keyword">as</span> L <span class="keyword">from</span> suser;</span><br></pre></td></tr></table></figure></li>
<li>依次选取不同长度的前缀再来统计该值：  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">4</span>)) <span class="keyword">as</span> L4,</span><br><span class="line">        <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">5</span>)) <span class="keyword">as</span> L5,</span><br><span class="line">        <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">6</span>)) <span class="keyword">as</span> L6,</span><br><span class="line">        <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">7</span>)) <span class="keyword">as</span> L7</span><br><span class="line"><span class="keyword">from</span> suser;</span><br></pre></td></tr></table></figure>
使用前缀索引会损失区分度，预先设定一个可以接受的损失比例：5%，然后再返回的L4~L7中，找出不小于L*95%的值。  </li>
</ul>
<p>索引选取的越长，占用的磁盘空间就越大，相同的数据页能放下的索引值就越少，搜索的效率也就会越低。  </p>
<blockquote>
<p>char（N）表示“最长存N，但是如果字符串小于N，用空格补到N”。<br>varchar（N）表示“最长存N，如果字符串小于N，按照实际长度来存”。</p>
</blockquote>
<h4 id="影响覆盖索引"><a href="#影响覆盖索引" class="headerlink" title="影响覆盖索引"></a>影响覆盖索引</h4><p>使用前缀索引用不上覆盖索引对查询性能的优化。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,email <span class="keyword">from</span> suser <span class="keyword">where</span> email = <span class="string">'abcdefg@xyz.com'</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span>,email <span class="keyword">from</span> suser <span class="keyword">where</span> email = <span class="string">'abcdefg@xyz.com'</span>;</span><br></pre></td></tr></table></figure>
<p>如果使用index1(email整个字符串的索引结构)，可以利用覆盖索引，从index1查到结果后直接就返回了，不需要回到主键ID索引再去查一次；<br>如果使用index2(email(n)前缀索引结构)，不得不回到主键ID索引再去判断email字段的值。  </p>
<p>即使将index2的定义修改为email(11)的前缀索引，这时虽然index2已经包含了所有的信息，但是InnoDB还是要回到id索引再查一下，拿到该主键值对应的行，再判断email是否正确。因为系统并不确定前缀索引的定义是否截断了完整信息，以防email字段返回的值不对。  </p>
<h3 id="倒序存储"><a href="#倒序存储" class="headerlink" title="倒序存储"></a>倒序存储</h3><p>身份证号，一共18位，其中前6位是地址码，同一个县的人的身份证号前6位一般是相同的。<br>对身份证号做长度为6的前缀索引的话，区分度非常低；创建长度为12以上的前缀索引能满足区分度要求，但是占用的磁盘空间过大。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> field_list <span class="keyword">from</span> t <span class="keyword">where</span> id_card = <span class="keyword">reverse</span>(<span class="string">'input_id_card_string'</span>);</span><br></pre></td></tr></table></figure>
<p>存储身份证号的时候把它倒过来存，每次查询的时候将输入的字符串反转后再查。<br>身份证的最后6位没有地址码这样的重复逻辑，做前缀索引提供了足够的区分度。  </p>
<h3 id="使用hash字段"><a href="#使用hash字段" class="headerlink" title="使用hash字段"></a>使用hash字段</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> id_card_crc <span class="built_in">int</span> <span class="keyword">unsigned</span>, <span class="keyword">add</span> <span class="keyword">index</span>(id_card_crc);</span><br><span class="line"><span class="keyword">select</span> field_list <span class="keyword">from</span> t <span class="keyword">where</span> id_card_crc=<span class="keyword">crc32</span>(<span class="string">'input_id_crad_string'</span>) <span class="keyword">and</span> id_card=<span class="string">'input_id_card_string'</span>;</span><br></pre></td></tr></table></figure>
<p>在表上再创建一个整数字段，来保存身份证的校验码，同时在这个字段上创建索引。  </p>
<p>每次插入新纪录的时候，都同时用crc32()这个函数得到检验码填到这个新字段。校验码可能存在冲突，查询语句where部分要判断id_card的值是否精确相同。  </p>
<p>索引长度比原来小，只需要四个字节。</p>
<h3 id="倒序存储和使用hash字段对比"><a href="#倒序存储和使用hash字段对比" class="headerlink" title="倒序存储和使用hash字段对比"></a>倒序存储和使用hash字段对比</h3><p>相同点：不支持范围查询。<br>倒序存储的字段上创建的索引是按照倒序字符串的方式排序的，已经没有办法利用索引方式查出身份证号码在[ID_X,ID_Y]的所有市民了，同样hash字段的方式也只能支持等值查询。  </p>
<p>不同点：  </p>
<ol>
<li>从占用的额外空间来看，倒序存储方式在主键索引上，不会消耗额外的存储空间，而hash字段方法需要增加一个字段。倒序存储方式使用4个字节的前缀长度应该是不够的，如果再长一点，这个消耗跟额外这个hash字段差不多抵消。  </li>
<li>在CPU消耗方面，倒序方式每次写和读的时候，都需要额外调用依次reverse函数，而hash字段的方式需要额外调用依次crc32()函数。如果只从这两个函数的计算复杂度来看，reverse函数额外消耗的CPU资源会更小一些。  </li>
<li>从查询效率看，使用hash字段方式的查询性能相对稳定。crc32算出来的值虽有冲突的概率，但是比较小，可以认为每次查询的平均扫描函数接近1.而倒序存储方式毕竟还是用的前缀索引的方式，还会增加扫描行数。  </li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>重建表回收空间</title>
    <url>/MySQL/%E9%87%8D%E5%BB%BA%E8%A1%A8%E5%9B%9E%E6%94%B6%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<p>一个InnoDB表包含两部分：表结构定义和数据。<br>MySQL8.0以前，表结构是存在以.frm为后缀的文件里。MySQL8.0版本，允许把表结构定义放在系统数据表中。表结构定义占用的空间很小。  </p>
<h3 id="表数据存储位置"><a href="#表数据存储位置" class="headerlink" title="表数据存储位置"></a>表数据存储位置</h3><p>表数据既可以存在共享表空间中，也可以是单独的文件。  </p>
<ol>
<li>innodb_file_per_table=OFF，表示表的数据放在系统共享表空间，也就是跟数据字典放在一起。  </li>
<li>innodb_file_per_table=ON，（建议）表示每个InnoDB表数据存储在一个以.ibd为后缀的文件中。  </li>
</ol>
<p>MySQL5.6.6版本开始，该参数默认值为ON。<br>一个表单独存储为一个文件更容易管理，而且在不需要这个表的时候，通过drop table命令，系统就会直接删除这个文件。而如果是放在共享表空间，即使表删掉了，空间也是不会回收的。  </p>
<p>针对表中某些行被删除，表空间没有被回收。  </p>
<h3 id="数据页空洞"><a href="#数据页空洞" class="headerlink" title="数据页空洞"></a>数据页空洞</h3><p>InnoDB里的数据都是用B+树的结构组织的。  </p>
<p>如果要删掉某个记录，InnoDB引擎只会把这个记录标记为删除，但磁盘文件的大小并不会缩小，后续有符合其前后范围的新记录插入，可能会复用这个位置。InnoDB的数据是按页存储的，如果删掉了一个数据页上的所有记录（被标记），整个数据页就可以被复用了（任意数据都可复用）。  </p>
<p><strong>记录的复用与数据页的复用是不同的</strong>。记录的复用，只限于符合范围条件的数据。而当整个页从B+树里面摘掉以后，可以复用到任何位置。如果相邻的两个数据页利用率都很小，系统还会把这两个页上的数据合到其中一个页上，另外一个数据页就被标记为可复用。  </p>
<p>如果用delete命令把整个表的数据删除，所有的数据页都会被标记为可复用，但是磁盘上，文件不会变小。delete命令是不能回收表空间的，这些可以复用，而没有被使用的空间，看起来就像是空洞。  </p>
<hr>
<p>插入数据也会造成空洞。  </p>
<p>如果数据是按照索引递增顺序插入的，那么索引是紧凑的。如果数据是随机插入的，就可能造成索引的数据页分裂。  </p>
<p>由于一个page1满了，再插入一个page1数值大小范围内的数据时，就不得不再申请一个新的页面page2来保存数据，并将page1上的后部分数据挪到page2，页分裂完成后，page1的末尾就留下了空洞。  </p>
<p>更新索引上的值，可以理解为删除一个旧的值，再插入一个新的值，明显也会造成空洞。经过大量增删改的表，都是可能存在空洞的。把这些空洞去掉，才能达到收缩表空间的目的。  </p>
<h3 id="重建表"><a href="#重建表" class="headerlink" title="重建表"></a>重建表</h3><p>重建表可以达到收缩表空间的目的。<br>在重建表的时候，InnoDB不会把整张表占满，每个页留了1/16给后续的更新用。重建表之后不是“最”紧凑的。  </p>
<blockquote>
<p>删除主键或者创建主键都会将整个表重建。<br>更改表结构(加字段)会重建主键索引，主键索引树叶子节点的值要更新。普通索引不用重建。  </p>
</blockquote>
<p>新建一个与表A(原始表)结构相同的临时表B，然后按照主键ID递增的顺序，把数据一行一行地从表A里读出来再插入到表B中。交换表名，删除临时表。  </p>
<blockquote>
<p>MySQL5.5版本前使用alter table A engine=InnoDB;命令来重建表。</p>
</blockquote>
<p>表B是新建的表，表A主键索引上的空洞，在表B中都不存在了。表B的主键索引更紧凑，数据页的利用率页更高。从效果上看，起到了收缩表A空间的作用。  </p>
<hr>
<p>DDL花时间最多的步骤是往临时表插入数据的过程，如果在这个过程中，有新的数据要写入到表A的话，就会造成数据丢失。在整个DDL过程中，表A中不能有更新，阻塞MDL，这个DDL不是Online的。  </p>
<p>MySQL5.6版本引入了OnlineDDL：  </p>
<ol>
<li>建立一个临时文件，扫描表A主键的所有数据页；  </li>
<li>用数据页中表A的记录生成B+树，存储到临时文件中；  </li>
<li>生成临时文件的过程中，将所有对A的操作记录在一个日志文件(row log)中。  </li>
<li>临时文件生成后，将日志文件中的操作应用到临时文件(可能会引入新的空洞)，得到一个逻辑数据上与表A相同的数据文件。  </li>
<li>用临时文件替换表A的数据文件。  </li>
</ol>
<p>由于日志文件记录和重放操作这个功能的存在，在重建表的过程冲，允许对表A(旧表)做增删改操作。  </p>
<p>alter语句（DDL操作）在启动的时候需要获取MDL写锁，在真正拷贝数据之前退化成读锁，MDL读锁不会阻塞增删改操作，同时禁止其他线程对这个表同时做DDL。最后临时文件替换表A的数据文件时重新加上MDL写锁。  </p>
<p>Online DDL最耗时的过程就是拷贝数据到临时表的过程，这个步骤的执行期间可以接收增删改操作。相对于整个DDL过程来说，写锁的时间非常短，对业务来说，相当于是Online的。  </p>
<p>重建表会扫描原表结构和构建临时文件。对于很大的表很消耗IO和CPU资源。线上服务要很小心的控制操作时间。<br>比较安全的操作是使用GitHub开源的gh-ost做。  </p>
<h3 id="Online和inplace"><a href="#Online和inplace" class="headerlink" title="Online和inplace"></a>Online和inplace</h3><p>MySQL5.5版本重建表，把表A中的数据导出来存放在tmp_table。这是一个临时表，是在server层创建的。  </p>
<blockquote>
<p>alter table t engine=innodb,ALGORITHM=copy;– 强制拷贝表  </p>
</blockquote>
<p>MySQL5.6版本重建表，根据表A重建出来的数据是放在tmp_file里的，这个临时文件是InnoDB在内部创建出来的。整个DDL过程都在InnoDB内部完成。对于server层来说，没有把数据挪动到临时表，是一个原地操作。称之为inplace。  </p>
<blockquote>
<p>alter table t engine=innodb,ALGORITHM=inplace;</p>
</blockquote>
<p>区别（都需要占用临时空间）：  </p>
<ul>
<li>DDL过程如果是Online的，就一定是inplace的；  </li>
<li>反过来未必，inplace的DDL，有可能不是Online的。添加全文索引(FULLTEXT index)和空间索引(SPATIAL index)。8.0  <blockquote>
<p>给InnoDB表的一个字段加全文索引：alter table t add FULLTEXT(field_name);<br>这个过程是inplace的，但是会阻塞增删改操作，是非Online的。  </p>
</blockquote>
</li>
</ul>
<hr>
<p>optimize table、analyze table、alter table三种重建表区别：</p>
<ul>
<li>MySQL5.6版本开始，alter table t engine=InnoDB;（recreate）默认ALGORITHM=inplace。（no-rebuild主键索引不用重建）  <blockquote>
<p>在事务里面显式用alter table语句，会默认提交前面的事务，然后自己独立执行。  </p>
</blockquote>
</li>
<li>analyze table t;不是重建表，只是对表的索引信息做重新统计，没有修改数据，这个过程中加了MDL读锁。  </li>
<li>optimize table t;等于recreate+analyze。（recreate后全新的表，极端情况下才需要analyze）  </li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>刷脏页抖动</title>
    <url>/MySQL/%E5%88%B7%E8%84%8F%E9%A1%B5%E6%8A%96%E5%8A%A8/</url>
    <content><![CDATA[<p>一条SQL语句，正常执行的时候特别快，但是有时候就会变得特别慢，这样的场景很难复现，它不只随机，而且持续时间还很短。  </p>
<h3 id="SQL语句变慢原因"><a href="#SQL语句变慢原因" class="headerlink" title="SQL语句变慢原因"></a>SQL语句变慢原因</h3><p>WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘。数据库将随机写转换成了顺序写，大大提升了数据库的性能。  </p>
<blockquote>
<p>随机写：每次更新，都直接将数据写到磁盘。  </p>
</blockquote>
<p>InnoDB在处理更新语句的时候，只做了写日志这一个<strong>磁盘</strong>操作。这个日志叫做redo log（重做日志），在更新内存写完redo log后，就返回给客户端本次更新成功。  </p>
<blockquote>
<p>redo log其实是“磁盘页到内存页的diff”，记录了“这是哪个页面的修改”。<br>undo log,每一行存了一个位置可以直接找到undo log，是MVCC的基础。</p>
</blockquote>
<p>把内存里的数据写入磁盘的过程，称为<strong>flush</strong>。在这个flush操作执行之前内存里的数据和磁盘上数据文件记录的数据是不一致的。  </p>
<blockquote>
<p>flush 一般是说刷脏页；<br>purge一般是指清undo log；<br>merge一般是指应用change buffer。（change buffer只对非唯一索引有效）  </p>
</blockquote>
<p>当内存数据页跟磁盘数据页内容不一致的时候，称这个内存页为“<strong>脏页</strong>”。内存数据写入磁盘后，内存和磁盘上的数据页的内容就一致了，称为“<strong>干净页</strong>”。(checkpoint往前推进只是把脏页变成干净页，干净页还在内存，只有淘汰时才会逐出内存)  </p>
<p>平时执行很快的更新操作，其实就是在写内存和日志，而MySQL偶尔“抖”一下的那个瞬间，可能就是再刷脏页（flush）。<br>刷脏页的时候要将内存页写入磁盘(直接将脏页数据覆盖到对应磁盘上的数据)。无论是查询语句在需要内存的时候要求淘汰一个脏页，还是由于刷脏页的逻辑会占用IO资源影响到了更新语句，都可能是业务端感知到MySQL抖一下的原因。  </p>
<blockquote>
<p>刷脏页不用动redo log，redo log在“重放”的时候，如果一个数据页已经是刷过的，会识别出来并跳过。（每个数据页头部有LSN，8字节，每次修改都会变大(更新这个page的最后一个lab)。对比这个LSN跟redo log的checkpoint的LSN，比checkpoint小的一定是干净页。）  </p>
</blockquote>
<blockquote>
<p>redolog buffer在事务执行过程中，先把要写的内容在内存中存起来，在commit阶段，一次性写入redolog file（磁盘上固定空间循环使用）。  innodb_flush_log_at_trx_commit=1;（默认值）表示每次事务提交时，redo log都直接持久化到磁盘。  </p>
</blockquote>
<h3 id="引发数据库flush的场景"><a href="#引发数据库flush的场景" class="headerlink" title="引发数据库flush的场景"></a>引发数据库flush的场景</h3><ul>
<li>场景一：InnoDB的redo log写满了。此时系统会停止所有更新操作，把checkpoint往前推进，redo log留出空间可以继续写。  <img src="/img/MySQL redo log结构图.png">  
checkpoint往前推进时，需要将推进过程中的日志，对应的所有脏页都flush到磁盘上。之后write pos到checkpoint新位置之间就可以再写入redo log。  

</li>
</ul>
<blockquote>
<p>每次事务提交都要写redo log，如果设置太小，很快就会被写满，write pos一直追着CP。这时系统不得不停止所有更新，去推进checkpoint。磁盘压力很小，但是数据库出现间歇性的性能下跌。  </p>
</blockquote>
<ul>
<li><p>场景二：系统内存不足。当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰掉的是脏页，就要先将脏页写到磁盘。刷脏页一定会写盘，保证每个数据页有两种状态：  </p>
<pre><code>- 内存里存在，内存里就肯定是正确的结果，直接返回；  
- 内存里没有数据，就可以肯定数据文件上是正确的结果，读入内存后返回。  </code></pre></li>
<li><p>场景三：MySQL认为系统空闲的时候。当然MySQL一直很忙时，也要合理的安排时间，即使是忙的时候，也要见缝插针的找时间，只要有机会就刷一点“脏页”。  </p>
</li>
<li><p>场景四：MySQL正常关闭的情况。这时，MySQL会把内存的脏页都flush到磁盘上，这样下次MySQL启动的时候，就可以直接从磁盘上读数据，启动速度会很快。  </p>
</li>
</ul>
<h3 id="不同flush场景对性能影响"><a href="#不同flush场景对性能影响" class="headerlink" title="不同flush场景对性能影响"></a>不同flush场景对性能影响</h3><ul>
<li><p>情况三，属于MySQL空闲时的操作。这时系统没什么压力。  </p>
</li>
<li><p>情况四，属于数据库本来就要关闭了。不太关注性能问题。  </p>
</li>
<li><p>情况一，是InnoDB要尽量避免的。出现这种情况时，整个系统就不能再接受更新了，所有的更新都必须堵住。从监控上看，此时更新数会跌为0。  </p>
</li>
<li><p>情况二，是常态。InnoDB用缓冲池buffer pool管理内存（查询缓存innodb buffer pool是server层的，存储的是SQL语句的查询结果），缓冲池中的内存页有三种状态：  </p>
<pre><code>- 第一种，还没有使用的；
- 第二种，使用了并且是干净页；
- 第三种，使用了并且是脏页。  </code></pre></li>
</ul>
<p>InnoDB的策略是尽量使用内存，因此对于一个长时间运行的库来说，未被使用的页面很少（第一种）。<br>当要读入的数据页没有在内存的时候，就必须到缓冲池中申请一个数据页。此时只能把最久不使用的数据页从内存中淘汰掉：如果要淘汰的是一个干净页，就直接释放出来复用（第二种）；但是如果是脏页，就必须将脏页先刷到磁盘，变成干净页后才能复用（第三种）。  </p>
<p>明显影响性能的两种情况：  </p>
<ol>
<li>一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长；  </li>
<li>日志写满，更新全部堵住，写性能跌为0，这种情况对敏感业务来说，是不能接受的。  </li>
</ol>
<p>InnoDB需要有控制脏页比例的机制，来尽量避免上面的这两种情况。  </p>
<h3 id="InnoDB刷脏页的控制策略"><a href="#InnoDB刷脏页的控制策略" class="headerlink" title="InnoDB刷脏页的控制策略"></a>InnoDB刷脏页的控制策略</h3><h4 id="正确的告诉InnoDB所在主机的IO能力"><a href="#正确的告诉InnoDB所在主机的IO能力" class="headerlink" title="正确的告诉InnoDB所在主机的IO能力"></a>正确的告诉InnoDB所在主机的IO能力</h4><p>这样InnoDB才能知道需要全力刷脏页的时候，可以刷多块。  </p>
<p>通过innodb_io_capacity参数告诉InnoDB磁盘能力。这个值设置成磁盘的IOPS。磁盘的IOPS可以通过fio工具测试(磁盘随机读写)：（机械硬盘的随机 IOPS 一般只有几百）</p>
<blockquote>
<p>fio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting  -name=mytest  </p>
</blockquote>
<p>设置太小，则InnoDB认为这个系统的能力差，所以刷脏页刷的特别慢（频率慢），甚至比脏页生成的速度还慢，这样就造成了脏页累积，影响了查询和更新性能。（要读取的数据不在内存中，但是脏页过多导致新页必须等待脏页刷新盘后，淘汰掉再加载到内存）  </p>
<p>磁盘能力不能只用来刷脏页，还需要服务用户请求。  </p>
<h4 id="InnoDB控制引擎按照“全力”的百分比来刷脏页"><a href="#InnoDB控制引擎按照“全力”的百分比来刷脏页" class="headerlink" title="InnoDB控制引擎按照“全力”的百分比来刷脏页"></a>InnoDB控制引擎按照“全力”的百分比来刷脏页</h4><p>InnoDB的刷盘速度参考两个因素：脏页比例、redo log写盘速度。  </p>
<p><strong>脏页比例</strong><br>参数innodb_max_dirty_pages_pct是脏页比例上限，默认值是75%。InnoDB会根据当前的脏页比例（假设为M），算出一个范围在0到100之间的数字。  </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">F1(M)</span><br><span class="line">&#123;</span><br><span class="line">      if M&gt;=innodb_max_dirty_pages_pct then</span><br><span class="line">            return 100;</span><br><span class="line">      return 100*M/innodb_max_dirty_pages_pct;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>脏页比例是通过innodb_buffer_pool_pages_dirty/innodb_buffer_pool_pages_tital得到的：  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">user information_schema;</span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> @a <span class="keyword">from</span> global_status <span class="keyword">where</span> VARIABLE_NAME = <span class="string">'Innodb_buffer_pool_pages_dirty'</span>;  </span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> @b <span class="keyword">from</span> global_status <span class="keyword">where</span> VARIABLE_NAME = <span class="string">'Innodb_buffer_pool_pages_total'</span>;  </span><br><span class="line"><span class="keyword">select</span> @a/@b;</span><br></pre></td></tr></table></figure>

<p>平时要多关注脏页比例，不要让它经常接近75%（max值）。  </p>
<p><strong>写盘速度</strong><br>InnoDB每次写入的日志都有一个序号，当前写入的序号跟checkpoint对应的序号之间的差值，设为N。InnoDB会根据这个N算出一个范围在0到100之间的数字，这个计算公式可以即为F2(N)。N越大，算出来的值越大。  </p>
<p><strong>根据上述算的的F1(M)和F2(N)两个值，取其中较大的值记为R，之后引擎就可以按照innodb_io_capacity定义的能力乘以R%来控制刷脏页的速度。</strong>  </p>
<h4 id="脏页连坐"><a href="#脏页连坐" class="headerlink" title="脏页连坐"></a>脏页连坐</h4><p>一旦一个查询请求需要在执行过程中先flush掉一个脏页时，这个查询就可能要比平时慢。MySQL中的一个机制会让查询更慢：在准备刷一个脏页的时候，如果这个数据页旁边的数据页刚好是脏页，就会把这个“邻居”也带着一起刷掉；而且把这个邻居拖下水的逻辑还可以继续蔓延，也就是对于每个邻居数据页，如果跟它相邻的数据页也还是脏页的话，也会被放到一起刷。  </p>
<p>innodb_flush_neighbors=1;时会有连坐机制；  </p>
<blockquote>
<p>（适合机械硬盘，可以减少随机IO，提升系统性能）  </p>
</blockquote>
<p>innodb_flush_neighbors=0;时不找邻居，自己刷自己的（随机IO）。(MySQL8.0默认值)  </p>
<blockquote>
<p>（适合固态硬盘，IOPS不是瓶颈，只刷自己，能更快的执行完必要的刷脏页操作，减少SQL语句相应时间）  </p>
</blockquote>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>count(*)</title>
    <url>/MySQL/count%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h3 id="count-的实现方式"><a href="#count-的实现方式" class="headerlink" title="count(*)的实现方式"></a>count(*)的实现方式</h3><p>在不同的MySQL引擎中，count(*)有不同的实现方式：  </p>
<ul>
<li>MyISAM引擎把一个表的总行数存在了磁盘上(实时改变)，执行count(*)的时候会直接返回这个数，效率很高。  <blockquote>
<p>没有过滤条件的count(*)，如果加了where条件的话，MyISAM表也不能直接返回。  </p>
</blockquote>
</li>
<li>InnoDB执行count(*)的时候，需要把数据一行一行的从引擎里面读出来，然后累积计数。遍历全表，结果准确，性能不高。  </li>
</ul>
<p>由于多版本并发控制(MVCC)的原因，即使是在同一时刻的多个查询，InnoDB表“应该返回多少行”是不确定的。<br>这和InnoDB的事务设计有关，可重复读是它默认的隔离级别，在代码上就是通过多版本并发控制(MVCC)来实现的。每一行记录都要判断自己是否对这个会话可见，因此对于count(*)请求来说，InnoDB只好把数据一行一行的读出依次判断，可见的行才能够用于计算“基于这个查询”的表的总行数。  </p>
<p>InnoDB是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值。普通索引树比主键索引树小很多。对于count(<em>)这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的。MySQL优化器会找到最小的那棵树来遍历。*</em>在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。**  </p>
<hr>
<p>show table status;命令的输出结果，table_rows用于显示这个表当前有多少行。索引统计的值是通过采样来估算的。table_rows是从这个采样估算得来的，不够准确。<strong>show table status命令显示的行数不能直接使用。</strong>  </p>
<p>information_schema.tables;可以查看表记录数。  </p>
<h3 id="用缓存系统保存计数"><a href="#用缓存系统保存计数" class="headerlink" title="用缓存系统保存计数"></a>用缓存系统保存计数</h3><p>用一个Redis服务来保存这个表的总行数。这个表每被插入一行Redis计数就加1，每被删除一行Redis计数就减1。读和更新操作都很快，但缓存系统可能会丢失更新。  </p>
<p>Redis的数据不能永久的留在内存里，需要把这个值定期的持久化存储起来。Redis异常重启时，未持久化的加1计数操作丢失。Redis异常重启后，在数据库里面单独执行一次count(*)获取真实的行数，再把这个值写回到Redis里。异常重启非经常出现的情况，偶尔一次全表扫描的成本可以接受。  </p>
<p>将计数保存在缓存系统，不只丢失更新的问题，即使Redis正常工作，这个值还是逻辑上不精确的。在并发系统里，无法精确控制不同线程的执行时刻，在会话先后执行表中插入记录与Redis计数加一两个操作期间，其他会话执行计数与记录的查询（一致性读/快照读，可以并发执行），会出现数据不一致的情况。  </p>
<p><strong>两个不同的存储构成的系统，不支持分布式事务，无法拿到精确一致的视图。</strong>  </p>
<h3 id="在数据库保存计数"><a href="#在数据库保存计数" class="headerlink" title="在数据库保存计数"></a>在数据库保存计数</h3><p>把计数放到数据库里单独的一张计数表中，利用事务的原子性和隔离性解决了一致性视图的问题。  </p>
<ul>
<li>解决了崩溃丢失的问题，InnoDB支持崩溃恢复不丢失数据。  </li>
<li>利用InnoDB支持事务的特性，表中插入数据与计数表中对应表的计数值加1两个操作在同一个事务中，未提交前其他事务不可见，保证了数据逻辑上的一致。  </li>
</ul>
<h3 id="count用法对比-InnoDB"><a href="#count用法对比-InnoDB" class="headerlink" title="count用法对比(InnoDB)"></a>count用法对比(InnoDB)</h3><p>count()是一个聚合函数，对于返回的结果集，一行行的判断，如果count函数的参数不是NULL，累计值就加1，否则不加，最后返回累积值。  </p>
<p>count(*)、count(主键id)和count(1)都表示返回满足条件的结果集的总行数；count(字段)表示返回满足条件的数据行里面，参数”字段”不为NULL的总个数。  </p>
<ul>
<li>server层要什么就给什么；  </li>
<li>InnoDB只给必要的值；  </li>
<li>目前优化器只优化了count(*)的语义为“取行数”，其他显而易见的优化并没有做。  </li>
</ul>
<hr>
<p><strong>count(主键id)</strong>，InnoDB引擎会遍历整张表，把每一行的id值都取出来，返回给server层。server层拿到id后，判断是不可能为空的(主键id一定不为空，但是未优化)，就按行累加。  </p>
<blockquote>
<p>count(id)不一定选主键索引进行统计。可能会选择最小的索引(占用空间比较小，磁盘读的少)，走全索引的扫描，就算索引是null，对应的主键id不是null，不影响统计结果；  </p>
</blockquote>
<p><strong>count(1)</strong>，InnoDB引擎遍历整张表，但不取值(返回一个空行，但在server层”不是空值，可以计数”。server层调用引擎接口，一行一样取)。server层对于返回的每一行，放一个数字“1”进去(返回了一行，但是0个字段)，判断不可能为空的，按行累加。  </p>
<blockquote>
<p>count(1)执行的要比count(主键id)快。从引擎返回id会涉及到(扫描树里的数据)解析数据行，以及拷贝字段值的操作。  </p>
</blockquote>
<p><strong>count(字段)</strong>：  </p>
<ul>
<li>如果这个“字段”是定义为not null的，一行行的从记录里面读出这个字段，判断不能为null(一定不为null，但未优化)，按行累加；</li>
<li>如果这个“字段”定义允许为null，执行的时候，判断到有可能是null，还要把值取出来再判断一下，不是null才累加。  </li>
</ul>
<blockquote>
<p>count(字段)如果字段上没有索引，只能选主键索引来进行统计。  </p>
</blockquote>
<p><strong>count(*)，并不会把全部字段取出来，而是专门做了优化，不取值(返回一个“空的行”)。count(*)肯定不是null，按行累加。</strong>  </p>
<p>按照效率排序：count(字段)&lt;count(主键id)&lt;count(1)≈count(*)。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>日志与索引</title>
    <url>/MySQL/%E6%97%A5%E5%BF%97%E4%B8%8E%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h3 id="两阶段提交的不同时刻，MySQL异常重启。"><a href="#两阶段提交的不同时刻，MySQL异常重启。" class="headerlink" title="两阶段提交的不同时刻，MySQL异常重启。"></a>两阶段提交的不同时刻，MySQL异常重启。</h3><p>崩溃恢复crash safe:  </p>
<ol>
<li>如果redo log里面的事务是完整的，也就是已经有了commit标识，则直接提交。  </li>
<li>如果redo log里面的事务只有完整的prepare，则判断对应的事务binlog是否存在并完整（提交标记）：  <ul>
<li>a. 如果是完整的，则提交事务；  </li>
<li>b. 否则，回滚事务。  </li>
</ul>
</li>
</ol>
<h4 id="MySQL怎么知道binlog是完整的"><a href="#MySQL怎么知道binlog是完整的" class="headerlink" title="MySQL怎么知道binlog是完整的"></a>MySQL怎么知道binlog是完整的</h4><p>一个事务的binlog是有完整格式的：</p>
<ul>
<li>statement格式的binlog，最后会有commit；  </li>
<li>row格式的binlog，最后会有一个XID event。  </li>
</ul>
<p>MySQL5.6.2版本后，引入binlog-checksum参数，用来验证binlog内容的正确性。对于binlog日志由于磁盘原因，可能会在日志中间出错的情况，MySQL可以通过校验checksum的结果来发现。  </p>
<h4 id="redo-log和binlog是怎么关联起来的"><a href="#redo-log和binlog是怎么关联起来的" class="headerlink" title="redo log和binlog是怎么关联起来的"></a>redo log和binlog是怎么关联起来的</h4><p>他们有一个共同的数据字段—XID。崩溃恢复的时候，会按顺序扫描redo log；  </p>
<ul>
<li>如果碰到既有prepare、又有commit的redo log，就直接提交；  </li>
<li>如果碰到只有prepare、而没有commit的redo log，就拿着XID去binlog找对应的事务。  </li>
</ul>
<h4 id="处于prepare阶段的redo-log加上完整binlog，重启就能恢复，MySQL为什么要这么设计"><a href="#处于prepare阶段的redo-log加上完整binlog，重启就能恢复，MySQL为什么要这么设计" class="headerlink" title="处于prepare阶段的redo log加上完整binlog，重启就能恢复，MySQL为什么要这么设计"></a>处于prepare阶段的redo log加上完整binlog，重启就能恢复，MySQL为什么要这么设计</h4><p>binlog写完以后MySQL发生崩溃，这时候binlog已经写入了，之后就会被从库(或者用这个binlog恢复出来的库)使用。  </p>
<p>所以在主库上也要提交这个事务。采用这个策略，主库和备库的数据就保证了一致性。  </p>
<h4 id="只用binlog就能恢复，为什么需要两阶段提交"><a href="#只用binlog就能恢复，为什么需要两阶段提交" class="headerlink" title="只用binlog就能恢复，为什么需要两阶段提交"></a>只用binlog就能恢复，为什么需要两阶段提交</h4><p>两阶段提交是经典的分布式系统问题。  </p>
<p>对于InnoDB引擎来说，如果redo log提交完成了，事务就不能回滚(如果还允许回滚，就可能覆盖掉别的事务的更新)。如果redo log直接提交，然后binlog写入的时候失败，InnoDB又回滚不了，数据和binlog日志不一致。  </p>
<p>两阶段提交是为了给所有人一个机会，当每个人都OK的时候，再一起提交。  </p>
<h4 id="不引入两个日志，也就没有两阶段提交的必要了。只用binlog来支持崩溃恢复，又能支持归档"><a href="#不引入两个日志，也就没有两阶段提交的必要了。只用binlog来支持崩溃恢复，又能支持归档" class="headerlink" title="不引入两个日志，也就没有两阶段提交的必要了。只用binlog来支持崩溃恢复，又能支持归档"></a>不引入两个日志，也就没有两阶段提交的必要了。只用binlog来支持崩溃恢复，又能支持归档</h4><p><strong>历史原因</strong>：<br>InnoDB并不是MySQL的原生存储引擎。MySQL的原生引擎是MyISAM，设计之初就没有支持崩溃恢复。  </p>
<p>InnoDB在作为MySQL的插件加入MySQL的引擎家族之前，就已经是一个提供了崩溃恢复和事务支持的引擎了。  </p>
<p>InnoDB接入了MySQL后，发现binlog没有崩溃恢复的能力，就用InnoDB原有的redo log。(redo log是在innodb引擎实现的，binlog是在server层实现的)  </p>
<p><strong>实现原因</strong>：<br>binlog没有能力恢复”数据页”。<br>InnoDB引擎使用的是WAL技术，执行事务的时候，写完内存和日志，事务就算完成了。如果之后崩溃，要依赖于日志来恢复数据页。<br>未提交的事务，重启后引擎内部事务会回滚，然后应用binlog可以补回来；已经提交了的事务是可能丢失的(MySQL写数据写在内存里已提交但未落盘，恢复只关注未提交但已写binlog的数据)，而且是数据页级的丢失。<br>binlog里面并没有记录数据页的更新细节，只记录了逻辑操作，数据页是补不回来的。  </p>
<blockquote>
<p>一个事务的binlog如果回放，就是重做整个事务，一个事务更新的可能不止一个page。  </p>
</blockquote>
<h4 id="只用redo-log，不要binlog"><a href="#只用redo-log，不要binlog" class="headerlink" title="只用redo log，不要binlog"></a>只用redo log，不要binlog</h4><p>如果只从崩溃恢复的角度来讲可以。可以把binlog关掉，这样就没有两阶段提交了，但系统依然是crash-safe的。  </p>
<p>正式的生产库上，binlog有着redo log无法替代的功能。  </p>
<ul>
<li>归档，redo log是循环写，写到末尾是要回到开头继续写的。这样历史日志没法保留，redo log也就起不到归档的作用。  </li>
<li>MySQL系统以来binlog。binlog作为MySQL一开始就有的功能，被用在了很多地方。其中MySQL系统高可用的基础就是binlog复制。  </li>
<li>异构系统(数据分析类系统)，这些系统依靠消费MySQL的binlog来更新自己的数据。关掉binlog的话，下游系统没有输入。  </li>
</ul>
<h4 id="redo-log一般设置多大"><a href="#redo-log一般设置多大" class="headerlink" title="redo log一般设置多大"></a>redo log一般设置多大</h4><p>redo log太小的话，会导致很快就被写满，然后不得不强行刷redo log，这样WAL机制的能力发挥不出来。  </p>
<p>对于几个TB的磁盘，redo log设置为4个文件，每个文件1GB。  </p>
<h4 id="正常运行中的实例，数据写入后的最终落盘，是从redo-log更新过来的还是从buffer-pool更新过来的-rodo-log里面到底是什么"><a href="#正常运行中的实例，数据写入后的最终落盘，是从redo-log更新过来的还是从buffer-pool更新过来的-rodo-log里面到底是什么" class="headerlink" title="正常运行中的实例，数据写入后的最终落盘，是从redo log更新过来的还是从buffer pool更新过来的(rodo log里面到底是什么)"></a>正常运行中的实例，数据写入后的最终落盘，是从redo log更新过来的还是从buffer pool更新过来的(rodo log里面到底是什么)</h4><p>redo log并没有记录数据页的完整数据，它并没有能力去更新磁盘数据页，页不存在“数据最终落盘，是由redo log更新过去”的情况。  </p>
<ul>
<li>如果是正常运行的实例，数据页被修改以后，跟磁盘的数据页不一致，称为脏页。最终数据落盘，就是把内存中的数据页写盘。这个过程跟redo log毫无关系。  </li>
<li>在崩溃恢复场景中，InnoDB如果判断到一个数据页可能在崩溃恢复的时候丢失了更新，就会将它督导内存，然后让redo log更新内存内容，更新完成后，内存页变成脏页，就回到了第一种情况的状态。  </li>
</ul>
<h4 id="redo-log-buffer是什么，是先修改内存，还是先写redo-log文件"><a href="#redo-log-buffer是什么，是先修改内存，还是先写redo-log文件" class="headerlink" title="redo log buffer是什么，是先修改内存，还是先写redo log文件"></a>redo log buffer是什么，是先修改内存，还是先写redo log文件</h4><p>在一个事务的更新过程中，日志是要写多次的。每次生成的日志都得先保存起来，但又不能在还没commit的时候就直接写到redo log文件里。  </p>
<p>redo log buffer就是一块内存，用来先存redo 日志的。真正把日志写到redo log文件(文件名是id_logfile+ 数字)，是在执行commit语句的时候做的。  </p>
<blockquote>
<p>prepare的时候就要落盘一次(包含一次写数据到盘)。一个大事务中，如果生成的redo log很多，在事务未提交之前，log也会从redo log buffer写到redo log file里。  </p>
</blockquote>
<p>事务执行过程中不会“主动去刷盘”，以减少不必要的IO消耗。但是可能会出现“被动写入磁盘”，比如内存不够、其他事务提交等情况。  </p>
<p>单独执行一个更新语句的时候，InnoDB会自己启动一个事务，在语句执行完成的时候提交。过程跟上面一样，只不多是“压缩”到了一个语句里面完成。  </p>
<p>binlo 有对应的binlog cache，binlog写完磁盘就发送给从库。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>相同逻辑，不同SQL，性能差异</title>
    <url>/MySQL/%E7%9B%B8%E5%90%8C%E9%80%BB%E8%BE%91%EF%BC%8C%E4%B8%8D%E5%90%8CSQL%EF%BC%8C%E6%80%A7%E8%83%BD%E5%B7%AE%E5%BC%82/</url>
    <content><![CDATA[<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tradelog`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`tradeid`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`operator`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`t_modified`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`tradeid`</span> (<span class="string">`tradeid`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`t_modified`</span> (<span class="string">`t_modified`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br></pre></td></tr></table></figure>

<h3 id="条件字段函数操作"><a href="#条件字段函数操作" class="headerlink" title="条件字段函数操作"></a>条件字段函数操作</h3><blockquote>
<p>select count(*) from tradelog where month(t_modified)=7;  </p>
</blockquote>
<p>B+树的快速定位能力，来源于同一层兄弟节点的有序性。<br><strong>对索引字段做函数操作，可能会破坏索引值的有序性，优化器决定放弃走树搜索功能(快速定位能力)。但优化器并不是要放弃使用这个索引。</strong>  </p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>partitions</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>filtered</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>tradelog</td>
<td>NULL</td>
<td>index</td>
<td>NULL</td>
<td>t_modified</td>
<td>6</td>
<td>NULL</td>
<td>100335</td>
<td>100.00</td>
<td>Using where;Using index</td>
</tr>
</tbody></table>
<p>放弃了树搜索功能，优化器可以选择遍历主键索引，也可以选择遍历索引t_modified，优化器对比索引大小后发现，索引t_moditied更小，遍历这个索引比遍历主键索引更快，最终会选择索引t_modified。  </p>
<p>key=t_modified表示使用了该索引；测试数据10W行，rows=100335说明扫描了整个索引的所有值；Extra的Using index，表示使用了覆盖索引。<br>由于在t_modified字段加了month()函数操作，MySQL无法再使用索引快速定位功能，只能使用全索引扫描。<br>即使是对于不改变有序性的函数，也不会考虑使用索引。(where id + 1 = 10000;—&gt;where id = 10000 - 1;)  </p>
<h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><blockquote>
<p>select * from tradelog where tradeid=110717;  </p>
</blockquote>
<p>tradeid字段类型是varchar(32)，输入参数是整型，需要做类型转换。  </p>
<p><strong>在MySQL中，字符串和数字做比较的话，是将字符串转换成数字。</strong>（索引字段为整型，条件字段为字符串时，走索引。截断式转换）  </p>
<blockquote>
<p>select * from tradelog where CAST（tradid AS signed int） = 110717;<br>触发对索引字段做函数操作，优化器会放弃走树搜索功能。  </p>
</blockquote>
<h3 id="隐式字符编码转换"><a href="#隐式字符编码转换" class="headerlink" title="隐式字符编码转换"></a>隐式字符编码转换</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `trade_detail` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `tradeid` varchar(32) DEFAULT NULL,</span><br><span class="line">  `trade_step` int(11) DEFAULT NULL, <span class="comment">/*操作步骤*/</span></span><br><span class="line">  `step_info` varchar(32) DEFAULT NULL, <span class="comment">/*步骤信息*/</span></span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `tradeid` (`tradeid`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>select d.* from tradelog l, trade_detail d where d.tradeid=l.tradeid and l.id=2;  </p>
</blockquote>
<ul>
<li>优化器会先在交易记录表tradelog上查到id=2的行，这个步骤用上了主键索引，只扫描一行。  </li>
<li>没有用上交易详情表trade_detail上的tradeid索引，进行了全表扫描。通过遍历主键索引的方式，一个一个的判断tradeid的值是否匹配。  </li>
</ul>
<p>这个执行计划里，从tradelog表中取tradeid字段，再去trade_detail表里查询匹配字段。把tradelog称为驱动表，trade_detail称为被驱动表，把tradeid称为关联字段。  </p>
<p>这两个表的字符集不同，一个是utf8，一个是utf8mb4，做表连接查询的时候用不上关联字段的索引。字符集utf8mb4是utf8的超集，当这两个类型的字符串做比较的时候，MySQL内部的操作是，先把utf8字符串转成utf8mb4字符集，再做比较。  </p>
<blockquote>
<p>select * from trade_detail  where CONVERT(traideid USING utf8mb4)=$L2.tradeid.value;<br>– convert()函数，把输入的字符串转成utf8mb4字符集。<br>触发对索引字段做函数操作，优化器会放弃走树搜索功能。  </p>
</blockquote>
<p><strong>连接过程中要求在被驱动表的索引字段上加函数操作，是直接导致对被驱动表做全表扫描的原因。</strong></p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        样例
    </div>
    <div class='spoiler-content'>
        <blockquote>
<p>select l.operator from tradelog l , trade_detail d where d.tradeid=l.tradeid and d.id=4;</p>
</blockquote>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>partitions</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>filtered</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>d</td>
<td>NULL</td>
<td>const</td>
<td>PRIMARY</td>
<td>PRIMARY</td>
<td>4</td>
<td>const</td>
<td>1</td>
<td>100.00</td>
<td>NULL</td>
</tr>
<tr>
<td>1</td>
<td>SIMPLE</td>
<td>l</td>
<td>NULL</td>
<td>ref</td>
<td>tradeid</td>
<td>tradeid</td>
<td>131</td>
<td>const</td>
<td>1</td>
<td>100.00</td>
<td>NULL</td>
</tr>
</tbody></table>
<p>驱动表trade_detail，被驱动表tradelog。  </p>
<blockquote>
<p>select opterator from tradelog where tradeid = CONVERT($R4.tradeid.value USING utf8mb4);<br>CONVERT函数是加在输入参数上的，可以用上被驱动表的tradeid索引。  </p>
</blockquote>

    </div>
</div>  

<p>原SQL改造：  </p>
<ul>
<li>把trade_detail表上的tradeid字段的字符集改成utf8mb4，避免字符集转换问题。<blockquote>
<p>alter table trade_detail modify tradeid varchar(32) CHARACTER set utf8mb4 default null;  </p>
</blockquote>
</li>
<li>修改SQL语句。<blockquote>
<p>select d.* from tradelog l , trade_detail d where d.tradeid=CONVERT(l.tradeid USING utf8) and l.id=2; </p>
</blockquote>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>order by工作原理</title>
    <url>/MySQL/order%20by%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`city`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`addr`</span> <span class="built_in">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`city`</span> (<span class="string">`city`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;<span class="comment">-- 市民表，city字段建普通索引city</span></span><br></pre></td></tr></table></figure>
<p>查询城市是“杭州”的所有人名字，并且按照姓名排序返回前1000个人的姓名、年龄。  </p>
<blockquote>
<p>select city,name,age from t where city=’杭州’ order by name limit 1000;  </p>
</blockquote>
<h3 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h3><table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>partitions</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>filtered</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>T</td>
<td>NULL</td>
<td>ref</td>
<td>city</td>
<td>city</td>
<td>51</td>
<td>const</td>
<td>4000</td>
<td>100.00</td>
<td>Using index condition;Using filesort</td>
</tr>
</tbody></table>
<p>Extra字段中的”Using filesort”表示需要排序，MySQL会给每个线程分配一块内存用于排序，称为sort_buffer。  </p>
<p>语句执行流程：  </p>
<ol>
<li>初始化sort_buffer，确定放入name、city、age这三个字段；  </li>
<li>从索引city找到第一个满足city=’杭州’条件的主键id；  </li>
<li>到主键id索引取出整行，取name、city、age三个字段的值，存入sort_buffer中；  </li>
<li>从索引city取下一个记录的主键id；  </li>
<li>重复步骤3、4直到city的值不满足查询条件为止；  </li>
<li>对sort_buffer中的数据按照字段name做快速排序；(<strong>全字段排序</strong>)  </li>
<li>按照排序结果取前1000行返回给客户端。  </li>
</ol>
<p>按照name排序这个动作，可能在内存中完成，也可能需要使用外部排序，取决于排序所需的内存和参数sort_buffer_size。<br>sort_buffer_size就是MySQL为排序开辟的内存(sort_buffer)的大小。如果要排序的数据量小于sort_buffer_size，排序就在内存中完成。如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序。  </p>
<hr>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 打开optimizer_trace，只对本线程有效 */</span></span><br><span class="line"><span class="keyword">SET</span> optimizer_trace=<span class="string">'enabled=on'</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* @a保存Innodb_rows_read的初始值 */</span></span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> @a <span class="keyword">from</span>  performance_schema.session_status <span class="keyword">where</span> variable_name = <span class="string">'Innodb_rows_read'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 执行语句 */</span></span><br><span class="line"><span class="keyword">select</span> city, <span class="keyword">name</span>,age <span class="keyword">from</span> t <span class="keyword">where</span> city=<span class="string">'杭州'</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">limit</span> <span class="number">1000</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查看 OPTIMIZER_TRACE 输出 */</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`information_schema`</span>.<span class="string">`OPTIMIZER_TRACE`</span>\G</span><br><span class="line"></span><br><span class="line"><span class="comment">/* @b保存Innodb_rows_read的当前值 */</span></span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> @b <span class="keyword">from</span> performance_schema.session_status <span class="keyword">where</span> variable_name = <span class="string">'Innodb_rows_read'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计算Innodb_rows_read差值 */</span></span><br><span class="line"><span class="keyword">select</span> @b-@a;<span class="comment">-- 4000</span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">通过查看OPTIMIZER_TRACE的结果来确认，可以从number_of_tmp_files中看到是否使用了临时文件。  </span><br><span class="line">``` json  </span><br><span class="line">"filesort_execution":[],</span><br><span class="line">"filesort_summary":&#123;</span><br><span class="line">    "rows":4000,</span><br><span class="line">    "examined_rows":4000,</span><br><span class="line">    "number_of_tmp_files":12,</span><br><span class="line">    "sort_buffer_size":32664,</span><br><span class="line">    "sort_mode":"&lt;sort_key,packed_additional_fields&gt;"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>examined_rows表示参与排序的行数。市民表中有4000条满足city=’杭州’的记录。  </li>
<li>number_of_tmp_files表示排序过程使用的临时文件数。内存放不下时，就需要使用外部排序，外部排序一般使用归并排序算法。  <blockquote>
<p>如果sort_buffer_size超过了需要排序的数据量的大小，number_of_tmp_files就是0，表示排序可以直接在内存中完成。否则就需要再临时文件中排序。sort_buffer_size越小，需要分成的份数越多，number_of_tmp_files的值就越大。  </p>
</blockquote>
</li>
<li>sort_mode中的packed_additional_fields的意思是排序过程对字符串做了”紧凑”处理。即使name字段的定义是varchar(16)，在排序过程中还是要按照实际长度来分配空间。</li>
<li>select @b-@a的结果为4000，整个执行过程只扫描了4000行。(MyISAM)  <blockquote>
<p>查询optimizer_trace这个表时，需要用到临时表，而internal_tmp_disk_storage_engine的默认值是InnoDB。把数据从临时表取出来的时候，会让innodb_rows_read的值加1。  </p>
</blockquote>
</li>
</ul>
<h3 id="rowid排序"><a href="#rowid排序" class="headerlink" title="rowid排序"></a>rowid排序</h3><p>原始算法过程中，只对原表的数据读了一遍，剩下的操作都是在sort_buffer和临时文件中执行的。如果查询要返回的字段很多的话，那么sort_buffer里面要放的字段数太多，这样内存里能同时放下的行数很少，要分成很多个临时文件，排序的性能会很差。  </p>
<blockquote>
<p>set max_length_for_sort_data=16;– 控制用于排序的行数据的长度(需要的字段的定义大小的和)，如果单行的长度超过这个值，MySQL就认为单行太大，要换一个算法。(city\name\age一共36)  </p>
</blockquote>
<p>新的算法放入sort_buffer的字段，只有要排序的列(name字段)和主键id。(因为排序的结果少了city和age字段的值，就不能直接返回了)  </p>
<ol>
<li>初始化sort_buffer，确定放入两个字段，name和id；  </li>
<li>从索引city找到第一个满足city=’杭州’条件的主键id；  </li>
<li>到主键id索引取出整行，取name、id这两个字段，存入sort_buffer中；  </li>
<li>从索引city取下一个记录的主键id；  </li>
<li>重复步骤3、4直到不满足city=’杭州’条件为止；  </li>
<li>对sort_buffer中的数据按照字段name进行排序；(<strong>rowid排序</strong>)  </li>
<li>遍历排序结果，取前1000行，并按照id的值回到原表中取出city、name、age三个字段返回给客户端。  </li>
</ol>
<p>rowid排序多访问了一次表t的主键索引。(回表)<br>MySQL服务端从排序后的sort_buffer中依次取出id，然后到原表查到city、name、age三个字段的结果，不需要在服务端再耗费内存存储结果，是直接返回给客户端的。  </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"filesort_execution":[],</span><br><span class="line">"filesort_summary":&#123;</span><br><span class="line">    "rows":4000,</span><br><span class="line">    "examined_rows":4000,</span><br><span class="line">    "number_of_tmp_files":10,</span><br><span class="line">    "sort_buffer_size":32728,</span><br><span class="line">    "sort_mode":"&lt;sort_key,rowid&gt;"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>examined_rows的值还是4000，表示用于排序的数据是4000行。但是select @b-@a的结果为5000。除了排序过程外，在排序完成后，还要根据id去原表取值。语句limit 1000，会多读1000行。  <blockquote>
<p>rows_examined。server层调用引擎取一行的时候加1；引擎内部自己调用读取行不加1。  </p>
</blockquote>
</li>
<li>number_of_tmp_file变小，参与排序的行数虽然是4000行，但是每一行都变小了，需要排序的总数据量就变小了，需要的临时问价也变小。  </li>
<li>sort_mode变成了&lt;sort_key,rowid&gt;表示参与排序的只有name和id这两个字段。  </li>
</ul>
<h3 id="对比与优化"><a href="#对比与优化" class="headerlink" title="对比与优化"></a>对比与优化</h3><p>如果MySQL是在使担心排序内存太小，会影响排序效率，才会采用rowid排序算法，这样排序过程中依次可以排序更多行，但是需要再回到原表去取数据。  </p>
<p>如果MySQL认为内存足够大，会优先选择全字段排序，把需要的字段都放到sort_buffer中，这样排序后就会直接从内存里返回查询结果，不用再回到原表去取数据。  </p>
<p>MySQL做排序是一个成本比较高的操作。并不是所有的order by语句，都需要排序操作。因为原来的数据是无序的，所以MySQL需要生成临时表，并且在临时表上做排序操作。  </p>
<h4 id="创建查询条件字段和排序字段的联合索引"><a href="#创建查询条件字段和排序字段的联合索引" class="headerlink" title="创建查询条件字段和排序字段的联合索引"></a>创建查询条件字段和排序字段的联合索引</h4><blockquote>
<p>alter table t add index city_user(city, name);  </p>
</blockquote>
<p>在联合索引里面，可以用树搜索的方式定位到第一个满足city=’杭州’的记录，并且额外保证了，接下来按顺序取”下一条记录”的遍历过程中，只要city的值是杭州，name的值就一定是有序的。  </p>
<ol>
<li>从索引(city,name)找到第一个满足city=’杭州’条件的主键id;  </li>
<li>到主键id索引取出整行，取name、city、age三个字段的值，作为结果集的一部分直接返回；  </li>
<li>从索引(city,name)取下一条记录主键id；  </li>
<li>重复步骤2、3，直到查到第1000条记录，或者是不满足city=’杭州’条件时循环结束。  </li>
</ol>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>partitions</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>filtered</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>T</td>
<td>NULL</td>
<td>ref</td>
<td>city,city_user</td>
<td>city_user</td>
<td>51</td>
<td>const</td>
<td>4000</td>
<td>100.00</td>
<td>Using index condition</td>
</tr>
</tbody></table>
<p>这个查询过程不需要临时表，也不需要排序。<br>Extra字段中没有Using filesort，不需要排序。而且由于(city,name)这个联合索引本身有序，所以查询也不用把4000行全都读一遍，只要找到满足条件的前1000条记录就可以退出了，只需要扫描1000次。  </p>
<h4 id="创建覆盖索引避免回表"><a href="#创建覆盖索引避免回表" class="headerlink" title="创建覆盖索引避免回表"></a>创建覆盖索引避免回表</h4><blockquote>
<p>alter table t add index city_user_age(city,name,age);  </p>
</blockquote>
<p>对于city字段的值相同的行来说，还是按照name字段的值递增排序的，此时的查询语句也不再需要排序了。  </p>
<ol>
<li>从索引(city、name、age)找到第一个满足city=’杭州’条件的记录，取出其中的city、name、age三个字段的值，作为结果集的一部分直接返回；  </li>
<li>从索引(city、name、age)取下一个记录，同样取出这三个字段的值，作为结果集的一部分直接返回；  </li>
<li>重复执行步骤2，直到查到第1000条记录，或者是不满足city=’杭州’条件时循环结束。  </li>
</ol>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>partitions</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>filtered</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>T</td>
<td>NULL</td>
<td>ref</td>
<td>city,city_user,city_user_age</td>
<td>city_user_age</td>
<td>51</td>
<td>const</td>
<td>4000</td>
<td>100.00</td>
<td>Using where;Using index</td>
</tr>
</tbody></table>
<p>Extra字段多了”Using index”，表示使用了覆盖索引，性能上会快很多。<br>索引维护代价需要权衡。  </p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><blockquote>
<p>select * from t where city in (“杭州”,”苏州”) order by name limit 100;  </p>
</blockquote>
<p>联合索引(city,name)对于单个city内部，name是递增的；对于多个city则所有满足条件的name不是递增的，需要排序。  </p>
<p>避免排序：  </p>
<ol>
<li>执行select * from t where city = “杭州” order by name limit 100;这个语句不需要排序，客户端用一个长度为100的内存数组A保存结果。  </li>
<li>执行select * from t where city = “苏州” order by name limit 100;同上，结果存在内存数组B。  </li>
<li>对于两个有序数组A、B，用归并排序的思想，得到name最小的前100值。  </li>
</ol>
<p>进一步limit 100–&gt;limit 10000,100;处理方式类似。但数据库返回给客户端的数据量变大。<br>优化select *–&gt;select id,name;取值并排序后，拿到100个id值再到数据中查出所有记录。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>随机排序</title>
    <url>/MySQL/%E9%9A%8F%E6%9C%BA%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>随机选择三个记录。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        单词表
    </div>
    <div class='spoiler-content'>
        <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `words` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `word` varchar(64) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="built_in">int</span>;</span><br><span class="line">  <span class="keyword">set</span> i=<span class="number">0</span>;</span><br><span class="line">  while i&lt;10000 do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> words(word) <span class="keyword">values</span>(<span class="keyword">concat</span>(<span class="built_in">char</span>(<span class="number">97</span>+(i <span class="keyword">div</span> <span class="number">1000</span>)), <span class="built_in">char</span>(<span class="number">97</span>+(i % <span class="number">1000</span> <span class="keyword">div</span> <span class="number">100</span>)), <span class="built_in">char</span>(<span class="number">97</span>+(i % <span class="number">100</span> <span class="keyword">div</span> <span class="number">10</span>)), <span class="built_in">char</span>(<span class="number">97</span>+(i % <span class="number">10</span>))));</span><br><span class="line">    <span class="keyword">set</span> i=i+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> idata();</span><br></pre></td></tr></table></figure>
    </div>
</div>  
<h3 id="内存临时表"><a href="#内存临时表" class="headerlink" title="内存临时表"></a>内存临时表</h3><p>随机排序取前3个。  </p>
<blockquote>
<p>explain select word from words order by rand() limit 3;  </p>
</blockquote>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>partitions</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>filtered</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>words</td>
<td>NULL</td>
<td>ALL</td>
<td>NULL</td>
<td>NULL</td>
<td>NULL</td>
<td>NULL</td>
<td>9980</td>
<td>100.00</td>
<td>Using temporary;Using filesort</td>
</tr>
</tbody></table>
<ul>
<li>Extra字段显示Using temporary，表示的是需要使用临时表；Using filesort，表示的是需要执行排序操作。（需要临时表，并且需要在临时表上排序）  </li>
</ul>
<p>对于InnoDB表，执行全字段排序会减少磁盘访问。<br>对于内存表，回表过程只是简单的根据数据行的位置，直接访问内存得到数据，根本不会导致多访问磁盘。用于排序的行越小越好，优先选择rowid排序。<br>针对临时表，小的用memory引擎，大的用innodb引擎。  </p>
<p>执行流程：  </p>
<ol>
<li>创建一个临时表。临时表使用的是memory引擎，表里两个字段，第一个字段是double类型，记为字段R，第二个字段是varchar(64)类型，记为字段W。这个表没有建索引。  </li>
<li>从words表中，按主键顺序取出所有word值。对于每一个word值，调用rand()函数生成一个大于0小于1的随机小数，并把这个随机小数和word分别存入临时表R和W字段中，此时扫描行数为10000。  </li>
<li>临时表有10000行数据，接下来在这个没有索引的内存临时表上，按照字段R排序。  </li>
<li>初始化sort_buffer。sort_buffer中有两个字段，一个是double类型，另一个是整型。</li>
<li>从内存临时表中一行一行的取出R值和<strong>位置信息</strong>，分别存入sort_buffer中的两个字段里。这个过程要对内存临时表做全表扫描，此时扫描行数增加10000，为20000。  </li>
<li>在sort_buffer中根据R的值进行排序。这个过程没有涉及到表操作，不会增加扫描行数。  </li>
<li>排序完成后，取出前三个结果的<strong>位置信息</strong>，依次到内存临时表中取出word值，返回给客户端。访问了表的三行数据，总扫描函数变成了20003。  </li>
</ol>
<hr>
<h4 id="MySQL的表定位“一行数据”的方法"><a href="#MySQL的表定位“一行数据”的方法" class="headerlink" title="MySQL的表定位“一行数据”的方法"></a>MySQL的表定位“一行数据”的方法</h4><p>如果创建的表没有主键，或者把一个表的主键删掉了，那么InnoDB会自己生成一个<strong>长度为6字节的rowid来作为主键</strong>。<strong>每个引擎用来唯一标识数据行的信息</strong>。  </p>
<ul>
<li>有主键的InnoDB表，rowid就是主键ID；  </li>
<li>没有主键的InnoDB表，rowid就是由系统生成的；  </li>
<li>MEMORY引擎不是索引组织表。可以认为它就是一个数组，rowid是数组的下标。  </li>
</ul>
<p>order by rand()使用了内存临时表，内存临时表排序的时候使用了rowid排序方法。  </p>
<h3 id="磁盘临时表"><a href="#磁盘临时表" class="headerlink" title="磁盘临时表"></a>磁盘临时表</h3><p>tmp_table_size这个配置限制了内存临时表的大小，默认值是16M。如果临时表大小超过了tmp_table_size，那么内存临时表就会转成磁盘临时表。  </p>
<p>磁盘临时表使用的引擎默认是InnoDB，由参数internal_tmp_disk_storage_engine控制。  </p>
<p>当使用磁盘临时表的时候，对应的就是一个没有显式索引的InnoDB表的排序过程。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        磁盘临时表
    </div>
    <div class='spoiler-content'>
        <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 单位字节(Byte)。1Byte=8bit</span></span><br><span class="line"><span class="keyword">set</span> tmp_table_size=<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">set</span> sort_buffer_size=<span class="number">32768</span>;</span><br><span class="line"><span class="keyword">set</span> max_length_for_sort_data=<span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打开 optimizer_trace，只对本线程有效 */</span></span><br><span class="line"><span class="keyword">SET</span> optimizer_trace=<span class="string">'enabled=on'</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 执行语句 */</span></span><br><span class="line"><span class="keyword">select</span> word <span class="keyword">from</span> words <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">rand</span>() <span class="keyword">limit</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查看 OPTIMIZER_TRACE 输出 */</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`information_schema`</span>.<span class="string">`OPTIMIZER_TRACE`</span>\G</span><br><span class="line"><span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span> <span class="keyword">json</span>  </span><br><span class="line"><span class="string">"filesort_priority_queue_optimization"</span>:&#123;</span><br><span class="line">    <span class="string">"limit"</span>:<span class="number">3</span>,</span><br><span class="line">    <span class="string">"rows_estimate"</span>:<span class="number">1213</span>,</span><br><span class="line">    <span class="string">"row_size"</span>:<span class="number">14</span>,</span><br><span class="line">    <span class="string">"memory_available"</span>:<span class="number">32768</span>,</span><br><span class="line">    <span class="string">"chosen"</span>:<span class="literal">true</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"filesort_execution"</span>:[],</span><br><span class="line"><span class="string">"filesort_summary"</span>:&#123;</span><br><span class="line">    <span class="string">"rows"</span>:<span class="number">4</span>,</span><br><span class="line">    <span class="string">"examined_rows"</span>:<span class="number">10000</span>,</span><br><span class="line">    <span class="string">"number_of_tmp_files"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="string">"sort_buffer_size"</span>:<span class="number">88</span>,</span><br><span class="line">    <span class="string">"sort_mode"</span>:<span class="string">"&lt;sort_key,rowid&gt;"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<ul>
<li>将max_length_for_sort_data=16，小于word字段的长度定义。sort_mode显示的是rowid排序，参与排序的是随机值R字段和rowid字段组成的行。  </li>
<li>R字段存放的随机值是8个字节，rowid是6个字节，数据总行数是10000，总共140000字节，超过sort_buffer_size为32768字节。number_of_tmp_files为0，表示不使用临时文件。  </li>
</ul>
<p>MySQL5.6引入优先队列排序算法。没有使用临时文件算法—归并排序算法(所有数据有序，浪费计算量)。  </p>
<p>执行流程：  </p>
<ol>
<li>对于10000个准备排序的(R,rowid)，先取前三行，构造一个堆；  </li>
<li>取下一个行(R’,rowid’)，跟当前堆里最大的R比较，如果R’小于R，把这个(R,rowid)从堆中去掉，换成(R’,rowid’)；   </li>
<li>重复第2步，直到第10000个(R’,rowid’)完成比较。  </li>
</ol>
<p>流程结束，堆中就是10000行中R值最小的三行，依次取出rowid，到临时表中拿到word字段。  </p>
<p>OPTIMIZER_TRACE结果中，filesort_priority_queue_optimization.chosen=true；表示使用优先级队列排序算法，不需要临时文件，对应的filesort_summary.number_of_tmp_files=0。  </p>
<blockquote>
<p>limit参数，影响排序算法，最小堆的维护代价小于sort_buffer_size时采用优先队列排序。  </p>
</blockquote>
<h3 id="随机排序方法"><a href="#随机排序方法" class="headerlink" title="随机排序方法"></a>随机排序方法</h3><p>无论使用哪种类型的临时表，order by rand()都会让计算过程非常复杂，需要大量的的扫描行数，排序过程的资源消耗也很大。  </p>
<h4 id="随机算法1"><a href="#随机算法1" class="headerlink" title="随机算法1"></a>随机算法1</h4><ol>
<li>取表的主键ID的最大值M和最小值N；  </li>
<li>用随机函数生成一个最大值到最小值之间的数X=(M-N)*rand()+N;  </li>
<li>取不小于X的第一个ID的行。  </li>
</ol>
<blockquote>
<p>select max(id),min(id) into @M,@N from t;<br>set @X= floor((@M-@N+1)*rand() + @N);<br>select * from t where id &gt;= @X limit 1;  </p>
</blockquote>
<p>取max(id)和min(id)走索引但不需要扫描索引，第三步的select可以用索引快速定位，综合扫描3行。  </p>
<h4 id="随机算法2"><a href="#随机算法2" class="headerlink" title="随机算法2"></a>随机算法2</h4><ol>
<li>取整个表的行数，记为C。  </li>
<li>取得Y=floor(C*rand())。floor函数取整数部分。  </li>
<li>用limitY,1取得一行。  </li>
</ol>
<blockquote>
<p>select count(*) into @C from t;<br>set @Y = floor(@C * rand());<br>set @sql = concat(“select * from t limit “, @Y, “,1”);<br>prepare stmt from @sql;<br>execute stmt;<br>DEALLOCATE prepare stmt;  </p>
</blockquote>
<p>解决了算法1的概率不均匀问题。(算法1要求ID中间没有空洞，否则选择不同行的概率不一样)  </p>
<p><strong>MySQL处理limit Y,1的做法是按顺序一个一个的读出来，丢掉前Y个，然后把下一个记录作为返回结果，这一步需要扫描Y+1行。</strong>加上第一步扫描的C行，总共需要扫描C+Y+1行，执行代价比算法1高，比直接order by rand()低。  </p>
<blockquote>
<p>limit获取数据的时候是根据主键排序获取的，主键索引天然有序，比order by rand()方法组成临时表R字段排序再获取rowid代价小。</p>
</blockquote>
<h4 id="随机算法3"><a href="#随机算法3" class="headerlink" title="随机算法3"></a>随机算法3</h4><ol>
<li>取整个表的行数，记为C。  </li>
<li>根据相同的随机方法得到Y1、Y2、Y3。  </li>
<li>执行三个limitY,1语句得到三行数据。  </li>
</ol>
<blockquote>
<p>select count(*) into @C from t;<br>set @Y1 = floor(@C * rand());<br>set @Y2 = floor(@C * rand());<br>set @Y3 = floor(@C * rand());<br>select * from t limit @Y1，1； //在应用代码里面取Y1、Y2、Y3值，拼出SQL后执行<br>select * from t limit @Y2，1；<br>select * from t limit @Y3，1；  </p>
</blockquote>
<p>总的扫描行数C+(Y1+1)+(Y2+1)+(Y3+1)。  </p>
<h4 id="随机算法4"><a href="#随机算法4" class="headerlink" title="随机算法4"></a>随机算法4</h4><p>取Y1、Y2、Y3里面最大的一个数，记为M，最小的一个数记为N。</p>
<blockquote>
<p>select * from t limit N,M-N+1;  </p>
</blockquote>
<p>总的扫描行数C+M+1。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>简单查询执行慢解析</title>
    <url>/MySQL/%E7%AE%80%E5%8D%95%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C%E6%85%A2%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        样例
    </div>
    <div class='spoiler-content'>
        <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `c` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="built_in">int</span>;</span><br><span class="line">  <span class="keyword">set</span> i=<span class="number">1</span>;</span><br><span class="line">  while(i&lt;=100000) do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(i,i);</span><br><span class="line">    <span class="keyword">set</span> i=i+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> idata();</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<h3 id="第一类：查询长时间不返回"><a href="#第一类：查询长时间不返回" class="headerlink" title="第一类：查询长时间不返回"></a>第一类：查询长时间不返回</h3><p>select * from t where id = 1;查询结果长时间不返回。  </p>
<p>一般碰到这种情况，大概率是表t被锁住了。<br>使用show processlist命令查看当前语句处于什么状态。  </p>
<blockquote>
<p>show processlist;<br>或者select * from information_schema.processlist;  </p>
</blockquote>
<h4 id="等MDL锁"><a href="#等MDL锁" class="headerlink" title="等MDL锁"></a>等MDL锁</h4><table>
<thead>
<tr>
<th>Id</th>
<th>User</th>
<th>Host</th>
<th>db</th>
<th>Command</th>
<th>Time</th>
<th>State</th>
<th>Info</th>
</tr>
</thead>
<tbody><tr>
<td>5</td>
<td>root</td>
<td>localhost:61558</td>
<td>test</td>
<td>Query</td>
<td>0</td>
<td>init</td>
<td>show processlist</td>
</tr>
<tr>
<td>7</td>
<td>root</td>
<td>localhost:63852</td>
<td>test</td>
<td>Sleep</td>
<td>31</td>
<td></td>
<td>NULL</td>
</tr>
<tr>
<td>8</td>
<td>root</td>
<td>localhost:63870</td>
<td>test</td>
<td>Query</td>
<td>25</td>
<td>Waiting for table metadata lock</td>
<td>select * from t where id = 1</td>
</tr>
</tbody></table>
<p><strong>Waiting for table metadata lock；表示有一个线程正在表t上请求或者持有MDL写锁，把select语句堵住了。</strong>（MySQL5.7修改了MDL的加锁策略，尽量避免此类问题。)  </p>
<h5 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h5><table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
</tr>
</thead>
<tbody><tr>
<td>lock table t write;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>select * from t where id=1;</td>
</tr>
</tbody></table>
<p>sessionA通过<strong>lock table命令持有表t的MDL写锁</strong>(MySQL5.5，阻止其他线程访问)(InnoDB中除非明确些lock table，否则不会锁表)，sessionB的查询需要获取MDL读锁。sessionB进入等待状态。  </p>
<h5 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h5><p>找到谁持有MDL写锁，kill掉。通过performance_schema和sys系统库处理。(MySQL启动时设置performance_schema=on；相比于设置为off会有10%左右的性能损失)。  </p>
<p><strong>select blocking_pid from sys.schema_table_lock_waits;</strong><br>select * from performance_schema.metadata_locks;  </p>
<blockquote>
<p>通过查询sys.schema_table_lock_waits这张表，直接找出造成阻塞的process id（blocking_pid），把这个连接用kill命令断开即可。  </p>
</blockquote>
<h4 id="等flush"><a href="#等flush" class="headerlink" title="等flush"></a>等flush</h4><table>
<thead>
<tr>
<th>Id</th>
<th>User</th>
<th>Host</th>
<th>db</th>
<th>Command</th>
<th>Time</th>
<th>State</th>
<th>Info</th>
</tr>
</thead>
<tbody><tr>
<td>4</td>
<td>root</td>
<td>localhost:49548</td>
<td>test</td>
<td>Query</td>
<td>38</td>
<td>User sleep</td>
<td>select sleep()1 from t</td>
</tr>
<tr>
<td>5</td>
<td>root</td>
<td>localhost:49604</td>
<td>test</td>
<td>Query</td>
<td>35</td>
<td>Waiting for table flush</td>
<td>sflush tables t</td>
</tr>
<tr>
<td>6</td>
<td>root</td>
<td>localhost:49634</td>
<td>test</td>
<td>Query</td>
<td>30</td>
<td>Waiting for table flush</td>
<td>select * from t where id=1</td>
</tr>
<tr>
<td>7</td>
<td>root</td>
<td>localhost:49726</td>
<td>test</td>
<td>Query</td>
<td>0</td>
<td>starting</td>
<td>show processlist</td>
</tr>
</tbody></table>
<p><strong>Waiting for table flush：表示有一个线程正要对表t做flush操作。有一个flush tables命令被别的语句堵住了(flush之前必须等待所有语句执行完成(包括select))，然后它又堵住了select语句。</strong>MySQL对表做flush操作有两种用法  </p>
<ul>
<li>flush tables t with read lock;– 只关闭表t；  </li>
<li>flush tables with read lock;– 关闭MySQL里所有打开的表(FTWRL加全局读锁，让整个库处于只读状态。flush过程中(关闭表)，查询也不行???)；  </li>
</ul>
<h5 id="复现-1"><a href="#复现-1" class="headerlink" title="复现"></a>复现</h5><table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
<th>sessionC</th>
</tr>
</thead>
<tbody><tr>
<td>select sleep(1) from t;</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>flush tables t;</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>select * from t where id=1;</td>
</tr>
</tbody></table>
<p>sessionA中每行都调用一次sleep(1)，这个语句默认要执行10W秒，在这期间表t一直是被sessionA“打开”着。sessionB的flush tables t命令要去关闭表t，就需要等sessionA的查询结束。sessionC再次查询的话，会被flush命令堵住。  </p>
<h5 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h5><p>同上</p>
<h4 id="等行锁-InnoDB引擎"><a href="#等行锁-InnoDB引擎" class="headerlink" title="等行锁(InnoDB引擎)"></a>等行锁(InnoDB引擎)</h4><table>
<thead>
<tr>
<th>Id</th>
<th>User</th>
<th>Host</th>
<th>db</th>
<th>Command</th>
<th>Time</th>
<th>State</th>
<th>Info</th>
</tr>
</thead>
<tbody><tr>
<td>4</td>
<td>root</td>
<td>localhost:65224</td>
<td>test</td>
<td>Query</td>
<td>0</td>
<td>starting</td>
<td>show processlist</td>
</tr>
<tr>
<td>8</td>
<td>root</td>
<td>localhost:10354</td>
<td>test</td>
<td>Query</td>
<td>1</td>
<td>statistics</td>
<td>select * from t where id=1 lock in share mode</td>
</tr>
<tr>
<td>10</td>
<td>root</td>
<td>localhost:11276</td>
<td>test</td>
<td>Sleep</td>
<td>52</td>
<td></td>
<td>NULL</td>
</tr>
</tbody></table>
<p>访问id=1这个记录时要加读锁，如果这时已经有一个事务在这行记录上持有一个写锁，select语句就会被堵住。  </p>
<h5 id="复现-2"><a href="#复现-2" class="headerlink" title="复现"></a>复现</h5><table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
</tr>
</thead>
<tbody><tr>
<td>begin;</td>
<td></td>
</tr>
<tr>
<td>update t set c=c+1 where id=1;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>select * from t where id=1 lock in share mode;</td>
</tr>
</tbody></table>
<p>sessionA启动了事务，占有写锁，还不提交，导致sessionB被堵住。</p>
<h5 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h5><p>MySQL5.7，通过sys.innodb_lock_waits表查到谁占着写锁，kill掉链接。  </p>
<p><strong>select blocking_pid from t sys.innodb_lock_waits where locked_table=’<code>test</code>.<code>t</code>‘;</strong>  </p>
<blockquote>
<p>假设4号线程是造成堵塞的罪魁祸首，”kill query 4”命令表示停止4号线程当前正在执行的语句，这个方法没有用。占行锁的是update语句，这个语句已经是之前执行完成了的，执行kill query无法让这个事务去掉id=1上的行锁。<br>“kill 4”命令表示直接断开这个链接。隐含的逻辑是，连接被断开的时候，会自动回滚这个链接里面正在执行的线程，也就释放了id=1上的行锁。  </p>
</blockquote>
<h3 id="第二类：查询慢"><a href="#第二类：查询慢" class="headerlink" title="第二类：查询慢"></a>第二类：查询慢</h3><h4 id="扫描行数多"><a href="#扫描行数多" class="headerlink" title="扫描行数多"></a>扫描行数多</h4><blockquote>
<p>set long_query_time=0;– 慢查询日志的时间阈值设置为0;</p>
</blockquote>
<p>select * from t where c=50000 limit 1;  </p>
<blockquote>
<p>Query_time:0.011543 Lock_time:0.000104 Rows_sent:1 Rows_examined:50000 SET timestamp=1544723147;– slow log慢查询日志  </p>
</blockquote>
<p>字段c上没有索引，这个语句只能走id主键顺序扫描，需要扫描5w行。  </p>
<h4 id="扫描一行，一致性读事务期间大量更新"><a href="#扫描一行，一致性读事务期间大量更新" class="headerlink" title="扫描一行，一致性读事务期间大量更新"></a>扫描一行，一致性读事务期间大量更新</h4><p>select * from t where id=1;  </p>
<blockquote>
<p>Query_time:0.804400 Lock_time:0.000132205 Rows_sent:1 Rows_examined:1 SET timestamp=1544728393;</p>
</blockquote>
<p>select * from t where id=1 lock in share mode;  </p>
<blockquote>
<p>Query_time:0.000258 Lock_time:0.000132 Rows_sent:1 Rows_examined:1 SET timestamp=1544728398;</p>
</blockquote>
<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
</tr>
</thead>
<tbody><tr>
<td>start transaction with consistent snapshot</td>
<td></td>
</tr>
<tr>
<td></td>
<td>update t set c=c+1 where id=1;//执行100W次</td>
</tr>
<tr>
<td>select * from t where id=1;</td>
<td></td>
</tr>
<tr>
<td>select * from t where id=1 lock in share mode;</td>
<td></td>
</tr>
</tbody></table>
<p>sessionA先用start transaction with consistent snapshot命令启动了一个事务，之后sessionB才开始执行update语句。<br>sessionB更新完100W次，生成了100W个回滚日志(undo log)。  </p>
<p>带lock in share mode的SQL语句，是当前读，直接读到1000001这个结果，所以速度很快；而select * from t where id=1这个语句，是一致性读，需要从当前1000001开始，依次执行undo log，执行100W次后，才将1这个结果返回，所以速度慢。  </p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>只要访问表，增删改查就要加MDL读锁。快照读没有读锁。  </p>
<p>read-commited隔离级别下，update语句有一个“semi-consistent”read优化:<br>一个update语句，如果读到一行已经加锁的记录，此时InnoDB返回记录最近提交的最新版本，由MySQL上层判断此版本是否满足update的where条件。若满足(需要更新)，则MySQL会重新发起一次读操作，此时会读取行的最新版本并加锁(锁等待)；对于扫描返回的不满足条件的记录，会提前释放锁。  </p>
<blockquote>
<p>(如果update语句碰到一个已经被锁了的行，会读入最新的版本，然后判断一下是不是满足查询条件，如果不满足则直接跳过，如果满足就进入锁等待。在语句执行完成后，只有行锁，而且语句执行完成后，InnoDB就会把不满足条件的行的行锁去掉，满足条件的行锁等到commit的时候才会释放)  </p>
</blockquote>
<p>repeatable-read隔离级别下，对于具有唯一搜索条件的唯一索引，InnoDB只锁定找到的索引记录，而不锁定其前面的间隙。对于update或delete语句，InnoDB只对其更新或者删除的行持有锁。在MySQL评估where条件之后，将释放非匹配行的记录锁，大大降低了死锁的可能性，但死锁仍可能发生。<br>为了保证binlog记录顺序，<strong>非索引更新则会锁住全表记录</strong>(无索引字段，一行一行逐一给所有行加行锁(在主键索引上)，不会加表锁)，且事务结束前不会对不符合条件记录有逐步释放的过程。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>幻读</title>
    <url>/MySQL/%E5%B9%BB%E8%AF%BB/</url>
    <content><![CDATA[<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        样例
    </div>
    <div class='spoiler-content'>
        <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">'t'</span> (</span><br><span class="line">    <span class="string">'id'</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="string">'c'</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="string">'d'</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line">    primary <span class="keyword">key</span> (<span class="string">'id'</span>),</span><br><span class="line">    <span class="keyword">key</span> <span class="string">'c'</span> (<span class="string">'c'</span>)</span><br><span class="line">) <span class="keyword">engine</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<blockquote>
<p>begin;<br>select * from t where d=5 for update;<br>commit;  </p>
</blockquote>
<p>这个语句会命中d=5这一行，对应的主键id=5，在select语句执行完成后，id=5这一行会加一个写锁，由于两阶段锁协议，这个写锁会在执行commit语句的时候释放。（由于字段d上没有索引，这条查询语句会做全表扫描。其他被扫描到的，但是不满足条件的记录也会加锁）  </p>
<h3 id="理解幻读"><a href="#理解幻读" class="headerlink" title="理解幻读"></a>理解幻读</h3><p>假设：  </p>
<table>
<thead>
<tr>
<th></th>
<th>sessionA</th>
<th>sessionB</th>
<th>sessionC</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>begin;  select * from t where d=5 for update;– Q1 (5,5,5)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td></td>
<td>update t set d=5 where id=0;</td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td>select * from t where d=5 for update;– Q2 (0,0,5),(5,5,5)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td></td>
<td>insert into t values(1,1,5);</td>
</tr>
<tr>
<td>T5</td>
<td>select * from t where d=5 for update;– Q3 (0,0,5),(1,1,5),(5,5,5)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>T6</td>
<td>commit;</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>sessionA执行了三次查询：Q1、Q2、Q3。它们的SQL语句相同。select * from t where d=5 for update;查所有d=5的行，而且使用的是当前读，能读到所有已经提交的记录的最新值，并且加上写锁。  </p>
<p>Q3读到id=1这一行的现象被称为“幻读”。<br><strong>幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。</strong>  </p>
<ul>
<li>在可重复读隔离级别下，普通的查询时快照读，是不会看到别的事务插入的数据的。幻读在“当前读”下才会出现。  </li>
<li>sessionB的修改结果，被sessionA之后的select语句用“当前读”看到，不能成为幻读。幻读仅专指“新插入的行”。  </li>
</ul>
<h3 id="幻读引发的问题"><a href="#幻读引发的问题" class="headerlink" title="幻读引发的问题"></a>幻读引发的问题</h3><h4 id="语义上的问题"><a href="#语义上的问题" class="headerlink" title="语义上的问题"></a>语义上的问题</h4><p>sessionA在T1时刻声明，把所有d=5的行锁住，不准别的事务进行读写操作，只给id=5这一行加了行锁。sessionB和sessionC中的语句正常修改，会产生新的d=5的行，破坏了sessionA中Q1语句要锁住所有d=5的行的加锁声明。  </p>
<h4 id="数据一致性问题"><a href="#数据一致性问题" class="headerlink" title="数据一致性问题"></a>数据一致性问题</h4><p>锁的设计是为了保证数据的一致性。不只是数据库内部数据状态在此刻的一致性，还包含了数据和日志在逻辑上的一致性。  </p>
<p>sessionA在T1时刻加一个更新语句：update t set d=100 where d=5;<br>数据库中结果：  </p>
<ul>
<li>T1时刻后，id=5这一行变成(5,5,100)，这个最终结果是在T6时刻正式提交的；</li>
<li>T2时刻后，id=0这一行变成(0,0,5);</li>
<li>T4时刻后，表里多了一行(1,1,5);</li>
</ul>
<p>binlog中内容：  </p>
<ul>
<li>T2时刻，sessionB事务提交，写入了一条语句；</li>
<li>T4时刻，sessionC事务提交，写入了一条语句；</li>
<li>T6时刻，sessionA事务提交，写入了update t set d=100 where d=5这条语句。（所有d=5的行，d改成100）</li>
</ul>
<p>使用binlog的语句序列，拿到备库执行或者克隆一个库，这三行结构都变成了(0,0,100),(1,1,100),(5,5,100)。产生了数据不一致。  </p>
<p>数据不一致是因为select * from t where d=5 for update只给d=5这一行，也就是id=5这一行加锁导致的。  </p>
<p>即使把扫描过程中碰到的行，都加上写锁(当前存在的所有行)，也只能解决update语句导致的数据不一致问题(sessionB被锁住，等到sessionA提交后才能继续执行)。但是阻止不了insert语句新插入记录，加锁的时候新插入的记录行不存在，不存在也就加不上锁(无锁可随意修改并先提交，若sessionC中加一条把d改成5的操作并先提交，根据日志语句序列依然会导致主从数据不一致)。</p>
<h3 id="解决幻读"><a href="#解决幻读" class="headerlink" title="解决幻读"></a>解决幻读</h3><h4 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h4><p>产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。为了解决幻读问题，InnoDB引入了新的锁—间隙锁(Gap Lock)。间隙锁锁的是两个值之间的空隙。  </p>
<p>执行select * from t where d=5 for update;时，不止是给数据中已有的6个记录加上了行锁，还同时加了7个间隙锁。确保了无法再插入新的记录。  </p>
<p><strong>行锁分成读锁和写锁。读读兼容，读写、写写冲突。跟行锁有冲突关系的是“另外一个行锁”。</strong>  </p>
<p><strong>间隙锁之间都不存在冲突关系。跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作。</strong>  </p>
<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
</tr>
</thead>
<tbody><tr>
<td>begin;select * from t where c=7 lock in share mode;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>begin;select * from t where c=7 for update;</td>
</tr>
</tbody></table>
<p>sessionB并不会被堵住，表t中没有c=7这个记录，因此sessionA加的是间隙锁(5,10)。而sessionB也是在这个间隙加的间隙锁。它们有共同的目标：保护这个间隙，不允许插入值，但是它们之间是不冲突的。  </p>
<h4 id="next-key-lock"><a href="#next-key-lock" class="headerlink" title="next-key lock"></a>next-key lock</h4><p>间隙锁和行锁合称next-key lock，每个next-key lock是前开后闭区间。示例表可以形成7个next-key lock：(-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20,25]、(25,+suprenum]。  </p>
<blockquote>
<p>间隙锁为开区间，next-key lock为前开后闭区间。<br>+∞是开区间。InnoDB给每个索引加了一个不存在的最大值supremum，符合前开后闭区间。  </p>
</blockquote>
<h4 id="新的问题"><a href="#新的问题" class="headerlink" title="新的问题"></a>新的问题</h4><p><strong>间隙锁和next-key lock的引入，解决了幻读的问题，但可能会导致同样的语句锁住更大的范围，影响了并发度。</strong></p>
<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
</tr>
</thead>
<tbody><tr>
<td>begin;select * from t where id=9 for update;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>begin;select * from t where id=9 for update;</td>
</tr>
<tr>
<td></td>
<td>insert into t values(9,9,9);– blocked</td>
</tr>
<tr>
<td>insert into t values(9,9,9);– error 1213(40001):deadlock found</td>
<td></td>
</tr>
</tbody></table>
<ol>
<li>sessionA执行select…for update语句，由于id=9这一行并不存在，因此会加上间隙锁(5,10)；</li>
<li>sessionB执行select…for update语句，同样会加上间隙锁(5,10)，间隙锁之间不会冲突，这个语句可以执行成功；</li>
<li>sessionB视图插入一行(9,9,9)，被sessionA的间隙锁挡住了，只好进入等待；</li>
<li>sessionA视图插入一行(9,9,9)，被sessionA的间隙锁挡住了。  </li>
</ol>
<p>两个session进入互相等待状态，形成死锁。(InnoDB的死锁检测马上就发现了这对死锁关系，让sessionA的insert语句报错返回)  </p>
<blockquote>
<p>只有一个唯一索引的时候，可以用insert…on duplicate key update语法避免死锁</p>
</blockquote>
<p>间隙锁是可重复读隔离级别下才会生效的。如果把隔离级别设置为读提交，就没有间隙锁了。但要解决可能出现的数据和日志不一致问题，需要把binlog格式设置为row。(set transaction_isolation=’read-committed’;set binlog_format=’row’)  </p>
<blockquote>
<p>innodb_locks_unsafe_for_binlog=1;表示不加间隙锁</p>
</blockquote>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>应急性能提升手段</title>
    <url>/MySQL/%E5%BA%94%E6%80%A5%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87%E6%89%8B%E6%AE%B5/</url>
    <content><![CDATA[<h3 id="短连接风暴"><a href="#短连接风暴" class="headerlink" title="短连接风暴"></a>短连接风暴</h3><p>正常的短连接模式是连接到数据库后，执行很少的SQL语句就断开，下次需要的时候再重连。使用短连接，在业务高峰期的时候，可能出现连接数突然暴涨的情况。MySQL建立连接的过程成本很高，除了网络连接三次握手外，还要做登录权限判断和获取该连接的读取权限。  </p>
<p>max_connextions参数，控制一个MySQL实例同时存在的连接数的上限，超过这个值，系统就会拒绝接下来的连接请求，并报错提示“Too many connections”，对业务来说就是数据库不可用。<br>负载比较高时，单纯调高max_connections的值，让更多的连接进来，会让系统的负载进一步加大，资源耗费在权限验证逻辑上，适得其反，导致已连接线程拿不到CPU资源去执行业务的SQL请求。</p>
<h4 id="1-先处理掉那些占着连接但是不工作的线程"><a href="#1-先处理掉那些占着连接但是不工作的线程" class="headerlink" title="1.先处理掉那些占着连接但是不工作的线程"></a>1.先处理掉那些占着连接但是不工作的线程</h4><p>max_connections的计算，不是看谁在running，只要连着就占用一个计数位置。对于不需要保持的连接，可以通过kill connection主动踢掉。<br>wait_timeout参数，表示一个线程空闲wait_timeout这么多秒之后，就会被MySQL直接断开连接。  </p>
<table>
<thead>
<tr>
<th></th>
<th>sessionA</th>
<th>sessionB</th>
<th>sessionC</th>
</tr>
</thead>
<tbody><tr>
<td>T</td>
<td>begin;</br>insert into t values(1,1);</td>
<td>select * from t where id=1;</td>
<td></td>
</tr>
<tr>
<td>T+30s</td>
<td></td>
<td></td>
<td>show processlist</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>id</th>
<th>user</th>
<th>host</th>
<th>db</th>
<th>command</th>
<th>time</th>
<th>state</th>
<th>info</th>
</tr>
</thead>
<tbody><tr>
<td>4</td>
<td>root</td>
<td>localhost:xxxxx</td>
<td>test</td>
<td>sleep</td>
<td>30</td>
<td></td>
<td>null</td>
</tr>
<tr>
<td>5</td>
<td>root</td>
<td>localhost:yyyyy</td>
<td>test</td>
<td>sleep</td>
<td>30</td>
<td></td>
<td>null</td>
</tr>
<tr>
<td>6</td>
<td>root</td>
<td>localhost:zzzzz</td>
<td>test</td>
<td>query</td>
<td>0</td>
<td>starting</td>
<td>show processlist</td>
</tr>
</tbody></table>
<p>会话4、5都是sleep状态，查询information_schema库的innodb_trx表查看事务具体状态：<br>select * from information_schema.innodb_trx;<br>其中trx_mysql_thread_id=4;表示id=4的线程处在事务中。还未提交不宜断开，会导致对应事务回滚。  </p>
<p>如果连接数过多，优先断开事务外空闲太久的连接；如果还不够，再考虑断开事务内空闲太久的连接。  </p>
<p>使用kill connection+id命令从服务器断开连接。一个客户端处于sleep状态时，它的连接被服务器主动断开后，这个客户端不会马上知道，知道客户端发起下一个请求时，才会收到报错”ERROR 2013(HY000):lost connection to MySQL server during query”。  </p>
<p>从数据库端主动断开连接可能是有损的，若应用端接收到错误后，不重新连接，而是直接用这个已经不能用的句柄重试查询，导致从应用端看上去”MySQL一直没恢复”。（<strong>链接异常断开是常有的事，业务开发的应用代码需要有正确的重连并重试的机制。</strong>）  </p>
<h4 id="2-减少连接过程的消耗"><a href="#2-减少连接过程的消耗" class="headerlink" title="2.减少连接过程的消耗"></a>2.减少连接过程的消耗</h4><p>让数据库跳过权限验证阶段：重启数据库，并使用-skip-grant-tables参数启动。整个数据库会跳过所有的权限验证阶段，包括连接过程和语句执行过程。  </p>
<p>跳过权限验证风险极高，MySQL8.0使用时会默认把–skip-networking参数打开，让数据库只能被本地的客户端连接。  </p>
<h3 id="慢查询性能问题"><a href="#慢查询性能问题" class="headerlink" title="慢查询性能问题"></a>慢查询性能问题</h3><ol>
<li>上线前，在测试环境，把慢查询日志(slow log)打开slow_query_log(默认关闭)，并且把long_query_time设置成0(默认值为10)，确保每个语句都会被记录人慢查询日志；  </li>
<li>在测试表里插入模拟线上的数据，做一遍回归测试；  </li>
<li>观察慢查询日志里每类语句的输出，特别留意Rows_examined字段(server层统计值)是否与预期一致。  </li>
</ol>
<p>开源工具pt-query-digest分析。  </p>
<h4 id="索引没有设计好"><a href="#索引没有设计好" class="headerlink" title="索引没有设计好"></a>索引没有设计好</h4><p>通过紧急创建索引解决。(MySQL5.6版本以后，创建索引支持Online DDL，可以直接执行alter table 语句)。  </p>
<p>主库A、备库B：  </p>
<ol>
<li>在备库B上执行set sql_log_bin=off，也就是不写binlog，然后执行alter table语句加上索引；  </li>
<li>执行主备切换；主库B、备库A。  </li>
<li>在A上执行set sql_log_bin=off，然后执行alter table语句加上索引。  </li>
</ol>
<p>使用gh-ost在线ddl变更。  </p>
<h4 id="SQL语句没有写好"><a href="#SQL语句没有写好" class="headerlink" title="SQL语句没有写好"></a>SQL语句没有写好</h4><p><a href="/MySQL/相同逻辑，不同SQL，性能差异">MySQL-相同逻辑，不同SQL，性能差异</a><br>条件字段函数操作、隐式类型转换、隐式字符编码转换等原因，导致语句没有使用上索引。  </p>
<p>通过改写SQL语句来处理。MySQL5.7提供了query_rewrite功能，可以把输入的一种语句改写成另外一种模式。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> query_rewrite.rewrite_rules(pattern,replacement,pattern_database) <span class="keyword">values</span> (<span class="string">"select * from t where id + 1 = ?"</span>,<span class="string">"select * from t where id = ? - 1"</span>,<span class="string">"db1"</span>);  </span><br><span class="line"><span class="keyword">call</span> query_rewrite.flush_rewrite_rules();<span class="comment">-- 让插入的新规则生效</span></span><br></pre></td></tr></table></figure>

<p>查询重写  </p>
<blockquote>
<p>Query ‘select * from t where id + 1 = 10000 ‘ rewritten to ‘select * from t where id = 10000 - 1’ by a query rewrite plugin;</p>
</blockquote>
<h4 id="MySQL选错了索引"><a href="#MySQL选错了索引" class="headerlink" title="MySQL选错了索引"></a>MySQL选错了索引</h4><p><a href="/MySQL/索引选择异常及处理">MySQL-索引选择异常及处理</a>  </p>
<p>应急方案给这个语句加上force index。<br>使用查询重写功能，给原来的语句佳航force index。  </p>
<h3 id="QPS突增问题"><a href="#QPS突增问题" class="headerlink" title="QPS突增问题"></a>QPS突增问题</h3><p>下掉一个功能，从数据库端处理：  </p>
<ol>
<li>由全新业务的bug导致的，确定业务方会下掉这个功能，从数据库端直接把白名单去掉。  </li>
<li>新功能使用的单独的数据库用户，用管理员账号把这个用户删掉，然后断开现有连接。这样新功能的连接不成功，由它引发的QPS就会变成0。  <blockquote>
<p>方案1、2依赖于规范的运维提下：虚拟化、白名单机制、业务账号分离。  </p>
</blockquote>
</li>
<li>新功能跟主体功能部署在一起，只能通过处理语句来限制，使用查询重写功能，把压力最大的SQL语句直接重写成”select 1”返回。  <blockquote>
<p>如果别的功能也用到了这个SQL语句模板，会有误伤。<br>很多业务并不是靠这一个语句就能完成逻辑的，单独改这一个语句，可能会导致后面的业务逻辑一起失败。  </p>
</blockquote>
</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>binlog保证主备一致</title>
    <url>/MySQL/binlog%E4%BF%9D%E8%AF%81%E4%B8%BB%E5%A4%87%E4%B8%80%E8%87%B4/</url>
    <content><![CDATA[<p>binlog可以用来归档，也可以用来做主备同步。  </p>
<h3 id="MySQL主备的基本原理"><a href="#MySQL主备的基本原理" class="headerlink" title="MySQL主备的基本原理"></a>MySQL主备的基本原理</h3><p>客户端的读写直接访问的节点为主库，另一个节点是备库，只是将主库的更新都同步过来，到本地执行。保持主库和备库的数据都是相同的。  </p>
<p>备库没有被直接访问，设置成只读(readonly)模式：  </p>
<ol>
<li>有时候一些运营类的查询语句会被放到备库上去查，设置为只读可以防止误操作；  </li>
<li>防止切换逻辑有bug，比如切换过程中出现双写，造成主备不一致；  </li>
<li>可以用readonly状态，来判断节点的角色。  </li>
</ol>
<p>备库设置成只读，依然能跟主库保持同步更新。readonly设置对超级(super)权限用户是无效的，用于同步更新的线程，拥有超级权限。  </p>
<hr>
<h4 id="主备同步流程"><a href="#主备同步流程" class="headerlink" title="主备同步流程"></a>主备同步流程</h4><img src="/img/MySQL主备流程图.png" width="333" height="333" >

<p>主库接收到客户端的更新请求后，执行内部事务的更新逻辑，同时写binlog。  </p>
<p>备库跟主库之间维持了一个长连接，主库A内部有一个线程，专门服务备库的长连接。</p>
<p>一个事务日志同步的完整过程：  </p>
<ol>
<li>在备库B上通过change master命令，设置主库A的IP、端口、用户名、密码，以及要从哪个位置开始请求binlog，这个位置包含文件名和日志偏移量。  </li>
<li>在备库B上执行start slave命令，这时备库会启动两个线程：io_thread和sql_thread。其中io_thread负责与主库建立连接。  </li>
<li>主库A校验完用户名、密码后，开始按照备库B传过来的位置，从本地读取binlog，发给B。(如果这个文件现在还在page cache中，直接读；如果不在page cache里，就去磁盘读)。(binlog write阶段就发起主从同步日志)  </li>
<li>备库B拿到binlog后，写到本地文件，称为中转日志relay log。  </li>
<li>sql_thread读取中转日志，解析出日志里的命令，并执行(relay log应用后就丢弃了)。(多线程复制方案引入，sql_thread演化成为了多个线程。)  </li>
</ol>
<h3 id="binlog的三种格式对比"><a href="#binlog的三种格式对比" class="headerlink" title="binlog的三种格式对比"></a>binlog的三种格式对比</h3><p>binlog有三种格式：statement、row、mixed。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        binlog示例代码
    </div>
    <div class='spoiler-content'>
        <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`t_modified`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`a`</span> (<span class="string">`a`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`t_modified`</span>(<span class="string">`t_modified`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="string">'2018-11-13'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">2</span>,<span class="number">2</span>,<span class="string">'2018-11-12'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">3</span>,<span class="number">3</span>,<span class="string">'2018-11-11'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">4</span>,<span class="number">4</span>,<span class="string">'2018-11-10'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">5</span>,<span class="number">5</span>,<span class="string">'2018-11-09'</span>);</span><br></pre></td></tr></table></figure>

    </div>
</div>  

<blockquote>
<p>delete from t where a&gt;=4 and t_modified&lt;=’2018-11-10’ limit 1;<br>show binlog events in ‘master.000001’;– 查看binlog中的内容。  </p>
</blockquote>
<h4 id="statement"><a href="#statement" class="headerlink" title="statement"></a>statement</h4><p>binlog记录的是SQL语句的原文。  </p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>mater.000001</td>
<td>5889</td>
<td>Anonymous_Gtid</td>
<td>1</td>
<td>5954</td>
<td>SET @@SESSION.GTID_NEXT=’ANONYMOUS’</td>
</tr>
<tr>
<td>mater.000001</td>
<td>5954</td>
<td>Query</td>
<td>1</td>
<td>6041</td>
<td>BEGIN</td>
</tr>
<tr>
<td>mater.000001</td>
<td>6041</td>
<td>Query</td>
<td>1</td>
<td>6197</td>
<td>use ‘test’;delete from t where a&gt;=4 and t_modified&lt;=’2018-11-10’ limit 1</td>
</tr>
<tr>
<td>mater.000001</td>
<td>6197</td>
<td>Xid</td>
<td>1</td>
<td>6228</td>
<td>COMMIT /*xid=61*/</td>
</tr>
</tbody></table>
<ul>
<li>第一行SET@@SESSION.GTID_NEXT=’ANONYMOUS’；  </li>
<li>第二行begin，跟第四行的commit对应，表示中间是一个事务；  </li>
<li>第三行是真实执行的语句。use ‘test’命令是MySQL根据当前要操作做的表所在的数据库，自行添加的。这样可以保证日志传到备库去执行的时候，不论当前的工作线程在哪个库里，都能够正确的更新到test库的表t。  </li>
<li>第四行commit。xid=61可以查找到redo log与binlog对应的事务。  </li>
</ul>
<p>statement存在的问题：<br>当binlog设置的是statement格式，并且语句中有limit，这个命令可能是unsafe的。可能会出现主备数据不一致的情况：  </p>
<ol>
<li>如果delete语句使用的是索引a，那么会根据索引a找到第一个满足条件的行，也就是说删除的是a=4这一行。  </li>
<li>但如果使用的是索引t_moditied，那么删除的就是t_modified=’2018-11-09’也就是a=5这一行。  </li>
</ol>
<h4 id="row"><a href="#row" class="headerlink" title="row"></a>row</h4><p>binlog中么有SQL语句的原文，替换成了两个event:Table_map和Delete_rows。  </p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>mater.000001</td>
<td>8900</td>
<td>Anonymous_Gtid</td>
<td>1</td>
<td>8965</td>
<td>SET @@SESSION.GTID_NEXT=’ANONYMOUS’</td>
</tr>
<tr>
<td>mater.000001</td>
<td>8965</td>
<td>Query</td>
<td>1</td>
<td>9045</td>
<td>BEGIN</td>
</tr>
<tr>
<td>mater.000001</td>
<td>9045</td>
<td>Table_map</td>
<td>1</td>
<td>9092</td>
<td>table_id:226(test.t)</td>
</tr>
<tr>
<td>mater.000001</td>
<td>9092</td>
<td>Delete_rows</td>
<td>1</td>
<td>9140</td>
<td>table_id:226 flags:STMT_END_F</td>
</tr>
<tr>
<td>mater.000001</td>
<td>9140</td>
<td>Xid</td>
<td>1</td>
<td>9171</td>
<td>COMMIT /*xid=68*/</td>
</tr>
</tbody></table>
<ul>
<li>Table_map event，用于说明接下来要操作的表是test库的表t；  </li>
<li>Delete_rows event，用于定义删除的行为。  </li>
</ul>
<p>借助mysqlbinlog工具解析和查看binlog中的内容：  </p>
<blockquote>
<p>mysqlbinlog -vv data/master.000001 –start-position=8900;– start-position参数指定从8900这个位置的日志开始解析。  </p>
</blockquote>
<img src="/img/MySQL row格式binlog示例的详细信息.png">

<ul>
<li><strong>server id 1，表示这个事务是在server_id=1的这个库上执行的</strong>。(避免循环复制)  </li>
<li>每个event都有CRC32的值，参数binlog_checksum设置为CRC32。  </li>
<li>Table_map event显示了接下来要打开的表，map到数字226。当前SQL语句只操作了一张表，如果要操作多张表，每个表都有一个对应的Table_map event、都会map到一个单独的数字，用于区分对不同表的操作。  </li>
<li>mysqlbinlog命令使用-vv参数可以把内容都解析出来，从结果里可以看到各个字段的值。  </li>
<li>binlog_row_image的默认配置是FULL，Delete_event里面包含了删除的行的所有字段的值。如果把binlog_row_image设置为MINIMAL，则只会记录必要的信息。(如本例删除时只记录id=4)  </li>
<li>Xid event用于表示事物被正确的提交了。  </li>
</ul>
<p>binlog记录了真实删除行的主键id，binlog传到备库去的时候，就肯定会删除id=4的行，不会有主备删除不同行的问题。  </p>
<h4 id="mixed"><a href="#mixed" class="headerlink" title="mixed"></a>mixed</h4><ul>
<li>有些statement格式的binlog可能会导致主备不一致，所以要使用row格式。  </li>
<li>row格式的缺点是很占空间。(用一个delete语句删掉10万行数据，用statement就是一个SQL语句被记录到binlog中，占用几十个字节的空间。用row就要把这10万条记录都写到binlog中，不仅占用更大的空间，写binlog也要耗费更多IO资源，影响执行速度)。  </li>
<li>折中方案mixed。MySQL自己会判断这条SQL语句是否可能引起主备不一致，如果有可能，就用row格式，否则就用statement格式。  </li>
</ul>
<hr>
<blockquote>
<p>insert into t values(10,10,now());– binlog设置为mixed格式  </p>
</blockquote>
<img src="/img/MySQL mixed格式和now().png">
<img src="/img/MySQL timestamp命令.png">

<p>binlog选择了statement格式，在记录event的时候，多记了一条命令：SET TIMESTAMP=1546103491。它用set timestamp命令约定了接下来now()函数的返回时间。  </p>
<p>不论这个binlog是一分钟之后被备库执行，还是3天之后用来恢复这个库的备份，这个insert语句插入的行，值都是固定的。通过这条set timestamp命令，MySQL确保了主备数据的一致性。  </p>
<p><strong>有些语句的执行结果是依赖于上下文命令的，直接执行的结果可能是错误的。用binlog来恢复数据的标准做法是，用mysqlbinlog工具解析出来，然后把解析结果整个发给MySQL执行</strong>:  </p>
<blockquote>
<p>mysqlbinlog master.000001 –start-position=2738<br> –stop-position=2973 | mysql -h127.0.0.1 -P13000 -u$user -p@pwd;<br>将master.00001文件里面从第2738字节到第2938字节中间这段内容解析出来，放到MySQL去执行。  </p>
</blockquote>
<h4 id="数据恢复原理"><a href="#数据恢复原理" class="headerlink" title="数据恢复原理"></a>数据恢复原理</h4><p>binlog格式设置为row，便于数据恢复。  </p>
<ul>
<li>delete语句，row格式的binlog会把被删掉的行的整行信息保存起来。在执行完一条delete语句以后，发现删错数据了，可以直接把binlog中记录的delete语句转成insert，把被错删的数据插入回去就可以恢复了。  </li>
<li>insert语句，row格式下，insert语句的binlog里会记录所有的字段信息，这些信息可以用来精确定位刚刚被插入的那一行，直接把insert语句转成delete语句，删除掉这被误插入的一行数据就可以了。  </li>
<li>update语句，binlog会记录修改前整行的数据和修改后的整行数据。只需要被这个event前后两行信息对调一下，再去数据库里执行，就能恢复这个更新操作了。  </li>
</ul>
<p>MariaDB的Flashback工具回滚数据原理与此相同。  </p>
<h3 id="循环复制问题"><a href="#循环复制问题" class="headerlink" title="循环复制问题"></a>循环复制问题</h3><p>binlog的特性确保了再备库执行相同的binlog，可以得到与主库相同的状态。正常情况下主备的数据是一致的。(流式发送，一个事务提交就会发送)  </p>
<p>M-S结构：一主一备；<br>双M结构：互为主备，切换的时候不用修改主备关系。但任何时刻只有一个节点在接受更新。  </p>
<blockquote>
<p>一开始创建主备关系的时候，是由备库指定的。主备复制关系搭建完成以后，是主库来决定“要发数据给备库”的，主库有生成新的日志，就会发给备库。  </p>
</blockquote>
<p>问题:<br>业务逻辑在节点A上更新了一条语句，然后再把生成的binlog发给节点B，节点B执行完这条语句后也会生成binlog。(参数log_slave_updates设置为on，表示备库执行relay log后生成binlog)  </p>
<p>如果节点A同时是节点B的备库，相当于又把节点B新生成的binlog拿过来执行了一次，然后节点AB之间，会不断的循环执行这个更新语句，导致循环复制。  </p>
<p>MySQL在binlog中记录了这个命令第一次执行时所在实例的server id。来解决两个节点间循环复制的问题：  </p>
<ol>
<li>规定两个库的server id必须不同，如果相同，则它们之间不能设定为主备关系；  </li>
<li>一个备库接到binlog并在重放的过程中，生成与原binlog的server id相同的新的binlog；  </li>
<li>每个库在收到从自己的主库发过来的日志后，先判断server id，如果跟自己的相同，表示这个日志时自己生成的，就直接丢弃这个日志。  </li>
</ol>
<p>双M结构，日志的执行流程：  </p>
<ol>
<li>从节点A更新的事务，binlog里面记的都是A的server id；  </li>
<li>传到节点B执行一次以后，节点B生成的binlog的server id也是A的server id；  </li>
<li>再传回给节点A，A判断到这个server id与自己的相同，就不会再处理这个日志。死循环在这里断掉。  </li>
</ol>
<p>双M结构，出现循环复制情况：  </p>
<ol>
<li>在一个主库更新事务后，用命令set global server_id=x修改了server_id。等日志再传回来的时候，发现server_id跟自己的server_id不同，就只能执行了。  </li>
<li>有三个节点，trx在节点B执行，binlog上的server_id就是B，binlog传给节点A，然后A和A’搭建了双M结构，就会出现循环复制。  </li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 数据库迁移。循环复制解决</span></span><br><span class="line"><span class="keyword">stop</span> <span class="keyword">slave</span>;  </span><br><span class="line"><span class="keyword">change</span> <span class="keyword">master</span> <span class="keyword">to</span> ignore_server_ids=(server_id_of_B);  </span><br><span class="line"><span class="keyword">start</span> <span class="keyword">slave</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 迁移</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span> <span class="keyword">slave</span>;  </span><br><span class="line"><span class="keyword">change</span> <span class="keyword">master</span> <span class="keyword">to</span> ignore_server_ids=();  </span><br><span class="line"><span class="keyword">start</span> <span class="keyword">slave</span>;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>加锁规则</title>
    <url>/MySQL/%E5%8A%A0%E9%94%81%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<p>MySQL新的版本可能会改变加锁策略，当前规则适用于5.x系列&lt;=5.7.24,8.0系列&lt;=8.0.13。  </p>
<p>执行update和delete的时候，要“先读后写”，这个读就开始加锁了。<br>insert的时候要有插入意向锁(跟gap lock冲突)。<br><strong>查询过程中，在 InnoDB 要去找“第一个值”的时候，是按照等值去找的，用的是等值判断的规则；找到第一个值以后，要在索引内找“下一个值”，对应于规则中说的范围查找。</strong>  </p>
<h3 id="加锁规则"><a href="#加锁规则" class="headerlink" title="加锁规则"></a>加锁规则</h3><p>包含两个“原则”、两个“优化”和一个“bug”：  </p>
<ol>
<li>原则1：加锁的基本单位是next-key lock(前开后闭区间)。  </li>
<li>原则2：查找过程中访问到的对象才会加锁(查询过程中访问到的行和间隙，不是查询结果)。  </li>
<li>优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁(若存在等于该值的行则退化为行锁，若不存在则不退化，参考优化2形成间隙锁)。  </li>
<li>优化2：索引上的等值查询，(无论是唯一索引还是不唯一的普通索引)向右遍历到最后一个不满足等值条件的值，next-key lock退化为间隙锁。  </li>
<li>一个bug：唯一索引上的范围查询也会访问到不满足条件的第一个值为止。  </li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`d`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`c`</span> (<span class="string">`c`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),</span><br><span class="line">(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure>

<h3 id="1-唯一索引等值查询"><a href="#1-唯一索引等值查询" class="headerlink" title="1. 唯一索引等值查询"></a>1. 唯一索引等值查询</h3><p>等值条件操作间隙：  </p>
<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
<th>sessionC</th>
</tr>
</thead>
<tbody><tr>
<td>begin;</br>update t set d=d+1 where id=7;</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>insert into t values(8,8,8);</br>(block)</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>update t set d=d+1 where id=10;</br>(Query OK)</td>
</tr>
</tbody></table>
<p>表t中没有id=7的记录：  </p>
<ol>
<li>根据原则1，加锁单位是next-key lock，sessionA加锁范围是(5,10]；  </li>
<li>根据优化2，这是一个等值查询id=7，而id=10不满足查询条件，next-key lock退化成间隙锁，最终加锁范围是(5,10)。  </li>
</ol>
<p>sessionB往间隙中插入id=8的记录会被锁住，sessionC修改id=10这行可以。  </p>
<h3 id="2-非唯一索引等值查询"><a href="#2-非唯一索引等值查询" class="headerlink" title="2. 非唯一索引等值查询"></a>2. 非唯一索引等值查询</h3><p>覆盖索引上的锁：  </p>
<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
<th>sessionC</th>
</tr>
</thead>
<tbody><tr>
<td>begin;</br>select id from t where c=5 lock in share mode;</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>update t set d=d+1 where id=5;</br>(Query OK)</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>insert into t values(7,7,7);</br>(blocked)</td>
</tr>
</tbody></table>
<p>sessionA给非唯一索引c上c=5的这一行加上读锁：  </p>
<ol>
<li>根据原则1，加锁单位是next-key lock，会给(0,5]加上next-key lock。  </li>
<li>c是普通索引，仅访问c=5这一条记录不能马上停下来，需要向右遍历，查到c=10才放弃。根据原则2，访问到的都要加锁，要给(5,10]加next-key lock。  </li>
<li>根据优化2，等值判断，向右遍历，最后一个值不满足c=5这个等值条件，退化成间隙锁(5,10)。  </li>
<li>根据原则2，只有访问到的对象才会加锁，这个查询使用覆盖索引，并不需要访问主键索引，所以主键索引上没有加任何锁，sessionB的update语句可以执行。  </li>
</ol>
<p>sessionC插入c=7的记录，会被sessionA的间隙锁(5,10)锁住。  </p>
<p><strong>锁是加在索引上的</strong>。由于覆盖索引的优化，本例中lock in share mode只锁了覆盖索引。若为了加读锁避免数据被更新，需要再查询字段中加入索引中不存在的字段，绕过覆盖索引优化；或者使用for update，系统认为接下来要更新数据，会顺便给主键索引上满足条件的行加上行锁。  </p>
<h3 id="3-唯一索引范围锁"><a href="#3-唯一索引范围锁" class="headerlink" title="3.唯一索引范围锁"></a>3.唯一索引范围锁</h3><p>范围查询：  </p>
<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
<th>sessionC</th>
</tr>
</thead>
<tbody><tr>
<td>begin;</br>select * from t where id&gt;=10 and id&lt;11 for update;</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>insert into t values(8,8,8);</br>(QueryOK)</br>insert into t values(13,13,13);</br>(blocked)</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>update t set d=d+1 where id=15;</br>(blocked)</td>
</tr>
</tbody></table>
<ol>
<li>开始执行时，要找到第一个id=10的行(等值查询)，加上next-key lock(5,10]。根据优化1，主键id上的等值条件，退化成行锁，只加了id=10这一行的行锁。  </li>
<li>范围查找往后继续找(范围查询)，找到id=15这一行停下来，需要加next-key lock(10,15]。  </li>
</ol>
<p>sessionA锁的范围就是主键索引上，行锁id=10和next-key lock(10,15]，综合为[10,15]。sessionB后半部和sessionC被锁住。  </p>
<h3 id="4-非唯一索引范围锁"><a href="#4-非唯一索引范围锁" class="headerlink" title="4.非唯一索引范围锁"></a>4.非唯一索引范围锁</h3><p>对照案例三：  </p>
<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
<th>sessionC</th>
</tr>
</thead>
<tbody><tr>
<td>begin;</br>select * from t where c&gt;=10 and c&lt;11 for update;</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>insert into t values(8,8,8);</br>(blocked)</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>update t set d=d+1 where c=15;</br>(blocked)</td>
</tr>
</tbody></table>
<p>sessionA用字段c来判断，加锁规则跟案例三不同处：在第一次用c=10定位记录的时候，索引c加上了(5,10]这个next-key lock后，由于索引c是非唯一索引，没有优化规则，不会蜕变为行锁。之后范围查询，扫描到c=15才知道不需要继续往后找了，才停止扫描。  </p>
<p>sessionA加的锁是索引c上的(5,10]和(10,15]这两个next-key lock，综合为(5,15]。sessionB被(5,10]堵住，sessionC被(10,15]堵住。  </p>
<blockquote>
<p>如果sessionA中语句为select * from t where c&gt;=10 and c&lt;=15 for update;加锁范围为(5,20]。  </p>
</blockquote>
<h3 id="5-唯一索引范围锁bug"><a href="#5-唯一索引范围锁bug" class="headerlink" title="5.唯一索引范围锁bug"></a>5.唯一索引范围锁bug</h3><table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
<th>sessionC</th>
</tr>
</thead>
<tbody><tr>
<td>begin;</br>select * from t where id&gt;10 and id&lt;=15 for update;</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>update t set d=d+1 where id=20;</br>(blocked)</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>insert into t values(16,16,16);</br>(blocked)</td>
</tr>
</tbody></table>
<p>sessionA是一个范围查询，按照原则1，索引id上加(10,15]这个next-key lock，(因为id是唯一键，循环判断到id=15这一行就可以停止了)，而InnoDB会继续往前扫描到第一个不满足条件的行id=20为止。由于是范围扫描，索引id上的(15,20]这个next-key lock会被锁上且没有优化。  </p>
<p>sessionB和sessionC被(15,20]锁住。</p>
<hr>
<h3 id="6-非唯一索引上存在“等值”的例子"><a href="#6-非唯一索引上存在“等值”的例子" class="headerlink" title="6.非唯一索引上存在“等值”的例子"></a>6.非唯一索引上存在“等值”的例子</h3><p>insert into t(id,c,d) values(30,10,30);  </p>
<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
<th>sessionC</th>
</tr>
</thead>
<tbody><tr>
<td>begin;</br>delete from t where c=10;</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>insert into t values(12,12,12);</br>(blocked)</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>update t set d=d+1 where c=15;</br>(Query OK)</td>
</tr>
</tbody></table>
<p>sessionA在遍历的时候，先访问第一个c=10的记录，根据原则1，加的是(c=5,id=5)-(c=10,id=10)这个前开后闭的next-key lock。<br>sessionA继续向右查找，直到碰到(c=15,id=15)这一行循环才结束。根据优化2，这是一个等值查询，向右查询到了不满足条件的行，(c=10,id=10)-(c=15,id=15)这个前开后闭的next-key lock会退化成(c=5,id=5)-(c=15,id=15)前后都开的间隙锁。总体索引c上的锁范围是(c=5,id=5)-(c=15,id=15)前后都开的区间。  </p>
<p>所以sessionB会被堵住，sessionC正常更新。  </p>
<h3 id="7-limit语句加锁"><a href="#7-limit语句加锁" class="headerlink" title="7.limit语句加锁"></a>7.limit语句加锁</h3><p>对照案例6：  </p>
<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
</tr>
</thead>
<tbody><tr>
<td>begin;</br>delete from t where c=10 limit 2;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>insert into t values(12,12,12);</br>(Query OK)</td>
</tr>
</tbody></table>
<p>sessionA的delete语句加了limit2，表t中c=10的记录只有两条，加不加limit2，删除效果相同，但加锁效果不同。  </p>
<p>delete语句明确加了limit2的限制，在遍历到(c=10,id=30)这一行之后，满足条件的语句已经有两条了，循环就结束了。索引c上的加锁范围变成了从(c=5,id=5)-(c=10,id=30)这个前开后闭的区间。  </p>
<p>(c=10,id=30)-(c=15,id=15)之间是没有锁的。sessionB没有被堵住。<strong>在删除数据的时候尽量加limit。不仅可以控制删除数据的条数，让操作更安全，还可以减少加锁的范围。</strong>  </p>
<h3 id="8-一个死锁的例子"><a href="#8-一个死锁的例子" class="headerlink" title="8.一个死锁的例子"></a>8.一个死锁的例子</h3><p>next-key lock实际上是间隙锁和行锁加起来的结果：  </p>
<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
</tr>
</thead>
<tbody><tr>
<td>begin;</br>select id from t where c=10 lock in share mode;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>update t set d=d+1 where c=10;</br>(blocked)</td>
</tr>
<tr>
<td>insert into t values(8,8,8);</td>
<td></td>
</tr>
<tr>
<td></td>
<td>ERROR 1213(40001): Deadlock found when trying to get lock;try restarting transaction;</td>
</tr>
</tbody></table>
<ol>
<li>sessionA启动事务后执行查询语句加lock in share mode，在索引c上加了next-key lock(5,10]（非唯一索引不会退化成行锁）和间隙锁(10,15)（优化2，等值查询优化后成为间隙锁）。  </li>
<li>sessionB的update语句先要在索引c上加next-key lock(5,10]，进入锁等待。  </li>
<li>sessionA要在插入(8,8,8)这一行，被sessionB的间隙锁锁住。出现了死锁，InnoDB让sessionB回滚。  </li>
</ol>
<p>sessionB的next-key lock(5,10]操作，实际上分成了两步：先是加(5,10)的间隙锁，加锁成功(间隙锁之间不互斥，只保护间隙，不让insert)；然后加c=10的行锁，加锁失败(行锁之间互斥)等待。若成功后面还要依次加(10,15]的锁。  </p>
<h3 id="9-倒序"><a href="#9-倒序" class="headerlink" title="9.倒序"></a>9.倒序</h3><table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
</tr>
</thead>
<tbody><tr>
<td>begin;</br>select * from t where c&gt;=15 and c&lt;=20 order by c desc lock in share mode;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>insert into t values(6,6,6);</br>(blocked)</td>
</tr>
</tbody></table>
<ol>
<li>由于是order by desc，第一个要定位的是索引c上“最右边的”c=20的行，所以会加上间隙锁(20,25)和next-key lock(15,20]。  </li>
<li>在索引c上向左遍历，要扫描到c=10才停下来(扫描到10，才知道已经不等于15了，找到第一个不等于15的值)，所以next-key lock会加到(5,10]，这是阻塞sessionB的insert语句的原因。  </li>
<li>在扫描过程中，c=20,c=15,c=10这三行都存在值，由于是select *，所以会在主键id上加三个行锁。  </li>
</ol>
<p>sessionA的select语句锁的范围是：  </p>
<ol>
<li>索引c上(5,25)；  </li>
<li>主键索引上id=15、20两个行锁。  </li>
</ol>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>可重复读隔离级别。遵守两阶段锁协议，所有加锁的资源，都是在事务提交或者回滚的时候才释放。next-key lock实际上是由间隙锁加行锁实现的。如果切换到读提交隔离级别，相当于去掉间隙锁的部分，只保留行锁部分。  </p>
<hr>
<p>读提交隔离级别下的优化：语句执行过程中加上的行锁，在语句执行完成后，就把“不满足条件的行”上的行锁直接释放了，不需要等到事务提交。读提交隔离级别下，锁的范围更小，锁的时间更短。  </p>
<p>读提交隔离级别下，update语句有一个“semi-consistent” read优化(delete语句无效)：如果update语句碰到一个已经被锁了的行，会读入最新的版本，然后判断一下是不是满足查询条件：</p>
<ul>
<li>不满足，直接跳过；  </li>
<li>满足，进入锁等待。  </li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>WAL保证数据不丢</title>
    <url>/MySQL/WAL%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2/</url>
    <content><![CDATA[<p>WAL(write ahead log)机制:先写内存，然后写日志(redo log&amp;binlog)，后台有机会将内存的数据写到数据盘。只要redo log和binlog保证持久化到磁盘，就能保证MySQL异常重启后，数据可以恢复。  </p>
<h3 id="binlog的写入机制"><a href="#binlog的写入机制" class="headerlink" title="binlog的写入机制"></a>binlog的写入机制</h3><p>事务执行过程中，先把日志写到binlog cache，事务提交的时候，再把binlog cache写到binlog文件中。  </p>
<p>一个事务的binlog是不能被拆开的，不论这个事务多大，都要确保一次性写入。  </p>
<blockquote>
<p>执行一条事务所产生的binlog准备写到binlog file时，都会先判断当前文件写入这条binlog之后是否会超过设置的max_binglog_size值，若超过，则rotate自动生成下个binlog file来记录这条binlog信息。<br>如果单条事务产生的binlog大于max_binlog_size，不会被拆到连个binlog文件，等到这个事务的日志写完再rotate，存在超过配置大小上限的binlog文件。  </p>
</blockquote>
<p>系统给binlog cache分配了一片内存，每个线程一个，参数binlog_cache_size用于控制单个线程内binlog cache所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。  </p>
<p>事务提交的时候，执行器把binlog cache里的完整事务写入到binlog中，并清空binlog cache。  </p>
<img src="/img/MySQL binlog写盘状态.png" width="500" height="500" >

<p>每个线程都有自己的binlog cache，但是共用同一份binlog文件。  </p>
<ol>
<li>图中的write，指的是<strong>把日志binlog cache写入到文件系统的page cache</strong>(文件系统向内核申请的一块内存，缓存读写文件)，并没有把数据持久化到磁盘，速度比较快。(<strong>此时commit标识完成write，响应客户端，client收到commit成功</strong>，主机掉电重启，事务会回滚)  </li>
<li>图中的fsync，指的是将数据持久化到磁盘的操作。一般情况下，fsync才占磁盘的IOPS。  </li>
</ol>
<p>write和fsync的时机，由参数sync_binlog控制：  </p>
<ol>
<li>sync_binlog=0时，表示每次提交事务都只write，不fsync；(可能会丢失日志)  </li>
<li>sync_binlog=1时，表示每次提交事务都会执行fsync；  </li>
<li>sync_binlog=N(N&gt;1)时，表示每次提交事务都write，但是累积N个事务后才fsync。(如果主机发生异常重启，会丢失最近N个事务的binlog日志)  </li>
</ol>
<p>出现IO瓶颈的场景里，将sync_binlog设置成一个比较大的值，可以提升性能。常见100~1000。  </p>
<h3 id="redo-log的写入机制"><a href="#redo-log的写入机制" class="headerlink" title="redo log的写入机制"></a>redo log的写入机制</h3><p><a href="/MySQL/2日志系统">MySQL-2日志系统</a>  </p>
<p>事务在执行过程中，生成的redo log是要先写到redo log buffer对应的内存中，在commit阶段，一次性写入redo log file。(redo log buffer中的内容，并不是每次生成后都直接持久化到磁盘。但一个还没有提交的事务，其部分日志也有可能被提前持久化到磁盘。)  </p>
<p>如果事务执行期间MySQL发生异常重启，那这部分日志就丢了。但由于事务并没有提交，这时日志丢了也不会有损失。  </p>
<p>redo log可能存在三种状态：</p>
<img src="/img/MySQL redo log存储状态.png" width="500" height="313" >

<ol>
<li>存在redo log buffer中，物理上是在MySQL进程内存中，对应图中红色部分；  </li>
<li>写到磁盘(write)，但是没有持久化(fsync)，物理上是在文件系统的page cache中，对应图中黄色部分；  </li>
<li>持久化到磁盘hard disk，对应图中的绿色部分。  </li>
</ol>
<p>日志写到redo log buffer是很快的，wirte到page cache也差不多，但是持久化到磁盘的速度较慢。  </p>
<p>InnoDB提供了innodb_flush_log_at_trx_commit参数，控制redo log的写入策略：  </p>
<ol>
<li>=0时，表示每次事务提交时都只是把redo log留在redo log buffer中；(MySQL本身异常重启就会丢数据)  </li>
<li>=1时，表示每次事务提交时都将redo log直接持久化到磁盘；  </li>
<li>=2时，表示每次事务提交时都只是把redo log写到page cache。(主机掉电重启才会丢数据)  </li>
</ol>
<p>出现IO瓶颈的场景里，将innodb_flush_log_at_trx_commit设置成2，性能跟设置成0差不多，但是MySQL异常重启时不会丢数据。  </p>
<p>其他操作：</p>
<ol>
<li>InnoDB有一个后台线程，每隔1秒，就会把redo log buffer中的日志，调用write写到文件系统的page cache，然后调用fsync持久化到磁盘。(事务执行中间过程的redo log也是直接写在redo log buffer中的，这些还未提交的事务的redo log也会被后台线程一起持久化到磁盘。checkpoint)  </li>
<li>redo log buffer占用的空间即将达到innodb_log_buffer_size一半的时候，后台线程会主动写盘。这个事务并没有提交，这个写盘动作只是write，而没有调用fsync，也就是只留在了文件系统的page cache。  </li>
<li>并行的其他事务提交的时候，顺带将这个事务的redo log buffer持久化到磁盘(参数设置=1)。(事务A执行到一半，已经写了一些redo log到buffer中，这时事务B提交，就会带上事务A在redo log buffer里的日志一起全部持久化到磁盘。)</li>
</ol>
<hr>
<h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p>两阶段提交(事务提交时，才会走到事务的redo log prepare阶段—属于事务提交的一个阶段)，时序上redo log先prepare，再写binlog，最后再把redo log commit。(事务提交过程中的最后一个步骤，这个步骤执行完成后，这个事务就提交完成了。)  </p>
<p>如果innodb_flush_log_at_trx_commit=1，那么<strong>redo log在提交的prepare阶段就会持久化一次</strong>(崩溃恢复逻辑之一是要依赖于prepare的redo log，再加上binlog来恢复的)。</p>
<p>每秒一次后台轮询刷盘，再加上崩溃恢复这个逻辑，InnoDB就认为redo log在commit的时候就不需要fsync了，只write到文件系统的page cache中就足够了。  </p>
<p>“双1”配置：指的是sync_binlog和innodb_flush_log_at_trx_commit都设置成1。<br>一个事务完整提交前，需要等待两次刷盘，一次是redo log(prepare阶段)，一次是binlog。  </p>
<p>“非双1”配置：innodb_flush_logs_at_trx_commit=2;sync_binlog=1000;</p>
<ul>
<li>业务高峰期。  </li>
<li>备库延迟，为了让备库尽快赶上主库。(追上后改回双1)  </li>
<li>用备份恢复主库的副本，应用binlog的过程。  </li>
<li>批量导入数据的时候。  </li>
</ul>
<h4 id="组提交优化"><a href="#组提交优化" class="headerlink" title="组提交优化"></a>组提交优化</h4><p>日志逻辑序列号(log sequence number，LSN)。LSN是单调递增的，用来对应redo log的一个个写入点。每次写入长度为length的redo log，LSN的值就会加上length。  </p>
<p><strong>LSN也会写到InnoDB的数据页中，来确保数据页不会被多次执行重复的redo log。</strong>（crash后恢复）  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        redo log组提交示例
    </div>
    <div class='spoiler-content'>
        <img src="/img/MySQL redo log组提交.png" width="500" height="1000" >

<p>三个并发事务(trx1,trx2,trx3)在prepare阶段，都写完redo log buffer，持久化到磁盘的过程中，对应的LSN分别是50、120、160。  </p>
<ol>
<li>trx1是第一个到达的，会被选为这组的leader；  </li>
<li>等trx1要开始写盘的时候，这个组里面已经有了三个事务，这时候LSN变成了160；  </li>
<li>trx1去写盘的时候带的就是LSN=160，因此等trx1返回时，所有LSN小于等于160的redo log都已经被持久化到磁盘；  </li>
<li>这时trx2和trx3就可以直接返回了。  </li>
</ol>

    </div>
</div>  

<p>一次组提交里面，组员越多，节约磁盘IOPS的效果越好。(单线程则只能一个事务对应一次持久化操作)  </p>
<p>在并发更新场景下，第一个事务写完redo log buffer以后，接下来这个fsync越晚调用，组员可能越多，节约IOPS的效果就越好。  </p>
<p>MySQL通过“拖时间”，让一次fsync带更多的组员。  </p>
<h4 id="组提交优化两阶段提交"><a href="#组提交优化两阶段提交" class="headerlink" title="组提交优化两阶段提交"></a>组提交优化两阶段提交</h4><p>写binlog也是分成两步的：  </p>
<ol>
<li>先把binlog从binlog cache中写到磁盘上的binlog文件(文件系统的page cache)；(write)(此时commit标识完成write，但没有落盘，就响应客户端，client收到commit成功，主机掉电重启，事务会回滚，数据会丢失)  </li>
<li>调用fsync持久化到磁盘。(fsync)  </li>
</ol>
<img src="/img/MySQL两阶段提交细化.png" width="500" height="500" >

<p>多个事务的binlog写完了也可以一起持久化(组提交)，进一步减少IOPS消耗：  </p>
<ol>
<li>binlog_group_commit_sync_delay参数，表示延迟多少微妙后才调用fsync；  </li>
<li>binlog_group_commit_sync_no_delay_count参数，表示累积多少次以后才调用fsync。  </li>
</ol>
<p>只要有一个条件满足就会调用fsync。(当delay=0时，no_delay_count就无效了)。(sync_binlog也受组提交参数影响，sync_delay和sync_no_delay_count的逻辑先走，等满足这两个条件之一，就进入sync_binlog阶段，如果sync_binlog=0,就直接跳过，不调fsync不刷盘)</p>
<hr>
<h3 id="WAL预写日志机制"><a href="#WAL预写日志机制" class="headerlink" title="WAL预写日志机制"></a>WAL预写日志机制</h3><p>WAL机制减少磁盘写，主要得益于两个方面：  </p>
<ol>
<li>redo log和binlog都是顺序写，磁盘的顺序写比随机写速度要快；  </li>
<li>组提交机制，可以大幅度降低磁盘的IOPS消耗。  </li>
</ol>
<p>MySQL出现IO性能瓶颈解决方案：  </p>
<ol>
<li>设置binlog_group_commit_sync_delay和binlog_group_commit_sync_no_delay_count参数，减少binlog的写盘次数。(基于“额外的故意等待”实现，可能会增加语句的响应时间，但没有丢失数据的风险)  </li>
<li>将sync_binlog设置为大于1的值(100-1000)。存在主机掉电时会丢binlog日志的风险。  </li>
<li>将innodb_flush_log_at_trx_commit设置为2。存在主机掉电时丢数据的风险。  </li>
</ol>
<hr>
<p>binlog cache是每个线程自己维护的，redo log buffer是全局共用的。  </p>
<ul>
<li><p>binlog是不能“被打断的”，一个事务的binlog必须连续写，因此要整个事务完成后，再一起写到文件里。(连续性是write的时候保证的)  </p>
<blockquote>
<p>一个线程只能同时有一个事务在执行。每当执行一个begin/start transaction时，就会默认提交上一个事务，如果一个事务的binlog被拆开，在备库执行就会被当做多个事务分段进行，破坏了原子性。  </p>
</blockquote>
</li>
<li><p>redo log没有连续的要求，中间生成的日志可以写到redo log buffer中。redo log buffer中的内容还可以“搭便车”，其他事务提交的时候可以被一起写到磁盘中。  </p>
</li>
<li><p>binlog存储是以statement或者row格式存储的，而redo log是以page页格式存储的。page格式，天生就是共有的，而row格式只跟当前事务相关。  </p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>主备切换保证系统高可用</title>
    <url>/MySQL/%E4%B8%BB%E5%A4%87%E5%88%87%E6%8D%A2%E4%BF%9D%E8%AF%81%E7%B3%BB%E7%BB%9F%E9%AB%98%E5%8F%AF%E7%94%A8/</url>
    <content><![CDATA[<p>在一个主备关系中，每个备库接受主库的binlog并执行。只要主库执行更新生成的所有binlog，都可以传到备库并被正确的执行，备库就能达到跟主库一致的状态—最终一致性。  </p>
<p>主备切换可能是主动运维动作(软件升级、主库所有机器按计划下线)，也可能是被动操作(主库所在机器掉电)。  </p>
<h3 id="主备延迟"><a href="#主备延迟" class="headerlink" title="主备延迟"></a>主备延迟</h3><p>所谓主备延迟就是同一个事务，在备库执行完成的时间和主库执行完成的时间之间的差值。  </p>
<p>同步延迟：  </p>
<ol>
<li>主库A执行完成一个事务，写入binlog，这个时刻记为T1；  </li>
<li>传给备库B，把备库B接受完成这个binlog的时刻记为T2；  </li>
<li>备库B执行完成这个事务，把这个时刻记为T3。主备延迟=T3-T1。  </li>
</ol>
<p>在备库上执行show slave status命令，返回结果中的seconds_behind_master表示当前备库延迟了多少秒。  </p>
<ol>
<li>每个事务的binlog里面都有一个时间字段，用于记录主库上写入的时间；  </li>
<li>备库取出当前正在执行的事务的时间字段的值，计算它与当前系统的差值，得到seconds_behind_master。  </li>
</ol>
<p>备库链接到主库时，通过执行select unix_timestamp()函数来获得当前主库的系统时间。如果发现主库的时间与自己不一致，备库在执行seconds_behind_master计算的时候会自动扣掉这个差值。  </p>
<blockquote>
<p>SBM不能当做真正的延迟时间。主库没有把日志都发给备库，备库没收到新的binlog时，从库不知道延迟。但主库提交了，从库查不到就算延迟。  </p>
</blockquote>
<p>网络正常，日志从主库传给备库所需的时间很短，T2-T1的值很小(io_thread)，主备延迟的主要来源是备库接收完binlog和执行完这个事务之间的时间差(sql_thread)。最直接表现：备库消费中转日志(relay log)的速度，比主库生产binlog的速度慢。</p>
<h3 id="延迟来源"><a href="#延迟来源" class="headerlink" title="延迟来源"></a>延迟来源</h3><h4 id="备库所在机器的性能比主库所在的机器性能差"><a href="#备库所在机器的性能比主库所在的机器性能差" class="headerlink" title="备库所在机器的性能比主库所在的机器性能差"></a>备库所在机器的性能比主库所在的机器性能差</h4><p>更新请求对IOPS的压力，在主库和备库上是无差别的。备库主机的性能差，一般将备库设置为“非双1”的模式。  </p>
<p>更新过程中触发大量的读操作，备库主机上的多个备库都在争抢中资源时，也可能会导致主备延迟。  </p>
<p>解决：<br>主备可能发生切换，备库随时可能变为主库，主<strong>备选用相同规格的机器，并做对称部署。</strong>  </p>
<h4 id="备库的压力大"><a href="#备库的压力大" class="headerlink" title="备库的压力大"></a>备库的压力大</h4><p>主库提供写能力，备库提供读能力，不影响业务的分析语句在备库上跑。备库查询耗费大量的CPU资源，影响同步速度，造成主备延迟。  </p>
<p>解决：  </p>
<ol>
<li>一主多从。除了备库(可被选成新主库)外，多接几个从库，让从库分担读的压力。(同时从库可以用来做定期全量备份)  </li>
<li>通过binlog输出到外部系统，如Hadoop，让外部系统提供统计类查询的能力。  </li>
</ol>
<h4 id="大事务"><a href="#大事务" class="headerlink" title="大事务"></a>大事务</h4><p>主库必须等事务执行完成才会写入binlog，再传给备库。主库语句执行时间长，就会导致从库延迟。未开并行复制，默认串行导致一个堵全部堵。  </p>
<h5 id="一次性的用delete语句删除太多数据"><a href="#一次性的用delete语句删除太多数据" class="headerlink" title="一次性的用delete语句删除太多数据"></a>一次性的用delete语句删除太多数据</h5><p>归档类数据，平时没有删除历史数据，等到空间快满了，一次性的删除大量历史数据。</p>
<p>解决：<br>避免高峰期操作，同时控制每个事务删除的数据量。  </p>
<h5 id="大表DDL"><a href="#大表DDL" class="headerlink" title="大表DDL"></a>大表DDL</h5><p><a href="/MySQL/重建表回收空间">MySQL-重建表回收空间</a>  </p>
<p>解决：<br>计划内的DDL，建议使用gh-ost方案。  </p>
<h4 id="备库的并行复制能力"><a href="#备库的并行复制能力" class="headerlink" title="备库的并行复制能力"></a>备库的并行复制能力</h4><p>// todo 待补充</p>
<h3 id="可靠性优先"><a href="#可靠性优先" class="headerlink" title="可靠性优先"></a>可靠性优先</h3><img src="/img/MySQL可靠性优先主备切换流程.png" width="500" height="333" >
SBM是seconds_behind_master参数的简写。  

<p>双M结构下，主备切换过程(可靠性优先)：  </p>
<ol>
<li>判断备库B现在的seconds_behind_master，如果小于某个值(5秒)继续下一步，否则持续重试这一步；  </li>
<li>把主库A改成只读状态，readonly=true；  </li>
<li>判断备库B的seconds_behind_master的值，直到整个值变成0为止；(最耗时的步骤，确保步骤1中SBM值足够小)  </li>
<li>把备库B改成可读写状态，readonly=false；  </li>
<li>把业务请求切换到备库B。  </li>
</ol>
<p>步骤2之后，主库A和备库B都处于readonly状态，系统处于不可写状态，直到步骤5完成后才恢复。  </p>
<p>主库掉电时，采用可靠性优先，备库只读，且中转日志未完成应用，系统不可用。且主库可能有来不及传的binlog(通过semi-sync解决)  </p>
<h3 id="可用性优先"><a href="#可用性优先" class="headerlink" title="可用性优先"></a>可用性优先</h3><p>把步骤4、5调整到最开始执行，不等主备数据同步，直接把连接切换到备库B，并且让备库可以读写，系统没有不可用时间。但是可能出现数据不一致的情况。  </p>
<ul>
<li>row格式，数据不一致更容易被发现。主键自动递增，binlog未同步时，连续两条新增语句被主备分别执行，导致主键冲突。(主库新增，binlog未同步，主备切换，备库新增。binlog互相同步时，由于记录了所有字段，发现主键相同的两条不同记录)  </li>
<li>statement格式，数据悄悄的就不一致了。binlog记录的只是SQL语句，先后执行两次，分别生成两条不同的数据。  </li>
</ul>
<p>使用场景：  </p>
<ul>
<li>有一个库的作用是记录操作日志。如果数据不一致可以通过binlog来修补，短暂的不一致不会引发业务问题。  </li>
<li>业务系统依赖于这个日志写入逻辑，如果这个库不可写，会导致线上的业务操作无法执行。  </li>
</ul>
<p>在满足数据可靠性的前提下，MySQL高可用系统的可用性，是依赖于主备延迟的，延迟时间越小(1s)，在主库故障的时候，服务恢复需要的时间就越短，可用性就越高。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>主备延迟解决方案</title>
    <url>/MySQL/%E4%B8%BB%E5%A4%87%E5%BB%B6%E8%BF%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>对于一个压力持续比较高的主库来说，备库执行日志的速度持续低于主库生成日志的速度，备库可能永远都追不上主库的节奏。  </p>
<p>在主库上，影响并发度的原因是各种锁。InnoDB引擎支持行锁，除了所有并发事务都在更新同一行这种极端场景外，它对业务并发度的支持很友好。  </p>
<p>日志在备库上的执行，sql_thread执行中转日志relay log更新数据的逻辑，如果是用单线程的话，就会导致备库应用日志不够快，造成主备延迟。  </p>
<p>多线程复制机制，把只有一个线程的sql_thread，拆成多个线程。coordinator代替原来的sql_thread，但不再直接更新数据，只负责读取中转日志和分发事务。真正更新日志的，变成worker线程。work线程的个数由参数slave_parallel_workers决定。1/4-1/2的CPU核数最佳，其他的供查询的使用。  </p>
<hr>
<p>事务不能按照轮询的方式分发给各个worker。事务分发给worker以后，不同的worker独立执行，但是CPU的调度策略无法保证更新同一行的两个事务按照主库传过来的顺序执行。  </p>
<p>同一个事务的多个更新语句，不能分给不同的worker执行。一个事务更新了表t1和t2中各一行，如果两条更新语句被分到不同的worker，最终的结果是主备一致的，但是表t1执行完成的瞬间，备库上有一个查询，会看到这个事务更新了一半的结果，破坏了事务逻辑的隔离性。  </p>
<p>coordinator分发要求：  </p>
<ol>
<li>不能造成更新覆盖。要求更新同一行的两个事务，必须被分到同一个worker中。  </li>
<li>同一个事务不能被拆开，必须放到同一个worker中。  </li>
</ol>
<h3 id="MySQL5-5版本并行复制策略"><a href="#MySQL5-5版本并行复制策略" class="headerlink" title="MySQL5.5版本并行复制策略"></a>MySQL5.5版本并行复制策略</h3><p>官方MySQL5.5版本不支持并行复制。  </p>
<h4 id="按表分发策略"><a href="#按表分发策略" class="headerlink" title="按表分发策略"></a>按表分发策略</h4><p>如果两个事务更新不同的表，它们就可以并行。数据是存储在表里的，按表分发可以保证两个worker不会更新同一行。如果有跨表的事务，要把两张表放在一起考虑。  </p>
<p>每个worker线程对应一个hash表，用于保存当前正在这个worker的“执行队列”里的事务所涉及的表。hash表的key是”库名.表名”，value是一个数字，表示队列中有多少个事务修改这个表。  </p>
<p>有事务分配给worker时，事务里面涉及的表会被加到对应的hash表中。worker执行完成后，这个表会被从hash表中去掉。  </p>
<p>每个事务在分发的时候，跟<strong>所有worker中的待执行事务队列</strong>(一个worker可能分配了多个事务，每个事务可能对应多张表，分配前挨个判断)的冲突关系包括三种情况：  </p>
<ol>
<li>如果跟所有worker都不冲突，coordinator线程就会把这个事务分配给最空闲的worker;  </li>
<li>如果跟多于一个worker冲突，coordinator线程就进入等待状态，直到和这个事务存在冲突关系的worker只剩下1个；  </li>
<li>如果只跟一个worker冲突，coordinator线程就会把这个事务分配给这个存在冲突关系的worker。  </li>
</ol>
<p>按表分发的方案，在多个表负载均匀的场景里应用效果很好，但是，碰到热点表，所有事务都会被分配到同一个worker中，变成单线程复制。  </p>
<h4 id="按行分发策略"><a href="#按行分发策略" class="headerlink" title="按行分发策略"></a>按行分发策略</h4><p>如果两个事务没有更新相同的行，它们在备库上可以并行执行。该模式要求binlog格式必须是row。  </p>
<p>为每个worker分配一个hash表。key必须是”库名+表名+唯一键的值”。  </p>
<p>“唯一键”除了主键还有唯一索引列，避免两个事务要更新的行的主键值不同，但被分到不同的worker后，唯一索引列的值后先更新导致唯一键冲突。一条语句可能对应多个hash表项，key=hash_func(db+t+唯一索引+唯一索引值)，value=n。  </p>
<blockquote>
<p>在表 t1 上执行 update t1 set a=1 where id=2 语句，在 binlog 里面记录了整行的数据修改前各个字段的值，和修改后各个字段的值。<br>coordinator 在解析这个语句的 binlog 的时候，这个事务的 hash 表就有三个项(primary主键唯一索引，a普通唯一索引):  </p>
<ol>
<li>key=hash_func(db1+t1+“PRIMARY”+2), value=2; 这里 value=2 是因为修改前后的行 id 值不变，出现了两次。  </li>
<li>key=hash_func(db1+t1+“a”+2), value=1，表示会影响到这个表 a=2 的行。  </li>
<li>key=hash_func(db1+t1+“a”+1), value=1，表示会影响到这个表 a=1 的行。</li>
</ol>
</blockquote>
<hr>
<p>相比于按表并行分发策略，按行并行策略在决定线程分发的时候，需要消耗更多的计算资源：  </p>
<ol>
<li>要能够从binlog里面解析出表名、主键值、唯一索引的值。主库binlog格式必须是row。  </li>
<li>表必须有主键。  </li>
<li>不能有外键。表上如果有外键，级联更新的行不会记录在binlog中，这样冲突检测就不准确。  </li>
</ol>
<p>按行分发问题：  </p>
<ol>
<li>耗费内存。一个语句要删除100万行数据，hash表就要记录100万个项。  </li>
<li>耗费CPU。解析binlog，然后计算hash值，对于大事务，成本很高。  </li>
</ol>
<p>单个事务如果超过行数阈值，就暂时退化为单线程模式：  </p>
<ol>
<li>coordinator暂时先hold住这个事务；  </li>
<li>等待所有worker都执行完成，变成空队列；  </li>
<li>coordinator直接执行这个事务；  </li>
<li>恢复并行模式。  </li>
</ol>
<h3 id="MySQL5-6版本并行复制策略"><a href="#MySQL5-6版本并行复制策略" class="headerlink" title="MySQL5.6版本并行复制策略"></a>MySQL5.6版本并行复制策略</h3><p>官方MySQL5.6版本，支持并行复制。</p>
<h4 id="按库分发策略"><a href="#按库分发策略" class="headerlink" title="按库分发策略"></a>按库分发策略</h4><p>key是数据库名。适用主库上有多个DB，并且各个DB的压力均衡。  </p>
<p>优点：  </p>
<ol>
<li>构造hash值的时候很快，只需要库名；一个实例上DB数也不会很多，不会出现需要构造100W个项的情况。  </li>
<li>不要求binlog的格式。statement格式的binlog可以很容易拿到库名。  </li>
</ol>
<p>问题：  </p>
<ol>
<li>主库上的表都放在同一个DB里，按库并行策略没有效果；  </li>
<li>不同DB的热点不同，如业务逻辑库+系统配置库，没有并行效果。  </li>
</ol>
<p>解决：<br>创建不同的DB，把相同热度的表均匀分到不同的DB中，强行使用该策略。  </p>
<h3 id="MariaDB并行复制策略"><a href="#MariaDB并行复制策略" class="headerlink" title="MariaDB并行复制策略"></a>MariaDB并行复制策略</h3><p>redo log组提交(group commit)优化特性：  </p>
<ol>
<li>能够在同一组里提交的事务，一定不会修改同一行；  </li>
<li>主库上可以并行执行的事务，备库上也一定是可以并行执行的。  </li>
</ol>
<p>MariaDB原理：  </p>
<ol>
<li>在一组里一起提交的事务，有一个相同的commit_id，下一组就是commit_id+1;  </li>
<li>commit_id直接写到binlog里；  </li>
<li>传到备库应用的时候，相同commit_id的事务分发到多个worker中执行；  </li>
<li>这一组全部执行完成后，coordinator再去取下一批。  </li>
</ol>
<p>问题：<br>主库上，一组事务在commit的时候，下一组事务是同时处于“执行中”状态的。<br>在备库上执行的时候，要等第一组事务完全执行完成后，第二组事务才能开始执行，系统的吞吐量不够。<br>容易被大事务拖后腿，同一组的多个事务(多个worker)要等最大的事务完成(只剩一个worker在工作)，下一组才能开始执行。  </p>
<h3 id="MySQL5-7版本并行复制策略"><a href="#MySQL5-7版本并行复制策略" class="headerlink" title="MySQL5.7版本并行复制策略"></a>MySQL5.7版本并行复制策略</h3><p>由参数slave-parallel-type控制并行复制策略：  </p>
<ol>
<li>配置为DATABASE，表示使用MySQL5.6版本的按库并行策略；  </li>
<li>配置为LOGICAL——CLOCK，表示使用类似MariaDB的策略。针对并行度做了优化。  </li>
</ol>
<p>原理：  </p>
<ol>
<li>同时处于“执行状态”的所有事务，可能有由于锁冲突而处于锁等待状态的事务，而并不能并行。这些事务在备库上被分配到不同的worker，会出现备库跟主库不一致的情况。  </li>
<li>MariaDB核心：所有处于commit状态的事务可以并行。事务处于commit转态，表示已经通过了锁冲突的检验。  </li>
<li>根据两阶段提交细化过程，只要能够到达redo log prepare阶段(事务处于开始“提交状态”)，就表示事务已经通过锁冲突的检验。  <ol>
<li>同时处于redo log prepare状态的事务，在备库执行时时可以并行的；  </li>
<li>处于redo log prepare状态的事务，与处于redo log commit状态的事务之间，在备库执行时也是可以并行的。  </li>
</ol>
</li>
</ol>
<p>每个事务都有两个数字表示它在执行提交阶段的时间范围，构成区间(c1,c2)。c1是事务启动的时候，当前系统里最大的commit_id。一个事务提交的时候，才会commit_id+1，+1之前启动的事务拥有相同的commit_id。如果两个事务的区间有交集，就是可以并行的。  </p>
<blockquote>
<p>主库在写binlog的时候，会在binlog里记录commit_id和sequence_no，来说明事务之间在主库上并行prepare的状态。备库里是通过解析binlog拿到commit_id和sequence_no来决定怎么并发。  </p>
</blockquote>
<p>binlog组提交的两个参数：  </p>
<blockquote>
<ul>
<li>binlog_group_commit_sync_delay参数，表示延迟多少微妙后才调用fsync；  </li>
<li>binlog_group_commit_sync_no_delay_count参数，表示累计多少次以后才调用fsync。  </li>
</ul>
</blockquote>
<p>这两个参数，用于故意拉binlog从write到fsync的时间，以此减少binlog的写盘次数。在并行复制策略里，可以用来制造更多的“同时处于prepare阶段的事务”，增加了备库复制的并行度。<br>这两个参数，既可以故意让主库提交的慢些，又可以让备库执行的快些。  </p>
<h3 id="MySQL5-7-22并行复制策略"><a href="#MySQL5-7-22并行复制策略" class="headerlink" title="MySQL5.7.22并行复制策略"></a>MySQL5.7.22并行复制策略</h3><p>基于WRITESET的并行复制。参数binlog-transaction-dependency-tracking控制是否启用该策略(如果同时设置了slave_parallel_type参数，则以该spt参数为准)：  </p>
<ol>
<li>COMMIT_ORDER，表示的是根据同时进入prepare和commit来判断是否可以并行的策略。  </li>
<li>WRITESET，表示的是对于事务涉及更新的每一行，计算出这一行的hash值，组成集合writeset。如果每个事务没有操作相同的行，他们的writeset没有交集，就可以并行。  </li>
<li>WRITESET_SESSION，在writeset的基础上多了一个约束，在主库上同一个线程先后执行的两个事务，在备库执行的时候，要保证相同的先后顺序。  </li>
</ol>
<p>唯一标识hash值是通过“库名+表名+索引名+值”计算出来的。如果一个表上除了有主键索引外，还有其它唯一索引，那么对于每一个唯一索引，insert语句对应的writeset就要多增加一个hash值。(类似5.5的按行分发策略，但有优化)：  </p>
<ol>
<li>writeset是在主库生成后直接写入到binlog里面的，这样在备库执行的时候，不需要解析binlog内容(event里的行数据)，节省了很多计算量；  </li>
<li>不需要把整个事务的binlog都扫一遍才能决定分发到那个worker，更省内存；  </li>
<li>由于备库的分发策略不依赖于binlog内容，所以binlog是statement格式也是可以的。  </li>
</ol>
<p>对于“表上没主键”和“外键约束”的场景，writeset策略无法并行，也会暂时退化为单线程模型。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>一主多从，主备切换逻辑</title>
    <url>/MySQL/%E4%B8%80%E4%B8%BB%E5%A4%9A%E4%BB%8E%EF%BC%8C%E4%B8%BB%E5%A4%87%E5%88%87%E6%8D%A2%E9%80%BB%E8%BE%91/</url>
    <content><![CDATA[<p>A和A’互为主备，从库B、C、D指向的是主库A。一主多从的设置，一般用于读写分离，主库负责所有的写入和一部分读，其他的读请求则由从库分担。相比于一主一备的切换流程，一主多从结构在切换完成后，A’会成为新的主库，从库B、C、D也要改接到A’。  </p>
<h3 id="基于位点的主备切换"><a href="#基于位点的主备切换" class="headerlink" title="基于位点的主备切换"></a>基于位点的主备切换</h3><p>把节点B设置成节点A’的从库的时候，需要执行一条change master命令：  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CHANGE</span> <span class="keyword">MASTER</span> <span class="keyword">TO</span> </span><br><span class="line">MASTER_HOST=$host_name </span><br><span class="line">MASTER_PORT=$port </span><br><span class="line">MASTER_USER=$user_name </span><br><span class="line">MASTER_PASSWORD=$<span class="keyword">password</span> </span><br><span class="line">MASTER_LOG_FILE=$master_log_name </span><br><span class="line">MASTER_LOG_POS=$master_log_pos</span><br></pre></td></tr></table></figure>

<ul>
<li>master_host、master_port、master_user、master_password四个参数，分别代表了主库A’的IP、端口、用户名、密码。  </li>
<li>master_log_file、master_log_pos参数，表示要从主库的master_log_name文件的master_log_pos这个位置的日志继续同步。这个位置就是同步位点，是主库对应的文件名和日志偏移量。  </li>
</ul>
<p>原来节点B是A的从库，本地记录的也是A的位点。但是相同的日志，A的位点和A’的位点是不同的，从库B切换的时候，需要先经过“找同步位点”逻辑。  </p>
<h4 id="同步位点设置"><a href="#同步位点设置" class="headerlink" title="同步位点设置"></a>同步位点设置</h4><p>切换过程中不能丢数据，找位点的时候，总是要找一个“稍微往前”的，然后再通过判断跳过那些在从库上已经执行过的事务：  </p>
<ol>
<li>等待新主库A’把中转日志relay log全部同步完成；  </li>
<li>在A’上执行show master status命令，得到当前A’上最新的File和Position；  </li>
<li>取援助库A故障的时刻T；  </li>
<li>用mysqlbinlog工具解析A’的File，等得到T时刻的位点。  <blockquote>
<p>mysqlbinlog File –stop-datetime=T –start-datetime=T;  </p>
</blockquote>
</li>
</ol>
<p>end_log_pos后面的值假设为’123’，表示的就是A’这个实例，在T时刻写入新的binlog的位置，把这个值123作为$master_log_pos，用在节点B的change master命令里。  </p>
<h4 id="同步位点不精确"><a href="#同步位点不精确" class="headerlink" title="同步位点不精确"></a>同步位点不精确</h4><p>在T时刻，主库A已经执行完成了一个insert语句插入了一行数据R，并且已经将binlog传给了A’和B，然后再传完的瞬间主库A的主机掉电了。  </p>
<ol>
<li>在从库B上，由于同步了binlog，R这一行已经存在；  </li>
<li>在新主库A’上，R这一行也已经存在，日志是写在A的end_log_pos值123对应的位置之后；  </li>
<li>在从库B上执行change master命令，指向A’的File文件的123位置，会把插入R这一行数据的binlog又同步到从库B去执行。  <blockquote>
<p>从库B的同步线程会报告Duplicate entry ‘id_of_R’ for key ‘PRIMARY’错误，提示出现了主键冲突，然后停止同步。  </p>
</blockquote>
</li>
</ol>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>切换任务的时候，主动跳过错误的两种方法：  </p>
<ul>
<li>主动跳过一个事务：  </li>
</ul>
<p><code>set global sql_slave_skip_counter=1;  
start slave;</code></p>
<p>sql_slave_skip_counter跳过的是一个event，但MySQL不能只执行一半的事务，跳过了一个event，就会跳到这个事务的末尾。  </p>
<p>切换过程中，可能会不止重复执行一个事务，需要在从库B刚开始接到新主库A’时，持续观察，每次碰到这些错误就停下来，执行一次跳过命令，直到不再出现停下来的情况，以此来跳过可能涉及的所有事务。  </p>
<ul>
<li>设置slave_skip_errors参数，直接跳过指定的错误：  </li>
</ul>
<p>在执行主备切换时，经常遇到的两类错误：1062错误是插入数据时唯一键冲突；1032错误是删除数据时找不到行。  </p>
<p>把slave_skip_errors设置为“1032,1062”，中间碰到这两个错误时直接跳过。<br>只有主备切换过程中，直接跳过1032和1062错误时无损的，等主备间的同步关系建立按成，并稳定执行一段时间之后，需要把这个参数设置为空，以免之后真的主从数据不一致被跳过。  </p>
<h3 id="GTID"><a href="#GTID" class="headerlink" title="GTID"></a>GTID</h3><p>MySQL5.6版本引入了GTID，解决主备切换复杂易错的问题。  </p>
<p>GTID全称是Global Transaction Identifier，全局事务ID，是一个<strong>事务在提交的时候生成</strong>的，是这个事务的唯一标识，由两部分组成，格式是：GTID=server_uuid:gno;  </p>
<ul>
<li>server_uuid是一个实例第一次启动时自动生成的，是一个全局唯一的值；  </li>
<li>gno是一个整数，初始值是1，每次提交事务的时候分配给这个事务，并加1。  </li>
</ul>
<p>官方文档定义格式：GTID=source_id:transaction_id;  </p>
<ul>
<li>source_id就是server_uuid；  </li>
<li>transaction_id容易造成误解，用gno代替。  <blockquote>
<p>MySQL中transaction_id是指事务id，事务id是在事务执行过程找那个分配的，即使这个事务回滚了，事务id也会递增，而gno是在事务提交的时候才会分配。<br>从效果上看GTID往往是连续的，用gno表示更容易理解。  </p>
</blockquote>
</li>
</ul>
<hr>
<p>启动一个MySQL实例的时候，加上参数gtid_mode=on和enforce_gtid_consistency=on；就可以启动GTID模式。  </p>
<p>在GTID模式下，每个事务都会跟一个GTID一一对应。有两种生成方式，使用哪种方式取决于session变量gtid_next的值:  </p>
<ol>
<li>如果gtid_next=automatic，代表使用默认值。MySQL会把server_uuid:gno分配给这个事务。<br> a. 记录binlog的时候，先记录一行set @@session.gtid_next=’server_uuid:gno’;<br> b. 把这个gtid加入本实例的gtid集合。  </li>
<li>如果gtid_next是一个指定的gtid值，如通过 set gtid_next=’current_gtid’指定为current_gtid，那么有两种可能：<br> a. 如果current_gtid已经存在于实例的gtid集合中，接下来执行的这个事务会直接被系统忽略；<br> b. 如果current_gtid没有存在于实例的gtid集合中，就将整个current_gtid分配给接下来要执行的事务，也就是说系统不需要给这个事务生成新的gtid，因此gno也不用加1。  </li>
</ol>
<p>一个current_gtid只能给一个事务使用。这个事务提交后，如果要执行下一个事务，就要执行set命令，把gtid_next设置成另外一个gtid或者automatic。  </p>
<blockquote>
<p>set gtid_next=’aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee:10’;<br>begin;<br>commit;<br>set gtid_next=automatic;<br>start slave;  </p>
</blockquote>
<p><strong>每个MySQL实例都维护了一个gtid集合，用来对应“这个实例执行过的所有事务”。</strong>通过show master status命令查看，对应的Executed_Gtid_set参数值。  </p>
<p>在binlog文件开头，有一个Previous_gtids，用于记录生成这个binlog的时候，实例的Executed_gtid_set。启动时只需要解析最后一个文件，就可以知道该实例所有的GTID集合，也可以快速的定位GTID在哪个文件。  </p>
<h3 id="基于GTID的主备切换"><a href="#基于GTID的主备切换" class="headerlink" title="基于GTID的主备切换"></a>基于GTID的主备切换</h3><p>在GTID模式下，备库B要设置为新主库A’的从库的语法：  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CHANGE</span> <span class="keyword">MASTER</span> <span class="keyword">TO</span> </span><br><span class="line">MASTER_HOST=$host_name </span><br><span class="line">MASTER_PORT=$port </span><br><span class="line">MASTER_USER=$user_name </span><br><span class="line">MASTER_PASSWORD=$<span class="keyword">password</span> </span><br><span class="line">master_auto_position=<span class="number">1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>master_auto_position=1表示这个准备关系使用的是GTID协议。  </li>
</ul>
<p>当前时刻，实例A’GTID集合记为set_a，实例B的GTID集合记为set_b。在实例B上执行start slave命令，取binlog的逻辑如下：  </p>
<ol>
<li>实例B指定主库A’，基于准备协议建立连接。  </li>
<li>实例B把set_b发给主库A’。  </li>
<li>实例A’算出set_a与set_b的差集，也就是所有存在于set_a，但是不存在于set_b的GTID的集合，判断A’本地是否包含了这个差集需要的所有binlog事务。<br> a. 如果不包含，表示A’已经把实例B需要的binlog给删掉的了，直接返回错误；<br> b. 如果确认全部包含，A’从自己的binlog文件里面，找出第一个不在set_b的事务，发给B；  </li>
<li>之后就从这个事务开始，往后读文件，按顺序取binlog发给B去执行。  </li>
</ol>
<p>设计思想之一：在基于GTID的主备关系里，系统认为只要建立了主备关系，就必须保证主库发给备库的日志是完成的。因此，如果实例B需要的日志已经不存在，A’就拒绝吧日志发给B。  </p>
<p>如果一个新的从库接上主库，但需要的binlog已经没了，解决方案：  </p>
<ol>
<li>如果业务允许主从不一致的情况，可以在主库上先执行show global variables like ‘gtid_purged’，得到主库已经删除的GTID集合，假设是gtid_purger1；然后先在从库上执行reset master，再执行set global gtid_purged=’gtid_purged1’；最后执行start slave，就会从主库现存的binlog开始同步。binlog缺失的那一部分，数据在从库上可能会有丢失，造成主从不一致。  </li>
<li>如果需要主从数据一致，通过重新搭建从库来做。  </li>
<li>如果有其他的从库保留有全量的binlog的话，可以把新的从库先接到这个保留了全量的binlog的从库，追上日志以后，如果有需要，再接回从库。  </li>
<li>如果binlog有备份的情况，可以先在从库上应用缺失的binlog，然后再执行start slave。  </li>
</ol>
<p>对比区别：基于位点的协议，是由备库决定的，备库指定哪个位点，主库就发哪个位点，不做日志的完整性判断。  </p>
<p>GTID同时解决了循环复制的问题。</p>
<hr>
<p>GTID模式下，一主多从主备切换，从库B、C、D只需要分别执行change master命令指向实例A’即可。找位点的工作在实例A’内部已经自动完成。对于HA系统的开发人员非常友好。  </p>
<p>之后整个系统就由新主库A’写入，主库A’的自己生成的binlog中的GTID集合格式是：server_uuid_of_A’:1-M。  </p>
<p>从库(包括备库)的GTID集合的整体格式为：server_uuid_of_A:1-N,server_uuid_of_A’:1-M。  </p>
<h3 id="GTID和在线DDL"><a href="#GTID和在线DDL" class="headerlink" title="GTID和在线DDL"></a>GTID和在线DDL</h3><p>索引缺失引起的性能问题，可以通过在线加索引来解决。考虑到要避免新增索引对主库性能造成影响，可以先在备库加索引，然后再切换。  </p>
<p>在双M结构下，备库执行的DDL语句也会传给主库，为了避免传回后对主库造成影响，要通过set sql_log_bin=off关掉binlog。binlog并没有记录下这一更新，导致数据和日志不一致。  </p>
<p>解决：假设互为主备关系的库是实例X和实例Y，当前主库是X，并且都打开了GTID模式，主备切换流程：  </p>
<ul>
<li><p>在实例X上执行 stop slave。  </p>
</li>
<li><p>在实例Y上执行DDL语句。这里不需要关闭binlog。  </p>
</li>
<li><p>执行完成后，查出这个DDL语句对应的GTID，并记为server_uuid_of_Y:gno。  </p>
</li>
<li><p>到实例X中执行以下语句序列：  </p>
<blockquote>
<p>set GTID_NEXT=”server_uuid_of_Y:gno”;<br>  begin;<br>  commit;<br>  set gtid_next=automatic;<br>  start slave;</p>
</blockquote>
<p>  这样模拟一个空事务既可以让实例Y的更新有binlog记录，同时也可以确保不会在实例X上执行这条更新。  </p>
</li>
<li><p>接下来，执行完主备切换，照着上述流程再执行一遍即可。  </p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>数据库异常状态判断</title>
    <url>/MySQL/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%82%E5%B8%B8%E7%8A%B6%E6%80%81%E5%88%A4%E6%96%AD/</url>
    <content><![CDATA[<p>在一主一备的双M架构中，主备切换只需要把客户端流量切到备库；而在一主多从架构中，主备切换除了要把客户端流量切到备库外，还需要把从库接到新主库上。  </p>
<p>主备切换有两种场景，一种是主动切换，一种是被动切换。被动切换，往往是因为主库出问题了，由HA系统发起的。  </p>
<h3 id="select-1-判断"><a href="#select-1-判断" class="headerlink" title="select 1 判断"></a>select 1 判断</h3><p>select 1成功返回，只能说明这个库的进程还在，并不能说明主库没问题。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> innodb_thread_concurrency=<span class="number">3</span>;<span class="comment">-- 控制InnoDB的并发线程上限，一旦并发线程数达到这个值，InnoDB在接收到新请求的时候，就会进入等待状态，直到有线程退出。  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">'t'</span> (</span><br><span class="line">    <span class="string">'id'</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="string">'c'</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line">    primary <span class="keyword">key</span> (<span class="string">'id'</span>)</span><br><span class="line">) <span class="keyword">engine</span>=<span class="keyword">innodb</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
<th>sessionC</th>
<th>sessionD</th>
</tr>
</thead>
<tbody><tr>
<td>select sleep(100) from t;</td>
<td>select sleep(100) from t;</td>
<td>select sleep(100) from t;</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>select 1;</br>(Query OK)</br>select * from t;</br>(blocked)</td>
</tr>
</tbody></table>
<p>sessionD中，select 1是能执行成功的，但是查询表t的语句会被堵住。用select 1来检测实例是否正常的话，是检测不出问题的。  </p>
<p>MHA(Master High Availability)默认使用的方法。另一个可选方案，只做连接，如果连接成功就认为主库没问题。  </p>
<p>在InnoDB中，innodb_thread_concurrency这个参数的默认值是0，表示不限制并发线程数量。一个机器的CPU核数有限，不限制并发数，线程全冲进来，上下文切换的成本太高。通常设置为64~128之间的值(理论上是核数的2倍左右最好)。  </p>
<h4 id="并发连接与并发查询"><a href="#并发连接与并发查询" class="headerlink" title="并发连接与并发查询"></a>并发连接与并发查询</h4><p>show processlist，看到的几千个连接，指的是并发连接；而当前正在执行的语句，才是并发查询。  </p>
<p>并发连接数达到几千个影响并不大，多占一些内存而已。应该关注的是并发查询，并发查询太高才是CPU杀手，必须设置innodb_thread_concurrency参数。  </p>
<p>在线程进入锁等待以后，并发线程的计数会减一，出现同一行热点更新的问题时，等行锁(也包括间隙锁)的线程是不算在128中的。因为，进入锁等待的线程已经不吃CPU了；另外这样设计，也能避免整个系统锁死。  </p>
<ol>
<li>线程1执行begin；update t set c=c+1 where id=1，启动了事务trx1，然后保持这个状态。这个时候，线程处于空闲状态，不算在并发线程里面。  </li>
<li>线程2到线程129都执行update t set c=c+1 where id=1;由于等待行锁，进入等待状态。这样就有128个线程处于等待状态；  </li>
<li>如果处于锁等待状态的线程计数不减一，InnoDB就会认为线程数用满了，会阻止其它语句进入引擎执行，这样线程1不能提交事务，而另外128个线程又处于锁等待状态，整个系统就堵住了。  </li>
</ol>
<p>这时InnoDB不能响应任何请求，整个系统被锁死。而且由于所有线程都处于等待状态，此时占用的CPU却是0，不合理。所以遇到进程进入锁等待的情况时，将并发线程的计数减1的设计，是合理而且是必要的。  </p>
<p>等锁的线程不算在并发线程计数里，但如果它在真正的执行查询(如select sleep(100) from 1)，还是要算进并发线程的计数的。  </p>
<p>问题：<br>同时在执行的语句超过了设置的值，这时候系统其实已经不行了，但是通过select 1来检测系统，会认为系统还是正常的。  </p>
<h3 id="查表判断"><a href="#查表判断" class="headerlink" title="查表判断"></a>查表判断</h3><p>为了能够检测InnoDB并发线程数过多导致的系统不可用情况，需要找一个访问InnoDB的场景。一般的做法是，在系统库(mysql库)里创建一个表，命名为health_check，里面只放一行数据，然后定期执行：<strong>select * from mysql.health_check;</strong>使用这个方法，可以检测出由于并发线程过多导致的数据库不可用的情况。  </p>
<p>问题：<br>空间满了以后，这种方法会变得不好使：更新事务要写binlog，一旦binlog所在磁盘的空间占用率达到100%，那么所有的更新语句和事务提交的commit语句就会被堵住，但是，系统这时候还是可以正常读数据的。  </p>
<h3 id="更新判断"><a href="#更新判断" class="headerlink" title="更新判断"></a>更新判断</h3><p>在表中放一个有意义的字段-timestamp，用来表示最后一次执行检测的时间：<strong>update mysql.health_check set t_modified=now();</strong></p>
<p>节点可用性的检测应该包含主库和备库，如果用更新来检测主库，那么备库也要进行更新检测。  </p>
<p>备库的检测也是要写binlog的，由于一般会把数据库A和B的主备关系设计为双M结构，所以在备库B上执行的检测命令，也要发回给主库A。但是如果主库A和备库B都用相同的更新命令，就可能出现行冲突，可能会导致主备同步停止。  </p>
<p>mysql.health_check这个表就不能只有一行数据了，可以在表上存入多行数据，并用A、B的server_id做主键，保证主、备库各自的检测命令不会发生冲突。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">'health_check'</span>(</span><br><span class="line">    <span class="string">'id'</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="string">'t_modified'</span> <span class="built_in">timestamp</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="keyword">current_timestamp</span>,</span><br><span class="line">    primary <span class="keyword">key</span>(<span class="string">'id'</span>)</span><br><span class="line">) <span class="keyword">engine</span>=<span class="keyword">innodb</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> inro mysql.health_check(<span class="keyword">id</span>,t_modified) <span class="keyword">values</span>(@@server_id, <span class="keyword">now</span>()) <span class="keyword">on</span> <span class="keyword">duplicate</span> <span class="keyword">key</span> <span class="keyword">update</span> t_modified=<span class="keyword">now</span>();</span><br></pre></td></tr></table></figure>

<p>问题：判定慢  </p>
<ul>
<li>所有的检测逻辑都需要一个超时时间N，执行一条update语句，超过N秒后还不返回，就认为系统不可用。  </li>
</ul>
<p>日志盘的IO利用率已经是100%，整个系统响应非常慢，已经需要做主备切换了。  </p>
<p>但是IO利用率100%表示系统的IO是在工作的，每个请求都有机会获得IO资源，执行自己的任务。检测使用的update命令，需要的资源很少，可能在拿到IO资源的时候就可以提交成功，并且在超时时间N秒未到达之前就返回给了检测系统。让检测系统得到”系统正常”的结论。  </p>
<ul>
<li>基于外部检测还有一个天然问题，随机性。  </li>
</ul>
<p>外部检测都需要定时轮询，所以系统可能已经出问题了，但是却要等到下一个检测发起执行语句的时候，才有可能发现问题。而且，可能第一次轮询还不能发现，导致切换更慢。  </p>
<h3 id="内部统计"><a href="#内部统计" class="headerlink" title="内部统计"></a>内部统计</h3><p>MySQL提供内部每一次IO请求的时间，来反映磁盘利用率的问题。  </p>
<p>MySQL5.6版本提供performance_schema库，在file_summary_by_event_name表里统计了每次IO请求的时间。  </p>
<img src='/img/MySQL performance_schema.file_summary_by_event_name.png'>

<p>图中表示的是redo log的写入时间。</p>
<ul>
<li>第一列event_name表示统计的类型。  </li>
<li>接下来有三组数据，显示的是redo log操作的时间统计。  </li>
<li>第一组5列，是所有IO类型的统计。其中count_star是所有IO的总次数。接下来四列是具体的统计项，单位是皮秒；前缀sum、min、avg、max，分别对应总和、最小值、平均值、最大值。  </li>
<li>第二组6列，是读操作的统计。最后一列sum_number_of_bytes_read统计的是，总共从redo log里读了多少个字节。  </li>
<li>第三组6列，统计的是写操作。  </li>
<li>最后四组数据，是对其他类型数据的统计。在redo log里，是对fsync的统计。  </li>
</ul>
<p>binlog对应的是event_name=’wait/io/file/sql/binlog’这一行。  </p>
<hr>
<p>每一次操作数据库，performance_schema都需要额外的统计这些信息，打开统计功能有性能损耗，打开所有的performance_schema项，性能下降10%。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> setup_instruments <span class="keyword">set</span> enabled=<span class="string">'YES'</span>, Timed=<span class="string">'YES'</span> <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'%wait/io/file/innodb/innodb_log_file%'</span>;<span class="comment">-- redo log</span></span><br></pre></td></tr></table></figure>

<p>可以通过max_timer的值来判断数据库是否出问题。假设单次IO请求时间超过200毫秒属于异常：  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> event_name,max_timer_wait <span class="keyword">from</span> performance_schema.file_summary_by_event_name <span class="keyword">where</span> event_name <span class="keyword">in</span> (<span class="string">'wait/io/file/innodb/innodb_log_file'</span>,<span class="string">'wait/io/file/sql/binlog'</span>) <span class="keyword">and</span> max_timer_wait&gt;<span class="number">200</span>*<span class="number">1000000000</span>;</span><br></pre></td></tr></table></figure>

<p>发现异常后，取到需要的信息，把之前的统计信息清空，这样如果后面的监控中，再次出现这个异常，就可以加入监控累计值了（？？）：  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> performance_schema.file_summary_by_event_name;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>用动态的观点看加锁</title>
    <url>/MySQL/%E7%94%A8%E5%8A%A8%E6%80%81%E7%9A%84%E8%A7%82%E7%82%B9%E7%9C%8B%E5%8A%A0%E9%94%81/</url>
    <content><![CDATA[<p>加锁规则：  </p>
<ul>
<li>原则1： 加锁的基本单位是next-key lock。前开后闭区间。  </li>
<li>原则2： 查找过程中访问到的对象才会加锁。  </li>
<li>优化1： 索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁。  </li>
<li>优化2： 索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁。  </li>
<li>一个bug： 唯一索引上的范围查询会访问到不满足条件的第一个值为止。  </li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">'t'</span> (</span><br><span class="line">    <span class="string">'id'</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="string">'c'</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="string">'d'</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line">    primary <span class="keyword">key</span> (<span class="string">'id'</span>),</span><br><span class="line">    <span class="keyword">key</span> <span class="string">'c'</span> (<span class="string">'c'</span>)</span><br><span class="line">) <span class="keyword">engine</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> inro t <span class="keyword">values</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure>

<h3 id="不等号条件里的等值查询"><a href="#不等号条件里的等值查询" class="headerlink" title="不等号条件里的等值查询"></a>不等号条件里的等值查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;  </span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span>&gt;<span class="number">9</span> <span class="keyword">and</span> <span class="keyword">id</span>&lt;<span class="number">12</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">desc</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p>这个语句的加锁范围是主键索引上的(0,5]、(5,10]、(10,15)。id=15这一行，并没有被加上锁。  </p>
<p>加锁单位是next-key lock，都是前开后闭区间，但是这里用到了优化2，索引上的等值查询，向右遍历的时候id=15不满足条件，所以next-key lock退化为了间隙锁(10,15)。  </p>
<p>查询语句中的“等值查询”分析：加锁动作是发生在语句执行过程中的，分析加锁行为需要从索引上的数据结果开始。  </p>
<ol>
<li>首先这个查询语句是order by id desc，要拿到满足条件的所有行，优化器必须先找到“第一个id&lt;12的值”。  </li>
<li>这个过程是通过索引树的搜索过程得到的，在引擎内部，其实是要找到id=12的这个值，只是最终没找到，但找到了(10,15)这个间隙。  </li>
<li>然后向左遍历，在遍历过程中，就不是等值查询了，会扫描到id=5这一行，所以会加一个next-key lock(0,5]。  </li>
</ol>
<p>在执行过程中，通过树搜索的方式定位记录的时候，用的是“等值查询”的方式。  </p>
<h3 id="等值查询的过程"><a href="#等值查询的过程" class="headerlink" title="等值查询的过程"></a>等值查询的过程</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;  </span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> c <span class="keyword">in</span>(<span class="number">5</span>,<span class="number">20</span>,<span class="number">10</span>) <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br></pre></td></tr></table></figure>

<p>in语句explain结果：  </p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>partitions</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>filtered</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>simple</td>
<td>t</td>
<td>null</td>
<td>range</td>
<td>c</td>
<td>c</td>
<td>5</td>
<td>null</td>
<td>3</td>
<td>100.00</td>
<td>Using where, Using index</td>
</tr>
</tbody></table>
<p>这条in语句使用了索引c并且rows=3，说明这三个值都是通过B+树搜索定位的。  </p>
<p>在查找c=5的时候，先锁住了(0,5]。但是因为c不是唯一索引，为了确认还有没有别的记录c=5，就要向右遍历，找到c=10才确认没有了，这个过程满足优化2，所以加了间隙锁(5,10)。 </p>
<p>同样，执行c=10这个逻辑的时候，加锁的范围是(5,10]和(10,15)；执行c=20这个逻辑的时候，加锁的范围是(15,20]和(20,25)。  </p>
<p>综上，语句在索引c上加的三个记录锁的顺序是：先加c=5的记录锁，再加c=10的记录锁，最后加c=20的记录锁。  </p>
<p>这些锁是“在执行过程中一个一个假的”，而不是一次性加上去的。  </p>
<hr>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> c <span class="keyword">in</span>(<span class="number">5</span>,<span class="number">20</span>,<span class="number">10</span>) <span class="keyword">order</span> <span class="keyword">by</span> c <span class="keyword">desc</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p>间隙锁是不互锁的，以上两条语句都会在索引c上的c=5、10、20这三行记录上加记录锁。  </p>
<p>由于语句里的order by c desc，这三个记录锁的加锁顺序，是先锁c=20，然后c=10，最后是c=5。  </p>
<p>以上两条语句要加锁相同的资源，但是加锁顺序相反。当这两条语句并发执行的时候，可能出现死锁。  </p>
<p>关于死锁的信息，MySQL只保留了最后一个死锁的现场，不完备。  </p>
<h3 id="死锁-select"><a href="#死锁-select" class="headerlink" title="死锁(select)"></a>死锁(select)</h3><p>出现死锁后，执行show engine innodb status命令得到部分输出。其中一节latest detected deadlock，记录的就是最后一次死锁信息。  </p>
<ul>
<li>lock_mode X waiting表示next-key lock；  </li>
<li>lock_mode X locks rec but not gap只有行锁；  </li>
<li>locks gap before rec只有间隙锁。  </li>
</ul>
<img src='/img/MySQL死锁现场.png'>

<ol>
<li>这个结果分成三个部分：  <ul>
<li>(1)transaction，是第一个事务的信息；  </li>
<li>(2)transaction，是第二个事务的信息；  </li>
<li>we roll back transaction(1)，是最终的处理结果，表示回滚了第一个事务。  </li>
</ul>
</li>
<li>第一个事务的信息中：  <ul>
<li>waiting for this lock to be granted，表示的是这事务在等待的锁信息；  </li>
<li>record lock说明这是一个记录锁；  </li>
<li>index c of table ‘test’.’t’，说明在等的是表t的索引c上面的锁；  </li>
<li>lock mode S waiting表示这个语句要自己加一个读锁，当前的状态时等待中；  </li>
<li>n_field 2表示这个记录是两列，也就是字段c和主键字段id；  </li>
<li>0:len 4; hex 0000000a; asc;;是第一个字段，也就是c。值是十六进制a，也就是10；  </li>
<li>1:len 4; hex 0000000a; asc;;是第二个字段，也就是主键id，值也是10；  </li>
<li>这两行里面的asc表示的是，接下来要打印出值里面的“可打印字符”，但10不是可打印字符，因此就显示空格。  </li>
<li>第一个事务信息就只显示出了等锁的状态，在等待(c=10,id=10)这一行的锁。  </li>
<li>既然出现死锁了，就表示这个事务也占有别的锁，但是没有显示出来。  </li>
</ul>
</li>
<li>第二个事务显示的信息多一些：  <ul>
<li>‘holds the lock(s)’用来显示这个事务持有哪些锁；  </li>
<li>index c of table ‘test’.’t’表示锁是在表t的索引c上；  </li>
<li>hex 0000000a和hex 00000014表示这个事务持有c=10和c=20这两个记录锁；  </li>
<li>waiting for this lock to be granted，表示在等(c=5,id=5)这个记录锁。  </li>
</ul>
</li>
</ol>
<p>综上：  </p>
<ol>
<li>‘lock in share mode’这条语句，持有c=5的记录锁，在等c=10的锁；  </li>
<li>‘for update’这个语句，持有c=20和c=10的记录锁，在等c=5的记录锁。  </li>
</ol>
<hr>
<ol>
<li>由于锁是一个个加的，要避免死锁，对同一组资源，要按照尽量相同的顺序访问；  </li>
<li>在发生死锁的时刻，for update语句占有的资源更多，回滚的成本更大，所以InnoDB选择了回滚成本更小的lock in share mode语句来回滚。  </li>
</ol>
<h3 id="锁等待-delete-amp-insert"><a href="#锁等待-delete-amp-insert" class="headerlink" title="锁等待(delete&amp;insert)"></a>锁等待(delete&amp;insert)</h3><table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
</tr>
</thead>
<tbody><tr>
<td>begin;</br>select * from t where id&gt;10 and id&lt;=15 for update;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>delete from t where id=10;</br>(Query OK)</br>insert into t values(10,10,10);(blocked)</td>
</tr>
</tbody></table>
<p>由于<strong>sessionA并没有锁住c=10这个记录</strong>，所以sessionB删除c=10这一行是可以的，但是之后，sessionB再想insert id=10这一行回去就不行了。  </p>
<blockquote>
<p>根据id&gt;10得到的第一个记录是id=15，所以不会加(5,10]这个next-key lock，又由于id是主键索引，只加了(10,15]这个next-key lock。  </p>
</blockquote>
<img src='/img/MySQL锁等待信息.png'>

<p>执行show engine innodb status命令，锁信息在transactions这一节：  </p>
<ol>
<li>index primary of table ‘test’.’t’，表示这个语句被锁住是因为表t主键上的某个锁。  </li>
<li>lock_mode X locks gap before rec before rec insert intenting waiting里有几个信息：  <ul>
<li>insert intention表示当前线程准备插入一个记录，这是一个<strong>插入意向锁</strong>。可以理解为插入动作本身。  </li>
<li>gap before rec表示这是一个间隙锁，而不是记录锁。  </li>
</ul>
</li>
<li>接下来的0~4这5行的内容是这个间隙的记录信息。  </li>
<li>n_fields 5也表示了，这一个记录有5列:  <ul>
<li>0:len 4; hex 0000000f; asc ;;第一列是主键id字段，十六进制f就是id=15。这个间隙锁值id=15之前的，因为id=10已经不存在了，它表示的就是(5,15)。  </li>
<li>1:len 6; hex 000000000513; asc;;第二列是长度为6字节的事务id，表示最后修改这一行的是trx id为1299的事务。  </li>
<li>2:len 7; hex b0000001250134; asc %4;;第三列长度为7的字节的回滚段信息。可以看到，这里的asc后面有显示内容(%和4)，这是因为刚好这个字节是可打印字符。  </li>
<li>后面两列是c和d的值，都是15。  </li>
</ul>
</li>
</ol>
<p>综上：<br>由于delete操作把id=10这一行删掉了，原来的两个间隙(5,10)、(10,15)变成了一个(5,15)。<strong>删除前间隙锁只有一个(10,15)</strong>，删除后间隙锁左侧扩张成了5，得到间隙锁(5,15)  </p>
<hr>
<ol>
<li>sessionA执行完select语句之后，什么都没做，但它加锁的范围突然变大了；  </li>
<li>对比，当执行select * from t where c&gt;=10 and c&lt;=25 order by c desc lock in share mode;倒序向左扫描到c=5(非唯一索引，一直扫描到第一个不符合条件的值)的时候才会停止，要把(0,5]锁起来。所谓“间隙”，是由“这个间隙右边的那个记录”定义的。  </li>
</ol>
<h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
</tr>
</thead>
<tbody><tr>
<td>begin;</br>select c from t where c&gt;5 lock in share mode;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>update t set c=1 where c=5;</br>(Query OK)</br>update t set c=5 where c=1;</br>(blocked)</td>
</tr>
</tbody></table>
<p>sessionA的加锁范围是索引C上的(5,10]、(10,15]、(15,20]、(20,25]、(25,supremum]。  </p>
<blockquote>
<p>根据c&gt;5查到的第一个记录是c=10，因此不会加(0,5]这个next-key lock。  </p>
</blockquote>
<p>之后sessionB的第一个update语句，要把c=5改成c=1，分为两步：  </p>
<ol>
<li>插入(c=1,id=5)这个记录；  </li>
<li>删除(c=5,id=5)这个记录。  </li>
</ol>
<p>索引c上(5,10)间隙是由这个间隙右边的记录c=10定义的(锁等待中的总结)。<br>执行第一个操作后，锁为(c=1,id=5)~(25,supremum]。  </p>
<p>sessionB的第二个update语句，要把c=1改成c=5，分为两步：  </p>
<ol>
<li>插入(c=5,id=5)这个记录；  </li>
<li>删除(c=1,id=5)这个记录。  </li>
</ol>
<p>第一步试图在已经加了间隙锁的(c=1,id=5)~(c=10,id=10)中插入数据，所以就被堵住了。  </p>
<h3 id="空表的间隙"><a href="#空表的间隙" class="headerlink" title="空表的间隙"></a>空表的间隙</h3><p>一个空表只有一个间隙。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;  </span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span>&gt;<span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;  </span><br><span class="line"><span class="comment">-- 这个查询语句加锁的范围是next-key lock(-∞,supremum]。</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
</tr>
</thead>
<tbody><tr>
<td>create table t(id int primary key) engine=innodb;</br>begin;</br>select * from t where id&gt;1;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>insert into t values(2);</br>(blocked)</td>
</tr>
<tr>
<td>show engine innodb status;</td>
<td></td>
</tr>
</tbody></table>
<img src='/img/MySQL锁等待-空表.png'>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>读写分离导致的过期读问题</title>
    <url>/MySQL/%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E5%AF%BC%E8%87%B4%E7%9A%84%E8%BF%87%E6%9C%9F%E8%AF%BB%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>读写分离的主要目标就是分摊主库的压力。两种架构：  </p>
<ul>
<li>客户端(client)主动做负载均衡，这种模式下一般会把数据库的连接信息放在客户端的连接层，由客户端来选择后端数据库进行查询。  </li>
<li>在MySQL和客户端之间有一个中间层proxy，客户端只连接proxy，由proxy根据请求类型和上下文决定请求的分发路由。  </li>
</ul>
<p>架构对比：  </p>
<ol>
<li>客户端直连方案，因为少了一层proxy转发，查询性能稍微好一点，并且整体架构简单，排查问题更方便。缺点由于要了解后端部署细节，在出现主备切换、库迁移等操作时，客户端都会感知到，并且需要调整数据库连接信息。一般采用这样的架构，一定会伴随一个管理后端的组件，比如Zookeeper，处理冗余的配置信息，尽量让业务端只专注于业务逻辑开发。  </li>
<li>带proxy的架构，对客户端比较友好。客户端不需要关注后端细节，连接维护、后端信息维护等工作，都是由proxy完成的。缺点对后端维护团队的要求会更高。而且proxy本身也需要有高可用架构，整体比较复杂。  </li>
</ol>
<hr>
<p>由于主从可能存在延迟，客户端执行完一个更新事务后马上发起查询，如果查询选择的是从库的话，就有可能读到刚刚的事务更新之前的状态。这种<strong>在从库上会读到系统的一个过期状态的现象，称为过期读。</strong>  </p>
<p>主从延迟是不能100%避免。但客户端希望查询从库的数据结果，跟查主库的数据结果时一样的。  </p>
<h3 id="强制走主库方案"><a href="#强制走主库方案" class="headerlink" title="强制走主库方案"></a>强制走主库方案</h3><p>强制走主库方案其实就是，将查询请求做分类：  </p>
<ol>
<li>对于必须要要拿到最新结果的请求，强制将其发到主库上。在一个交易平台上，卖家发布商品以后，马上要返回主页面，看商品是否发布成功。这个请求需要拿到最新的结果，就必须走主库。  </li>
<li>对于可以读到旧数据的请求，才将其发到从库上。在这个交易平台上，买家来逛商铺页面，就算晚几秒看到最新发布的商品，也是可以接受的。这类请求可以走从库。  </li>
</ol>
<p>问题：针对“所有查询都不能是过期读”的需求，金融类业务。需要放弃读写分离，放弃扩展性，所有读写压力都在主库。</p>
<h3 id="sleep方案"><a href="#sleep方案" class="headerlink" title="sleep方案"></a>sleep方案</h3><p>主库更新后，读从库之前先sleep一下，具体方案就是，类似于执行一条select sleep(1)命令。方案的前提是，大多数情况下主备延迟在1秒之内，做一个sleep可以有很大概率拿到最新的数据。  </p>
<p>卖家发布商品，商品发布后，用Ajax(Asynchronous JacaScript + XML,异步JavaScript和XML)直接把客户端输入的内容作为“新的商品”显示在页面上，而不是真正的去数据库做查询。卖家可以通过这个显示，来确认产品已经发布成功了，等卖家再刷新页面，去查看商品的时候，已经过了一段时间，达到了类似sleep的目的，解决了过期读的问题。  </p>
<p>问题：1.如果这个查询请求本来0.5秒就可以在从库上拿到正确结果，也会等1秒；2.如果延迟超过1秒，还是会出现过期读。  </p>
<h3 id="判断主备无延迟方案"><a href="#判断主备无延迟方案" class="headerlink" title="判断主备无延迟方案"></a>判断主备无延迟方案</h3><p>show slave status结果里的seconds_behind_master参数的值，可以用来衡量主备延迟时间的长短。  </p>
<h4 id="判断seconds-behind-master确保主备无延迟"><a href="#判断seconds-behind-master确保主备无延迟" class="headerlink" title="判断seconds_behind_master确保主备无延迟"></a>判断seconds_behind_master确保主备无延迟</h4><p>每次从库执行查询请求前，先判断seconds_behind_master是否已经对于0。如果还不等于0，就必须等到这个参数变为0才能执行查询请求。  </p>
<p>问题：SBM的单位是秒，精度不够。   </p>
<hr>
<img src="/img/MySQL show slave status结果.png" width="600" height="300" >

<h4 id="对比位点确保主备无延迟"><a href="#对比位点确保主备无延迟" class="headerlink" title="对比位点确保主备无延迟"></a>对比位点确保主备无延迟</h4><ul>
<li>Master_Log_File和Read_Master_Log_Pos，表示的是读到的主库的最新位点；  </li>
<li>Relay_Master_Log_File和Exec_Master_Log_Pos，表示的是备库执行的最新位点。  </li>
</ul>
<p>如果这两组值完全相同，就表示接收到的日志已经同步完成。  </p>
<h4 id="对比GTID集合确保主备无延迟"><a href="#对比GTID集合确保主备无延迟" class="headerlink" title="对比GTID集合确保主备无延迟"></a>对比GTID集合确保主备无延迟</h4><ul>
<li>Auto_Position=1，表示这对主备关系使用了GTID协议。  </li>
<li>Retrieved_Gtid_Set，是备库收到的所有日志的GTID集合。  </li>
<li>Executed_Gtid_set，是备库所有已经执行完成的GTID集合。  </li>
</ul>
<p>如果这两个集合相同，也表示备库接收到的日志都已经同步完成。  </p>
<hr>
<p>在执行查询请求前，先判断从库是否同步完成的方法，相比于sleep方案，准确度有提升，但达不到“精确”的程度。  </p>
<p>一个事务的binlog在主备之间的状态：  </p>
<ol>
<li>主库执行完成，写入binlog，并反馈给客户端；  </li>
<li>binlog被从主库发送给备库，备库收到；  </li>
<li>在备库执行binlog完成。  </li>
</ol>
<p>本方案中判断主备无延迟的逻辑，是备库收到的日志都执行完成了。但是还有一部分日志，处于客户端已经收到提交确认，而备库还没收到日志的状态。但从库认为已经没有同步延迟，客户端在从库上执行查询请求却查不到数据。  </p>
<h3 id="配合semi-sync方案"><a href="#配合semi-sync方案" class="headerlink" title="配合semi-sync方案"></a>配合semi-sync方案</h3><p>半同步复制：semi-sync replication。</p>
<ol>
<li>事务提交的时候，主库把binlog发给从库；  </li>
<li>从库收到binlog以后，发回给主库一个ack，表示收到了；  </li>
<li>主库收到这个ack以后，才能给客户端返回“事务完成”的确认。  </li>
</ol>
<p>如果启用了semi-sync，就表示所有给客户端发送过确认的事务，都确保了备库已经收到了这个日志。<br>半同步复制也解决了普通模式下主库掉电，来不及发送给从库的binlog导致系统数据丢失的问题。  </p>
<p>semi-sync配合关于位点(或者GTID)的判断，就能够确定在从库上执行的查询请求，可以避免过期读。  </p>
<p>问题1：半同步复制+位点判断的方案，只对一主一备的场景是成立的。在一主多从场景中，主库只要等到一个从库的ack，就开始给客户端返回确认。此时，在从库上执行查询请求有两种情况：  </p>
<ol>
<li>如果查询是落在这个响应了ack的从库上，是能够确保读到最新数据；  </li>
<li>但如果是查询落到其他从库上，它们可能还没有收到最新的日志，就会产生过期读的问题。  </li>
</ol>
<p>问题2：在业务更新的高峰期，主库的位点或者GTID集合更新很快，那么上面的两个位点等值判断就会一直不成立，很可能出现从库上迟迟无法响应查询请求，而过度等待的情况。  </p>
<h3 id="等主库位点方案"><a href="#等主库位点方案" class="headerlink" title="等主库位点方案"></a>等主库位点方案</h3><p>select master_pos_wait(file, pos[, timeout]);  </p>
<ol>
<li>它是在从库执行的；  </li>
<li>参数file和pos指的是主库上的文件名和位置；  </li>
<li>timeout可选，设置为正整数N，表示这个函数最多等待N秒。  </li>
</ol>
<p>这个命令正常返回的结果是一个正整数M，表示从命令开始执行，到应用完file和pos表示的binlog位置，执行了多少事务。其他异常返回：  </p>
<ol>
<li>如果执行期间，备库同步线程发生异常，则返回NULL；  </li>
<li>如果等待超过N秒，就返回-1；(从库的延迟时间不可控，不能无限等待，等待超时，就应该放弃，然后到主库上去查)  </li>
<li>如果刚开始执行的时候，就发现已经执行过这个位置了，则返回0。  </li>
</ol>
<p>示例：<br>先执行trx1，再执行一个查询请求的逻辑，要保证能够查到正确的数据：  </p>
<ol>
<li>trx1事务更新完成后，马上执行show master status得到当前主库执行到的File和Position；  </li>
<li>选定一个从库执行查询语句；  </li>
<li>在从库上执行select master_pos_wait(File, Position, 1)；(最多等待一秒)  </li>
<li>如果返回值是&gt;=0的正整数，则在这个从库上执行查询语句；  </li>
<li>否则，到主库上执行查询语句。  </li>
</ol>
<p>问题：如果所有的从库都延迟超过了1秒，查询压力都跑到主库上了。否则就超时放弃。  </p>
<h3 id="等GTID方案"><a href="#等GTID方案" class="headerlink" title="等GTID方案"></a>等GTID方案</h3><p>数据库开启了GTID模式，对应等主库位点的等GTID方案。  </p>
<p>select wait_for_executed_gtid_set(gtid_set, 1);  </p>
<ol>
<li>等待，知道这个库执行的事务中包含传入的gtid_set，返回0；  </li>
<li>超时返回1。  </li>
</ol>
<p>对比等主库位点，执行完事务后，还要主动去主库自行show master status。从MySQL5.7.6版本开始，允许在执行完更新类事务后，把这个事务的GTID返回给客户端，这样等GTID的方案可以减少一次查询。  </p>
<p>示例：  </p>
<ol>
<li>trx1事务更新完成后，从返回包直接获取这个事务的GTID，记为gtid1；(将参数session_track_gtids设置为OWN_GTID，然后通过API接口mysql_session_track_get_first从返回包解析出GTID的值)  </li>
<li>选定一个从库执行查询语句；  </li>
<li>在从库上执行select wait_for_executed_gtid_set(gtid1, 1)；  </li>
<li>如果返回值是0，则在这个从库执行查询语句；  </li>
<li>否则，到主库执行查询语句。  </li>
</ol>
<p>问题：与等主库位点一样。超时放弃或者直接到主库查询。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>误删数据处理</title>
    <url>/MySQL/%E8%AF%AF%E5%88%A0%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>误删数据分类：  </p>
<ol>
<li>使用delete语句误删数据行；  </li>
<li>使用drop table或者truncate table语句误删数据表；  </li>
<li>使用drop database语句误删数据库；  </li>
<li>使用rm命令误删整个MySQL实例。  </li>
</ol>
<h3 id="误删行"><a href="#误删行" class="headerlink" title="误删行"></a>误删行</h3><p>如果使用delete语句误删了数据行，可以用Flashback工具通过闪回把数据恢复回来。  </p>
<p>Flashback恢复数据的原理，是修改binlog的内容，拿回原库重放。前提要确保binlog_format=row和binlog_row_image=FULL。  </p>
<h4 id="单个事务"><a href="#单个事务" class="headerlink" title="单个事务"></a>单个事务</h4><ol>
<li>对于insert语句，对应的binlog event类型是Write_rows event，把它改成Delete_rows event即可；  </li>
<li>对于delete语句，将Delete_rows event改为Write_rows event；  </li>
<li>如果是Update_rows，binlog里面记录了数据行修改前后修改后的值，对调这两行的位置即可。  </li>
</ol>
<h4 id="多个事务"><a href="#多个事务" class="headerlink" title="多个事务"></a>多个事务</h4><blockquote>
<p>(A)delete …<br>(B)insert …<br>(C)update …  </p>
</blockquote>
<p>写回主库的命令是：  </p>
<blockquote>
<p>(reverse C)update …<br>(reverse B)delete …<br>(reverse A)insert …  </p>
</blockquote>
<p>误删数据涉及多个事务的话，需要将事务的顺序倒过来再执行。  </p>
<h4 id="事后处理"><a href="#事后处理" class="headerlink" title="事后处理"></a>事后处理</h4><p>恢复数据比较安全的做法，恢复出一个备份，或者找一个从库作为临时库，在临时库上执行这些操作，然后再讲确认过的临时库的数据，恢复回主库。  </p>
<p>一个在执行线上逻辑的主库，数据状态的变更往往是有关联的。发现数据问题的时间晚一点，容易导致已经在之前误操作的基础上，业务代码逻辑又继续修改了其他数据。单独恢复这几行数据，又未经过确认，可能会出现对数据的二次破坏。  </p>
<h4 id="事前预防"><a href="#事前预防" class="headerlink" title="事前预防"></a>事前预防</h4><ol>
<li>把sql_safe_updates参数设置为on。如果忘记delete或者update语句中写where条件，或者where条件里面没有包含索引字段的话，这条语句的执行就会报错。  <blockquote>
<p>设置为on后确实要删，可以在delete语句中加上where条件，where id&gt;=0。  </p>
</blockquote>
</li>
<li>代码上线前，做SQL审计。  </li>
</ol>
<hr>
<p>delete全表很慢，需要生成回滚日志undo、写redo、写binlog。从性能角度考虑，应该优先考虑使用truncate table或者drop table命令。  </p>
<p>使用delete命令删除的数据，可以用Flashback来恢复，而使用truncate/drop table和drop database命令删除的数据，就没办法通过Flashback来恢复了。即使配置了binlog_format=row，执行这三个命令时，记录的binlog还是statement格式，binlog里面只有一个truncate/drop语句，这些信息是恢复不出数据的。  </p>
<h3 id="误删库-表"><a href="#误删库-表" class="headerlink" title="误删库/表"></a>误删库/表</h3><p>这种情况下，要想恢复数据，就需要使用全量备份，加增量日志的方式，这个方案要求线上有定期的全量备份，并且实时备份binlog。  </p>
<h4 id="binlog备份应用到临时库"><a href="#binlog备份应用到临时库" class="headerlink" title="binlog备份应用到临时库"></a>binlog备份应用到临时库</h4><p>中午12点误删后恢复流程：  </p>
<ol>
<li>取最近一次全量备份，假设这个库是一天一备，上次备份是当天0点；  </li>
<li>用备份会付出一个临时库；  </li>
<li>从日志备份里面，取出0点之后的日志；  </li>
<li>把这些日志，除了误删数据的语句外，全部应用到临时库。  </li>
</ol>
<p>优化：  </p>
<ol>
<li>为了加速数据恢复，如果这个临时库上有多个数据库，可以在使用mysqlbinlog命令时，加上一个database参数，用来指定误删表所在的库，避免了在恢复数据时还要应用其他库日志的情况。  </li>
<li>在应用日志的时候，需要跳过12点误操作的那个语句的binlog：  <ul>
<li>如果原实例没有使用GTID模式，只能在应用到包含12点的binlog文件的时候，先用-stop-position参数执行到误操作之前的日志，然后再用-start-position从误操作之后的日志继续执行；  </li>
<li>如果实例使用了GTID模式，假设误操作命令的GTID是gtid1，那么只需要执行set gtid_next=gtid1;begin;commit;先把这个GTID加到临时实例的GTID集合，之后按顺序执行binlog的时候，就会自动跳过误操作的语句。  </li>
</ul>
</li>
</ol>
<p>问题：  </p>
<ol>
<li>如果是误删表，最好就是只恢复出这张表，也就是只重放这张表的操作，但是mysqlbinlog工具并不能指定只解析一个表的日志；  </li>
<li>用mysqlbinlog解析出日志应用，应用日志的过程只能是单线程。并行复制的方法用不上。  </li>
</ol>
<h4 id="临时库接到备库上"><a href="#临时库接到备库上" class="headerlink" title="临时库接到备库上"></a>临时库接到备库上</h4><p>在备份恢复出临时实例之后，将这个临时实例设置成线上备库的从库：  </p>
<ol>
<li>在start slave之前，先通过执行change replication filter replicate_do_table=(tbl_name)命令，就可以让临时库只同步误操作的表；  </li>
<li>同时可以用上并行复制技术，来加速整个数据恢复过程。</li>
</ol>
<p>如果由于时间太久，备库上(show binlogs最小的binlog文件master.00007)已经删除了临时实例需要的binlog(master.000005)，可以从binlog备份系统中找到需要的binlog，再放回备库中。  </p>
<ol>
<li>从备份系统下载master.000005和master.000006这两个文件，放到备库的日志目录下；  </li>
<li>打开日志目录下的master.index文件，在文件开头加入两行，内容分别是“./master.000005”和“./master.000006”；  </li>
<li>重启备库，目的是让备库重新识别这两个日志文件；  </li>
<li>备库上备齐临时库需要的所有binlog，建立主备关系，可以正常同步。  </li>
</ol>
<hr>
<p>误删库或者表后，恢复数据的思路主要就是通过备份，再加上应用binlog的方式。两个方案都要求备份系统定期备份全量日志，而且需要确保binlog在被从本地删除之前已经做了备份。但一个系统不可能备份无限的日志。  </p>
<p>数据恢复功能做成自动化工具，并且经常拿出来演练。</p>
<h3 id="延迟复制备库"><a href="#延迟复制备库" class="headerlink" title="延迟复制备库"></a>延迟复制备库</h3><p>利用并行复制来加速恢复数据的过程，依然存在恢复时间不可控的问题。  </p>
<p>如果一个库的备份特别大，或者误操作的时间距离上一个全量备份的时间较长，恢复时间较长。如果有非常核心的业务，不允许太长的恢复时间，可以考虑搭建延迟复制的备库。MySQL5.6引入。  </p>
<p>一般的主备复制结果存在的问题，如果主库上有个表被误删了，这个命令很快也会被发给所有的从库，进而导致所有从库的数据表也都一起被误删。  </p>
<p>延迟复制的备库是一种特殊的备库，通过change master to master_delay=n命令，可以执行这个备库持续保持跟主库有N秒的延迟。  </p>
<p>发现误删后，在备库上执行stop slave，在通过之前介绍的方法，跳过误操作命令，可以得到一个只延迟n秒就可以恢复出数据的临时实例。  </p>
<h3 id="预防误删库-表的方法"><a href="#预防误删库-表的方法" class="headerlink" title="预防误删库/表的方法"></a>预防误删库/表的方法</h3><h4 id="账号分离"><a href="#账号分离" class="headerlink" title="账号分离"></a>账号分离</h4><p>目的是避免写错命令  </p>
<ul>
<li>只给业务开发同学DML权限，而不给truncate/drop权限。如果业务开发人员有DDL需求，可以通过开发管理系统得到支持。  </li>
<li>即使是DBA团队成员，日常也都规定只使用只读账号，必要的时候才使用有更新权限的账号。  </li>
</ul>
<p>show grants命令查看账户的权限。  </p>
<h4 id="指定操作规范"><a href="#指定操作规范" class="headerlink" title="指定操作规范"></a>指定操作规范</h4><p>目的是避免写错要删除的表名  </p>
<ul>
<li>在删除数据表之前，必须先对表做改名操作。然后，观察一段时间，确保对业务无影响以后再删除这张表。  </li>
<li>改表名的时候，要求给表名加固定的后缀(如_to_be_deleted)，然后删除表的动作必须通过管理系统执行。并且管理系统删除表的时候，只能删除固定后缀的表。  </li>
</ul>
<h3 id="rm删除数据"><a href="#rm删除数据" class="headerlink" title="rm删除数据"></a>rm删除数据</h3><p>高可用MySQL集群。不怕rm删除数据。只要不是恶意的把整个集群删除，而只是删掉了其中某一个节点的数据，HA系统会开始工作，选出一个新的主库，从而保证整个集群的正常工作。个人只需要在这个节点上把数据恢复回来，再接入整个集群。  </p>
<p>备份跨机房，跨城市保存。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>全表扫描对内存的影响</title>
    <url>/MySQL/%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F%E5%AF%B9%E5%86%85%E5%AD%98%E7%9A%84%E5%BD%B1%E5%93%8D/</url>
    <content><![CDATA[<h3 id="全表扫描对server层的影响"><a href="#全表扫描对server层的影响" class="headerlink" title="全表扫描对server层的影响"></a>全表扫描对server层的影响</h3><p>对一个200G的InnoDB表db1.t，执行一个全表扫描，把扫描结果保存在客户端：  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql -h$host -P$port -u$user -p$pwd -e "<span class="keyword">select</span> * <span class="keyword">from</span> db1.t<span class="string">" &gt; $target_file</span></span><br></pre></td></tr></table></figure>

<p>InnoDB的数据是保存在主键索引上的，全表扫描实际上是直接扫描表t的主键索引。查询语句中没有其他的判断条件，查到的每一行都可以直接放到结果集里，然后返回给客户端。但服务端并不需要保存一个完整的结果集。  </p>
<p>服务端取数据和发数据的流程：  </p>
<ol>
<li>获取一行，写到net_buffer中，这块内存的大小是有参数net_buffer_length定义的，默认是16K。  </li>
<li>重复获取行，直到net_buffer写满，调用网络接口发出去。  </li>
<li>如果发送成功，就清空net_buffer，然后继续取下一行，并写入net_buffer。  </li>
<li>如果发送函数返回EAGAIN或者WSAEWOULDBLOCK，就表示本地网络栈(socket send buffer)写满了，进入等待(对应客户端Socket receive buffer)。直到网络栈重新可写，再继续发送。  </li>
</ol>
<ul>
<li>一个查询在发送过程中，占用的MySQL内部的内存最大就是net_buffer_length那么大。  </li>
<li>socket send buffer默认定义在/proc/sys/net/core/wmem_default。如果socket send buffer被写满，就会暂停读数据的流程。  </li>
</ul>
<h4 id="Sending-to-client"><a href="#Sending-to-client" class="headerlink" title="Sending to client"></a>Sending to client</h4><p><strong>MySQL是“边读边发的</strong>”。如果客户端接收的慢，会导致MySQL服务端由于结果发不出去，这个事务的执行时间变长。  </p>
<p>如果让客户端不去读socket receive buffer中的内容，在服务端show processlist看到State的值一致处于”<strong>Sending to client</strong>“，表示服务端的网络栈写满了。  </p>
<p>如果客户端使用-quick参数，会使用mysql_user_result方法。这个方法是读一行处理一行。假设有一个业务的逻辑比较复杂，每读一行数据以后要处理的逻辑如果很慢，就会导致客户端要过很久才会去取下一行数据，可能会出现上边服务端发送阻塞的情况。  </p>
<p>对于正常的线上业务来说，如果一个查询的返回结果不会很多的话，建议使用，mysql_store_result这个接口，直接把查询结果保存到本地内存。  </p>
<p>如果在自己负责维护的MySQL里看到很多个线程都处于“Sending to client”这个状态，就意味着需要业务开发优化查询结果，并评估这么多的返回结果是否合理。如果要快速减少处于这个状态的线程，将net_buffer_length参数设置为一个更大的值是一个可选的方案。  </p>
<h4 id="Sending-data"><a href="#Sending-data" class="headerlink" title="Sending data"></a>Sending data</h4><p>一个查询语句的状态变化：  </p>
<ul>
<li>MySQL查询语句进入执行阶段后，首先把状态设置成“Sending data”；  </li>
<li>然后，发送执行结果的列相关的信息(meta data)给客户端；  </li>
<li>再继续执行语句的流程；  </li>
<li>执行完成后，把状态设置成空字符串。  </li>
</ul>
<p>Sending data并不一定是指“正在发送数据”，而可能是出于执行器过程中的任意阶段。例如锁等待的场景。  </p>
<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
</tr>
</thead>
<tbody><tr>
<td>begin;</br>select * from t where id=1 for update;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>select * from t lock in share mode;</br>(blocked)</td>
</tr>
</tbody></table>
<p>sessionB是在等锁，但是show processlist命令中State列显示为Sending data。  </p>
<p>仅当一个线程处于“等待客户端接收结果”的状态，才会显示”Sending to client”；而如果显示成“Sending data”，它的意思只是“正在执行”。  </p>
<p>查询结果是分段发送给客户端的，扫描全表，查询返回大量的数据，不会在server端保存完整的结果集，即使客户端读结果不及时，会堵住MySQL的查询过程，但并不会把内存打爆。  </p>
<h3 id="全表扫描对InnoDB的影响"><a href="#全表扫描对InnoDB的影响" class="headerlink" title="全表扫描对InnoDB的影响"></a>全表扫描对InnoDB的影响</h3><p>内存的数据页是在Buffer Pool(BP)中管理的，在WAL中Buffer Pool起到了加速更新的作用(随机写磁盘-&gt;顺序写磁盘)。实际上，Buffer Pool还有一个更重要的作用，就是加速查询。  </p>
<p>当事务提交的时候，磁盘上的数据页是旧的，此时马上有一个查询来读这个数据页，不需要把redo log应用到数据页。这时内存数据页的结果时最新的，直接读内存页就可以了。这时候查询根本不需要读磁盘，直接从内存拿结果，速度是很快的。所以Buffer Pool还有加速查询的作用。  </p>
<p>Buffer Pool对查询的加速效果，依赖于一个重要指标：<strong>内存命中率</strong>。  </p>
<p>可以在show engine innodb status结果中，查看一个系统当前的BP命中率。一般情况下，一个稳定服务的线上系统，要保证响应时间符合要求的话，内存命中率要在99%以上。  </p>
<blockquote>
<p>Buffer pool hit rate 990/1000  </p>
</blockquote>
<p>InnoDB Buffer Pool的大小是由参数innodb_buffer_pool_size确定的，一般建议设置成可用物理内存的60%~80%。  </p>
<h4 id="LRU淘汰算法"><a href="#LRU淘汰算法" class="headerlink" title="LRU淘汰算法"></a>LRU淘汰算法</h4><p>innodb_buffer_pool_size小于磁盘的数据量是很常见的。如果一个Buffer Pool满了，而又要从磁盘读入一个数据页，那肯定是要淘汰一个旧数据页的(刷脏页)，大查询也不会导致内存暴涨。  </p>
<p>InnoDB内存管理用的是最近最少使用(Least Recently Used,LRU)算法，核心是淘汰最久未使用的数据。  </p>
<p>InnoDB管理Buffer Pool的LRU算法，是用链表来实现的。<br><a href="/数据结构与算法/链表">数据结构与算法-链表</a><br><a href="/数据结构与算法/散列表应用">数据结构与算法-散列表应用</a>  </p>
<h4 id="改进LRU算法"><a href="#改进LRU算法" class="headerlink" title="改进LRU算法"></a>改进LRU算法</h4><p>按照LRU算法，要扫描一个200G的表，而这个表是一个历史数据表，平时没有业务访问它。按照普通LRU算法扫描的话，就会把当前的Buffer Pool里的数据全部淘汰掉，存入扫描过程中访问到的数据页的内容。Buffer Pool里面主要放的是这个历史数据表的数据。  </p>
<p>对于一个正在做业务服务的库，Buffer Pool的内存命中率急剧下降，磁盘压力增加，SQL语句响应变慢。  </p>
<p>InnoDB对LRU算法做了改进：  </p>
<img src='/img/MySQL改进LRU算法.png'>

<p>InnoDB实现上，按照5:3的比例把整个LRU链表分成了young区域和old区域。图中LRU_old指向的就是old区域的第一个位置，是整个链表的5/8处。靠近链表头部的5/8是young区域，靠近链表尾部的3/8是old区域。  </p>
<p>改进后的LRU算法执行流程：  </p>
<ol>
<li>状态1，要访问数据页P3，由于P3在young区域，因此和优化前的LRU算法一样，将其移到链表头部，变成状态2。  </li>
<li>之后要访问一个新的不存在于当前链表的数据页，这时候依然是淘汰掉数据页Pm，但新插入的数据页Px，是放在LRU_old处。  </li>
<li>处于old区域的数据页，每次被访问的时候都要做下面的判断：  <ul>
<li>若这个数据页在LRU链表中存在的时间超过了1秒，就把它移动到链表头部；  </li>
<li>如果这个数据页在LRU链表中存在的时间短于1秒，位置保持不变。1秒这个时间，是由参数innodb_old_blocks_times控制的，其默认值是1000，单位毫秒。  </li>
</ul>
</li>
</ol>
<p>这个策略，就是为了处理类似全表扫描的操作量身定制的。  </p>
<ol>
<li>扫描过程中，需要新插入的数据页，都被放到old区域；  </li>
<li>一个数据页里面有多条记录，这个数据页会被多次访问到，但由于是顺序扫描，这个数据页第一次被访问和最后一次被访问的时间间隔不会超过1秒，因此还是会被保留在old区域；  </li>
<li>再继续扫描后续的数据，之前的这个数据页之后也不会再被访问到，于是始终没有机会移动到链表头部(young区域)，很快就会被淘汰出去。  </li>
</ol>
<p>这个策略最大的收益，就是在扫描大表的过程中，即使是冷数据的全表扫描，虽然也用到了Buffer Pool，但是对young区域完全没有影响，从而保证了Buffer Pool响应正常业务的查询命中率。  </p>
<blockquote>
<p>全表扫描比较耗费IO资源，业务高峰期不能直接在线上主库执行全表扫描。  </p>
</blockquote>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>kill query threadId与kill [connection] threadId</title>
    <url>/MySQL/%20kill%20query%20threadId%E4%B8%8Ekill%20%5Bconnection%5D%20threadId/</url>
    <content><![CDATA[<p>在MySQL中有两个kill命令：一个是kill query +线程id，表示终止这个线程中正在执行的语句；一个是kill [connection] +线程id，表示断开这个线程的连接，如果这个线程有语句正在执行，是要先停止正在执行的语句的。  </p>
<p>有时使用了kill命令，却没能断开这个连接。再执行show processlist命令，看到这条语句的Command列显示的是Killed。  </p>
<p>大多数情况下，kill query/connection命令是有效的。  </p>
<ul>
<li>执行一个查询的过程中，发现执行时间太久，要放弃继续查询，可以用kill query命令，终止这条查询语句。  </li>
<li>语句处于锁等待的时候，直接使用kill命令。  </li>
</ul>
<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
<th>sessionC</th>
</tr>
</thead>
<tbody><tr>
<td>begin;</br>update t set c=c+1 where id=1;</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>update t set c=c+1 where id=1;</br>(blocked)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>ERROR 1317(70100):Query execution was interrupted</td>
<td>kill query thread_id_B;</td>
</tr>
</tbody></table>
<h3 id="收到kill以后，线程做什么"><a href="#收到kill以后，线程做什么" class="headerlink" title="收到kill以后，线程做什么"></a>收到kill以后，线程做什么</h3><p>当对一个表做增删改查操作时，会在表上加MDL读锁。sessionB虽然处于blocked状态，但还是拿着一个MDL读锁，如果线程被kill的时候，直接终止，那之后这个MDL读锁就没机会被释放了。  </p>
<p>kill并不是马上停止的意思，而是告诉执行线程说，这条语句已经不需要继续执行了，可以开始执行停止的逻辑了。  </p>
<blockquote>
<p>跟Linux的kill命令类似，kill -N pid并不是让进程直接停止，而是给进城发一个信号，然后进程处理这个信号，进入终止逻辑。只是对于MySQL的kill命令来说，不需要传信号量参数，就只有“停止”这个命令。  </p>
</blockquote>
<p>当用户执行kill query Thread_id_B时，MySQL里处理kill命令的线程做了两件事：  </p>
<ol>
<li>把sessionB的运行状态改成THD::KILL_QUERY(将变量killed赋值为THD::KILL_QUERY)；  </li>
<li>给sessionB的执行线程发一个信号。  <blockquote>
<p>sessionB处于锁等待状态，如果只是把sessionB的线程状态设置THD::KILL_QUERY，线程B并不知道这个状态变化，还是会继续等待。发一个信号的目的，就是让sessionB退出等待，来处理这个THD::KILL_QUERY状态。  </p>
</blockquote>
</li>
</ol>
<ul>
<li>一个语句执行过程中有多处“埋点”，在这些“埋点”的地方判断线程状态，如果发现线程状态时THD::KILL_QUERY，才开始进入语句终止逻辑；  </li>
<li>如果处于等待状态，必须是一个可以被唤醒的等待，否则根本不会执行到“埋点”处；  </li>
<li>语句从开始进入终止逻辑，到终止逻辑完全完成，是有一个过程的。  </li>
</ul>
<h3 id="kill-query无效"><a href="#kill-query无效" class="headerlink" title="kill query无效"></a>kill query无效</h3><p><a href="/MySQL/数据库异常状态判断">MySQL-数据库异常状态判断</a> 中innodb_thread_concurrency参数讲解，不够用例子。  </p>
<h4 id="线程没有执行到判断线程状态的逻辑"><a href="#线程没有执行到判断线程状态的逻辑" class="headerlink" title="线程没有执行到判断线程状态的逻辑"></a>线程没有执行到判断线程状态的逻辑</h4><p>执行set global innodb_thread_concurrency=2，将InnoDB的并发线程上限数设置为2；  </p>
<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
<th>sessionC</th>
<th>sessionD</th>
<th>sessionE</th>
</tr>
</thead>
<tbody><tr>
<td>select sleep(100) from t;</td>
<td>select sleep(100) from t;</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>select * from t;</br>(blocked)</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>kill query C;</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>ERROR 2013(HY000):Lost connection to MySQL server during query</td>
<td></td>
<td>kill C;</td>
</tr>
</tbody></table>
<ol>
<li>sessionC执行的时候被堵住了；  </li>
<li>但是sessionD执行的kill query C命令却没什么效果；  </li>
<li>直到sessionE执行了kill connection命令，才断开了sessionC的连接，提示”Lost connection to MySQL server during query”；  </li>
<li>但是这时，如果在sessionE中执行show processlist，展示的sessionC对应的线程的Command列显示的是Killed。客户端虽然断开了连接，但实际上服务端上这条语句还在执行过程中。  </li>
</ol>
<p>对比：<br>在实现上，例子1中update语句等行锁时，使用的是pthread_cond_timedwait函数，这个等待状态可以被唤醒。但是例子2，sessionC对应的线程等待逻辑是这样的，每10毫秒判断一下是否可以进入InnoDB执行，如果不行，就调用nanosleep函数进入sleep状态。  </p>
<p>虽然sessionC对应的线程的状态已经被设置成了KILL_QUERY，但是在这个等待进入InnoDB的循环过程中，并没有去判断线程的状态，因此根本不会进入终止逻辑阶段。  </p>
<p>当sessionE执行kill connection命令时：  </p>
<ol>
<li>把sessionC对应的线程状态设置为KILL_CONNECTION；  </li>
<li>关掉sessionC对应线程的网络连接。因为这个操作，可以看到此时sessionC收到了断开连接的提示。  </li>
</ol>
<p><strong>kill connection本质上只是把客户端的sql断开，后面的执行流程还是要走kill query的。另外执行show processlist时，有一个特别的逻辑：如果一个线程的状态时KILL_CONNECTION，就把Command列显示成killed。</strong>  </p>
<p>即使是客户端退出了，这个线程的状态仍然是在等待中。<br>只有等待满足进入InnoDB的条件后，sessionC的查询语句继续执行，然后才有可能判断到线程状态已经变成了kill_query或者kill_connection，再进入终止逻辑阶段。  </p>
<p>其他情况：<br>IO压力过大，读写IO的函数一直无法返回，导致不能及时判断线程的状态。  </p>
<h4 id="终止逻辑耗时较长"><a href="#终止逻辑耗时较长" class="headerlink" title="终止逻辑耗时较长"></a>终止逻辑耗时较长</h4><p>从show processlist结果上看是Command=killed，需要等到终止逻辑完成，语句才算真正完成。  </p>
<ol>
<li>超大事务执行期间被kill。这时，回滚操作需要对事务执行期间生成的所有新数据版本做回收操作，耗时很长。  </li>
<li>大查询回滚。如果查询过程中生成了比较大的临时文件，加上此时文件系统压力大，删除临时文件可能需要等待IO资源，导致耗时较长。  </li>
<li>DDL命令执行到最后阶段，如果被kill，需要删除中间过程的临时文件，也可能受IO资源影响耗时较久。  </li>
</ol>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>要kill掉一个线程，涉及到后端的很多操作。<br><strong>发送kill命令的客户端，并没有强行停止目标线程的执行，只是设置了个状态，并唤醒对应的线程。而被kill的线程，需要执行到判断状态的“埋点”，才会开始进入终止逻辑阶段。并且，终止逻辑本身也是需要耗费时间的。导致出现“kill不掉”的情况。</strong>  </p>
<p>如果发现一个线程处于killed状态，可以通过影响系统环境，让整个killed状态尽快结束。  </p>
<ul>
<li>InnoDB并发度的问题，可以临时调大innodb_thread_concurrency的值，或者停掉别的线程，让出位子给这个线程执行。  </li>
<li>回滚逻辑由于受到IO资源限制执行得比较慢，通过减少系统压力让它加速。  </li>
</ul>
<p>其他情况只能等待流程自己完成。  </p>
<h3 id="Ctrl-C"><a href="#Ctrl-C" class="headerlink" title="Ctrl+C"></a>Ctrl+C</h3><p>直接在客户端通过Ctrl+C命令，不会直接终止线程。<br>在客户端的操作只能操作到客户端的线程，客户端和服务端只能通过网络交互，是不可能直接操作服务端线程的。  </p>
<p>由于MySQL是停等协议，所以这个线程执行的语句还没有返回的时候，再往这个连接里面继续发命令也是没有用的。实际上，执行Ctrl+C的时候，是MySQL客户端另外启动了一个连接，然后发送一个kill query命令。  </p>
<h3 id="关于客户端的其他误解"><a href="#关于客户端的其他误解" class="headerlink" title="关于客户端的其他误解"></a>关于客户端的其他误解</h3><h4 id="A参数-如果库里面的表特别多，连接就会很慢"><a href="#A参数-如果库里面的表特别多，连接就会很慢" class="headerlink" title="-A参数 如果库里面的表特别多，连接就会很慢"></a>-A参数 如果库里面的表特别多，连接就会很慢</h4><p>有些线上的库，会包含很多表。每次用客户端连接都会卡在界面上：  </p>
<blockquote>
<p>mysql -h127.0.0.1 -uu1 -pp1 db1<br>Reading table information for completion of table and column names<br>You can turn off this feature to get a quicker startup with -A  </p>
</blockquote>
<p>如果db1这个库里表很少的话，连接起来就会很快，可以很快进入输入命令的状态。误认为是表的数目影响了连接性能。  </p>
<p>每个客户端在和服务端建立连接的时候，需要做的事情就是TCP握手、用户校验、获取权限。但这几个操作，显然跟库中表的个数无关。  </p>
<p>实际上，当使用默认参数连接的时候，MySQL客户端会提供一个本地库名和表名补全的功能。为了实现这个功能，客户端连接成功后，需要多做一些操作：  </p>
<ol>
<li>执行show database；  </li>
<li>切到db1库，执行show tables；  </li>
<li>把这两个命令的结果用于构建一个本地的哈希表。  </li>
</ol>
<p>在这些操作中，最花时间的就是第三步在本地构建哈希表的操作，所以，当一个库中的表个数非常多的时候，这一步会花比较长的时间。<br>感知到的连接过程慢，并不是连接慢，也不是服务端慢，而是客户端慢。  </p>
<p>自动补全的效果就是，在输入库名或者表名的时候，输入前缀，可以使用Tab建自动补全表名或者显示提示。在连接命令中加上-A，可以关掉这个自动补全的功能。  </p>
<h4 id="quick参数"><a href="#quick参数" class="headerlink" title="-quick参数"></a>-quick参数</h4><p>除了加-A以外，加-quick(简写为-q)参数，也可以跳过这个阶段。  </p>
<p>设置了这个参数可能会降低服务端的性能。  </p>
<p>MySQL客户端发送请求后，接收服务端返回结果的方式有两种：  </p>
<ol>
<li>一种是本地缓存，也就是在本地开一片内存，先把结果存起来。如果用API开发，对应的就是mysql_store_result方法。  </li>
<li>一种是不缓存，读一个处理一个。如果用API开发，对应的就是mysql_use_result方法。  </li>
</ol>
<p>MySQL客户端默认采用第一种方式，而如果加上-quick参数，就会使用第二种不缓存的方式。采用不缓存的方式时，如果本地处理的很慢，就会导致服务端发送结果被阻塞，因此会让服务端变慢。  </p>
<p>quick参数的意思是让客户端变快：  </p>
<ol>
<li>跳过表名自动补全功能。  </li>
<li>mysql_store_result需要申请本地内存来缓存查询结果，如果查询结果太大，会耗费较多的本地内存，可能会影响客户端本地机器的性能。  </li>
<li>不会把执行命令记录到本地的命令历史文件。  </li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>join执行原理</title>
    <url>/MySQL/join%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        示例表
    </div>
    <div class='spoiler-content'>
        <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">'t2'</span> (</span><br><span class="line">    <span class="string">'id'</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="string">'a'</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="string">'b'</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line">    primary <span class="keyword">key</span> (<span class="string">'id'</span>),<span class="comment">-- 主键索引</span></span><br><span class="line">    <span class="keyword">key</span> <span class="string">'a'</span> (<span class="string">'a'</span>)<span class="comment">-- 普通索引</span></span><br><span class="line">) <span class="keyword">engine</span>=<span class="keyword">innodb</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入t2表1000行数据</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> idata;</span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span> </span><br><span class="line">    <span class="keyword">declare</span> i <span class="built_in">int</span>;</span><br><span class="line">    <span class="keyword">set</span> i=<span class="number">1</span>;</span><br><span class="line">    while(i&lt;=1000) do</span><br><span class="line">        <span class="keyword">insert</span> <span class="keyword">into</span> t2 <span class="keyword">values</span>(i,i,i);</span><br><span class="line">        <span class="keyword">set</span> i=i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> idata();</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1 <span class="keyword">like</span> t2;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 (<span class="keyword">select</span> * <span class="keyword">from</span> t2 <span class="keyword">where</span> <span class="keyword">id</span>&lt;=<span class="number">100</span>)</span><br><span class="line"><span class="comment">-- 插入t1表100行数据</span></span><br></pre></td></tr></table></figure>
    </div>
</div>  

<h3 id="Index-Nested-Loop-Join"><a href="#Index-Nested-Loop-Join" class="headerlink" title="Index Nested-Loop Join"></a>Index Nested-Loop Join</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">straight_join</span> t2 <span class="keyword">on</span>(t1.a=t2.a);</span><br></pre></td></tr></table></figure>

<p>如果直接使用join语句，MySQL优化器可能会选择表t1或t2作为驱动表，这样会影响分析SQL语句的执行过程。使用straight_join让MySQL使用固定的连接方式执行查询，优化器只会按照指定的方式去join。上述语句，t1是驱动表，t2是被驱动表。  </p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>partitions</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>filtered</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>simple</td>
<td>t1</td>
<td>null</td>
<td>all</td>
<td>a</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>100</td>
<td>100.00</td>
<td>Using where</td>
</tr>
<tr>
<td>1</td>
<td>simple</td>
<td>t2</td>
<td>null</td>
<td>ref</td>
<td>a</td>
<td>a</td>
<td>5</td>
<td>test.t1.a</td>
<td>1</td>
<td>100.00</td>
<td>null</td>
</tr>
</tbody></table>
<p>被驱动表t2的字段a上有索引，join过程用上了这个索引。  </p>
<ol>
<li>从表t1中读入一行数据R；  </li>
<li>从数据行R中，取出a字段到表t2里去查找；  </li>
<li>取出表t2中满足条件的行，跟R组成一行，作为结果集的一部分；  </li>
<li>重复执行步骤1到3，直到表t1的末尾循环结束。  </li>
</ol>
<p>这个过程是先遍历表t1，然后根据表t1中取出的每行数据中的a值，去表t2中查找满足条件的记录。在形式上，这个过程跟写程序时的嵌套查询类似，并且可以用上被驱动表的索引，称之为”Index Nested-Loop Join”，简称NLJ。  </p>
<img src='/img/MySQL Index Nested-Loop Join算法执行流程.jpg'>

<ol>
<li>对驱动表t1做了全表扫描，这个过程需要扫描100行；  </li>
<li>而对于每一行R，根据a字段去表t2查找，走的是树搜索过程。由于插入的数据都是一一对应的，因此每次的扫描过程都只扫描一行，总共扫描100行。  </li>
<li>整个执行流程，总扫描行数是200。  </li>
</ol>
<h4 id="不使用join"><a href="#不使用join" class="headerlink" title="不使用join"></a>不使用join</h4><p>假设不使用join，只能用单表查询。  </p>
<ol>
<li>执行select * from t1，查出表t1的所有数据，这里有100行。  </li>
<li>循环遍历这100行数据：  <ul>
<li>从每一行R取出字段a的值$R.a；  </li>
<li>执行select * from t2 where a=$R.a；  </li>
<li>把返回的结果和R构成结果集的一行。  </li>
</ul>
</li>
</ol>
<p>这个查询过程，扫描了200行，但是总共执行了101条语句，比直接join多了100次交互。除此之外，客户端还要自己拼接SQL语句和结果。  </p>
<h4 id="驱动表选择"><a href="#驱动表选择" class="headerlink" title="驱动表选择"></a>驱动表选择</h4><p>示例join语句执行过程中，驱动表是走全表扫描，被驱动表是走树搜索。  </p>
<p>假设被驱动表的行数是M。每次在被驱动表查一行数据，要先搜索索引a，再搜索主键索引。每次搜索一棵树近似复杂度是以2为底的M的对数，记为log<sub>2</sub>M，在被驱动表上查一行的时间复杂度是2*log<sub>2</sub>M。  </p>
<p>假设驱动表的行数是N，执行过程就要扫描驱动表N行，然后对于每一行，到被驱动表上匹配一次。整个执行过程，近似复杂度是N+N*2*log<sub>2</sub>M。显然N对扫描函数的影响更大，因此应该让小表来做驱动表。  </p>
<blockquote>
<p>N扩大1000被，扫描行数就扩大1000倍；M扩大1000倍，扫描行数扩大不到10倍。  </p>
</blockquote>
<hr>
<ul>
<li>使用join语句，性能比强行拆成多个单表执行SQL语句的性能要好；  </li>
<li>如果使用join语句的话，需要让小表做驱动表。前提是可以使用被驱动表的序索引。  </li>
</ul>
<h3 id="Simple-Nested-Loop-Join"><a href="#Simple-Nested-Loop-Join" class="headerlink" title="Simple Nested-Loop Join"></a>Simple Nested-Loop Join</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">straight_join</span> t2 <span class="keyword">on</span> (t1.a=t2.b);</span><br></pre></td></tr></table></figure>

<p>采用方案一的类似嵌套查询算法，由于表t2的字段b上没有索引，每次到t2去匹配的时候，就要做一次全表扫描。这个SQL请求需要扫描表t2多达100次，总共扫描100*1000=10万行。  </p>
<h3 id="Block-Nested-Loop-Join"><a href="#Block-Nested-Loop-Join" class="headerlink" title="Block Nested-Loop Join"></a>Block Nested-Loop Join</h3><p>被驱动表上没有可用的索引，算法流程：  </p>
<ol>
<li>把表t1的数据读入线程内存join_buffer中，由于语句中写的是select *，因此是把整个表t1放入了内存；  </li>
<li>扫描表t2，把表t2中的每一行取出来，跟join_buffer中的数据做对比，满足join条件的，作为结果集的一部分返回。  </li>
</ol>
<img src='/img/MySQL Block Nested-Loop Join算法执行流程.jpg'>

<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>partitions</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>filtered</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>simple</td>
<td>t1</td>
<td>null</td>
<td>all</td>
<td>a</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>100</td>
<td>100.00</td>
<td>null</td>
</tr>
<tr>
<td>1</td>
<td>simple</td>
<td>t2</td>
<td>null</td>
<td>all</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>1000</td>
<td>10.00</td>
<td>Using where;Using join buffer(Block Nested Loop)</td>
</tr>
</tbody></table>
<p>在这个过程中，对t1和t2都做了一次全表扫描，总的扫描行数是1100。由于join_budder是以无序数组的方式组织的，因此对表t2中的每一行，都要做100次判断，总共需要在内存中做的判断次数是:100*1000=10万次。  </p>
<p>如果使用Simple Nested-Loop Join算法进行查询，扫描行数也是10万行。从时间复杂度上说，两个算法是一样的。但是Block Nested-Loop Join算法的10万次判断是内存操作，速度上会快很多，性能也更好。  </p>
<p>假设小表的行数是N，大表的行数是M：  </p>
<ol>
<li>两个表都做一次全表扫描，所以总的扫描行数是M+N；  </li>
<li>内存中的判断次数是M*N。  </li>
</ol>
<p>调换这两个算式中的M和N没差别，此时选择大表还是小表做驱动表，执行耗时是一样的。  </p>
<h4 id="join-buffer"><a href="#join-buffer" class="headerlink" title="join_buffer"></a>join_buffer</h4><p>join_buffer的大小是由参数join_buffer_size设定的，默认值是256k。如果放不下表t1的所有数据，就分段放。(join_buffer_size设置为1200)</p>
<ol>
<li>扫描表t1，顺序读取数据行放入join_buffer中，放完第88行join_buffer满了，继续第2步；  </li>
<li>扫描表t2，把t2中的每一行取出来，跟join_buffer中的数据做对比，满足join条件的，作为结果集的一部分返回；  </li>
<li>清空join_buffer；  </li>
<li>继续扫描表t1，顺序读取最后的12行数据放入join_buffer中，继续执行第2步。  </li>
</ol>
<p>算法中的“Block”表示分块去join。由于表t1被分成了两次放入join_buffer中，导致表t2会被扫描两次。虽然分成两次放入join_buffer，但是判断等值条件的次数是不变的，依然是(88+12)*1000=10万次。  </p>
<h4 id="驱动表选择-1"><a href="#驱动表选择-1" class="headerlink" title="驱动表选择"></a>驱动表选择</h4><p>假设驱动表的数据行数是N，需要分K段(N越大K就会越大，表示为λ*N，λ取值范围0-1)才能完成算法流程，被驱动表的数据行数是M。  </p>
<ol>
<li>扫描函数是N+λ<em>N</em>M；  </li>
<li>内存判断N*M次。  </li>
</ol>
<p>内存判断次数是不受选择哪个表作为驱动表影响的。考虑到扫描行数，在M和N大小确定的情况下，N小一些，整个算式的结果会更小。应该让小表做驱动表。  </p>
<p>在N+λ*N*M这个式子中，λ是影响扫描行数的关键因素，这个值越小越好。  </p>
<p>N越大，分段数K越大。N固定的时候，λ(join_buffer_size)影响K的大小。join_buffer_size越大，一次可以放入的行越多，分成的段数也越小，对被驱动表的全表扫描次数就越少。所以，如果join语句很慢，就把join_buffer_size改大。  </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="使用join语句"><a href="#使用join语句" class="headerlink" title="使用join语句"></a>使用join语句</h4><ol>
<li>如果可以使用Index Nested-Loop Join算法，也就是说可以用上被驱动表上的索引，是没问题的；  </li>
<li>如果使用Block Nested-Loop Join算法，扫描的行数就会过多。尤其是在大表上的join操作，可能要扫描被驱动表很多次，会占用大量的西戎资源。这种join尽量不要用。  </li>
</ol>
<p>在判断要不要使用join语句时，就是看explain结果里面，Extra字段里面有没有出现”Block Nested Loop”字样。  </p>
<h4 id="选择驱动表"><a href="#选择驱动表" class="headerlink" title="选择驱动表"></a>选择驱动表</h4><ol>
<li>如果是Index Nested-Loop Join算法，应该选择小表做驱动表；  </li>
<li>如果是Block Nested-Loop Join算法：  <ul>
<li>在join_buffer_size足够大的时候，是一样的；  </li>
<li>在join_buffer_size不够大的时候，应该选择小表做驱动表。</li>
</ul>
</li>
</ol>
<p>总体结论，应该使用小表做驱动表。  </p>
<h5 id="“小表”解析"><a href="#“小表”解析" class="headerlink" title="“小表”解析"></a>“小表”解析</h5><p>示例1：  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">straight_join</span> t2 <span class="keyword">on</span> (t1.b=t2.b) <span class="keyword">where</span> t2.id&lt;=<span class="number">50</span>;  </span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t2 <span class="keyword">straight_join</span> t1 <span class="keyword">on</span> (t1.b=t2.b) <span class="keyword">where</span> t2.id&lt;=<span class="number">50</span>;</span><br></pre></td></tr></table></figure>

<p>第二个语句，join_buffer只需要放入t2的前50行，是相对较小的表。  </p>
<p>示例2：  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> t1.b,t2.* <span class="keyword">from</span> t1 <span class="keyword">straight_join</span> t2 <span class="keyword">on</span> (t1.b=t2.b) <span class="keyword">where</span> t2.id&lt;=<span class="number">100</span>;  </span><br><span class="line"><span class="keyword">select</span> t1.b,t2.* <span class="keyword">from</span> t2 <span class="keyword">straight_join</span> t1 <span class="keyword">on</span> (t1.b=t2.b) <span class="keyword">where</span> t2.id&lt;=<span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>两个语句中，表t1和t2都是只有100行参加join，但是每次查询放入join_buffer中的数据是不一样的：  </p>
<ul>
<li>表t1只查字段b，因此如果把t1放到join_buffer中，则join_buffer中只需要放入b的值；  </li>
<li>表t2需要查所有的字段，因此如果把表t2放到join_buffer中，就需要放入三个字段id、a和b。  </li>
</ul>
<p>只需要一列参与join的表t1是相对较小的表。  </p>
<p>两个表按照各自的条件过滤，过滤完成之后，计算参与join的各个字段的总数据量，数据量小的那个表，就是小表，应该作为驱动表。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/uncategorized/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
</search>
