<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>复杂度分析</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="时间复杂度与空间复杂度"><a href="#时间复杂度与空间复杂度" class="headerlink" title="时间复杂度与空间复杂度"></a>时间复杂度与空间复杂度</h2><p>复杂度描述的是算法执行时间或者占用空间与数据规模的增长关系。  </p>
<h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><p>代码执行时间随数据规模增长的变化趋势，叫作渐进时间复杂度（asymptotic time complexity），简称<strong>时间复杂度</strong>。  </p>
<p>所有代码的执行时间T(n)与每行代码的执行次数成正比  </p>
<p><code>T(n) = O(f(n))</code>  </p>
<blockquote>
<p>其中T(n)表示算法执行的总时间，f(n)表示每行代码执行总次数，而n往往表示数据的规模。常量阶、低阶、系数对增长趋势不产生决定性影响，在做复杂度分析时可忽略这些项。</p>
</blockquote>
<h4 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h4><ol>
<li>单段代码看高频：比如循环。</li>
<li>多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。</li>
<li>嵌套代码求乘积：比如递归、多重循环等。</li>
<li>多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这是就取二者复杂度相加。</li>
</ol>
<h4 id="级别"><a href="#级别" class="headerlink" title="级别"></a>级别</h4><p><em>多项式量级</em>  随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。</p>
<ol>
<li>常量阶 O(1)  </li>
<li>对数阶 O(logn)  </li>
<li>线性阶 O(n)  </li>
<li>线性对数阶 O(nlogn)  </li>
<li>O(n<sup>2</sup>)平方阶、O(n<sup>3</sup>)立方阶……</li>
</ol>
<p><em>非多项式量级</em>  随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法的性能极差</p>
<ol start="6">
<li>指数阶 O(2<sup>n</sup>)  </li>
<li>阶乘阶 O(n!)  </li>
</ol>
<h3 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h3><p><strong>空间复杂度</strong>全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。  </p>
<p>类似于时间复杂度</p>
<h3 id="其他复杂度"><a href="#其他复杂度" class="headerlink" title="其他复杂度"></a>其他复杂度</h3><ol>
<li><p>最好情况时间复杂度（best case time complexity）  </p>
<blockquote>
<p>在最理想的情况下，执行这段代码的时间复杂度  </p>
</blockquote>
</li>
<li><p>最坏情况时间复杂度（worst case time complexity）</p>
<blockquote>
<p>在最糟糕的情况下，执行这段代码的时间复杂度  </p>
</blockquote>
</li>
<li><p>平均情况时间复杂度（average case time complexity）</p>
<blockquote>
<p>加权平均时间复杂度/期望时间复杂度<br>用代码在所有情况下执行的次数的加权平均值表示</p>
</blockquote>
</li>
<li><p>均摊时间复杂度（amortized time complexity）</p>
<blockquote>
<p>摊还分析、平摊分析。一种特殊的平均时间复杂度。<br>在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果等于低级别复杂度。（重点1、高级别少数2、低高出现具有时序规律）</p>
</blockquote>
</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>时间复杂度</tag>
        <tag>空间复杂度</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>链表的内存结构是不连续的内存空间，将一组零散的内存块串联起来进行数据存储的数据结构。</p>
<p>引子：缓存淘汰策略</p>
<blockquote>
<ul>
<li>先进先出FITO(First In,First Out)</li>
<li>最少使用LFU(Least Frequently Used)</li>
<li>最近最少使用LRU(Least Recently Used)</li>
</ul>
</blockquote>
<h4 id="常见链表结构"><a href="#常见链表结构" class="headerlink" title="常见链表结构"></a>常见链表结构</h4><ol>
<li>单链表  <blockquote>
<p>-&gt;(数据+后继指针next)-&gt;<br>首结点地址表示整条链表，尾结点的后继指针指向空地址null </p>
</blockquote>
</li>
<li>双向链表<blockquote>
<p>-&gt;(前驱指针prev+数据+后继指针next)-&gt;<br>首结点的前驱指针prev和尾结点的后继指针均指向空地址null</p>
<ul>
<li>给定数据值删除对应结点,需要从头到尾遍历时间复杂度O(n);  </li>
<li>给定结点地址删除结点,单链表需要从头到尾遍历前驱结点时间复杂度O(n),双向链表可以直接找到前驱结点时间复杂度O(1)。</li>
</ul>
</blockquote>
</li>
<li>循环链表<blockquote>
<p>尾结点的后继指针指向链表的首结点的地址</p>
</blockquote>
</li>
<li>双向循环链表</li>
</ol>
<h4 id="实现链表"><a href="#实现链表" class="headerlink" title="实现链表"></a>实现链表</h4><ol>
<li>理解指针或引用的含义(所指或引用对象的内存地址)<br>将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针；指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。</li>
<li>警惕指针丢失和内存泄漏<br>插入结点时，一定要注意操作的顺序；删除结点时，一定要记得手动释放内存空间。</li>
<li>利用哨兵简化实现难度<br>针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。利用哨兵解决边界问题，不直接参与业务逻辑。<br>引入哨兵结点，在任何时候，不管链表是不是空，head指针都会一直指向这个哨兵结点，哨兵结点不存储数据。</li>
<li>重点留意边界条件处理<br>链表为空、链表只包含一个结点、链表只包含两个结点、代码逻辑在处理头结点和尾结点等情况时，是否能正常工作。</li>
<li>举例画图，辅助思考  </li>
<li>多写多练，没有捷径<br>单链表反转、链表中环的检测、两个有序的链表合并、删除链表倒数第n个结点、求链表的中间结点</li>
</ol>
<h4 id="链表or数组"><a href="#链表or数组" class="headerlink" title="链表or数组"></a>链表or数组</h4><table>
<thead>
<tr>
<th>时间复杂度</th>
<th>数组</th>
<th>链表</th>
</tr>
</thead>
<tbody><tr>
<td>插入操作</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>随机访问</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
</tbody></table>
<p>与数组相比，链表除了存储数据，需要消耗更多的内存空间，存储后继指针。<br>对链表进行频繁的插入和删除操作，会导致频繁的内存申请和释放，容易造成内存碎片。</p>
<p>数组需要连续的内存空间。有利有弊，便于借助CPU缓冲机制于都数组中的数据；不能充分利用不连续的内存空间。<br>数组大小固定，若存储空间不足需要进行扩容，一旦扩容需要进行数据复制，非常耗时。</p>
<h4 id="链表实现LRU算法"><a href="#链表实现LRU算法" class="headerlink" title="链表实现LRU算法"></a>链表实现LRU算法</h4><p>维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有有一个新的数据被访问时，从链表头开始顺序遍历链表。  </p>
<blockquote>
<ol>
<li>数据之前已经被缓存在链表中了，将遍历得到的对应结点从原来的位置删除，然后再插入到链表的头部。</li>
<li>数据没有在缓存链表中，若缓存未满，将结点直接插入到链表的头部；若缓存已满，将链表尾结点删除，将新数据结点插入链表的头部。</li>
</ol>
</blockquote>
<h4 id="数组实现LRU算法"><a href="#数组实现LRU算法" class="headerlink" title="数组实现LRU算法"></a>数组实现LRU算法</h4><p>维护一个有序数组，越靠近数组尾部的元素是越早访问的，当有一个新的数据被访问时，从数组第一个元素开始遍历数组</p>
<blockquote>
<ol>
<li>数据在数组中，将当前数据对应元素前的元素后移一位，并将当前数据放入头部。</li>
<li>数据不在数组中，若缓存未满，将当前数组所有元素后移一位，将数据放入头部；若缓存已满，先删除数组最后一个元素，将数组所有元素后移一位，将数据放入头部。</li>
</ol>
</blockquote>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>单链表判断回文字符串</p>
<blockquote>
<p>快慢指针，链表反转</p>
</blockquote>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>栈</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%88/</url>
    <content><![CDATA[<p>从栈的操作特性上看，栈是一种”操作受限”的线性表，只允许在一端插入和删除数据。并且满足先进后出、后进先出的特性。</p>
<h4 id="实现栈"><a href="#实现栈" class="headerlink" title="实现栈"></a>实现栈</h4><p>栈主要包含两个操作：入栈push()，在栈顶插入一个数据；出栈pop()，从栈顶删除一个数据。<br>用数组实现的栈-<strong>顺序栈</strong>。<br>用链表实现的栈-<strong>链式栈</strong>。<br>空间复杂度为O(1)<br>时间复杂度为O(1)<br>动态扩容的顺序栈的入栈操作的均摊时间复杂度为O(1)</p>
<h4 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h4><ul>
<li>函数调用栈<br>操作系统给每个线程分配了一块独立的内存空间，用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成返回之后，将这个函数对应的栈帧出栈。  </li>
<li>表达式求值<br>通过两个栈实现，其中一个保存操作数的栈，另一个是保存运算符的栈。从左向右遍历表达式，遇到数字就压入操作数栈；遇到操作符与运算符栈的栈顶元素进行比较，<br>比运算符栈顶元素的优先级高，将当前运算符压入栈；<br>比运算符栈顶元素的优先级低或者相同，从运算符中取栈顶运算符，从操作数栈顶取两个操作数，进行计算，把计算结果压入操作数栈。  </li>
<li>匹配括号<br>用栈保存未匹配的左括号，从左到右依次扫描字符串。扫描到左括号压入栈；扫描到右括号，从栈顶取出一个左括号进行匹配。</li>
<li>浏览器前进&amp;后退<br>两个栈实现，浏览页面依次压入栈X，后退时，从栈X中出栈，压入栈Y;前进时，从栈Y中出栈，压入栈X.</li>
</ul>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>JVM内存管理中堆栈</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>数组</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>数组是一种<strong>线性表</strong>结构。它用一组<strong>连续的内存空间</strong>，来存储一组具有<strong>相同类型的数据</strong>。</p>
<h4 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h4><ol>
<li>线性表<blockquote>
<p>数组、链表、队列、栈  </p>
</blockquote>
</li>
<li>非线性表<blockquote>
<p>二叉树、堆、图  </p>
</blockquote>
</li>
</ol>
<h4 id="连续的内存空间和相同类型的数据-1"><a href="#连续的内存空间和相同类型的数据-1" class="headerlink" title="连续的内存空间和相同类型的数据  1"></a>连续的内存空间和相同类型的数据  <a href="#refer-anchor-1"><sup>1</sup></a></h4><p>寻址公式（数组下标从0开始 ，减少计算内存地址时的减法运算）</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">a[i]_address</span> = base_address + i * data_type_size</span><br></pre></td></tr></table></figure>
<ol>
<li>数组支持随机访问，根据下标随机访问的时间复杂度为O(1)。排好序的数组二分查找的时间复杂度为O(logn)</li>
<li>插入操作 大量数据搬移保证连续性<br>最好O(1)在数组末尾插入元素，不需要移动数据；<br>最坏O(n)在数组开头插入元素，所有数据都需要依次往后移动一位。<br>在每个位置插入元素的概率是一样的，平均时间复杂度为”(1+2+…n)/n=O(n)”；<br>优化：数组中存储的数据没有规律，只是作为一个存储数据的集合，避免大规模的数据搬移，在将某个数据插入到第k个位置时，直接将第k位的数据搬移到数组元素的最后，把新的元素直接放入第k个位置。<blockquote>
<p>快速排序的思想</p>
</blockquote>
</li>
<li>删除操作(大量数据搬移保证连续性)的平均时间复杂度为O(n)，最好O(1)，最坏O(n)<br>优化：先记录下已经删除的数据。每次的删除操作并不是真正的搬移数据，只是记录数据已经被删除了，当数组没有更多空间存储数据时，再触发执行一次真正的删除操作，从而大大减少删除操作导致的数据搬移。  <blockquote>
<p>JVM标记清除垃圾回收算法的核心思想</p>
</blockquote>
</li>
</ol>
<h4 id="数组or容器"><a href="#数组or容器" class="headerlink" title="数组or容器"></a>数组or容器</h4><p>容器：<br>将很多数组操作的细节封装起来，比如搬移数据；支持动态扩容。<br>数组：<br>存储基本类型，避免自动装箱拆箱的性能消耗；<br>数组大小事先已知、对数据的操作简单；<br>表示多维数组比较直观；<br>注重性能的底层开发。 </p>
<h4 id="参考-amp-扩展"><a href="#参考-amp-扩展" class="headerlink" title="参考&amp;扩展"></a>参考&amp;扩展</h4><div id="refer-anchor-1"></div>

<ul>
<li>[1] <a href="https://mp.weixin.qq.com/s/E-c41h2v_AfffrlAQpkyLg" target="_blank" rel="noopener">详解数据结构中的“数组”与编程语言中的“数组”的区别和联系</a> </li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>递归</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<p>方法或者函数调用自身的方式称为递归调用，调用称为递，返回称为归。<br>用栈的数据结构加上简单的逻辑算法实现业务功能。  </p>
<h4 id="递归特点"><a href="#递归特点" class="headerlink" title="递归特点"></a>递归特点</h4><ul>
<li>一个问题的解可以分解为几个子问题的解</li>
<li>原问题与分解后的子问题，除了数据规模不同，求解思路完全一样</li>
<li>存在递归终止条件</li>
</ul>
<p>关键：<br>找到如何将大问题分解为小问题的规律，基于此写出递推公式，推敲终止条件，最后将递推公式和终止条件翻译成代码。<br>遇到递归，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤，把它抽象成一个递推公式。</p>
<h4 id="递归问题"><a href="#递归问题" class="headerlink" title="递归问题"></a>递归问题</h4><ul>
<li>栈溢出<a href="#refer-anchor-1"><sup>1</sup></a><br>函数调用会使用栈来保存临时变量，每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时才出栈。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有栈溢出的风险。<br>解决：1.最大深度比较小的情况，在代码中限制递归调用的最大深度。2.数据规模较大的情况，用非递归-循环代码实现。</li>
<li>重复计算<br>解决：通过一个数据结构（散列表）来保存已经求解过的f(k)，当递归调用到f(k)时，先看下是否已经求解过。如果是则直接从散列表中取值返回，不需要重复计算。</li>
<li>时间空间成本</li>
</ul>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>所有的递归代码都可以改为迭代循环的非递归写法</p>
<blockquote>
<p>递归本身依然是借助栈实现的。抽象出递推公式、初始值、边界条件，用迭代循环实现。</p>
</blockquote>
<p>递归代码的调试方法</p>
<blockquote>
<p>日志中打印递归值<br>添加条件语句进行断点调试  </p>
</blockquote>
<p>检测递归中环的存在</p>
<blockquote>
<p>通过散列表保存已计算完成的数据，每次递归调用，先去散列表中查询，没有查到的话就加入，如果存在则表示存在环。  </p>
</blockquote>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><div id="refer-anchor-1"></div>

<ul>
<li>[1] <a href="https://mp.weixin.qq.com/s/Ki3WN2AJ5HhxxmaQ0lVh3Q" target="_blank" rel="noopener">还有程序员天真地以为”尾递归“真的可以避免堆栈溢出！</a> </li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序、快速排序</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>归并排序和快速排序的时间复杂度为O(nlogn)。利用分治思想将大问题分解成小问题解决；利用递归代码实现归并排序。  </p>
<h4 id="归并排序1"><a href="#归并排序1" class="headerlink" title="归并排序1"></a>归并排序<a href="#refer-anchor-1"><sup>1</sup></a></h4><p>先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起。  </p>
<ul>
<li>递推公式:<br>merge_sort(p…r) = merge(merge_sort(p…q),merge_sort(q+1…r))  </li>
<li>终止条件：<br>p = r 不用再继续分解  <blockquote>
<p>merge_sort(p…r)表示给下标从p到r之间的数组排序。将此问题转化为了两个子问题：merge(merge_sort(p…q),merge_sort(q+1…r))，其中下标q等于p和r的中间位置(p+r)/2。当下标从p到q和从q+1到r这两个子数组都排好序之后，再将两个有序的子数组合并在一起，那么下标从p到r之间的数据也就排好序了。<br>合并函数merge([p…r],[p…q],[q+1…r])，申请一个临时数组temp,大小与数组[p…r]相同。用两个游标i和j，分别指向[p…q]和[q+1…r]的第一个元素。比较这两个元素[i]、[j]的大小，将较小的元素放入到临时数组temp中，并将相应的游标后移一位。  </p>
</blockquote>
</li>
</ul>
<ol>
<li><p>归并排序是一个<strong>稳定的排序算法</strong>，合并数组时，遇到值相同的元素，现将[p…q]区间的元素放入到临时数组temp中，保证值相同的元素在合并前后的先后顺序不变。  </p>
</li>
<li><p>最好、最坏、平均情况时间复杂度都是<strong>O(nlogn)</strong>。  </p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line"><span class="built_in">T</span>(<span class="number">1</span>) = C；   <span class="built_in">n</span>=<span class="number">1</span>时，只需要常量级的执行时间，所以表示为C。</span><br><span class="line"><span class="built_in">T</span>(<span class="built_in">n</span>) = <span class="number">2</span>*<span class="built_in">T</span>(<span class="built_in">n</span>/<span class="number">2</span>) + <span class="built_in">n</span>； <span class="built_in">n</span>&gt;<span class="number">1</span></span><br><span class="line">     = <span class="number">2</span>*(<span class="number">2</span>*<span class="built_in">T</span>(<span class="built_in">n</span>/<span class="number">4</span>) + <span class="built_in">n</span>/<span class="number">2</span>) + <span class="built_in">n</span> = <span class="number">4</span>*<span class="built_in">T</span>(<span class="built_in">n</span>/<span class="number">4</span>) + <span class="number">2</span>*<span class="built_in">n</span></span><br><span class="line">     = <span class="number">4</span>*(<span class="number">2</span>*<span class="built_in">T</span>(<span class="built_in">n</span>/<span class="number">8</span>) + <span class="built_in">n</span>/<span class="number">4</span>) + <span class="number">2</span>*<span class="built_in">n</span> = <span class="number">8</span>*<span class="built_in">T</span>(<span class="built_in">n</span>/<span class="number">8</span>) + <span class="number">3</span>*<span class="built_in">n</span></span><br><span class="line">     = <span class="number">8</span>*(<span class="number">2</span>*<span class="built_in">T</span>(<span class="built_in">n</span>/<span class="number">16</span>) + <span class="built_in">n</span>/<span class="number">8</span>) + <span class="number">3</span>*<span class="built_in">n</span> = <span class="number">16</span>*<span class="built_in">T</span>(<span class="built_in">n</span>/<span class="number">16</span>) + <span class="number">4</span>*<span class="built_in">n</span></span><br><span class="line">     ......</span><br><span class="line">     = <span class="number">2</span>^k * <span class="built_in">T</span>(<span class="built_in">n</span>/<span class="number">2</span>^k) + k * <span class="built_in">n</span></span><br><span class="line">     ......</span><br></pre></td></tr></table></figure>
<p>当T(n/2^k)=T(1)时，k=log<sub>2</sub>n，T(n)=Cn+nlog<sub>2</sub>n  </p>
</li>
<li><p>归并排序<strong>不是原地排序算法</strong>。<br>归并排序在合并两个有序数组为一个有序数组时，需要借助额外的存储空间。每次合并操作都需要申请额外的内存空间，但在合并完成之后，临时开辟的内存空间就被释放掉了。在任意时刻，CPU只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过n个数据的大小，<strong>空间复杂度是O(n)</strong>。  </p>
</li>
</ol>
<h4 id="快速排序2"><a href="#快速排序2" class="headerlink" title="快速排序2"></a>快速排序<a href="#refer-anchor-2"><sup>2</sup></a></h4><p>如果要排序数组中下标从p到r之间的一组数据，选择p到r之间的任意一个数据作为分区点(pivot)。遍历p到r之间的数据，将小于pivot的放到左边，将大于pivot的放到右边，将pivot放到中间。这样数组p到r之间的数据被分成了三个部分，前面p到q-1之间都是小于pivot的，中间是pivot，后面的q+1到r之间是大于pivot的。<br>根据分治、递归的处理思想，可以用递归排序下标从p到q-1之间的数据和下标从q+1到r之间的数据，直到区间缩小为1，就说明所有的数据都有序了。  </p>
<ul>
<li>递推公式：<br>quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1…r)  </li>
<li>终止条件：<br>p = r  <blockquote>
<p>快速排序中的分区函数partition()，随机选择一个元素作为分区点pivot，一般情况下可以选择p到r区间的最后一个元素，对数组进行分区，函数返回分区点pivot的下标。  </p>
</blockquote>
</li>
</ul>
<ol>
<li><p>空间复杂度</p>
<ul>
<li>不考虑空间消耗可以申请两个临时数组X和Y，遍历数组，将小于分区点的元素拷贝到临时数组X，大于分区点的元素拷贝到临时数组Y，最后将数组X、Y中的数据顺序拷贝到原数组中。   </li>
<li>原地分区操作，类似选择排序<br>通过游标i将数组[p…r-1]分成两部分，已处理区间[p…i-1]和未处理区间[i…r-1]，每次从未处理区间中取出一个元素[j]和分区点对比，如果小于，则将其加入到已处理区间的尾部[i]的位置。优化：不搬移数据，交换操作，将a[i]与a[j]交换。</li>
</ul>
</li>
<li><p>涉及交换操作，属于<strong>不稳定的排序算法</strong>。  </p>
</li>
<li><p>时间复杂度<br>分区极其均衡，每次分区操作都能正好把数组分成大小接近相等的两个小区间，<strong>最好时间复杂度为O(nlogn)</strong>。<br>分区极其不均衡，数组正序，需要n次分区操作，每次分区平均要扫描n、2个元素，<strong>最坏时间复杂度为O(n<sup>2</sup>)</strong>。<br>大部分情况下的时间复杂度都可以做到O(nlogn)，只有在极端情况下，才会退化到O(n<sup>2</sup>)。<strong>平均时间复杂度O(nlogn)</strong>。   </p>
</li>
</ol>
<h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p>归并排序的处理过程是由下到上的，先处理子问题，然后再合并。<br>快速排序的处理过程是由上到下的，先分区，然后再处理子问题。</p>
<h4 id="参考-amp-扩展"><a href="#参考-amp-扩展" class="headerlink" title="参考&amp;扩展"></a>参考&amp;扩展</h4><div id="refer-anchor-1"></div>  
[1] 归并排序  

<pre><code>//归并排序
public void mergeSort(int[] a) {
    mergeSortInter(a,0,a.length-1);
}
public void mergeSortInter(int[] a,int start,int end) {
    //终止条件
    if(start==end) return;

    //中间结点
    int mid = (start+end)/2;

    mergeSortInter(a,start,mid);
    mergeSortInter(a,mid+1,end);

    //合并函数
    merge(a,start,mid,end);
}
public void merge(int[] a,int left,int mid,int right) {
    //临时数组，大小为当前分区的大小
    int[] temp = new int[right - left + 1];

    int m = 0, i = left, j = mid + 1;
    while (i &lt;= mid &amp;&amp; j &lt;= right) {
        //取左右区间中元素最小值放入当前位置
        temp[m++] = a[i] &lt;= a[j] ? a[i++] : a[j++];
    }
    //拷贝剩余数据到临时数组
    while (i &lt;= mid)
        temp[m++] = a[i++];
    while (j &lt;= right)
        temp[m++] = a[j++];

    //拷贝临时数据到原数组对应区间
    for (int k=0;k &lt;= right-left;k++)
        a[left+k] = temp[k];
}</code></pre><div id="refer-anchor-2"></div>  
[2] 快速排序  

<pre><code>//快速排序
public void quickSort(int[] a) {
    quickSortInter(a,0,a.length-1);
}

public void quickSortInter(int[] a,int start,int end) {
    //终止条件  start 可能大于end
    if(start&gt;=end) return;

    //分区函数获取分区点
    int p = partition(a,start,end);

    quickSortInter(a,start,p-1);
    quickSortInter(a,p+1,end);
}

public int partition(int[] a,int start,int end) {
    //取当前分区最后一个元素做分区点
    int pivot = a[end];
    //记录下一个小于分区点元素值的元素应放置的下标
    int i = start;
    for(int j = start; j &lt; end; j++) {
        //当前元素与分区点元素值比较，小于则当前元素与上一个小于分区点元素的后一个元素进行交换
        if(a[j] &lt; pivot) {
            if(i != j) {
                int temp = a[i];
                a[i] = a[j];
                a[j] = temp;
            }
            i++;
        }
    }

    //分区点元素值与最后一个小于分区点元素的后一个元素进行交换
    int temp = a[i];
    a[i] =a[end];
    a[end] = temp;

    return i;
}</code></pre><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>线性排序</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>时间复杂度为O(n)的线性排序算法：桶排序、计数排序、基数排序。<br>算法是非基于比较的排序算法（主排序是非比较的），不涉及元素之间的比较操作。对要排序的数据要求比较苛刻。  </p>
<h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><ul>
<li><p>原理<br>核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。</p>
</li>
<li><p>时间复杂度<br>如果要排序的数据有n个，把他们均匀的划分到m个桶内，每个桶有k=n/m个元素。每个桶内部使用快速排序，时间复杂度为O(k<em>logk)。m个桶排序的时间复杂度为O(m</em>k<em>logk)。因为k=n/m，所以整个桶排序的时间复杂度为O(n</em>log(n/m))。当桶的个数m接近数据个数n时，log(n/m)为一个非常小的常量，这时桶排序的时间复杂度接近O(n)。  </p>
</li>
<li><p>适用场景<br>排序的数据需要很容易就能划分为m个桶，桶与桶之间有着天然的大小顺序，每个桶内的数据都排序完成之后，桶与桶之间的数据不需要再进行排序。<br>数据再各个桶之间的分布是比较均匀的。如果数据经过桶的划分之后，有的桶数据非常多，有的非常少，那桶内数据排序的时间复杂度就不是常量级了。在极端情况下，如果数据都被划分到一个桶里，那就退化为O(nlogn)的排序算法了。  </p>
<p>桶排序适合用在外部排序中。数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。  </p>
</li>
</ul>
<h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><ul>
<li><p>时间复杂度<br>计数排序是桶排序的一种特殊情况。当要排序的n个数据，所处的范围并不大的时候，比如最大值为k，可以把数据划分成k个桶，每个桶内的数据值都是相同的，省去了桶内排序的时间。只涉及扫描遍历操作，时间复杂度为O(n)。  </p>
</li>
<li><p>原理<br>计数排序用一个数据范围大小的统计数组C[k+1]（原数组A中元素取值范围为0-k），下标k等于原数组A中元素的值，遍历原数组A将各个元素值出现的次数存储在统计数组C对应下标中c[k]（即C[k]存储的是原数组A等于k的元素的个数）。然后对统计数组C顺序求和，各个下标处C[k]存储的是小于等于k的元素个数。<br>扫描原数组A（从后面开始遍历-保证稳定性），依次取出元素的值如a作为统计数组C的下标得到统计数组C对应的值C[a]，说明到目前为止，原数组A中小于等于a的值还有C[a]个，元素a是排好序的新数组R中的第C[a]个元素(放在新数组R下标为C[a]-1的位置)，将其a放入新数组R后，原数组A小于等于a的元素剩下C[a]-1个，则统计数组C[a]=C[a]-1，类推取原数组A下一个元素值。（从后往前做减法，确定该值可以放的最大下标）</p>
</li>
<li><p>适用场景<br>计数排序只能用在数据范围不大的场景中，如果数据范围k比要排序的数据n大很多，就不适合用计数排序。而且计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。  </p>
</li>
</ul>
<h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><ul>
<li><p>原理<br>以11位手机号排序为例，如果前面几位中，其中一个数据已经比较大了，那么后几位就不用看了。先按照最后一位排序，再按照倒数第二位排序，以此类推，最后按照第一位排序，经过11次排序后，手机号有序。要求按照每位来排序的排序算法是稳定的。  </p>
</li>
<li><p>时间复杂度<br>根据每位来排序，可以用桶排序或者计数排序，时间复杂度可以做到O(n)。如果要排序的数据有k位，那么需要进行k次桶排序或者计数排序，总的时间复杂度是O(k*n)。当k不大时，基数排序的时间复杂度就近似于O(n)。  </p>
</li>
<li><p>适用场景<br>基数排序要求要排序的数据可以分割出独立的“位”来比较，而且位之间有递进关系-数据可以划分成高低位。比较两个数只需要比较高位，高位相同再比较低位。<br>每一位的数据范围不能太大，要借助线性排序算法-桶排序/计数排序来完成每一位的排序工作，否则计数排序的时间复杂度无法做到O(n)。  </p>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>桶排序：分桶-快排/归并<br>计数排序：分桶-计数-统计<br>基数排序：高位桶排序-低位桶排序</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>排序优化</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>算法</th>
<th>时间复杂度</th>
<th>稳定</th>
<th>原地</th>
</tr>
</thead>
<tbody><tr>
<td>冒泡</td>
<td>O(n<sup>2</sup>)</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>插入</td>
<td>O(n<sup>2</sup>)</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>选择</td>
<td>O(n<sup>2</sup>)</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>归并</td>
<td>O(nlogn)</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>快速</td>
<td>O(nlogn)</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>桶</td>
<td>O(n)</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>计数</td>
<td>O(n+k) k是数据范围</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>基数</td>
<td>O(dn) d是维度</td>
<td>Y</td>
<td>N</td>
</tr>
</tbody></table>
<h4 id="优化快排"><a href="#优化快排" class="headerlink" title="优化快排"></a>优化快排</h4><p>最坏情况下快排的时间复杂度是O(n<sup>2</sup>)，如果数据本来就是有序的或者接近有序的，每次分区点都选择最后一个数据，那快速排序算法的时间复杂度就会退化为O(n<sup>2</sup>)。主要愿意是分区点选的不够合理。  </p>
<p>最理想的分区点是：被分区点分开的两个分区中，数据的数量差不多。</p>
<ul>
<li>三数取中法<br>从区间的首、尾、中间分别取出一个数，然后对比大小，取这3个数的中间值作为分区点。如果要排序的数组比较大，可以使用五数取中、十数取中。  </li>
<li>随机法<br>每次从要排序的区间中，随机选择一个元素作为分区点。不能保证每次分区点都选择的比较好，但是从概率的角度来看，也不大可能出现每次分区点都选的很差的情况，平均情况下，这样选的分区点是比较好的。  </li>
</ul>
<p>快排是用递归来实现的，递归要警惕堆栈溢出。避免递归过深而堆栈过小，导致堆栈溢出。  </p>
<ul>
<li>限制递归深度，一旦递归过深，超过了设定的阈值就停止递归。  </li>
<li>在堆上模拟实现一个函数调用栈，手动模拟递归压栈、出栈的过程，这样就没有了系统栈大小的限制。(将递归调用改写为循环非递归方式)  </li>
</ul>
<p>时间复杂度代表的是一个增长趋势。大O复杂度表示法中，会省略低阶、系数、常数。在小规模数据面前，O(n<sup>2</sup>)时间复杂度的算法并不一定比O(nlogn)的算法执行时间长。</p>
<h4 id="排序函数"><a href="#排序函数" class="headerlink" title="排序函数"></a>排序函数</h4><p>Java<br>基础数据类型：<br>Arrays.sort() -&gt; DualPivotQuicksort.sort()  </p>
<ul>
<li>元素个数&lt;47，插入排序</li>
<li>元素个数47-286，快速排序</li>
<li>元素个数&gt;286，归并排序（类似TimSort）  </li>
</ul>
<p>对象类型：<br>Collections.sort() -&gt; Arrays.sort() -&gt; TimSort  </p>
<ul>
<li><p>元素个数&lt;32，采用二分查找插入排序Binary Sort；  </p>
</li>
<li><p>元素个数&gt;=32，采用归并排序，归并的核心是分区Run;  </p>
</li>
<li><p>找连续升或者降的序列作为分区，分区最终被调整为升序后压入栈；  </p>
</li>
<li><p>如果分区长度太小，通过二分插入排序扩充分区长度到分区最小阈值minrun；  </p>
</li>
<li><p>每次压入栈，都要检查栈内已存在的分区是否满足合并条件，满足则进行合并；  </p>
</li>
<li><p>最终栈内分区被全部合并，得到一个排序好的数组。  </p>
<blockquote>
<p>TimSort合并：<br>  找出左分区最后一个元素在右分区的位置；<br>  找出右分区第一个元素在左分区的位置；<br>  仅对这两个位置之间的元素进行合并，之外的元素本身就是有序的。  </p>
</blockquote>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>冒泡排序、插入排序、选择排序</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E3%80%81%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h4 id="排序算法分析方法"><a href="#排序算法分析方法" class="headerlink" title="排序算法分析方法"></a>排序算法分析方法</h4><ol>
<li>分析排序算法的执行效率  <ul>
<li>最好情况、最坏情况、平均情况时间复杂度以及原始数据的有序度(有序度不同对排序的执行时间有影响)</li>
<li>时间复杂度反应的是大规模数据的增长趋势，实际中规模小需要考虑系数、常数、低阶</li>
<li>元素比较次数和交换/移动次数（基于比较的排序算法）  </li>
</ul>
</li>
<li>排序算法的内存消耗（空间复杂度）  <ul>
<li><strong>原地排序</strong>算法：空间复杂度为O(1)的排序算法。</li>
</ul>
</li>
<li>排序算法的稳定性    <ul>
<li>稳定性：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。稳定的排序算法||不稳定的排序算法  </li>
</ul>
</li>
</ol>
<p>插入排序和冒泡排序的时间复杂度相同，都是O(n<sup>2</sup>)</p>
<a id="more"></a>

<h4 id="冒泡排序-1"><a href="#冒泡排序-1" class="headerlink" title="冒泡排序 1"></a>冒泡排序 <a href="#refer-anchor-1"><sup>1</sup></a></h4><p>冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求，如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复n次，就完成了n个数据的排序工作。<br>优化：当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。  </p>
<ol>
<li><p>冒泡过程只涉及相邻数据的交换操作，只需要常量级的临时空间，空间复杂度为O(1)，属于<strong>原地排序算法</strong>。</p>
</li>
<li><p>冒泡排序中只有交换才改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，不做交换，相同大小的数据在排序前后不会改变顺序，属于<strong>稳定的排序算法</strong>。</p>
</li>
<li><p>时间复杂度  </p>
<ul>
<li><strong>最好情况时间复杂度是O(n)</strong>，数据有序，进行一次冒泡操作;</li>
<li><strong>最坏情况时间复杂度O(n<sup>2</sup>)</strong>，数据倒序，进行n次冒泡操作。</li>
<li><strong>平均时间复杂度</strong>：对于包含n个数据的数组，这n个数据有n!种排序方式。不同的排列方式，冒泡排序执行的时间不同。用概率论方法定量分析平均时间复杂度较复杂。  </li>
</ul>
<p><strong>有序度</strong>：数组中具有有序关系的元素对的个数。有序元素对：a[i] &lt;= a[j];i&lt;j。<br>倒序排列的数组，有序度为0;<br>完全有序的数组，有序度n<em>(n-1)/2. 满有序度。<br>*</em>逆序度**。逆序元素对：a[i] &gt; a[j];i&lt;j。<br>逆序度 = 满有序度 - 有序度。排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度。  </p>
<p>冒泡排序包含两个操作原子，<strong>比较&amp;交换</strong>。每交换一次，有序度加1，交换次数是确定的，为逆序度：n<em>(n-1)/2 - 初始有序度。<br>对于包含n个数据的数组进行冒泡排序，最坏情况下，初始状态的有序度是0，要进行n</em>(n-1)/2次交换；最好情况下，初始状态的有序度是n<em>(n-1)/2，不需要进行交换。取中间值n</em>(n-1)/4来表示初始有序度。平均情况下要进行n<em>(n-1)/4次交换操作，比较操作比交换操作多，复杂度的上限是O(n<sup>2</sup>)，所以*</em>平均情况下的时间复杂度是O(n<sup>2</sup>)**。</p>
</li>
</ol>
<h4 id="插入排序-2"><a href="#插入排序-2" class="headerlink" title="插入排序 2"></a>插入排序 <a href="#refer-anchor-2"><sup>2</sup></a></h4><p>动态的往有序集合中添加数据，遍历数组找到数据应该插入的位置进行插入，保持集合中的数据一直有序。  </p>
<p>将数组中的数据分为两个区间：<strong>已排序区间&amp;未排序区间</strong>。初始已排序区间只有一个元素-数组的第一个元素。插入排序的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。  </p>
<p>插入排序包含两种操作：<strong>元素的比较</strong>，<strong>元素的移动</strong>。将一个数据a插入到已排序区间时，需要拿a与已排序区间的元素一次比较大小，找到合适的插入位置。找到插入点之后，需要将插入点之后的元素往后移动一位，腾出位置给元素a插入。 不同的查找插入点方法（从头到尾、从尾到头），元素的比较次数是有区别的，但对于一个给定的初始序列，移动操作的次数是固定等于逆序度。  </p>
<ol>
<li>插入排序算法的运行并不需要额外的存储空间，空间复杂度是O(1)，属于<strong>原地排序算法</strong>。</li>
<li>在插入排序中，对值相同的元素，可以选择将后面出现的元素，插入到前面出现元素的后面，这样可以保证原有的前后顺序不变，插入排序是<strong>稳定的排序算法</strong>。</li>
<li>时间复杂度<ul>
<li><strong>最好时间复杂度O(n)</strong>，数据有序，不需要搬移任何数据。如果从尾到头在有序数组里面查找插入位置，每次只需要比较一个数据（当前元素与其前一个元素比较，当前大不小于不用动）就能确定插入的位置。（内层循环只执行一次就break）</li>
<li><strong>最坏时间复杂度O(n<sup>2</sup>)</strong>，数据倒序，每次插入都相当于在数据的第一个位置插入新的数据，需要移动大量的数据。</li>
<li><strong>平均时间复杂度</strong>：在数组中插入一个数据的平均时间复杂度是O(n)（详见数组篇）。对于插入排序，每次插入操作都相当于在数组中插入一个数据，循环执行n次插入操作，<strong>平均时间复杂度为O(n<sup>2</sup>)</strong>。  </li>
</ul>
</li>
</ol>
<h4 id="选择排序-3"><a href="#选择排序-3" class="headerlink" title="选择排序  3"></a>选择排序  <a href="#refer-anchor-3"><sup>3</sup></a></h4><p>选择排序类似插入排序，分为已排序区间&amp;未排序区间。选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。  </p>
<ol>
<li>空间复杂度为O(1)，<strong>原地排序算法</strong>。</li>
<li>时间复杂度：<strong>最好、最坏、平均时间复杂度都为O(n<sup>2</sup>)</strong>。</li>
<li>选择排序是一种<strong>不稳定的排序算法</strong>。选择排序每次都要找到剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。  </li>
</ol>
<h4 id="插入与冒泡对比"><a href="#插入与冒泡对比" class="headerlink" title="插入与冒泡对比"></a>插入与冒泡对比</h4><p>冒泡跟插入不管怎么优化，元素移动的次数是一个固定值，等于原始数据的逆序度。<br>冒泡的数据交换要比插入的数据移动复杂，3个赋值操作&gt;1个赋值操作。</p>
<h4 id="参考-amp-扩展"><a href="#参考-amp-扩展" class="headerlink" title="参考&amp;扩展"></a>参考&amp;扩展</h4><div id="refer-anchor-1"></div>
- [1] 冒泡排序：  

<pre><code>public void bubbleSort(int[] a) {
    int n = a.length;
    if(n &lt;= 1) return;
    //未排序区间+已排序区间
    for (int i = 0; i &lt; n; i++) {
        boolean flag = false;
        //从第一个元素开始进行比较，选出前面剩余未排序区间（n-i-1）元素的最大值
        for(int j = 0; j &lt; n - i -1; j++) {
            //当前元素大于下一个元素值，交换两个元素位置
            if(a[j] &gt; a[j+1]) {
                int temp = a[j];
                a[j] = a[j+1];
                a[j+1] = temp;
                //有数据交换交换需要继续进行
                flag = true;
            }
        }
        if(!flag) break;
    }
    for (int i : a)
        System.out.print(i);
}  </code></pre><div id="refer-anchor-2"></div>  
- [2]插入排序：  

<pre><code>public void insertionSort(int[] a) {
    int n = a.length;
    if(n &lt;= 1) return;
    //已排序区间+未排序区间
    for (int i = 1; i &lt; n; i++) {
        //当前要排序（插入）的元素值
        int temp = a[i];
        //从已排序区间(i-1)元素最大下标，倒着一一进行比较
        int j = i - 1;
        for (; j &gt;= 0; j--) {
            if (a[j] &gt; temp) {
                //已排序区间目前元素值大于当前元素值，则交换位置，继续与前一个元素值比较
                a[j+1] = a[j];
            } else {
                break;
            }
        }
        //for循环中与j--之后的元素比较后break，最终移入的下标应为j++
        a[j+1] = temp;
    }
    for (int i : a)
        System.out.println(i);
}  </code></pre><div id="refer-anchor-3"></div>  
- [3]选择排序：

<pre><code>public void selectSort(int[] a) {
    int n = a.length;
    if(n &lt;= 1) return;
    //已排序区间+未排序区间
    for(int i=0;i&lt;n;i++){
         int min=i;
         //查找未排序区间最小元素的下标值
         for(int j=i+1;j&lt;n;j++){
              if(a[j] &lt; a[min]) min=j;
         }
         //将最小元素放到当前已排序区间的最后一位
         if(min != i){
              int temp=a[i];
              a[i]=a[min];
              a[min]=temp;
         }
    }
    for (int i : a)
        System.out.println(i);
}</code></pre><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p>二分查找算法-折半查找算法  </p>
<h4 id="二分思想"><a href="#二分思想" class="headerlink" title="二分思想"></a>二分思想</h4><p>二分查找针对的是一个有序的数据集合，查找思想类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为0。  </p>
<h4 id="查找速度O-logn"><a href="#查找速度O-logn" class="headerlink" title="查找速度O(logn)"></a>查找速度O(logn)</h4><p><strong>数组：</strong><br>假设数据大小是n，每次查找后数据都会缩小为原来的一半，也就是除以2。最坏情况下，直到查找区间被缩小为空才停止。被查找区间的大小变化n,n/2,n/4,n/8,…,n/2<sup>k</sup>…为一个等比数列，当n/2<sup>k</sup>=1时，k的值就是总共缩小的次数。而每一次缩小操作只涉及两个数据的大小比较，所以经过了k次区间缩小操作，时间复杂度就是O(k)。通过n/2<sup>k</sup>，可以求得k=log<sub>2</sub>n，所以时间复杂度就是O(logn)。   </p>
<p>对数时间复杂度是一直极其高效的时间复杂度，有的时候甚至常量级时间复杂度的算法还要高效。  </p>
<p><strong>链表：</strong><br>假设链表长度为n，二分查找每次都要找到中间结点：<br>第一次查找中间结点需要移动指针n/2次;<br>第二次，需要移动n/4次；<br>第三次，需要n/8次；<br>。。。<br>以此类推，一直到1次为止。<br>指针一共移动次数k=n/2+n/4+n/8+…+1，等比数列求和为n-1。<br>时间复杂度为O(n)。与顺序查找时间复杂度相同。但二分查找需要进行多余的运算，比顺序查找慢。</p>
<h4 id="递归与非递归实现"><a href="#递归与非递归实现" class="headerlink" title="递归与非递归实现"></a>递归与非递归实现</h4><p>最简单的情况就是有序数组中不存在重复元素，用二分查找值等于给定值的数据。  </p>
<pre><code>//非递归
public int bsearch(int[] a,int value) {
    int low = 0;
    int high = a.length-1;
    while(low &lt;= high) {
        int mid = (low+high) / 2;
        if(a[mid] == value) {
            return mid;
        } else if(a[mid] &lt; value) {
            low = mid + 1;
        } else {
            high = mid -1;
        }
    }
    return -1;
}</code></pre><blockquote>
<p>low、high、mid都是指数组下标，low和high表示当前查找的区间范围，初始low=0,high=n-1。mid表示[low,high]的中间位置，通过a[mid]与value的大小，来更新接下来要查找的区间范围，直到找到或者区间缩小为0就退出。  </p>
</blockquote>
<ul>
<li>循环退出条件<br>low&lt;=high  </li>
<li>mid取值<br>mid=(low+high)/2。<br>low + (high - low) /2;避免low和high比较大时，两者和溢出。<br>将除以2转化成位运算low+((high-low)&gt;&gt;1)。注意位运算优先级  </li>
<li>low和high的更新<br>low=mid+1&amp;high=mid-1。<br>low=mid|high=mid可能发生死循环。  </li>
</ul>
<pre><code>//递归
public int bsearch(int[] a,int value) {
    return bserachInter(a,0,a.length-1,value);
}

private int bserachInter(int[] a,int low,int high,int value) {
    if(low &gt; high) return -1;
    int mid = low + ((high-low)&gt;&gt;1);
    if(a[mid] == value) {
        return mid;
    } else if(a[mid] &lt; value) {
        return bserachInter(a,mid+1,high,value);
    } else {
        return bserachInter(a,low,high+1,value);
    }
}</code></pre><h4 id="应用场景局限性"><a href="#应用场景局限性" class="headerlink" title="应用场景局限性"></a>应用场景局限性</h4><ul>
<li><p>二分查找依赖的是顺序表结构-数组<br>二分查找算法需要按照下标随机访问数组。数组按照下标随机访问数据的时间复杂度是O(1)，链表随机访问的时间复杂度是O(n)。如果数据使用链表存储，二分查找的时间复杂度会变得很高。<br>二分查找只能用在数据是通过顺序表来存储的数据结构上，如果数据是通过其他数据结构存储的，则无法使用二分查找。 </p>
</li>
<li><p>二分查找针对的是有序数据<br>数据必须是有序的。如果数据无序，需要先排序，排序的时间复杂度最低是O(nlogn)。如果针对的是一组静态的数据，没有频繁的插入、删除，可以进行一次排序、多次二分查找。这样排序的成本可被均摊，二分查找的边际成本就会比较低。<br>数据集合有频繁的插入和删除操作，要想用二分查找，要么每次插入、删除操作之后保证数据仍然有序，要么在每次二分查找之前都先进行排序。针对动态数据，无论什么方法，维护有序的成本都很高。(二叉树)  </p>
</li>
<li><p>数据量太小不适合二分查找<br>数据量很小，顺序便利足够。但是数据之间的比较操作非常耗时，不管数据量大小，都推荐二分查找，尽可能的减少比较次数，大大提高性能。  </p>
</li>
<li><p>数据量太大不适合二分查找<br>二分查找底层依赖数组这种数据结构，数组为了支持随机访问特性，要求内存空间连续，对内存的要求比较苛刻。即使拥有更多的内存空间剩余，如果是零散的不连续，依然无法申请相应大小的数组。  </p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>变体二分查找</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8F%98%E4%BD%93%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h4 id="查找第一个值等于给定值的元素"><a href="#查找第一个值等于给定值的元素" class="headerlink" title="查找第一个值等于给定值的元素"></a>查找第一个值等于给定值的元素</h4><pre><code>public int bsearch(int[] a,int value) {
    int low = 0;
    int hight = a.length - 1;
    while(low &lt;= high) {
        int mid = low + ((high - low) &gt;&gt; 1);
        if(a[mid] &gt; value) {
            high = mid + 1;
        }else if(a[mid] &lt; value) {
            low = mid + 1;
        } else {
            if((mid == 0) || (a[mid - 1] != value)) {
                return mid;
            } else {
                high = mid -1;
            }
        }
    }
    return -1;
}</code></pre><p>a[mid]跟目标value的大小关系有三种情况：大于、小于、等于。  </p>
<ul>
<li>对于a[mid] &gt; value的情况，需要更新high=mid-1；  </li>
<li>对于a[mid] &lt; value的情况。需要更新low=mid+1；  </li>
<li>当a[mid] = value时：如果查找的是任意一个值等于给定值的元素，a[mid]就是要找的元素。如果查找的是第一个值等于给定值的元素，需要进一步确认：代码中如果mid=0，那么这个元素已经是数组的第一个元素，那它肯定是要找的元素；如果mid!=0，但a[mid]的前一个元素a[mid-1]!=value，那么a[mid]就是要找的元素；如果经过检查后发现a[mid-1]=value，则a[mid]肯定不是要找的第一个值等于给定值的元素，需要更新high=mid-1，要找的元素肯定出现在[low,mid-1]之间。  </li>
</ul>
<h4 id="查找最后一个值等于给定值的元素"><a href="#查找最后一个值等于给定值的元素" class="headerlink" title="查找最后一个值等于给定值的元素"></a>查找最后一个值等于给定值的元素</h4><pre><code>public int bsearch(int[] a,int value) {
    int low = 0;
    int high = a.length - 1;
    while(low &lt;= high) {
        int mid = low + ((high -low) &gt;&gt; 1);
        if(a[mid] &gt; value) {
            high = mid - 1;
        } else if(a[mid] &lt; value) {
            low = mid + 1;
        } else {
            if((mid == a.length -1) || (a[mid + 1] != value)) {
                return mid;
            } else {
                low = mid + 1;
            }
        }
    }
    return -1;
}  </code></pre><ul>
<li>当a[mid] = value时：如果mid=0，a[mid]已经是数组中最后一个元素，那它肯定是要找的元素；如果a[mid]的后一个元素a[mid+1]!=value，那么a[mid]是要找的元素；如果经过检查后发现a[mid+1]=value，那a[mid]不是最后一个值等于给定值的元素，需要更新low=mid+1，要找的元素肯定出现在[mid+1,high]之间。  </li>
</ul>
<h4 id="查找第一个大于等于给定值的元素"><a href="#查找第一个大于等于给定值的元素" class="headerlink" title="查找第一个大于等于给定值的元素"></a>查找第一个大于等于给定值的元素</h4><pre><code>public int bsearch(int a[],int value) {
    int low = 0;
    int high = a.length -1;
    while(low &lt;= high) {
        int mid = low + ((high -low) &gt;&gt; 1);
        if(a[mid] &gt;= value) {
            if((mid == 0) || (a[mid - 1] &lt; value)) {
                return mid;
            } else {
                high = mid - 1;
            }
        } else {
            low = mid + 1;
        }
    }
    return -1;
}</code></pre><ul>
<li>如果a[mid] &lt; value，那要找的值肯定在[mid+1,high]之间，所以更新low=mid+1；  </li>
<li>对于a[mid] &gt;= value的情况，首先判断a[mid]是不是要找的第一个值大于等于给定值的元素。如果mid=0,a[mid]前面已经没有元素就是第一个元素，那么a[mid]就是要找的元素；或者a[mid]前面的一个元素a[mid-1]小于指定值value，那么a[mid]就是要找的元素。如果a[mid-1]&gt;=value，那么说明要找的元素在[low,mid-1]之间。  </li>
</ul>
<h4 id="查找最后一个小于等于给定值的元素"><a href="#查找最后一个小于等于给定值的元素" class="headerlink" title="查找最后一个小于等于给定值的元素"></a>查找最后一个小于等于给定值的元素</h4><pre><code>public int bsearch(int[] a,int value) {
    int low = 0;
    int high = a.length -1;
    while(low &lt;= high) {
        int mid = low + ((high -low) &gt;&gt; 1);
        if(a[mid] &gt; value) {
            high = mid -1;
        } else {
            if((mid == a.length -1) || (a[mid +1] &gt; value)) {
                return mid;
            } else {
                low = mid + 1;
            }
        }
    }
    return -1;
}</code></pre><h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>凡是用二分查找能解决的，绝大部分更倾向于用散列表或者二叉查找树。二分查找更适合用在“近似”查找问题，用其他数据结构比较难实现。<br>变体二分查找实现注意细节问题：</p>
<ul>
<li>终止条件  </li>
<li>区间上下界更新方法  </li>
<li>返回值选择  </li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>位图</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BD%8D%E5%9B%BE/</url>
    <content><![CDATA[<h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><p>将网页链接存储在散列表中。散列表需维持较小的装载因子，保证不会出现过多的散列冲突，导致操作的性能下降。需要的内存空间过大时，采用分治的思想，用多台机器进行存储。  </p>
<h3 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h3><p>有1千万个整数，整数的范围在1到1亿之间。快速查找某个整数是否在这1千万个整数中。  </p>
<p>申请一个大小为1亿、数据类型为布尔类型(true/false)的数组。将这1千万个整数作为数组下标，将对应的数组设置成true。<br>当查询某个整数K是否在这1千万个整数中的时候，只需要将对应的数组值array[K]取出来，看是否等于true。如果等于true，说明1千万整数中包含这个整数K；相反，就表示不包含这个整数K。  </p>
<p>布尔类型大小是1个字节，只需要一个二进制位(bit)就可以表示true和false两个值。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        位图-借助char类型通过位运算实现
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java中char类型占16bit，也就是2个字节（1字节8bit）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitMap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] bytes;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> nbits;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BitMap</span><span class="params">(<span class="keyword">int</span> nbits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nbits = nbits;</span><br><span class="line">        <span class="keyword">this</span>.bytes = <span class="keyword">new</span> <span class="keyword">char</span>[nbits/<span class="number">16</span>+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k &gt; nbits) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> byteIndex = k/<span class="number">16</span>;</span><br><span class="line">        <span class="keyword">int</span> bitIndex = k%<span class="number">16</span>;</span><br><span class="line">        bytes[byteIndex] |= (<span class="number">1</span> &lt;&lt; bitIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k &gt; nbits) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> byteIndex = k/<span class="number">16</span>;</span><br><span class="line">        <span class="keyword">int</span> bitIndex = k%<span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (bytes[byteIndex] &amp; (<span class="number">1</span> &lt;&lt; bitIndex)) != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<blockquote>
<p>将数字A的第K位设置为1：A = A|(1 &lt;&lt; (k-1));<br>将数字A的第K位设置为0：A = A&amp;~(1 &lt;&lt; (k-1));<br>检测数字A的第k位：A&amp;(1 &lt;&lt; (k-1)) != 0;</p>
</blockquote>
<p>位图通过数组下标来定位数据，访问效率非常高。每个数字用一个二进制位来表示，在数字范围不大的情况下，所需要的内存空间非常节省。  </p>
<h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>布隆过滤器是对位图的一种改进，针对数据范围较大的数据。  </p>
<p>数据个数是1千万，数据的范围是1到10亿。仍然使用一个1亿个二进制大小的位图，然后通过哈希函数，对数字进行处理，让它落在这1到1亿范围内。  </p>
<p>一个哈希函数可能会存在冲突，用多个哈希函数一块定位一个数据。<br>使用K个哈希函数，对同一个数字进行求哈希值，会得到K个不同的哈希值，分别记作X<sub>1</sub>,X<sub>2</sub>,X<sub>3</sub>,…,X<sub>k</sub>。把k个数字作为位图中的下标，将对应的BitMap[X<sub>1</sub>],BitMap[X<sub>2</sub>],BitMap[X<sub>3</sub>],…,BitMap[X<sub>k</sub>]都设置成true，也就是用k个二进制位，来表示一个数字的存在。  </p>
<p>当要查询某个数字是否存在的时候，用同样的K个哈希函数，对这个数字求哈希值，分别得到Y<sub>1</sub>,Y<sub>2</sub>,Y<sub>3</sub>,…,Y<sub>k</sub>。看这k个哈希值，对应位图中的数值是否都为true，如果都是true，则说明，这个数字存在，如果有其中任意一个不为true，那就说明这个数字不存在。  </p>
<p>对于两个不同的数字来说，经过一个哈希函数处理之后，可能会产生相同的哈希值。但是经过K个哈希函数处理之后，k个哈希值都相同的概率就非常低了。尽管采用k个哈希函数之后，两个数字哈希冲突的概率降低了，但是这种处理方式又带来了新的问题，容易误判。  </p>
<p>布隆过滤器只会对存在的情况有误判。如果某个数字经过布隆过滤器判断不存在，那就说明这个数字真的不存在，不会发生误判；如果某个数字经过布隆过滤器判断存在，可能误判，有可能并不存在。  </p>
<p>布隆过滤器用多个哈希函数对同一个网页链接进行处理，CPU只需要将网页链接从内存中读取一次，进行多次哈希计算，理论上讲这组操作是CPU密集型的。<br>而在散列表的处理方式中，需要读取散列值相同（散列冲突）的多个网页链接，分别跟判重的网页链接，进行字符串匹配，这个操作涉及很多内存数据的读取，是内存密集型的。<br>CPU计算比内存访问更快。  </p>
<p>当布隆过滤器中，数据个数与位图大小的比例超过某个阈值的时候，就重新申请一个新的位图。后面来的新数据，会被放置到新的位图中。如果要判断某个数据是否在布隆过滤器中已经存在，需要查看多个位图。  </p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>Java-BitSet<br>Redis-BitMap<br>Google-Guava-BloomFilter  </p>
<p>[1] <a href="https://mp.weixin.qq.com/s/xxauNrJY9HlVNvLrL5j2hg" target="_blank" rel="noopener">漫画：Bitmap算法 整合版</a> </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>位图</tag>
        <tag>布隆过滤器</tag>
      </tags>
  </entry>
  <entry>
    <title>散列表</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%A3%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<h4 id="散列思想"><a href="#散列思想" class="headerlink" title="散列思想"></a>散列思想</h4><p>散列表用的数组支持按照下标随机访问数据的特性，是数组的一种扩展，由数组演化而来。没有数组，就没有散列表。   </p>
<p>键/key/关键字–标识唯一数据<br>散列函数/Hash函数/哈希函数–将键转化为数组下标的映射方法<br>散列值/Hash值/哈希值–散列函数计算得到的值    </p>
<p>通过散列函数把元素的键值映射为下标（取模），然后将数据存储在数组中对应下标的位置。按照键值查询元素时，用同样的散列函数，将键值转化为数组下标，从对应的数组下标的位置取数据。  </p>
<h4 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h4><p>散列函数–<strong>hash(key)</strong>，其中key表示元素的键值，hash(key)的值表示经过散列函数计算得到的散列值。  </p>
<p>散列函数设计的基本要求：  </p>
<ul>
<li>散列函数计算得到的散列值是一个非负整数；</li>
<li>如果key1=key2，那hash(key1) == hash(key2)；</li>
<li>如果key1!=key2，那hash(key1) != hash(key2)；<blockquote>
<p>数组的存储空间有限，找到一个不同的key对应的散列值都不一样的散列函数，几乎是不可能的。必然存在散列冲突。   </p>
</blockquote>
</li>
</ul>
<h4 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h4><p>再好的散列函数也无法避免散列冲突，常用的散列冲突解决方法有两类：开放寻址法、链表法。  </p>
<ol>
<li><p>开放寻址法<br>如果出现散列冲突，就重新探测一个空闲位置，将其插入。  </p>
<ul>
<li><p>线性探测<br>往散列表中<strong>插入</strong>数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。<br>在散列表中<strong>查找</strong>元素的过程类似插入过程。通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，则说明就是我们要找的元素；否则就顺序往后依次查找。如果遍历到数组中的空闲位置，还没有找到，就说明要查找的元素并没有在散列表中。<br>使用线性探测法解决冲突的散列表，不能单纯的把要<strong>删除</strong>的元素设置为空。在查找的时候，一旦通过线性探测方法，找到一个空闲位置，可以认定散列表中不存在这个数据。但是如果这个空闲位置是我们后来删除的，就会导致原来的查找算法失效。本来存在的数据会被认定为不存在。解决方案，将删除的元素特殊标记为deleted，当线性探测查找的时候，遇到标记为deleted的空间，并不是停下来，而是继续往下探测。  </p>
<p>缺陷：当散列表中插入的数据越来越多时，散列冲突发生的可能性会越来越大，空闲位置会越来越少，线性探测的时间会越来越久，极端情况下，可能需要探测整个散列表，所以最坏情况下的时间复杂度为O(n)。在删除和查找时也可能会探测整张散列表，才只能找到要查找或者删除的数据。  </p>
</li>
<li><p>二次探测<br>类似线性探测，线性探测每次探测的步长是1，探测的下标序列是hash(key)+0,hash(key)+1,hash(key)+2…二次探测的步长变成了原来的“二次方”，探测的下标序列是hash(key)+0,hash(key)+1<sup>2</sup>,hash(key)+2<sup>2</sup>…  </p>
</li>
<li><p>双重散列<br>不仅仅使用一个散列函数。使用一组散列函数hash1(key),hash2(key),hash3(key)…先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。  </p>
</li>
</ul>
<p>不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，尽可能保证散列表中有一定比列的空槽位置。用<strong>装载因子</strong>来表示空位的多少。<br>计算公式：  </p>
<blockquote>
<p>散列表的装载因子=填入表中的元素个数/散列表的长度   </p>
</blockquote>
<p>装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。  </p>
</li>
<li><p>链表法<br>在散列表中，每个“桶”或者“槽”会对应一条链表，所有散列值相同的元素都放到相同槽位对应的链表中。<br>当插入的时候，只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，所以插入的时间复杂度是O(1)。当查找/删除一个元素时，同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除。查找、删除的时间复杂度跟链表的长度k成正比O(k)。对于散列比较均匀的散列函数来说，k=n/m，其中n表示散列中数据的个数，m表示散列表中“槽”的个数。  </p>
</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>散列表</tag>
      </tags>
  </entry>
  <entry>
    <title>队列</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>队列也是一种操作受限的线性表数据结构，具有先进者先出的特性。  </p>
<h4 id="实现队列"><a href="#实现队列" class="headerlink" title="实现队列"></a>实现队列</h4><p>队列主要包含两个操作：入队enqueue(),放一个数据到队列尾部；出队dequeue(),从队列头部取一个元素。<br>用数组实现的队列-<strong>顺序队列</strong>，多为有界队列。<br>队列需要两个指针：1指向队头的head指针；2指向队尾的tail指针。<br>顺序队列实现优化，出队时不搬移数据，入队时如果没有空闲空间集中触发一次数据的搬移操作。更进一步，循环队列可以避免数据搬移操作。<br>用链表实现的队列-<strong>链式队列</strong>，多为无界队列。<br>入队：tail-&gt;next=new_node,tail=tail-&gt;next(tail=new_node);<br>出队：head=head-&gt;next.</p>
<h4 id="特殊队列"><a href="#特殊队列" class="headerlink" title="特殊队列"></a>特殊队列</h4><ul>
<li>循环队列(基于数组)<br>与普通队列的区别关键在于队空和队满的判定条件<br>普通队列：队空<strong>head==tail</strong>,队满<strong>tail==n</strong>;<br>循环队列：队空<strong>head==tail</strong>,队满<strong>(tail+1)%n==head</strong>.  <blockquote>
<p>tail指向的位置没有存储数据，循环队列会浪费一个数组的存储空间。为了区分队空和队满。<br>普通队列队满的时候tail指向n，而不是n-1，不会浪费空间，数组中所有的位置都有数据。  </p>
</blockquote>
</li>
<li>阻塞队列（生产者-消费者模型）<br>在队列的基础上增加了阻塞操作：在队列为空的时候，从对头取数据会被阻塞；如果队列已满，插入数组的操作会被阻塞。  </li>
<li>并发队列<br>线程安全的队列<br>在入队、出队操作方法上加锁，锁粒度大并发度低。<br>基于数组的循环队列，利用CAS原子操作实现高效的并发队列。  </li>
</ul>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>资源有限场景中，没有空闲资源时，通过队列来实现请求排队。<br>线程池、数据库连接池等</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>散列表应用</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%A3%E5%88%97%E8%A1%A8%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>散列表支持非常高效的数据插入、删除、查找操作，但是散列表中的数据都是通过散列函数打乱之后无规律的存储的，无法支持按照某种顺序快速地遍历数据。如果希望按照顺序遍历散列表中的数据，需要将散列表中的数据拷贝到数组中，然后排序再遍历。<br>散列表是动态数据结构，不停地有数据的插入、删除，每次希望按顺序遍历散列表中的数据的时候，都需要先排序，效率很低，为了解决这个问题，将散列表和链表（或者跳表）结合在一起使用。  </p>
<h4 id="LRU缓存淘汰算法"><a href="#LRU缓存淘汰算法" class="headerlink" title="LRU缓存淘汰算法"></a>LRU缓存淘汰算法</h4><ul>
<li><p>通过链表实现LRU缓存淘汰算法：维护一个按照访问时间从大到小有序排列的链表结构。因为缓存大小有限，当缓存空间不够，需要淘汰一个数据的时候，直接将链表头部的结点删除。<br>当要缓存某个数据的时候，先在链表中查找这个数据。如果没有找到，则直接将数据放到链表的尾部；如果找到了，就把它移动到链表的尾部。因为查找数据需要遍历链表，所以单纯使用链表实现的LRU缓存淘汰算法的时间复杂度很高为O(n)。  </p>
</li>
<li><p>将散列表和链表两种结构组合使用，可以将添加、删除、查找操作的时间复杂度都降低到O(1)。使用双向链表存储数据，链表中的每个节点除了存储数据data、前驱指针prev、后继指针next之外，还新增了一个特殊的字段hnext。这里的散列表通过链表法解决散列冲突，每个节点会在两条链中。一个链式双向链表，一个是散列表中的拉链。前驱和后继指针将结点串在双向链表中，hnext指针将结点串在散列表的拉链中。  </p>
<blockquote>
<ul>
<li>查找数据，散列表中查找数据的时间复杂度为O(1)。找到数据之后将其移动到双向链表的尾部。  </li>
<li>删除数据，散列表中在O(1)时间复杂度里找到要删除的结点，双向链表中通过前驱指针O(1)时间复杂度获取前驱结点。则删除结点的时间复杂度为O(1)。  </li>
<li>添加数据，先判断数据是否已经在缓存中。如果存在，需要将其移动到双向链表的尾部；如果不存在，判断缓存是否已满，如果已满，则将双向链表头部的结点删除在将数据放到链表的尾部，如果未满，则直接将数据放到链表的尾部。<br>涉及查找操作都通过散列表来完成，其他删除、插入操作通过链表来完成，只需更改指针指向。时间复杂度都为O(1)。  </li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="Redis有序集合"><a href="#Redis有序集合" class="headerlink" title="Redis有序集合"></a>Redis有序集合</h4><p>有序集合中，每个成员对象有两个重要的属性，键值key和分值score，可以通过score查找数据，也可以通过key来查找数据。<br>按照分值将对象组织成跳表的结构<br>按照键值构建一个散列表   </p>
<h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><p>通过散列表和双向链表组合实现。Linked指的是双向链表，并非指用链表法解决散列冲突。<br>不仅支持按照插入顺序遍历数据，还支持按照访问数据遍历数据。  </p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 10是初始大小，0.75是装载因子，true是表示按照访问时间排序</span></span><br><span class="line">HashMap&lt;<span class="built_in">Integer</span>, <span class="built_in">Integer</span>&gt; m = <span class="literal">new</span> LinkedHashMap&lt;&gt;(<span class="number">10</span>, <span class="number">0.75</span>f, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>散列表</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉查找树</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/</url>
    <content><![CDATA[<p>二叉查找树是二叉树中最常用的一种类型，也叫二叉查找树。<br>二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。  </p>
<h4 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h4><p>先取根节点，如果它等于要查找的数据，直接返回。<br>如果要查找的数据比根节点的值小，那就在左子树中递归查找；<br>如果要查找的数据比根节点的值大，那就在右子树中递归查找。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        查找
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node tree;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">select</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        Node p = tree;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(data &lt; p.data) </span><br><span class="line">                p = p.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (data &gt; p.data)</span><br><span class="line">                p = p.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> data;</span><br><span class="line">        <span class="keyword">private</span> Node left;</span><br><span class="line">        <span class="keyword">private</span> Node right;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>插入类似查找，新插入的数据一般都是在叶子节点上，只需要从根节点开始，依次比较要插入的数据和节点的大小关系。  </p>
<p>如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；<br>如果不为空，就在递归遍历右子树，查找插入位置。<br>同理，如果要插入的数据比节点数据小，并且节点的左子树为空，就将新数据插入到左子节点的位置；<br>如果不为空，就再递归遍历左子树，查找插入位置。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        插入
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node tree;</span><br><span class="line">    <span class="comment">//不考虑插入节点与已有节点相同的情况</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tree == <span class="keyword">null</span>) &#123;</span><br><span class="line">            tree = <span class="keyword">new</span> Node(data);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node p = tree;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(data &gt; p.data) &#123;</span><br><span class="line">                <span class="keyword">if</span>(p.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.right = <span class="keyword">new</span> Node(data);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                p = p.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//data &lt; p.data</span></span><br><span class="line">                <span class="keyword">if</span>(p.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.left = <span class="keyword">new</span> Node(data);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                p = p.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> data;</span><br><span class="line">        <span class="keyword">private</span> Node left;</span><br><span class="line">        <span class="keyword">private</span> Node right;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>针对要删除节点的子节点个数的不同，需要分为三种情况处理：  </p>
<ol>
<li>要删除的节点没有子节点，只需要直接将父节点中，指向要删除节点的指针置为null。  </li>
<li>要删除的节点只有一个子节点(只有左子节点或者右子节点)，只需要更新父节点中，指向要删除节点的指针，让它指向要删除结点的子节点。  </li>
<li>要删除的节点有两个子节点。需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上，然后再删除掉这个最小节点，因为最小节点肯定没有左子节点(如果有左子节点，那就不是最小节点了)，所以可以应用这两条规则来删除这个最小节点。  </li>
</ol>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        删除
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node tree;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//p指向要删除的节点，初始化指向根节点</span></span><br><span class="line">        Node p = tree;</span><br><span class="line">        <span class="comment">//pp记录的是p的父节点</span></span><br><span class="line">        Node pp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span> &amp;&amp; p.data != data) &#123;</span><br><span class="line">            <span class="comment">//更新当前节点为父节点，进而遍历子节点、子子节点</span></span><br><span class="line">            pp = p;</span><br><span class="line">            <span class="keyword">if</span>(data &gt; p.data)</span><br><span class="line">                p = p.right;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//data &lt; p.data</span></span><br><span class="line">                p = p.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有找到</span></span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//要删除的节点有两个子节点</span></span><br><span class="line">        <span class="keyword">if</span>(p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//查找右子树中最小节点</span></span><br><span class="line">            Node minP = p.right;</span><br><span class="line">            <span class="comment">//minPP表示minP的父节点</span></span><br><span class="line">            Node minPP = p;</span><br><span class="line">            <span class="keyword">while</span>(minP.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//更新当前最小节点为当前节点的左子节点</span></span><br><span class="line">                minPP = minP;</span><br><span class="line">                minP = minP.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将minP的数据替换到p中，后续通过minPP(pp)删除原minP</span></span><br><span class="line">            p.data = minP.data;</span><br><span class="line">            p = minP;</span><br><span class="line">            pp = minPP;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除的节点是叶子节点或者仅有一个子节点</span></span><br><span class="line">        Node child;<span class="comment">//p的子节点</span></span><br><span class="line">        <span class="keyword">if</span>(p.left != <span class="keyword">null</span>)</span><br><span class="line">            child = p.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p.right != <span class="keyword">null</span>)</span><br><span class="line">            child = p.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            child = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//通过更新父节点的子节点来删除指定的p</span></span><br><span class="line">        <span class="keyword">if</span>(pp == <span class="keyword">null</span>) <span class="comment">//删除的节点是根节点</span></span><br><span class="line">            tree = child;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pp.left == p)</span><br><span class="line">            pp.left = child;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//pp.right == p</span></span><br><span class="line">            pp.right = child;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> data;</span><br><span class="line">        <span class="keyword">private</span> Node left;</span><br><span class="line">        <span class="keyword">private</span> Node right;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<h4 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h4><p>快速的查找最大节点和最小节点、前驱节点和后继节点。  </p>
<h4 id="重要特性"><a href="#重要特性" class="headerlink" title="重要特性"></a>重要特性</h4><p>中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是O(n)。  </p>
<h4 id="重复数据"><a href="#重复数据" class="headerlink" title="重复数据"></a>重复数据</h4><p>实际开发中，二叉查找树中存储的是包含很多字段的对象，利用对象的某个字段作为键值来构建二叉查找树，对象中的其他字段叫做卫星数据。  </p>
<p>键值相同的两个对象存储解决方案：   </p>
<ol>
<li><p>二叉查找树中每个节点不仅存储一个数据，通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。   </p>
</li>
<li><p>每个节点仍然只存储一个数据。在查找插入位置的过程冲，如果 碰到一个节点的值与要插入数据的值相同，把这个新插入的数据当做大于这个节点的值来处理，将新数据放到这个节点的右子树。  </p>
<p>当要查找数据的时候，遇到值相同的节点，并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点才停止。这样可以把键值等于要查找值的所有节点都找出来。    </p>
<p>对于删除操作，也需要先查找到每个要删除的节点，然后再按之前的删除操作的方法依次删除。   </p>
</li>
</ol>
<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>二叉查找树的插入、删除、查找的时间复杂度都跟树的高度成正比，为O(height)。也就是求包含n个节点的完全二叉树的高度。树的高度等于最大层数减一。  </p>
<p>最坏情况：二叉查找树退化为链表，查找的时间复杂度为O(n)。</p>
<p>最好情况：二叉查找树为完全二叉查找树。<br>包含n个节点的完全二叉树，第一层包含1个节点，第二层包含2个节点，第三层包含4个节点，依次类推，下面一层节点个数是上一层的2倍，第k层包含的节点个数就是2<sup>K-1</sup>。<br>完全二叉树最后一层的节点个数在1个到2<sup>L-1</sup>之间(最大层数为L)。则  </p>
<p>n &gt;= 1+2+4+8+…+2<sup>L-2</sup>+1<br>n &lt;= 1+2+4+8+…+2<sup>L-2</sup>+2<sup>L-1</sup></p>
<p>等比数列求和公式，L的范围是[log<sub>2</sub>(n+1),log<sub>2</sub>n+1]。完全二叉树的层数小于log<sub>2</sub>n+1，完全二叉树的高度小于log<sub>2</sub>n。平衡二叉查找树的高度接近logn，插入、删除、查找操作的时间复杂度稳定为O(logn)。</p>
<h4 id="对比散列表"><a href="#对比散列表" class="headerlink" title="对比散列表"></a>对比散列表</h4><ul>
<li>散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。二叉查找树只需要中序遍历，就可以在O(n)的时间复杂度内输出有序的数据序列。  </li>
<li>散列表扩容耗时多，遇到散列冲突时性能不稳定。二叉查找树的性能不稳定，但平衡二叉查找树的性能非常稳定，时间复杂度稳定在O(logn)。</li>
<li>散列表的查找等操作的时间复杂度是常量级的，但是哈希冲突存在&amp;哈希函数耗时，不一定比平衡二叉查找树的效率高。</li>
<li>散列表的构造比二叉查找树要复杂，需要考虑的额东西很多，散列函数、冲突解决、扩容、缩容等。平衡二叉查找树只需要考虑平衡性。  </li>
<li>为了避免散列冲突，装载因子不能太大，基于开放寻址法解决冲突的散列表，会浪费一定的存储空间。</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>堆&amp;堆排序</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%A0%86&amp;%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h4 id="堆的定义"><a href="#堆的定义" class="headerlink" title="堆的定义"></a>堆的定义</h4><ul>
<li><p>堆是一个完全二叉树<br>除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。  </p>
</li>
<li><p>堆中每一个节点的值都必须大于等于(或小于等于)其子树中每个节点的值<br>堆中每个节点的值都大于等于(或者小于等于)其左右子节点的值。  </p>
<blockquote>
<p>二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。  </p>
</blockquote>
<p>大顶堆：每个节点的值都大于等于子树中每个节点值。<br>小顶堆：每个节点的值都小于等于子树中每个节点值。  </p>
</li>
</ul>
<h4 id="堆的存储"><a href="#堆的存储" class="headerlink" title="堆的存储"></a>堆的存储</h4><p>完全二叉树适合用数组存储。节省存储空间，不需要存储左右节点的指针，单纯的通过数组下标就可以找到节点的左右节点和父节点。 </p>
<p>假设堆中的数据从数组下标为1的位置开始存储。<br>数组中下标为i的节点的左子节点就是下标为i<em>2的节点，右子节点就是下标为i</em>2+1的节点，父节点就是下标为i/2的节点。  </p>
<h4 id="堆的操作"><a href="#堆的操作" class="headerlink" title="堆的操作"></a>堆的操作</h4><p>往堆中插入一个元素或者删除堆顶元素后，数据结构不满足堆的特性，对其进行调整让它重新满足堆的特性，该过程称为<strong>堆化</strong>。<br>堆化分为从下往上和从上往下两种。顺着节点所在路径，对比然后交换。  </p>
<ul>
<li><p>插入一个元素-从下往上堆化。<br>将节点放在数组最后，然后让新插入的节点与父节点对比大小。如果不满足自己点小于等于父节点的大小关系，就互换两个节点。一直重复这个过程，直到父子节点之间满足大小关系。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        插入
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heap</span> </span>&#123;</span><br><span class="line">    <span class="comment">//数组，从下标1开始存储数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] a;</span><br><span class="line">    <span class="comment">//堆可以存储的最大数据个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">//堆中已经存储的数据个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Heap</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        a = <span class="keyword">new</span> <span class="keyword">int</span>[capacity + <span class="number">1</span>];</span><br><span class="line">        n = capacity;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//堆满</span></span><br><span class="line">        <span class="keyword">if</span>(count &gt;= n) <span class="keyword">return</span>;</span><br><span class="line">        count++;</span><br><span class="line">        a[count] = data;</span><br><span class="line">        <span class="keyword">int</span> i = count;</span><br><span class="line">        <span class="comment">//自下往上堆化</span></span><br><span class="line">        <span class="keyword">while</span>(i/<span class="number">2</span> &gt; <span class="number">0</span> &amp;&amp; a[i] &gt; a[i/<span class="number">2</span>]) &#123;</span><br><span class="line">            <span class="comment">//交换下标为i和i/2的两个元素</span></span><br><span class="line">            swap(a,i,i/<span class="number">2</span>);</span><br><span class="line">            i = i/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  
</li>
<li><p>删除堆顶元素-从上往下堆化。<br>堆顶元素存储的是堆中数据的最大值或者最小值。  </p>
<p>方法1：当删除堆顶元素之后，把第二大元素放到堆顶，第二大元素必然是左右子节点之一。迭代删除第二大节点，以此类推直到叶子节点被删除。最后堆化出来的堆不满足完全二叉树特性，可能出现空洞。  </p>
<p>方法2：当删除堆顶元素之后，把最后一个元素放到堆顶，然后利用父子节点对比方法，对不满足父子节点大小关系的交换两个节点，重复这个过程，直到父子节点之间满足大小关系为止。移除的是数组最后一个元素，堆化过程中都是交换操作，不会出现数组空洞，满足完全二叉树特性。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        删除
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heap</span> </span>&#123;</span><br><span class="line">    <span class="comment">//数组，从下标1开始存储数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] a;</span><br><span class="line">    <span class="comment">//堆可以存储的最大数据个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">//堆中已经存储的数据个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Heap</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        a = <span class="keyword">new</span> <span class="keyword">int</span>[capacity + <span class="number">1</span>];</span><br><span class="line">        n = capacity;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//堆中没有数据</span></span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        a[<span class="number">1</span>] = a[count];</span><br><span class="line">        count--;</span><br><span class="line">        heapify(a,count,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//自上往下堆化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> n,<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>（<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> maxPos = i;</span><br><span class="line">            <span class="keyword">if</span>(i*<span class="number">2</span> &lt;= n &amp;&amp; a[i] &lt; a[i*<span class="number">2</span>])</span><br><span class="line">                maxPos = i*<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(i*<span class="number">2</span>+<span class="number">1</span> &lt;= n &amp;&amp; a[maxPos] &lt; a[i*<span class="number">2</span>+<span class="number">1</span>])</span><br><span class="line">                maxPos = i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(maxPos == i)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            swap(a,i,maxPos);</span><br><span class="line">            i = maxPos;    </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

</li>
</ul>
<p>包含n个节点的完全二叉树，树的高度不会超过log<sub>2</sub>n。堆化的过程是顺着节点所在路径比较交换的，堆化的时间复杂度跟树的高度成正比，为O(logn)。插入数据和删除堆顶元素的的主要逻辑是堆化，所以往堆中插入一个元素和删除堆顶元素的时间复杂度都是O(logn)。  </p>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>借助堆这种数据结构实现的排序算法称为堆排序。时间复杂度为O(nlogn),原地不稳定排序算法。<br>堆排序的过程分为两个步骤：<strong>建堆、排序</strong>。  </p>
<ol>
<li><p>建堆<br>不借助另一个数组，在原数组上操作建堆。  </p>
<ul>
<li><p>从前往后处理数组数据，从下往上堆化。  </p>
<p>   在堆中插入一个元素的思路。数组中包含n个数据，假设起初堆中只包含一个数据，就是下标为1的数据。然后调用插入操作，将下标从2到n的数据依次插入到堆中最后一个位置，并进行堆化，不符合大小关系就交换位置，重复，最后将包含n个数据的数组组织成了堆。  </p>
</li>
<li><p>从后往前梳理数据，每个数据都是从上往下堆化。  </p>
<p>   从最后一个非叶子节点开始倒序依次堆化，不符合大小关系就交换位置。叶子节点往下堆化只能自己跟自己比较。    </p>
</li>
</ul>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        建堆
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n/<span class="number">2</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        heapify(a,n,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> n,<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>（<span class="keyword">true</span>) &#123;</span><br><span class="line">         <span class="keyword">int</span> maxPos = i;</span><br><span class="line">         <span class="keyword">if</span>(i*<span class="number">2</span> &lt;= n &amp;&amp; a[i] &lt; a[i*<span class="number">2</span>])</span><br><span class="line">             maxPos = i*<span class="number">2</span>;</span><br><span class="line">         <span class="keyword">if</span>(i*<span class="number">2</span>+<span class="number">1</span> &lt;= n &amp;&amp; a[maxPos] &lt; a[i*<span class="number">2</span>+<span class="number">1</span>])</span><br><span class="line">             maxPos = i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">if</span>(maxPos == i)</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">         swap(a,i,maxPos);</span><br><span class="line">         i = maxPos;    </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p>完全二叉树下标n/2 + 1到n的节点是叶子节点不需要堆化，只需对下标从n/2到1的数据进行堆化。<br>每个节点的堆化的时间复杂度是O(logn)，n/2 + 1个节点堆化的总时间复杂度就是O(nlogn)。(粗略)  </p>
<p>叶子节点不需要堆化，需要堆化的的节点从倒数第二层开始，每个节点堆化的过程中，需要比较和交换的节点个数跟这个节点的高度k成正比，将每个节点的高度求和得到建堆的时间复杂度：  </p>
<p>S=1<em>h + 2<sup>1</sup></em>(h-1) + 2<sup>2</sup><em>(h-2) +<br>2<sup>k</sup></em>(h-k) + 2<sup>h-1</sup>*1  </p>
<blockquote>
<p>公式左右乘以2，再错位对齐后与原公式相减，中间是个等比数列</p>
</blockquote>
<p>= -h + 2 + 2<sup>2</sup> + 2<sup>3</sup> + ··· + 2<sup>k</sup> + ··· + 2<sup>h-1</sup> + 2<sup>h</sup><br>= -h + (2<sup>h</sup>-2) + 2<sup>h</sup><br>= 2<sup>h+1</sup> -h -2  </p>
<p>h=log<sub>2</sub>n,S=O(n).</p>
<p>建堆的时间复杂度为O(n)。</p>
</li>
<li><p>排序<br>建堆结束后，数组中的数据已经是按照大顶堆的特性来组织的。数组中的第一个元素就是堆顶，也是最大的元素。<br>将堆顶元素与最后一个元素交换，最大元素就放到了下标为n的位置。类似删除堆顶元素操作。堆顶元素被移除，下标为n的最小元素被放到堆顶，通过堆化的方法将剩下的n-1个元素重新构建成堆；再取堆顶元素(原堆第二大元素)-与n-1位置的元素交换-堆化-重复。直到最后堆中只剩下下标为1的一个元素，排序完成。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        排序
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//n表示数据的个数，数组a中的数据从下标1到n的位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    buildHeap(a,n);</span><br><span class="line">    <span class="keyword">int</span> k = n;</span><br><span class="line">    <span class="keyword">while</span>(k&gt;<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//当前堆尾与堆顶交换</span></span><br><span class="line">        swap(a,<span class="number">1</span>,k);</span><br><span class="line">        k--;</span><br><span class="line">        <span class="comment">//只需要堆化堆顶元素</span></span><br><span class="line">        heapify(a,k,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p>整个堆排序的过程，只需要极个别的临时存储空间，属于<strong>原地排序算法</strong>。<br>堆排序包括建堆和排序两个操作，建堆的时间复杂度是O(n)，排序过程的时间复杂度是O(nlogn)，堆排序整体的<strong>时间复杂度是O(nlogn)</strong>。<br>堆排序过程中，将堆的最后一个节点跟堆顶节点互换，改变了值相同数据的原始相对顺序。堆排序<strong>不是稳定的排序算法</strong>。</p>
</li>
</ol>
<h4 id="对比快排"><a href="#对比快排" class="headerlink" title="对比快排"></a>对比快排</h4><ul>
<li>堆排序数据访问的方式没有快速排序友好。<br>快排数据是顺序访问的，堆排序堆化过程数据是跳着访问的(2的指数)，对CPU缓存不友好。  </li>
<li>同样的数据，在排序过程中，堆排序的数据交换次数多于快速排序。<br>快排数据交换的次数不会比逆序多。堆排序建堆的过程会打乱数据原有的相对先后顺序，导致原数据有序度降低。  </li>
</ul>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>用数组存储表示完全二叉树时，若从下标为0开始存储，如果节点下标是i，则左子节点的下标就是2<em>i+1，右子节点的下标是2</em>i+2，父节点的下标是(i-1)/2。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>堆的应用</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%A0%86%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h4 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h4><p>在优先级队列中，数据的出队顺序不是先进先出，而是按照优先级来，优先级高的，最先出队。  </p>
<p>优先级队列实现方法有很多，用堆来实现是最直接、最高效的。<strong>一个堆可以看做一个优先级队列</strong>，往优先级队列中插入一个元素，就相当于往堆中插入一个元素；从优先级队列中取出优先级最高的元素，相当于取出堆顶元素。<br>霍夫曼编码、图的最短路径、最小生成树算法。  </p>
<ul>
<li><p>合并有序小文件<br>小文件中存储的都是有序的字符串。从各个小文件中各取出一个字符串，放入到与文件个数等长的小顶堆中，堆顶的元素就是优先级队列队首的元素-最小的字符串。<br>将这个字符串放入到大文件中，并将其从堆中删除。然后再从对应的小文件中取出下一个字符串，放入到堆中。循环。  </p>
<p>删除堆顶数据和往堆中插入数据的时间复杂度都是O(logn)，n表示堆中的数据个数。  </p>
</li>
<li><p>高性能定时器<br>按照任务设定的执行时间，将这些任务存储在优先级队列中，队列首部（小顶堆的堆顶）存储的是最先执行的任务。<br>拿队首任务的执行时间点，与当前时间点相减，得到时间间隔T。表示从当前时间开始，等待多久才会有第一个任务需要被执行。这样定时器就可以设定在T秒之后再来执行任务，从当前时间点到（T-1）秒这段时间里，定时器不需要做任何事情。<br>当T秒过去后，定时器取优先级队列中队首的任务执行。然后再计算新的队首任务的执行时间点与当前时间点的差值，该值是定时器执行下一个任务需要等待的时间。</p>
<p>避免了普通定时器频繁轮训和遍历整个任务列表。  </p>
</li>
</ul>
<h4 id="利用堆求TopK"><a href="#利用堆求TopK" class="headerlink" title="利用堆求TopK"></a>利用堆求TopK</h4><ul>
<li><p>静态数据集合<br>针对包含n个数据的数组，查找前K大元素。先顺序取出数组中前k个元素，维护成一个大小为K的小顶堆，再顺序遍历数组，从数组中取出数据与堆顶元素比较。如果比堆顶元素大，就把堆顶元素删除，并将这个数据插入堆中；如果比堆顶元素小，则不处理。数组中护具都遍历完之后，堆中的数据就是前K大数据。  </p>
<p>遍历数组时间复杂度为O(n)，一次堆化操作时间复杂度为O(logK)，最坏情况下，n个元素都入堆一次，时间复杂度为O(nlogK)。</p>
</li>
<li><p>动态数据集合<br>如果每次询问前K大数据，都基于当前的数据重新计算的话，时间复杂度为O(nlogK)，n表示当前的数据的大小。  </p>
<p>维护一个K大小的小顶堆，当有数据被添加进集合中时，与堆顶元素比较。如果比堆顶元素大，就把堆顶元素删除，并将这个数据插入堆中；如多比堆顶元素小，就不做处理。无论任何时候需要查询当前的前K大数据，都可以立刻返回。  </p>
</li>
</ul>
<h4 id="利用堆求中位数"><a href="#利用堆求中位数" class="headerlink" title="利用堆求中位数"></a>利用堆求中位数</h4><p>中位数，处在中间位置的那个数。如果数据的个数是奇数，把数据从小到大排列，第n/2 + 1个数就是中位数（数据从0开始编号）；如果数据的个数是偶数，处于中间位置的数据有两个，第n/2个和第n/2 + 1个，可以随意取一个作为中位数。  </p>
<ul>
<li><p>静态数据<br>中位数固定，可以先排序，第n/2个数据就是中位数。每次询问中位数直接返回固定值。  </p>
</li>
<li><p>动态数据<br>中位数在不停的变动，不能每次都先排序。  </p>
<p>维护两个堆，一个大顶堆，一个小顶堆。大顶堆存储前半部分数据，小顶堆存储后半部分数据，而且小顶堆中的数据都大于大顶堆中的数据。<br>如果新加入的数据小于等于大顶堆的堆顶元素，就将新数据插入到大顶堆；否则将新数据插入到小顶堆。插入后两个堆中的数据个数不符合约定情况时，从一个堆中将堆顶元素移动到另一个堆。  </p>
<p>插入数据因为需要涉及堆化，时间复杂度为O(logn)，求中位数只需要返回大顶堆的堆顶元素，时间复杂度是O(1)。  </p>
<p>中位数相当于50%，可以扩展到任意百分位数。  </p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>散列表扩展</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%A3%E5%88%97%E8%A1%A8%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<p>散列函数、装载因子、散列冲突等都会影响散列表的查询效率。<br>极端情况，所有的数据经过散列函数之后，都散列到同一个槽里，如果使用基于链表的冲突解决方法，散列表就会退化为链表，查询的时间复杂度从O(1)急剧退化为O(n)。  </p>
<h4 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h4><p>散列函数设计的好坏，决定了散列表冲突的概率大小，也直接决定了散列表的性能。  </p>
<ul>
<li>散列函数的设计不能太复杂<br>过于复杂的撒捏函数，会消耗很多计算时间，间接影响到散列表的性能。  </li>
<li>散列函数生成的值要尽可能随机并且均匀分布<br>避免或者最小化散列冲突，即便出现冲突，散列到每个槽里的数据也会比较平均，不会出现某个槽内数据特别多的情况。  </li>
<li>考虑关键字的长度、特点、分布、散列表的大小等其他因素  </li>
</ul>
<p>数据分析法<br>直接寻址法<br>平方取中法<br>折叠法<br>随机数法<br>。。。</p>
<h4 id="装载因子"><a href="#装载因子" class="headerlink" title="装载因子"></a>装载因子</h4><p>装载因子越大说明散列表中的元素越多，空闲位置越少，散列冲突的概率就越大。插入数据的过程要多次寻址或者拉很长的链，查找的过程也会变得很慢。  </p>
<ul>
<li>静态数据<br>没有频繁的插入和删除的静态数据集合。  </li>
<li>动态散列表<br>数据集合是频繁变动的，事先无法预估将要加入的数据个数，无法事先申请一个足够大的散列表。随着数据慢慢加入，装载因子就会慢慢变大。当装载因子过大时，需要进行动态扩容。<br>散列表的大小变了，数据的存储位置也变了，需要通过散列函数重新计算每个数据的存储位置。<br>插入一个数据，最好情况下不需要扩容，最好时间复杂度为O(1)；最坏情况下，散列表装载因子过高启动扩容，需要重新申请内存空间，重新计算哈希位置，并且搬移数据，时间复杂度为O(n)。用摊还分析法，均摊情况下，时间复杂度接近最好情况O(1)。<br>随着数据的删除，散列表中的数据会越来越少，空闲空间会越来越多。如果对空间消耗非常敏感，可以在装载因子小于某个值之后，启动动态缩容。<br>装载因子阈值的设置要权衡时间、空间复杂度。同事要避免数据的插入和删除导致频繁的扩容和缩容。  </li>
</ul>
<h4 id="动态扩容"><a href="#动态扩容" class="headerlink" title="动态扩容"></a>动态扩容</h4><p>大部分情况下，动态扩容的散列表插入一个数据都很快，当装载银子啊已经达到阈值，需要先进行扩容，再插入数据，插入数据就会变得很慢。<br>解决一次性扩容耗时过多的情况，可以将扩容操作穿插在插入操作的过程中，分批完成。当装载时因子触达阈值之后，只申请新空间，但并不将老的数据搬移到新散列表中。<br>当新数据要插入时，将新数据插入新散列表中，并从老散列表中拿出一个数据放入到新散列表。每次插入一个数据到散列表，重复上述过程，避免了集中一次性数据搬移。任何情况下，插入一个数据的时间复杂度都是O(1)。<br>查询操作，兼容新、老散列表的数据，先从新散列表中查找，如果没有找到，再去老散列表中查找。  </p>
<h4 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h4><ul>
<li><p>开放寻址法<br>数据量小、装载因子小。ThreadLocalMap  </p>
<p>优点：<br>散列表的数据存储在数组中，可以有效利用CPU缓存加快查询速度，序列化起来比较简单。  </p>
<p>缺点：<br>删除数据比较麻烦，需要特殊标记已经删掉的数据。所有的数据存储在一个数组中，冲突的代价高。装载因子的上限不能太大，浪费内存空间。  </p>
</li>
<li><p>链表法<br>大对象、大数据量。LinkedHashMap  </p>
<p>优点：<br>内存利用率高。链表结点可以在需要的时候再创建，并不需要事先申请好。<br>对大装载因子的容忍度高。只要散列函数的值随机均匀，更大的装载因子也就是链表的长度变长了而已，虽然查找效率有所下降，但是比顺序查找快。  </p>
<p>缺点：<br>链表要存储指针，对于比较小的对象的存储比较消耗内存。如果存储的是大对象，要存储的对象的大小远远大于一个指针的大小（4个字节或者8个字节），指针的内存消耗在大对象面前可以忽略。<br>链表中的结点是零散分布在内存中的，不是连续的，对CPU缓存是不友好的，对执行效率有一定影响。  </p>
<p>将链表法中的链表改造为其他高效的动态数据结构：跳表、红黑树。极端情况下，所有的数据都散列到同一个桶内，查找的时间复杂度为O(logn)，能避免散列碰撞攻击。  </p>
</li>
</ul>
<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><ul>
<li><p>初始大小<br>默认初始大小16。  </p>
</li>
<li><p>装载因子&amp;动态扩容<br>默认0.75。当hashMap中元素个数超过0.75*capacity的时候，就会启动自动扩容，每次扩容都会扩容为原来的两倍大小。  </p>
</li>
<li><p>散列冲突<br>链表法。会出现拉链过长的情况，影响HashMap的性能。<br>JDK1.8中，引入了红黑树，当链表长度太长（TREEIFY_THRESHOLD超过8且数组长度-哈希表容量MIN_TREEIFY_CAPACITY大于64）时，链表就转换为红黑树。当红黑树的结点个数小于6时（UNTREEIFY_THRESHOLD），会将红黑树转化为链表。避免频繁插入/删除导致数据结构频繁转换发生抖动。    </p>
</li>
<li><p>散列函数   </p>
<pre><code>
int hash(Object key) {
    int h = key.hashCode()；
    return (h ^ (h &gt;&gt;&gt; 16)) &amp; (capicity -1); //capicity表示散列表的大小
}

public int hashCode() {
  int var1 = this.hash;
  if(var1 == 0 &amp;&amp; this.value.length &gt; 0) {
    char[] var2 = this.value;
    for(int var3 = 0; var3 &lt; this.value.length; ++var3) {
      var1 = 31 * var1 + var2[var3];
    }
    this.hash = var1;
  }
  return var1;
}</code></pre><p>hashcode是32位整型值，4294967296，获取对象的hashcode后，先进行移位运算，再和自己做异或运算=&gt;hashcode ^ (hashcode &gt;&gt;&gt; 16)，将高16位移到16位，混合原哈希码的高位和低位，计算出来的整型值具有高位和低位的性质，并加大了低位的随机性。<br>用hash表当前的容量减一，再和计算出来的整型值做位于运算A % B = A &amp; (B - 1)，当B是2的指数时等式成立。即(h ^ (h &gt;&gt;&gt; 16)) &amp; (capitity -1) = (h ^ (h &gt;&gt;&gt; 16)) % capitity，即除留余数法保证位置分布均匀。</p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>散列表</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="贪心算法理解"><a href="#贪心算法理解" class="headerlink" title="贪心算法理解"></a>贪心算法理解</h3><ul>
<li>针对一组数据，定义了限制值和期望值，希望从中选出几个数据，在满足限制值的情况下，期望值最大。这类问题首先要联想到贪心算法。  </li>
<li>每次选择当前情况下，在对限制值同等共享量的情况下，对期望值贡献最大的数据。这种问题可以用贪心算法解决。  </li>
<li>举例验证贪心算法产生的结果是否是最优的。  </li>
</ul>
<p><strong>用贪心算法解决问题的思路，并不总能给出最优解。</strong>  </p>
<p>在一个有权图中，从顶点S开始，找一条到顶点T的最短路径（路径中边的权值和最小）。<br>贪心算法的解决思路是，每次都选择一条跟当前顶点相连的权最小的边，直到找到顶点T。前面的选择，会影响到后面的选择。即便第一步选择最优的走法（边最短），但有可能因为这一步选择，导致后面每一步的选择都很糟糕，最终也就无缘全局最优解了。  </p>
<h3 id="贪心算法实战"><a href="#贪心算法实战" class="headerlink" title="贪心算法实战"></a>贪心算法实战</h3><ol>
<li><p>分糖果<br>m个糖果分给n个孩子，m&lt;n。每个糖果的大小不等，每个孩子对糖果大小的需求也不一样，糖果大小需要&gt;=孩子对糖果大小的需求，最多能满足多少个孩子。  </p>
<p>从需求小的孩子开始分配糖果，然后每次从剩下的孩子中，找出对糖果大小需求最小的，然后发给他剩下的糖果中能满足他的最小的糖果，这样的分配方案是能满足的孩子个数最多的方案。  </p>
</li>
<li><p>钱币找零<br>不同面值的钱币，不同的张数，支付K元，最少需要多少张纸币。  </p>
<p>先用面值最大的来支付，如果不够，就继续用更小一点面值的，以此类推。  </p>
</li>
<li><p>区间覆盖<br>有n个区间，区间的起始端点和结束端点各不相同。从这n个区间中选出一部分区间，这部分区间满足两两不相交。最多能选出多少个区间。（任务调度、教师排课）  </p>
<p>每次选择的时候，左端点跟前面的已经覆盖的区间不重合的，右端点尽量小的，可以让剩下的未覆盖区间尽可能的打，就可以放置更多的区间。  </p>
</li>
</ol>
<h3 id="实现霍夫曼编码"><a href="#实现霍夫曼编码" class="headerlink" title="实现霍夫曼编码"></a>实现霍夫曼编码</h3><p>一个包含1000个字符的文件，每个字符占1个byte(1byte=8bits)，存储这个文件需要8000bits。  </p>
<p>1000个字符中质保函6中不同的字符，分别是a、b、c、d、e、f。三个二进制位（bit）就可以表示8个不同的字符，为了尽量减少存储空间，每个字符用3个二进制位来表示，存储这个文件只需要3000bits。  </p>
<blockquote>
<p>a(000)、b(001)、c(010)、d(011)、e(100)、f(101)  </p>
</blockquote>
<p><strong>霍夫曼编码思想</strong>：  </p>
<ul>
<li>霍夫曼编码不仅考察文本中有多少个不同字符，还会考察每个字符出现的频率，根据频率的不同选择不同长度的编码。霍夫曼编码用这种<strong>不等长的编码方法</strong>，来进一步增加压缩的效率。  </li>
<li>根据贪心的思想，可以把出现频率比较多的字符，用稍微短一些的编码；出现评率比较少的字符，用稍微长一些的编码。  </li>
<li>为了避免解压缩过程中的歧义，霍夫曼编码要求各个字符的编码之间，不会出现某个编码是另一个编码前缀的情况。在解压缩的时候，每次读取尽可能长的可解压的二进制串。  </li>
</ul>
<p><strong>霍夫曼编码实现：</strong>：</p>
<ul>
<li><p>把每个字符看做一个节点，并且辅带着把频率放到优先级队列中。从队列中取出频率最小的两个节点A、B，然后新建一个节点C，把频率设置为两个节点的频率之和，并把新节点C作为A、B的父节点，再把C节点翻入到优先级队列中，重复这个过程，直到队列中没有数据。<br>（构造的优先级队列根据频率的不同，各不相同，极端退化成近似链表的结构，除了最后一层都走一个叉，1、01、001、0001、00001、00000）  </p>
</li>
<li><p>给每一条边加上一个权值，指向左子节点的边标记为0，指向右子节点的边，标记为1，从根节点到叶子节点就是叶子节点对应字符的霍夫曼编码。<br>（最理想情况，完全二叉树00、01、10、11）</p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
        <tag>霍夫曼编码</tag>
        <tag>Huffman Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>分治算法</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>MapReduce、GFS(Google File System)、Bigtable是谷歌大数据处理的三驾马车。<br>MapReduce在倒排索引、PageRank计算、网页分析等搜索引擎相关的技术中有大量的应用。  </p>
<h3 id="分治算法理解"><a href="#分治算法理解" class="headerlink" title="分治算法理解"></a>分治算法理解</h3><p>分治算法的核心思想：分而治之。<br>将原问题划分成n个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后在合并其结果，得到原问题的解。  </p>
<p>分治算法是一种处理问题的思想，递归是一种编程技巧。分治算法一般都比较适合用递归来实现。  </p>
<ul>
<li>分解：将原问题分解成一系列子问题；  </li>
<li>解决：递归地求解各个子问题，若子问题足够小，则直接求解；  </li>
<li>合并：将子问题的结果合并成原问题。  </li>
</ul>
<p>前提条件：  </p>
<ul>
<li>原问题与分解成的小问题具有相同的模式；  </li>
<li>原问题分解成的子问题可以独立求解，子问题之间没有相关性；（分治算法与动态规划的区别）  </li>
<li>具有分解终止条件，当问题足够小时，可以直接求解；  </li>
<li>可以将子问题合并成原问题，合并操作的复杂度不高。  </li>
</ul>
<h3 id="分治算法编程应用"><a href="#分治算法编程应用" class="headerlink" title="分治算法编程应用"></a>分治算法编程应用</h3><p>排序中应用(二分、归并、快排)<br>有序度表示一组数据的有序程度，逆序度表示一组数据的无序程度。<br>n个数据从小到大排列，完全有序的数据（等差数列求和）的有序度就是n(n-1)/2，逆序度等于0；倒序排列的数据的有序度是0，逆序度是n(n-1)/2。<br>其余通过计算有序对/逆序对的个数，表示数据的有序度或逆序度。  </p>
<ul>
<li><p>拿每个数字跟它后面的数据比较，看有几个比它小的，把比它小的数字个数记作k，依次类推，对每个数字对应的k值求和，最后得到的总和就是逆序对个数。时间复杂度是O(n<sup>2</sup>)。  </p>
</li>
<li><p>套用分治的思想求数组的逆序对个数，将数组分成前后两半A1和A2，分别计算A1和A2的逆序对个数K1和K2，然后再计算A1与A2之间的逆序对个数K3。数组A的逆序对个数为K1+K2+K3。  </p>
<p>借助归并排序算法，将两个有序的小数组合并成一个有序的数组的过程中，每次合并操作都计算逆序对个数，把计算出来的逆序对个数求和，就是这个数组的逆序对个数。  </p>
  <div class='spoiler collapsed'>
    <div class='spoiler-title'>
        逆序度
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    num = <span class="number">0</span>;</span><br><span class="line">    mergeSortCounting(a,<span class="number">0</span>,n-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeSortCounting</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//中点</span></span><br><span class="line">    <span class="keyword">int</span> mid = (start+r=end)/<span class="number">2</span>;</span><br><span class="line">    mergeSortCounting(a,start,mid);</span><br><span class="line">    mergeSortCounting(a,mid+<span class="number">1</span>,end);</span><br><span class="line">    <span class="comment">//合并函数</span></span><br><span class="line">    mergeSort(a,start,mid,end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//临时数组，大小为当前分区的大小</span></span><br><span class="line">    <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[right-left+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = left;<span class="comment">//左边起始下标</span></span><br><span class="line">    <span class="keyword">int</span> j = mid+<span class="number">1</span>;<span class="comment">//右边起始下标</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">        <span class="comment">//取左右区间中元素最小值放入当前位置</span></span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt;= a[j]) &#123;</span><br><span class="line">            tmp[k++] = a[i++]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//统计左区间left-mid之间，比右区间当前元素a[j]大的元素个数</span></span><br><span class="line">            num += (mid-i+<span class="number">1</span>);</span><br><span class="line">            tmp[k++] = a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理左区间剩下的</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) &#123;</span><br><span class="line">        tmp[k++] = a[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理右区间剩下的</span></span><br><span class="line">    <span class="keyword">while</span>(j &lt;= right) &#123;</span><br><span class="line">        tmp[k++] = a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从tmp拷贝回原数组a对应区间</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= right-left+<span class="number">1</span>; i++) &#123;</span><br><span class="line">        a[left+i] = tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

</li>
</ul>
<h3 id="分治算法处理海量数据"><a href="#分治算法处理海量数据" class="headerlink" title="分治算法处理海量数据"></a>分治算法处理海量数据</h3><p>利用分治的思想解决数据量大到内存装不下的问题。  </p>
<p>将海量数据集合根据某种方法，划分为几个小的数据集合，每个小的数据集合单独加载到内存来解决，然后再将小数据集合合并成大数据集合。  </p>
<p>利用这种分治的处理思路，能克服内存的限制，还能利用多线程或者多机处理，加快处理的速度。  </p>
<p>MapReduce框架只是一个任务调度器，底层依赖GFS来存储数据，依赖Borg管理及其。从GFS中拿数据，交给Borg中的机器执行，时刻监控机器执行状态并调度。<br>可以处理数据与数据之间存在关系的任务-统计文件中单词出现频率<br>可以处理数据与数据之间没有关系的任务-网页分析、分词  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>分治算法</tag>
        <tag>MapRedue</tag>
      </tags>
  </entry>
  <entry>
    <title>图</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/</url>
    <content><![CDATA[<h3 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h3><p>图是比树更加复杂的非线性表结构。适合存储微博、微信等社交网络中的好友关系。<br><strong>顶点</strong>：图中的元素；用户<br><strong>边</strong>：顶点与任意其它顶点之间的连接关系；好友关系<br><strong>度</strong>：顶点相连接的边的条数；好友个数<br><strong>有向图</strong>：带箭头的边，表示边的方向，有方向的图；关注关系<br><strong>无向图</strong>：边没有方向的图；好友关系<br><strong>度</strong>：无向图中表示一个顶点有多少条边；好友个数<br><strong>入度</strong>：有向图中，表示有多少条边指向这个顶点；粉丝个数<br><strong>出度</strong>：有向图中，表示有多少条边是以这个顶点为起点指向其他顶点；关注人数<br><strong>带权图</strong>：每条边都有一个权重。亲密度  </p>
<h3 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h3><ul>
<li><p>邻接矩阵<br>邻接矩阵-二维数组。<br>无向图，如果顶点i与顶点j之间有边，就将A[i][j]和A[j][i]标记为1；浪费一半的存储空间；<br>有向图，如果顶点i到j之间，有一条箭头从顶点i指向顶点j的边，就将A[i][j]标记为1。如果有一条箭头从顶点j指向顶点i的边，就将A[j][i]标记为1。<br>带权图，数组中就存储相应的权重。<br>稀疏图，顶点很多，但每个顶点的边不多，邻接矩阵的存储方法更加浪费。</p>
<p>优点：<br>存储方式简单、直接，获取顶点关系高效，图计算-矩阵计算方便。</p>
</li>
<li><p>邻接表<br>邻接表-散列表<br>无向图每个顶点对应一条链表，链表中存储的是与这个顶点相连接的其他顶点。<br>有向图，每个顶点对应的链表里，存储其指向的顶点。  </p>
<p>优化；<br>顶点中的链表转换成平衡二叉查找树、红黑树、跳表、散列表、有序动态数组(二分查找)。  </p>
</li>
</ul>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ol>
<li><p>微博-有向图<br>微博操作：  </p>
<ul>
<li>判断用户A是否关注用户B  </li>
<li>判断用户A是否被用户B的关注  </li>
<li>用户A关注用户B  </li>
<li>用户A取消关注用户B  </li>
<li>根据用户名称的首字母排序，分页获取用户的粉丝列表  </li>
<li>根据用户名称的首字母排序，分页获取用户的关注列表  </li>
</ul>
<p>社交关系存储：  </p>
<ul>
<li>内存（数据量大用哈希算法将数据分片）<br>邻接表，存储用户关注了哪些用户；每个顶点的链表中，存储这个顶点指向的顶点。<br>逆邻接表，存储用户被哪些用户关注；每个顶点的链表中，存储指向这个顶点的顶点。  </li>
<li>硬盘<br>两列表。一列用户id，一列关注id。分别建立索引。  </li>
</ul>
</li>
<li><p>微信-无向图<br>微信操作：  </p>
<ul>
<li>判断A、B是否为好友关系  </li>
<li>A删除B，断开与B的好友关系  </li>
<li>展示出A的好友列表，并按名称首字母排序  </li>
</ul>
<p>社交关系存储：  </p>
<ul>
<li>邻接表存储每个人对应的好友列表，好友列表可用红黑树/跳表存储</li>
</ul>
</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>深度优先&amp;广度优先</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88&amp;%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88/</url>
    <content><![CDATA[<p>在社交网络中，通过用户之间的连接关系，可以实现推荐“可能认识的人”的功能。  </p>
<h3 id="“搜索”算法"><a href="#“搜索”算法" class="headerlink" title="“搜索”算法"></a>“搜索”算法</h3><p>大部分涉及搜索的场景都可以抽象成图，深度优先算法和广度优先算法都是基于图这种表达能力很强的数据结构。<br>在图中找出从一个顶点出发，到另一个顶点的路径。简单暴力的深度优先、广度优先；启发式的A<em>、IDA</em>。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        图
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无向图</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="comment">//顶点的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> v;</span><br><span class="line">    <span class="comment">//邻接表（声明一个存储LinkedList链表类型的数组）</span></span><br><span class="line">    <span class="comment">//保存每个顶点的邻接链表</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; adj[];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.v = v;</span><br><span class="line">        adj = <span class="keyword">new</span> LinkedList[v];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;v; i++) &#123;</span><br><span class="line">            adj[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//无向图一条边存两次</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        adj[s].add(t);</span><br><span class="line">        adj[t].add(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<h3 id="广度优先BFS"><a href="#广度优先BFS" class="headerlink" title="广度优先BFS"></a>广度优先BFS</h3><p>类似二叉树按层遍历。  </p>
<p>广度优先搜索Breadth-First-Search，是一种地毯式层层推进的搜索策略，先查找离起始顶点最近的，然后是次近的，依次往外搜索。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        广度优先搜索-借助队列实现
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == t) </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//记录已经被访问的顶点，避免顶点被重复访问，布尔值默认为false</span></span><br><span class="line">    <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[v];</span><br><span class="line">    visited[s] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//存储已经被访问，但是相连的顶点还没有被访问的顶点</span></span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(s);</span><br><span class="line">    <span class="comment">//记录搜索路径（路径最大为v,找到t就可以直接返回）</span></span><br><span class="line">    <span class="keyword">int</span>[] prev = <span class="keyword">new</span> <span class="keyword">int</span>[v];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; i++) &#123;</span><br><span class="line">        prev[i] = -<span class="number">1</span>;<span class="comment">//-1初始化路径</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(queue.size() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//弹出当前顶点</span></span><br><span class="line">        <span class="keyword">int</span> w = queue.poll();</span><br><span class="line">        <span class="comment">//遍历当前顶点的邻接顶点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj[w].size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> q = adj[w].get(i);</span><br><span class="line">            <span class="keyword">if</span>(!visited[q]) &#123;</span><br><span class="line">                <span class="comment">//将当前顶点存入当前邻接顶点的访问路径</span></span><br><span class="line">                prev[q] = w;</span><br><span class="line">                <span class="keyword">if</span>(q == t) &#123;</span><br><span class="line">                    print(prev,s,t);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//当前邻接顶点标记为已访问</span></span><br><span class="line">                visited[q] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//当前邻接顶点入队</span></span><br><span class="line">                queue.add(q);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归打印s-&gt;t的路径</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[] prev, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prev[t] != -<span class="number">1</span> &amp;&amp; t != s) &#123;</span><br><span class="line">        print(prev,s,prev[t]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.print(t + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  
<p><strong>visited</strong>记录已经被访问的顶点，避免顶点被重读访问。<br>如果顶点q被访问，那相应的visited[q]会被设置为true。  </p>
<p><strong>queue</strong>用队列存储已经被访问、但相连的顶点还没有被访问的顶点。<br>只有把k层的顶点都访问完成之后，才能访问第k+1层的顶点。当访问到第k层的顶点时，需要把第k层的顶点记录下来，稍后才能通过第k层的顶点来找第k+1层的顶点。  </p>
<p><strong>prev</strong>记录搜索路径。<br>从顶点s开始，广度优先搜索到顶点t后，prev数组中存储的就是搜索的路径。<br>路径是反向存储的。prev[w]存储的是，顶点w是从哪个前驱顶点遍历过来的。需要递归来打印出正向的路径。  </p>
<p>最坏情况下，终止顶点t离起始顶点s很远，需要遍历完整个图才能找到。每个顶点都要进出一遍队列，每个边都会被访问依次，广度优选搜索的时间复杂度是O(V+E)，V表示顶点的个数，E表示边的个数。<br>对一个连通图来说，图中的所有顶点都是连通的，E&gt;=V-1，广度优先搜索的<strong>时间复杂度</strong>简化为O(E)。<br>广度优先搜索的空间消耗主要在几个辅助变量visited数组、queue队列、prev数组上。存储空间的大小都不会超过顶点的个数，整体<strong>空间复杂度</strong>为O(V)。  </p>
<h3 id="深度优先DFS"><a href="#深度优先DFS" class="headerlink" title="深度优先DFS"></a>深度优先DFS</h3><p>类似二叉树前序遍历。  </p>
<p>深度优先搜索Depth-First-Search，使用回溯思想，解决问题的过程适合用递归来实现。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        深度优先搜索-借助栈实现
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局变量，当找到终止顶点之后，不再递归地继续查找</span></span><br><span class="line"><span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    found = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[v];</span><br><span class="line">    <span class="keyword">int</span>[] prev = <span class="keyword">new</span> <span class="keyword">int</span>[v]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; i++) &#123;</span><br><span class="line">        prev[i] = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    recurDfs(s,t,visited,prev);</span><br><span class="line">    print(prev,s,t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recurDfs</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> t, <span class="keyword">boolean</span>[] visited, <span class="keyword">int</span>[] prev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(found == <span class="keyword">true</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//标记当前顶点为已访问</span></span><br><span class="line">    visited[w] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(w == t) &#123;</span><br><span class="line">        found = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历当前顶点的邻接顶点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj[w].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(found == <span class="keyword">true</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> q = adj[w].get(i);</span><br><span class="line">        <span class="comment">//只递归未被访问的顶点</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[q]) &#123;</span><br><span class="line">            <span class="comment">//将当前顶点记录在当前邻接顶点的访问路径</span></span><br><span class="line">            prev[q] = w;</span><br><span class="line">            <span class="comment">//递归当前邻接顶点</span></span><br><span class="line">            recurDfs(q,r,visited,prev);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  
<p><strong>prev和visited中元素下标与元素值一致。prev[]</strong>  </p>
<p>每条边最多会被访问两次，一次是遍历，一次是回退，深度优先搜索算法的时间复杂度是O(E)，E表示边的个数。  </p>
<p>深度优先搜索算法的内存消耗主要是visited、prev数组和递归调用栈。vixited、prev数组的大小跟顶点的个数V成正比，递归调用栈的最大深度不会超过顶点的个数，整体空间复杂度是O(V)。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>图的搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>初识动态规划</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%9D%E8%AF%86%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p>动态规划可以非常显著的降低时间复杂度，提高代码的执行效率。  </p>
<h3 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h3><p>对于一组不同重量、不可分割的物品，选择一些装入背包，在满足背包最大重量限制的前提下，背包中物品总重量的最大值。  </p>
<ol>
<li><p>回溯算法<br>穷举所有可能的装法，然后找出 满足条件的最大值。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        0-1背包 回溯算法
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxW = Integer.MIN_VALUE;</span><br><span class="line"><span class="comment">//物品重量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] weight = &#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">//物品个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="comment">//背包承受的最大重量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> w = <span class="number">9</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> cw)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//cw == w表示装满了，i == n表示物品考察完了</span></span><br><span class="line">    <span class="keyword">if</span>(cw == w || i == n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cw &gt; maxW) maxW = cw;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f(i+<span class="number">1</span>, cw);<span class="comment">//不装第i个物品</span></span><br><span class="line">    <span class="keyword">if</span>(cw + wight[i] &lt;= w) &#123;</span><br><span class="line">        <span class="comment">//装第i个物品</span></span><br><span class="line">        f(i+<span class="number">1</span>, cw + weight[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p>将回溯求解过程转换为递归树<br>树中的每个节点表示一种状态，用(i,cw)表示。i表示将要决策第几个物品是否装入背包，cw表示当前背包中物品的总重量。<br>在递归树中，有些子问题的求解是重复的，可以借助递归中的备忘录的解决方式，记录已经计算好的f(i,cw)，当再次计算到重复的f(i,cw)时，直接从备忘录中取出来，避免冗余计算。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        0-1背包 回溯算法+备忘录
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxW = Integer.MIN_VALUE;</span><br><span class="line"><span class="comment">//物品重量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] weight = &#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">//物品个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="comment">//背包承受的最大重量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> w = <span class="number">9</span>;</span><br><span class="line"><span class="comment">//备忘录，默认值false</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[][] mem = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">5</span>][<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> cw)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//cw == w表示装满了，i == n表示物品考察完了</span></span><br><span class="line">    <span class="keyword">if</span>(cw == w || i == n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cw &gt; maxW) maxW = cw;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mem[i][cw]) <span class="keyword">return</span>;<span class="comment">//重复状态</span></span><br><span class="line">    mem[i][cw] = <span class="keyword">true</span>;<span class="comment">//标记（i,cw）这个状态</span></span><br><span class="line">    f(i+<span class="number">1</span>, cw);<span class="comment">//不装第i个物品</span></span><br><span class="line">    <span class="keyword">if</span>(cw + wight[i] &lt;= w) &#123;</span><br><span class="line">        <span class="comment">//装第i个物品</span></span><br><span class="line">        f(i+<span class="number">1</span>, cw + weight[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p>回溯算法解决问题的时间复杂度是O(2<sup>n</sup>)，是指数级的。  </p>
</li>
<li><p>动态规划<br>把整个求解过程分为多个阶段，每个阶段对应一个决策，记录每一阶段可达的状态集合（去掉重复的），通过当前阶段的状态集合，来推导下一阶段的状态集合，动态的往前推进。  </p>
<blockquote>
<p>对应背包问题，把整个求解过程分为n个阶段，每个阶段会决策一个物品是否放到背包中。每个物品决策完之后，背包中的物品的重量会有多种情况，达到多种不同的状态，对应到递归树中，就是很多不同的节点。<br>把每一层重复的状态（节点）合并，只记录不同的状态，然后基于上一层的状态集合，来推导下一层的状态集合。动态的往前推进。  </p>
</blockquote>
<p>通过合并每一层重复的状态，这样保证每一层不同状态的个数都不会超过w个(如背包的承载重量w)，成功避免了每层状态个数的指数级增长。  </p>
<p>最终，只需要在最后一层找一个值为true的最接近w的值，就是背包中物品总重量的最大值。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        0-1背包 动态规划
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//wight物品重量</span></span><br><span class="line"><span class="comment">//n物品个数</span></span><br><span class="line"><span class="comment">//w背包可承载重量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span>[] weight, <span class="keyword">int</span> n, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[][] states = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][w+<span class="number">1</span>];<span class="comment">//默认值false</span></span><br><span class="line">    <span class="comment">//哨兵特殊处理第一行的数据</span></span><br><span class="line">    states[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(weight[<span class="number">0</span>] &lt;= w) &#123;</span><br><span class="line">        states[<span class="number">0</span>][weight[<span class="number">0</span>]] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//动态规划状态转移</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment">//不把第i个物品放入背包</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= w; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(states[i-<span class="number">1</span>][j] == <span class="keyword">true</span>) &#123;</span><br><span class="line">                states[i][j] = states[i-<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把第i个物品放入背包</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= w-weight[i]; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(states[i-<span class="number">1</span>][j]==<span class="keyword">true</span>) &#123;</span><br><span class="line">                states[i][j+weight[i]] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出结果</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = w; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(states[n-<span class="number">1</span>][i] == <span class="keyword">true</span>) </span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p>动态规划代码中，耗时最多的部分就是代码中的两层for循环，时间复杂度是O(n*w)。n表示物品个数，w表示背包可以承载的总重量。<br>代码中，需要额外申请一个n乘以w+1的二维数组，对空间的消耗比较多。动态规划是一种空间换时间的解决思路。  </p>
<p>一维数组优化,只记录当前层选择后的最终结果，节省空间，但是无法倒推放入了哪些物品。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        0-1背包 动态规划-一维数组
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span>[] items, <span class="keyword">int</span> n, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] states = <span class="keyword">new</span> <span class="keyword">boolean</span>[w+<span class="number">1</span>];<span class="comment">//默认值false</span></span><br><span class="line">    <span class="comment">//哨兵特殊处理第一行数据</span></span><br><span class="line">    states[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(items[<span class="number">0</span>] &lt;= w) &#123;</span><br><span class="line">        states[items[<span class="number">0</span>]] =<span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//动态规划</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = w-items[i]; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(states[j] == <span class="keyword">true</span>)</span><br><span class="line">                states[j+items[i]] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出结果，最大重量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = w; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(states[i] == <span class="keyword">true</span>)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p>j从大到小处理，避免for循环重复计算的问题。  </p>
<blockquote>
<p>比如 j = 0, item[i] = 5, w=10，如果正向循环，j=0 时会设置 state[5] = true, 而当遍历至 j=5时，由于 state[5]=true，会设置 state[10] = true，但是实际上将 5 这个重量使用了两次，所以导致了重量的重复使用。  </p>
</blockquote>
</li>
</ol>
<h3 id="0-1背包问题升级版"><a href="#0-1背包问题升级版" class="headerlink" title="0-1背包问题升级版"></a>0-1背包问题升级版</h3><p>引入物品价值变量。<br>对于一组不同重量、不同价值、不可分割的物品，选择将某些物品装入背包，在满足背包最大重量限制的前提下，背包中可装入物品的总价值的最大值。  </p>
<ol>
<li><p>回溯算法  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        0-1背包升级版 回溯算法
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxV = Integer.MIN_VALUE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] items = &#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] value = &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> w = <span class="number">9</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> cw, <span class="keyword">int</span> cv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cw == w || i == n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cv &gt; maxV) &#123;</span><br><span class="line">            maxV = cv;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f(i+<span class="number">1</span>,cw,cv);</span><br><span class="line">    <span class="keyword">if</span>(cw+weight[i] &lt;= w) &#123;</span><br><span class="line">        f(i+<span class="number">1</span>, cw+weight[i], cv+value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p>递归树：<br>在递归树中，每个节点表示一个状态。用三个变量(i,cw,cv)表示一个状态，其中i表示即将要决策第i个物品是否装入背包，cw表示当前背包中物品的总重量，cv表示当前背包中物品的总价值。<br>在递归树中，有些节点的i和cw是完全相同的，在背包中物品总重量一样的情况下，某种状态对应的物品总价值更大，可以舍弃同种状态价值小的状态，沿着价值大的决策路线继续往下决策。<br>对于(i，cw)相同的不同状态，只需要保留cv值最大的状态，继续递归处理，其他状态不予考虑。  </p>
</li>
<li><p>动态规划<br>把整个求解过程分为n个阶段，每个阶段决策一个物品是否放入背包中。每个阶段决策之后，背包中的物品的总重量以及总价值会有多种情况。<br>用一个二维数组states[n][w+1]，来记录每层可以达到的不同状态，数组中存储的是当前状态对应的最大总价值。把每一层中(i,cw)重复的状态节点合并，只记录cv值最大的那个状态，然后基于这些状态来推导下一层的状态。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        0-1背包升级版 动态规划
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span>[] weight, <span class="keyword">int</span>[] value, <span class="keyword">int</span> n, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//n个物品，w+1种重量</span></span><br><span class="line">    <span class="keyword">int</span>[][] states = <span class="keyword">new</span> <span class="keyword">int</span>[n][w+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//初始化states</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;w+<span class="number">1</span>; ++j) &#123;</span><br><span class="line">            states[i][j] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第一行数据特殊处理</span></span><br><span class="line">    states[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(weight[<span class="number">0</span>] &lt;= w) &#123;</span><br><span class="line">        states[<span class="number">0</span>][weight[<span class="number">0</span>]] = value[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//动态规划，状态转移</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; ++i) &#123;</span><br><span class="line">        <span class="comment">//不选择第i个物品，上一行该列的状态转移导致本行该列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=w; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(states[i-<span class="number">1</span>][j] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                states[i][j] = states[i-<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//选择第i个物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=w-weight[i]; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(states[i-<span class="number">1</span>][j] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = states[i-<span class="number">1</span>][j] + value[i];</span><br><span class="line">                <span class="keyword">if</span>(v &gt; states[i][j+weight[i]]) &#123;</span><br><span class="line">                    states[i][j+weight[i]] = v;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找到最大值,必定在最后一行</span></span><br><span class="line">    <span class="keyword">int</span> maxvalue = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=w; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span>(states[n-<span class="number">1</span>][j] &gt; maxvalue) &#123;</span><br><span class="line">            maxvalue = states[n-<span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxvalue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p>时间复杂度为O(n*w),空间复杂度O(n*w)。  </p>
</li>
</ol>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>大部分动态规划能解决的问题，都可以通过回溯算法来解决。<br>回溯算法解决起来效率比较低，时间复杂度是指数级的。<br>动态规划在执行效率方面高很多，但是空间复杂度也提高了。<br>动态规划是一种空间换时间的算法思想。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>0-1背包</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><p>每个元素代表一个结点，相邻节点之间的连线关系，称为父子关系。<br>父节点<br>子节点<br>兄弟节点：节点的父节点是同一个节点<br>根节点：没有父节点的节点<br>叶子节点/叶节点：没有子节点的节点  </p>
<p>节点的高度=节点到叶子节点的最长路径(边数)。起点是0，从下往上<br>节点的深度=根节点到这个所经历的边的个数。起点是0，从上往下<br>节点的层数=节点的深度+1。起点是1，从上往下<br>树的高度=根节点的高度  </p>
<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>每个节点最多有两个叉-两个子节点，分别是左子节点和右子节点。但不要求每个节点都有两个子节点，有的节点只有左子节点，有的节点只有右子节点。<br>满二叉树：叶子节点全部在最底层，除叶子节点之外，每个节点都有左右两个子节点。<br>完全二叉树：叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其它层的节点个数都要达到最大。  </p>
<h4 id="存储-表示一棵二叉树"><a href="#存储-表示一棵二叉树" class="headerlink" title="存储/表示一棵二叉树"></a>存储/表示一棵二叉树</h4><ol>
<li>基于指针或者引用的二叉链式存储法<br>每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针。只要拎住根节点，就可以通过左右子节点的指针，把整棵树都串起来。  </li>
<li>基于数组的顺序存储法<br>把根节点存储在下标i=1的位置，左子节点存储在下标2<em>i=2的位置，右子节点存储在2</em>i+1=3的位置。以此类推。<br>如果节点X存储在数据中下标为i的位置，下标为i<em>2的位置存储的就是左子节点，下标为2</em>i+1的位置存储的就是右子节点。反过来，下标为i/2的位置存储的是它的父节点。只要知道根节点存储的位置(一般为下标为1的位置，便于计算)，可以通过下标计算，把整棵树都串起来。<br>完全二叉树，仅仅浪费了一个下标为0的存储位置，如果是非完全二叉树，会浪费比较多的数组存储空间。如果某棵二叉树是完全二叉树，那用数组存储无疑是最节省内存的一种方式。(堆-完全二叉树)  </li>
</ol>
<h4 id="遍历二叉树-递归1"><a href="#遍历二叉树-递归1" class="headerlink" title="遍历二叉树-递归1"></a>遍历二叉树-递归<a href="#refer-anchor-1"><sup>1</sup></a></h4><ol>
<li><p>前序遍历<br>对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。  </p>
</li>
<li><p>中序遍历<br>对于树中的任意节点来说，先打印它的左子树，再打印它本身，最后打印它的右子树。  </p>
</li>
<li><p>后序遍历<br>对于树中的任意节点来说，先打印它的左子树，再打印它的右子树，最后打印这个节点本身。  </p>
<p> 递推公式：  </p>
 <figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">前序遍历  </span><br><span class="line">preOrder<span class="function"><span class="params">(r)</span> = <span class="title">print</span> <span class="title">r</span> -&gt;</span> preOrder<span class="function"><span class="params">(r-&gt;left)</span> -&gt;</span> preOrder(r-&gt;right)  </span><br><span class="line">中序遍历  </span><br><span class="line">inOrder<span class="function"><span class="params">(r)</span> = <span class="title">inOrder</span><span class="params">(r-&gt;left)</span> -&gt;</span> <span class="built_in">print</span> r<span class="function"> -&gt;</span> inOrder(r-&gt;right)  </span><br><span class="line">后序遍历  </span><br><span class="line">postOrder<span class="function"><span class="params">(r)</span> = <span class="title">postOrder</span><span class="params">(r-&gt;left)</span> -&gt;</span> postOrder<span class="function"><span class="params">(r-&gt;right)</span> -&gt;</span> <span class="built_in">print</span> r</span><br></pre></td></tr></table></figure>

<p> 伪代码：  </p>
 <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line">void pre<span class="constructor">Order(Node<span class="operator">*</span> <span class="params">root</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root<span class="operator"> == </span>null) return;</span><br><span class="line">    print root;</span><br><span class="line">    pre<span class="constructor">Order(<span class="params">root</span> -&gt; <span class="params">left</span>)</span>;</span><br><span class="line">    pre<span class="constructor">Order(<span class="params">root</span> -&gt; <span class="params">right</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line">void <span class="keyword">in</span><span class="constructor">Order(Node<span class="operator">*</span> <span class="params">root</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root<span class="operator"> == </span>null) return;</span><br><span class="line">    <span class="keyword">in</span><span class="constructor">Order(<span class="params">root</span> -&gt; <span class="params">left</span>)</span>;</span><br><span class="line">    print root;</span><br><span class="line">    <span class="keyword">in</span><span class="constructor">Order(<span class="params">root</span> -&gt; <span class="params">right</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line">void post<span class="constructor">Order(Node<span class="operator">*</span> <span class="params">root</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root<span class="operator"> == </span>null) return;</span><br><span class="line">    post<span class="constructor">Order(<span class="params">root</span> -&gt; <span class="params">left</span>)</span>;</span><br><span class="line">    post<span class="constructor">Order(<span class="params">root</span> -&gt; <span class="params">right</span>)</span>;</span><br><span class="line">    print root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>按层遍历<br>借助队列辅助：根节点先入队列，队列不为空，取出对头元素，如果左子存在就入队列，否则什么也不做，如果右子同理，直到队列为空，表示树层次遍历结束。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        按层遍历
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(T x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;TreeNode&gt; <span class="title">floorlevelOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;TreeNode&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//利用队列先进先出的特点实现按层遍历</span></span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">//根节点入队</span></span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="comment">//从队列中弹出各结点数据，直到队列为空，遍历完毕</span></span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//弹出队首元素，放入结果集。并依次将其左右子节点入队(如果存在的话)，进行下一轮循环</span></span><br><span class="line">        TreeNode node = queue.poll();</span><br><span class="line">        result.add(node);</span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>  

</li>
</ol>
<h4 id="二叉树遍历时间复杂度"><a href="#二叉树遍历时间复杂度" class="headerlink" title="二叉树遍历时间复杂度"></a>二叉树遍历时间复杂度</h4><p>每个节点最多会被访问两次，遍历操作的时间复杂度跟节点的个数n成正比，时间复杂度为O(n)。  </p>
<h4 id="参考-amp-扩展"><a href="#参考-amp-扩展" class="headerlink" title="参考&amp;扩展"></a>参考&amp;扩展</h4><div id="refer-anchor-1"></div>

<ul>
<li>[1] <a href="https://mp.weixin.qq.com/s/0b5OsnFLLg18Td4CuR51_Q" target="_blank" rel="noopener">一篇总结二叉树的4种遍历方式（含模板）</a> </li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯算法</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>深度优先搜索利用的是回溯算法思想。<br>回溯算法大部分情况下都是用来解决广义的搜索问题：从一组可能的解中，选出一个满足要求的解。  </p>
<p>回溯算法非常适合用递归来实现，在实现的过程中，剪枝操作是提高回溯效率的一种技巧，利用剪枝，并不需要穷举搜索所有的情况，从未提高搜索效率。  </p>
<h3 id="回溯算法理解"><a href="#回溯算法理解" class="headerlink" title="回溯算法理解"></a>回溯算法理解</h3><p>对比贪心算法，在每次面对岔路口的时候，都做出看起来最优的选择，期望这一组选择是最终的最优解。但是贪心算法并不一定能得到最优解。  </p>
<p>回溯的处理思想，类似枚举搜索。枚举所有的解，找到满足期望的解。为了有规律的枚举所有可能的解，避免遗漏和重复，把问题求解的过程分为多个阶段。每个阶段都有会面对一个岔路口，先随意选一条路走，当发现这条路走不通的时候（不符合期望的解），就退回到上一个岔路口，另选一种走法继续走。  </p>
<h3 id="回溯算法应用"><a href="#回溯算法应用" class="headerlink" title="回溯算法应用"></a>回溯算法应用</h3><p><strong>八皇后问题</strong><a href="#refer-anchor-1"><sup>1</sup></a>  <span id="back-1"></span></p>
<p>有一个8X8的棋盘，希望往里放8个棋子（皇后），每个棋子所在的行、列、对角线都不能有另一个棋子。  </p>
<p>把这个问题分成8个阶段，依次将8个棋子放到第一行、第二行、第三行…第八行。在放置的过程中，不停地检查当前放法，是否满足要求。如果满足，则跳到下一行继续放置棋子；如果不满足，那就再换一种放法，继续尝试。<a href="#refer-anchor-2"><sup>2</sup></a>  <span id="back-2"></span>  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        八皇后
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局变量，下标表示行，值表示queen存在哪一列</span></span><br><span class="line"><span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>];</span><br><span class="line"><span class="comment">//记录目前是第几种解法</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//调用：cal8queens(0)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cal8queens</span><span class="params">(<span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//8个棋子都放置好了，打印结果</span></span><br><span class="line">    <span class="keyword">if</span>(row == <span class="number">8</span>) &#123;</span><br><span class="line">        printQueens(result);</span><br><span class="line">        <span class="comment">//8行棋子都放好了，已经无法再往下递归</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//每一行都有8种放法</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; <span class="number">8</span>; ++column) &#123;</span><br><span class="line">        <span class="comment">//有些放法不满足要求</span></span><br><span class="line">        <span class="keyword">if</span>(isOk(row,column)) &#123;</span><br><span class="line">            <span class="comment">//第row行的棋子放到了column列</span></span><br><span class="line">            result[row] = column;</span><br><span class="line">            <span class="comment">//考察下一行</span></span><br><span class="line">            cal8queens(row + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断row行column列放置是否合适</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isOk</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> column)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当前的左上和右上</span></span><br><span class="line">    <span class="keyword">int</span> leftup = column - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> rightup = column + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//逐行往上考察每一行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = row - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="comment">//1、第i行的column列有棋子么</span></span><br><span class="line">        <span class="keyword">if</span>(result[i] == column) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//2、考察左上对角线，第i行的leftup列有棋子么</span></span><br><span class="line">        <span class="keyword">if</span>(leftup &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(result[i] == leftup) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3、考察右上对角线，第i行rightup列有棋子么</span></span><br><span class="line">        <span class="keyword">if</span>(rightup &lt; <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(result[i] == rightup) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//行互减的绝对值等于列互减的绝对值</span></span><br><span class="line">        --leftup;</span><br><span class="line">        ++rightup;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印一个二维矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printQueens</span><span class="params">(<span class="keyword">int</span>[] result)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"第"</span> + ++count + <span class="string">"种解法："</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; <span class="number">8</span>; ++row) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; <span class="number">8</span>; ++column) &#123;</span><br><span class="line">            <span class="keyword">if</span>(result[row] == column)</span><br><span class="line">                System.out.print(<span class="string">"Q "</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                System.out.print(<span class="string">"* "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p><strong>0-1背包</strong><br>动态规划<br>回溯算法<br>一个背包，背包总的承载重量是Wkg。现在有n个物品，每个物品的重量不等，并且不可分割。期望选择几件物品，装载到背包中，在不超过背包所能装载重量的前提下，让背包中物品的总重量最大。  </p>
<p>对于每个物品来说，都有两种选择，装进背包或者不装进背包。对于n各物品来说，总的装法就有2<sup>n</sup>种，去掉总重量超过Wkg的，从剩下的装法中选择总重量最接近Wkg的。<br>把物品依次排列，整个问题就分解成了n个阶段，每个阶段对应一个物品怎么选择，先对第一个物品进行处理，选择装进去或者不装进去，然后再递归地处理剩下的物品。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        0-1背包
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//存储背包中物品总重量的最大值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> maxW = Integer.MIN_VALUE;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* cw表示当前已经装进去的物品的重量综合；</span></span><br><span class="line"><span class="comment">* i表示考察到哪个物品了；</span></span><br><span class="line"><span class="comment">* w背包重量；</span></span><br><span class="line"><span class="comment">* items表示每个物品的重量；</span></span><br><span class="line"><span class="comment">* n表示物品个数；</span></span><br><span class="line"><span class="comment">* 假设背包可承受重量100，物品个数10，物品重量存储在数组a中，调用方法 f(0,0,a,10,100)</span></span><br><span class="line"><span class="comment">* 借助递归回到上一个状态，装或者不装都只影响递归调用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f01</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> cw, <span class="keyword">int</span>[] items, <span class="keyword">int</span> n, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//cw==w表示装满了；i==n表示已考察完所有的物品</span></span><br><span class="line">        <span class="keyword">if</span>(cw == w || i == n) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cw &gt; maxW)</span><br><span class="line">                maxW = cw;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前物品不装进背包，考虑下一个时（i+1），cw不更新</span></span><br><span class="line">        f01(i+<span class="number">1</span>,cw,items,n,w);</span><br><span class="line">        <span class="keyword">if</span>(cw + items[i] &lt;= w) &#123;</span><br><span class="line">            <span class="comment">//当前物品装进背包，考虑下一个时（i+1），cw通过入参更新为cw+items[i]</span></span><br><span class="line">            f01(i+<span class="number">1</span>,cw+items[i],items,n,w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<p>变体：每个物品重量不同，价值不同，在不超过背包重量的情况下，让背包中的总价值最大。</p>
<p><strong>正则表达式</strong><br>背景假设，正则表达式中只包含“<em>”和“？”这两种通配符，其中“</em>”匹配任意多个（&gt;=0个）任意字符，“？”匹配另个或者一个任意字符。  </p>
<p>依次考察正则表达式中的每个字符，当是非通配符时，就直接跟文本的字符进行匹配，如果相同，则继续往下处理；如果不同，则回溯。<br>如果遇到特殊字符的时候，也就是岔路口，“*”，先随意的选择一种匹配方案，然后继续考察剩下的字符，如果中途发现无法继续匹配下去，就回溯到岔路口，重新选择一种匹配方案，然后再继续匹配剩下的字符。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        正则表达式
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pattern</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> matched = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//正则表达式</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">char</span>[] pattern;</span><br><span class="line">        <span class="comment">//正则表达式长度</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> plen;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Pattern</span><span class="params">(<span class="keyword">char</span>[] pattern,<span class="keyword">int</span> plen)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.pattern = pattern;</span><br><span class="line">            <span class="keyword">this</span>.plen = plen;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//文本串及长度</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>[] text, <span class="keyword">int</span> tlen)</span> </span>&#123;</span><br><span class="line">            matched = <span class="keyword">false</span>;</span><br><span class="line">            rmatch(<span class="number">0</span>,<span class="number">0</span>,text,tlen);</span><br><span class="line">            <span class="keyword">return</span> matched;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rmatch</span><span class="params">(<span class="keyword">int</span> ti, <span class="keyword">int</span> pj, <span class="keyword">char</span>[] text, <span class="keyword">int</span> tlen)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//已经匹配了，不用继续递归</span></span><br><span class="line">            <span class="keyword">if</span>(matched) <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">//正则表达式结束</span></span><br><span class="line">            <span class="keyword">if</span>(pj == plen) &#123;</span><br><span class="line">                <span class="comment">//文本串结束</span></span><br><span class="line">                <span class="keyword">if</span>(ti == tlen)</span><br><span class="line">                    matched = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(pattern[pj] == <span class="string">'*'</span>) &#123;</span><br><span class="line">                <span class="comment">//匹配任意个字符0~tlen-ti</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= tlen-ti; ++k) &#123;</span><br><span class="line">                    rmatch(ti+k,pj+<span class="number">1</span>,text,tlen);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pattern[pj] == <span class="string">'?'</span>) &#123;</span><br><span class="line">                <span class="comment">//匹配0个或者1个字符</span></span><br><span class="line">                rmatch(ti,pj+<span class="number">1</span>,text,tlen);<span class="comment">//0个</span></span><br><span class="line">                rmatch(ti+<span class="number">1</span>,pj+<span class="number">1</span>,text,tlen);<span class="comment">//1个</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ti &lt; tlen &amp;&amp; pattern[pj] == text[ti]) &#123;</span><br><span class="line">                <span class="comment">//纯字符匹配</span></span><br><span class="line">                rmatch(ti+<span class="number">1</span>,pj+<span class="number">1</span>,text,tlen);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><div id="refer-anchor-1"></div>  

<ul>
<li><p>[<a href="#back-1">1</a>] <a href="https://algorithm-visualizer.org/backtracking/n-queens-problem" target="_blank" rel="noopener">N皇后问题-回溯</a>  </p>
<div id="refer-anchor-2"></div>  
</li>
<li><p>[<a href="#back-2">2</a>] <a href="https://www.geeksforgeeks.org/n-queen-problem-backtracking-3/" target="_blank" rel="noopener">回溯算法-N皇后问题</a>  </p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>回溯算法</tag>
        <tag>深度优先</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划实战</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<p>量化两个字符串之间的相似程度-编辑距离(Edit Distance)<br>编辑距离指的是，将一个字符串转化成另一个字符串，需要的最少编辑操作次数（增加一个字符、删除一个字符、替换一个字符）。编辑距离越大说明两个字符串的相似程度越小；相反编辑距离越小，说明两个字符串的相似程度越大。对于两个完全相同的字符串来说，编辑距离就是0。  </p>
<p>根据所包含的编辑操作种类的不同，编辑距离有多种不同的计算方式：<br><strong>莱文斯坦距离</strong>，允许增加、删除、替换字符，表示两个字符串差异的大小；<br><strong>最长公共子串长度</strong>，允许增加、删除字符，表示两个字符串相似程度的大小。  </p>
<h3 id="莱文斯坦距离"><a href="#莱文斯坦距离" class="headerlink" title="莱文斯坦距离"></a>莱文斯坦距离</h3><p>把一个字符串变成另一个字符串，需要的最少编辑次数。<br>整个求解过程，涉及多个决策阶段，需要依次考察一个字符串中的每个字符，跟另一个字符串中的字符是否匹配，匹配与不匹配分别对应不同的处理方式。符合多阶段决策最优解模型（贪心、回溯、动态规划）。  </p>
<ol>
<li><p>回溯算法-递归处理<br>如果a[i]与b[j]匹配，递归考察a[i+1]和b[j+1]。<br>如果a[i]与b[j]不匹配：  </p>
<ul>
<li>删除a[i]，递归考察a[i+1]和b[j]；</li>
<li>删除b[j]，递归考察a[i]和b[j+1]；</li>
<li>在a[i]前面添加一个跟b[j]相同的字符，然后递归考察a[i]和b[j+1]；</li>
<li>在b[j]前面添加一个跟a[i]相同的字符，然后递归考察a[i+1]和b[j]；</li>
<li>将a[i]替换成b[j]，或者将b[j]替换成a[i]，然后递归考察a[i+1]和b[j+1]。  </li>
</ul>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        莱文斯坦距离 回溯算法
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">char</span>[] a = <span class="string">"mitcmu"</span>.toCharArray();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">char</span>[] b = <span class="string">"mtacnu"</span>.toCharArray();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> m = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> minDist = Integer.MAX_VALUE;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">lwstBT</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> edist)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == n || j == m) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; n) edist += (n-i);</span><br><span class="line">        <span class="keyword">if</span>(j &lt; m) edist += (m-j);</span><br><span class="line">        <span class="keyword">if</span>(edist &lt; minDist) minDist = edist;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a[i] == b[j]) &#123;<span class="comment">//两个字符匹配</span></span><br><span class="line">        lwstBT(i+<span class="number">1</span>, j+<span class="number">1</span>, edist);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//两个字符不匹配</span></span><br><span class="line">        lwstBT(i+<span class="number">1</span>, j, edist+<span class="number">1</span>);<span class="comment">//删除a[i]或者b[j]前添加一个字符</span></span><br><span class="line">        lwstBT(i, j+<span class="number">1</span>, edist+<span class="number">1</span>);<span class="comment">//删除b[j]或者a[i]前添加一个字符</span></span><br><span class="line">        lwstBT(i+<span class="number">1</span>, j+<span class="number">1</span>, edist+<span class="number">1</span>);<span class="comment">//将a[i]和b[j]替换为相同字符</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  
</li>
<li><p>根据回溯算法的代码实现，可以画出递归树，看是否存在重复子问题。<br>如果存在重复子问题，可以考虑是否用动态规划来解决；<br>如果不存在重复子问题，那回溯算法就是最好的解决方法。<br>在递归树中，每个节点代表一个状态，状态包含三个变量(i,j,edist)，其中edist表示处理a[i]和b[j]时，已经执行的编辑操作的次数。  </p>
</li>
<li><p>在递归树中，(i,j)两个变量重复的节点很多。<br>对于(i,j)相同的节点， 只需要保留edist最小的，继续递归处理就可以了，剩下的节点都可以舍弃。所以状态就从(i,j,edist)变成了(i,j,min_edist)，其中min_edist表示处理到a[i]和b[j]已经执行的最小编辑次数。<br>状态(i,j)可能从(i-1,j)、(i,j-1)，(i-1,j-1)三个状态中的任意一个转移过来。  </p>
</li>
<li><p>尝试将状态转移的过程用公式写出来-状态转移方程  </p>
<blockquote>
<p>如果:a[i]!=b[j],那么:min_edist(i,j)就等于:<br>min(min_edist(i-1,j)+1,min_edist(i,j-1)+1,min_edist(i-1,j-1)+1)  </p>
</blockquote>
<blockquote>
<p>如果:a[i]=b[j],那么:min_edist(i,j)就等于:<br>min(min_edist(i-1,j)+1,min_edist(i,j-1)+1,min_edist(i-1,j-1))<br>min表示求三数中的最小值</p>
</blockquote>
</li>
<li><p>了解状态与状态之间的递推关系，画出一个二维状态表，按行依次来填充状态表中的每个值。  </p>
</li>
<li><p>根据状态转移方程和填表过程，翻译成代码：  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        莱文斯坦距离 动态规划
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lwstDP</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> n, <span class="keyword">char</span>[] b, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] minDist = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">    <span class="comment">//初始化第0行：a[0...0]与b[0...j]的编辑距离</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;m; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>] == b[j]) minDist[<span class="number">0</span>][j] = j;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j != <span class="number">0</span>) minDist[<span class="number">0</span>][j] = minDist[<span class="number">0</span>][j-<span class="number">1</span>] +<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> minDist[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化第0列：a[0...i]与b[0...0]的编辑距离</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == b[<span class="number">0</span>]) minDist[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i != <span class="number">0</span>) minDist[i][<span class="number">0</span>] = minDist[i-<span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> minDist[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//按行填表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] == b[j]) minDist[i][j] = min(minDist[i-<span class="number">1</span>][j] + <span class="number">1</span>, minDist[i][j-<span class="number">1</span>] + <span class="number">1</span>, minDist[i-<span class="number">1</span>][j-<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">else</span> minDist[i][j] = min(minDist[i-<span class="number">1</span>][j]+<span class="number">1</span>, minDist[i][j-<span class="number">1</span>]+<span class="number">1</span>, minDist[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minDist[n-<span class="number">1</span>][m-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minv = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; minv) minv = x;</span><br><span class="line">    <span class="keyword">if</span>(y &lt; minv) minv = y;</span><br><span class="line">    <span class="keyword">if</span>(z &lt; minv) minv = z;</span><br><span class="line">    <span class="keyword">return</span> minv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

</li>
</ol>
<h3 id="最长公共子串长度"><a href="#最长公共子串长度" class="headerlink" title="最长公共子串长度"></a>最长公共子串长度</h3><p>解决思路类似莱文斯坦距离<br>每个状态包括三个变量(i,j,max_lcs)，max_lcs表示a[0…i]和b[0…j]的最长公共子串长度。<br>从a[0]和b[0]开始，依次考察两个字符串中的字符是否匹配。  </p>
<ul>
<li>如果a[i]与b[j]互相匹配，将最大公共子串长度加一，并且继续考察a[i+1]和b[j+1]。  </li>
<li>如果a[i]和b[j]不匹配，最长公共子串长度不变，解决思路：<blockquote>
<ul>
<li>删除a[i]，或者在b[j]前面加上一个字符a[i]，然后继续考察a[i+1]和b[j]；  </li>
<li>删除b[j]，或者在a[i]前面加上一个字符b[j]，然后继续考察a[i]和b[j+1]。  </li>
</ul>
</blockquote>
</li>
</ul>
<p>求a[0…i]和b[0…j]的最长公共长度max_lcs[i,j]，只能通过下边三个状态转移过来：  </p>
<ul>
<li>(i-1, j-1, max_lcs)，其中max_lcs表示a[0…i-1]和b[0…j-1]的最长公共子串长度；</li>
<li>(i-1, j, max_lcs)，其中max_lcs表示a[0…i-1]和b[0…j]的最长公共子串长度；  </li>
<li>(i, j-1, max_lcs)，其中max_lcs表示a[0…i]和b[0…j-1]的最长公共子串长度。  </li>
</ul>
<p>状态转移方程：  </p>
<blockquote>
<p>如果：a[i]==b[j]，那么：max_lcs(i,j)就等于：<br>max(max_lcs(i-1,j-1)+1, max_lcs(i-1, j), max_lcs(i, j-1));<br>aba与a的最长公共子串是1不是2；max_lcs(i-1, j)与max_lcs(i, j-1)不需要+1。  </p>
</blockquote>
<blockquote>
<p>如果：a[i]!=b{j}，那么：max_lcs(i,j)就等于：<br>max(max_lcs(i-1,j-1), max_lcs(i-1, j), max(i, j-1));<br>max表示求三个数中的最大值；  </p>
</blockquote>
<p>代码实现：  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        最长公共子串长度 动态规划
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lcs</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> n ,<span class="keyword">char</span>[] b, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] maxlcs = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>] == b[j]) maxlcs[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j != <span class="number">0</span>) maxlcs[<span class="number">0</span>][j] = maxlcs[<span class="number">0</span>][j-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> maxlcs[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == b[<span class="number">0</span>]) maxlcs[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i != <span class="number">0</span>) maxlcs[i][<span class="number">0</span>] = maxlcs[i-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> maxlcs[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] == b[j])</span><br><span class="line">                maxlcs[i][j] = max(maxlcs[i-<span class="number">1</span>][j], maxlcs[i][j-<span class="number">1</span>], maxlcs[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                maxlcs[i][j] = max(maxlcs[i-<span class="number">1</span>][j], maxlcs[i][j-<span class="number">1</span>], maxlcs[i-<span class="number">1</span>][j-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxlcs[n-<span class="number">1</span>][m-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxv = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; maxv) maxv = x;</span><br><span class="line">    <span class="keyword">if</span>(y &gt; maxv) maxv = y;</span><br><span class="line">    <span class="keyword">if</span>(z &gt; maxv) maxv = z;</span><br><span class="line">    <span class="keyword">return</span> maxv; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<h3 id="搜索引擎纠错优化"><a href="#搜索引擎纠错优化" class="headerlink" title="搜索引擎纠错优化"></a>搜索引擎纠错优化</h3><p>纠错效果优化：  </p>
<ul>
<li>取编辑距离最小的TOP10，加上其他参数（如搜索热门程度），决策选择哪个单词作为拼写纠错单词。。  </li>
<li>多种编辑距离计算方法，求交集，用交集的结果继续优化处理。  </li>
<li>统计用户的搜索日志，得到最常被拼错的单词列表，以及对应的拼写正确的单词。搜索引擎找到对应直接返回。  </li>
<li>引入个性化因素，针对每个用户，维护其特有的搜索喜好-常用搜索关键词，当用户输入错误的单词的时候，首先在该用户常用的搜索关键词中，计算编辑距离，查找编辑距离最小的单词。  </li>
</ul>
<p>纠错性能优化：  </p>
<ul>
<li>针对纠错功能的TPS不高，可部署多台机器，每台机器运行一个独立的纠错功能。当有一个纠错请求的时候，通过负载均衡，分配到其中一台机器，开计算编辑距离，得到纠错单词。  </li>
<li>针对纠错系统的响应时间太长，可将纠错的词库分割到多台机器。当有一个纠错请求的时候，将拼写错误的单词同时发送到多台机器上并行处理，分别得到编辑距离最小的单词，然后再对比合并，最终决定一个最优的纠错单词。  </li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划理论</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<h3 id="一个模型三个特征"><a href="#一个模型三个特征" class="headerlink" title="一个模型三个特征"></a>一个模型三个特征</h3><ul>
<li><p><strong>多阶段决策最优解模型</strong><br>一般用动态规划解决最优问题。解决问题的过程需要经历多个决策阶段，每个决策阶段都对应着一组状态。寻找一组决策序列，经过这组决策序列，能够产生最终期望求解的最优值。  </p>
</li>
<li><p><strong>最优子结构</strong><br>问题的最优解包含子问题的最优解。同样，可以通过子问题的最优解，推导出问题的最优解。对应动态规划问题模型，后面阶段的装填可以通过前面阶段状的状态推导出来。  </p>
</li>
<li><p><strong>无后效性</strong><br>两层含义，第一层含义是，在推导后面阶段的状态的时候，只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。第二层含义是，某阶段状态一旦确定，就不受之后阶段的决策影响。  </p>
</li>
<li><p><strong>重复子问题</strong><br>不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。  </p>
</li>
</ul>
<p>实例解析：<br>一个n乘以n的矩阵w[n][n]。矩阵存储的都是正整数，棋子起始位置在左上角，终止位置在右下角。将棋子从左上角移动到右下角。每次只能向右或者向下移动一位。从左上角到右下角，会有很多不同的路径可以走。把每条路径经过的数字加起来看做路径的长度。求从左上角移动到右下角的最短路径长度。  </p>
<p>从(0,0)走到(n-1.n-1),总共需要走2*(n-1)步，也就对应着2*(n-1)个阶段。每个阶段都有向右走或者向下走两种决策，并且每个阶段都会对应一个状态集合。把状态定义为min_dist(i,j)，其中i表示行，j表示列。min_dist表达式的值表示从(0,0)到达(i,j)的最短路径长度。这个问题是一个多阶段决策最优解问题，符合“动态规划的模型”。  </p>
<p>可以用回溯算法解决问题。递归树中有重复的节点，重复的节点表示，从左上角到节点对应的位置，有多种路线，说明这个问题存在“重复子问题”。  </p>
<p>走到(i,j)这个位置，只能通过(i-1,j)，(i,j-1)这两个位置移动过来。所以计算(i,j)位置对应的状态，只需要关心(i-1,j)，(i,j-1)两个位置对应的状态，并不关心棋子是通过什么样的路线到达这两个位置的。而且，仅仅允许往下和往右移动，不允许后退，前面阶段的状态确定之后，不会被后面阶段的决策所改变，符合“无后效性”。  </p>
<p>定义状态的时候，把从起始位置(0,0)到(i,j)的最小路径，记作min_dist(i,j)。因为只能往右或往下移动，所以只有可能从(i-1,j)或者(i,j-1)两个位置到达(i,j)。到达(i,j)的最短路径肯定包含到达这两个位置的最短路径之一。min_dist(i,j)可以通过min_dist(i,j-1)和min_dist(i-1,j)这两个状态推导出来，这个问题符合“最优子结构”。</p>
<blockquote>
<p>min_dist(i,j) = w[i][j] + min(min_dist(i,j-1),min(i-1,j))</p>
</blockquote>
<h3 id="动态规划解题思路"><a href="#动态规划解题思路" class="headerlink" title="动态规划解题思路"></a>动态规划解题思路</h3><p><strong>一般能用动态规划解决的问题，都可以使用回溯算法的暴力搜索解决</strong>。  </p>
<p>状态转移表法&amp;状态转移方程法  </p>
<ol>
<li><p>状态转移表法<br>思路：回溯算法实现-定义状态-画递归树-找重复子问题-画状态转移表-根据递推关系填表-将填表过程翻译成代码  </p>
<p>先用简单的回溯算法解决，然后定义状态，每个状态表示一个节点，然后对应画出递归树。从递归树中，可以看出来是否存才重复子问题，以及重复子问题是如何产生的。以此来寻找规律，看是够能用动态规划解决。<br>找到重复子问题之后，一种是直接使用<strong>回溯加备忘录</strong>的方法，来避免重复子问题，提高执行效率。一种是使用动态规划的解决方法，<strong>状态转移表法</strong>。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        矩阵最短路径 回溯算法
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> minDist = Integer.MAX_VALUE;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">minDistBT</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> dist, <span class="keyword">int</span>[][] w, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//到达(n-1,n-1)这个位置</span></span><br><span class="line">    <span class="keyword">if</span>(i == n &amp;&amp; j == n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dist &lt; minDist) midDist = dist;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; n) &#123;</span><br><span class="line">        <span class="comment">//往下走，更新i=i+1,j=j</span></span><br><span class="line">        minDistBT(i+<span class="number">1</span>, j, dist+w[i][j], w, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j &lt; n) &#123;</span><br><span class="line">        <span class="comment">//往右走，更新i=i,j=j+1</span></span><br><span class="line">        minDistBT(i, j+<span class="number">1</span>, dist+w[i][j], w, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p>先画出一个状态表，状态表一般是二维的，类似二维数组。其中每个状态包含三个变量，行、列、数组值。根据决策的先后过程，从前往后，根据递推关系，分阶段填充状态表中的每个状态。最后将这个递推填表的过程，翻译成代码，就是动态规划代码。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        矩阵最短路径 状态转移表
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistDP</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] states = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//初始化states的第一行数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">        sum += matrix[<span class="number">0</span>][j];</span><br><span class="line">        states[<span class="number">0</span>][j] = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//初始化states的第一列数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        sum += matrix[i][<span class="number">0</span>];</span><br><span class="line">        states[i][<span class="number">0</span>] = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            states[i][j] + Math.min(states[i][j-<span class="number">1</span>], states[i-<span class="number">1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> states[n-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p>大部分状态表都是二维的，如果状态比较复杂，需要很多变量来表示，那对应的状态表可能是高维的，不适合用状态转移表法解决，  </p>
</li>
<li><p>状态转移方程法<br>思路：找最优子结构-写状态转移方程-将状态转移方程翻译成代码  </p>
<p>状态转移方程法类似递归的解题思路。分析某个问题如何通过子问题来递归求解，即最优子结构。根据最优子结构，写出递归公式，即状态转移方程。状态转移方程式解决动态规划的关键。<br>有了状态转移方程，一种是<strong>递归加备忘录</strong>，一种是<strong>迭代递推</strong>。  </p>
 <div class='spoiler collapsed'>
    <div class='spoiler-title'>
        矩阵最短路径 递归+备忘录
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] matrix = &#123;&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>&#125;,&#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">7</span>&#125;,&#123;<span class="number">6</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">3</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] mem = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDist</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) <span class="keyword">return</span> matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(men[i][j] &gt; <span class="number">0</span>) <span class="keyword">return</span> matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> minLeft = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">if</span>(j-<span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        minLeft = minDeft(i, j-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> minUp = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">if</span>(i-<span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        minUp = minDist(i-<span class="number">1</span>,j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> currMinDist = matrix[i][j] + Math.min(minLeft, minUp);<span class="comment">//状态转移方程</span></span><br><span class="line">    mem[i][j] = currMinDist;</span><br><span class="line">    <span class="keyword">return</span> currMinDist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

 <div class='spoiler collapsed'>
    <div class='spoiler-title'>
        矩阵最短路径 迭代递推
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">参考状态转移表法代码。（代码相同，只是思路不同）</span><br></pre></td></tr></table></figure>
    </div>
</div>  

</li>
</ol>
<h3 id="贪心、分治、回溯、动态规划对比"><a href="#贪心、分治、回溯、动态规划对比" class="headerlink" title="贪心、分治、回溯、动态规划对比"></a>贪心、分治、回溯、动态规划对比</h3><ul>
<li><p><strong>分治算法</strong><br>贪心、回溯、动态规划可以归为一类，解决问题的模型都可以抽象成多阶段决策最优解模型；分治算法解决问题大部分是最优解问题，但是大部分都<strong>不能抽象成多阶段决策模型</strong>（各阶段情况相同，类似二分查找），不能有重复子问题。  </p>
</li>
<li><p><strong>回溯算法</strong><br>回溯算法是个<strong>万金油</strong>。基本上能用动态规划、贪心算法解决的问题，都可以用回溯算法解决。回溯算法相当于<strong>穷举(暴力)搜索</strong>，穷举所有的情况，然后对比得到最优解。回溯算法的时间复杂度 非常高，是指数级别的，只能用来解决<strong>小规模数据</strong>的问题。  </p>
</li>
<li><p><strong>动态规划</strong><br>尽管动态规划比回溯算法高效，但是并不是所有问题都可以用动态规划来解决。能用动态规划解决的问题，需要满足三个特征，最优子结构、无后效性、重复子问题。<strong>多阶段最优解模型</strong>。<br>在重复子问题上，动态规划和分治算法的区分非常明显。分治算法要求分割成的子问题，不能有重复子问题，而动态规划正好相反，动态规划之所以高效，就是因为回溯算法实现中存在大量的重复子问题。  </p>
</li>
<li><p><strong>贪心算法</strong><br>贪心算法实际上是一种<strong>特殊的动态规划</strong>。它解决问题起来更加高效，代码实现也更加简洁，可以解决的问题也更加有限。它能解决的问题需要满足三个条件，最优子结构、无后效性、贪心选择性（不强调重复子问题）。<br>贪心选择性指，<strong>通过局部最优的选择，能产生全局的最优选择</strong>。每一个阶段，都选择当前看起来最优的决策，所有阶段的决策完成之后，最终由这些局部最优解构成全局最优解。（贪心算法的解不一定是全局最优解）  </p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>B+树</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/B+%E6%A0%91/</url>
    <content><![CDATA[<h3 id="支持快速查询、插入等操作的数据结构"><a href="#支持快速查询、插入等操作的数据结构" class="headerlink" title="支持快速查询、插入等操作的数据结构"></a>支持快速查询、插入等操作的数据结构</h3><p><strong>散列表</strong><br>散列表的查询性能很好，时间复杂度是O(1)。散列表不能支持按照区间快速查找数据。  </p>
<p><strong>平衡二叉查找树</strong><br>平衡二叉查找树的性能很好，时间复杂度是O(logn)。对树进行中序遍历，可以得到一个从小到大的有序的数据序列，但不足以支持按照区间快速查找数据。  </p>
<p><strong>跳表</strong><br>跳表是在链表之上加上多层索引构成的，支持快速的插入、查找、删除数据，时间复杂度为O(logn)。跳表也支持按照区间快速的查找数据，只需要定位到区间起点值对应在链表中的结点，然后从这个结点开始，顺序遍历链表，直到区间终点对应的结点为止，这期间遍历得到的数据就是满足区间值的数据。  </p>
<p><strong>二叉查找树改造—&gt;B+树</strong><br>解决<strong>区间查找</strong>问题，树中的节点并不存储数据本身，而是只是作为索引。把每个叶子节点串在一条链表上，链表中的数据是从小到大有序的。<br>改造之后，如果要求某个区间的数据，只需要拿区间的起始值，在树中进行查找，当查找到某个叶子节点之后，再顺着链表往后遍历，直到链表中的结点数据值大于区间的终点值位置。所遍历到的数据，就是符合区间值的所有数据。  </p>
<p>解决<strong>内存占用</strong>问题，借助时间换空间的思路，把索引存储在硬盘中。<br>比起内存读写操作，磁盘IO操作非常耗时，尽量减少磁盘IO操作—降低树的高度。构建m叉树。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        m叉树实现B+树索引
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 非叶子节点</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* 假设keywords=[3,5,8,10]</span></span><br><span class="line"><span class="comment">* 4个键值将数据分为5个区间：(-INF,3),[3,5),[5,8),[8,10),[10,inf)</span></span><br><span class="line"><span class="comment">* 5个区间分别对应：children[0]...children[4]</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* m值是事先计算得到的，计算的依据是让所有信息的大小正好等于页的大小：</span></span><br><span class="line"><span class="comment">* PAGE_SIZE = (m-1)*4[keywords大小] + m*8[children大小]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BPlusTreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> m = <span class="number">5</span>;<span class="comment">//5叉树</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] keywords = <span class="keyword">new</span> <span class="keyword">int</span>[m-<span class="number">1</span>];<span class="comment">//键值，用来划分数据区间</span></span><br><span class="line">    <span class="keyword">public</span> BPlusTressNode[] children = <span class="keyword">new</span> BPlusTreeNode[m];<span class="comment">//保存子节点指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 叶子节点</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 叶子节点存储的是值，而非区间</span></span><br><span class="line"><span class="comment">* 每个叶子节点存储3个数据行的键值及地址信息</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* k值是事先计算得到的，计算的依据是让所有信息的大小正好等于页的大小：</span></span><br><span class="line"><span class="comment">* PAGE_SIZE = k*4[keywords大小]+k*8[dataAddress大小]+8[prev大小]+8[next大小]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BPlusTreeLeafNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> k = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] keywords = <span class="keyword">new</span> <span class="keyword">int</span>[k];<span class="comment">//数据的键值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span>[] dataAddress = <span class="keyword">new</span> <span class="keyword">long</span>[k];<span class="comment">//数据地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BPlusTreeLeafNode prev;<span class="comment">//这个结点在链表中的前驱结点</span></span><br><span class="line">    <span class="keyword">public</span> BPlusTreeLeafNode next;<span class="comment">//这个结点在链表中的后继结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p>对于相同个数的数据构建m叉树索引，m叉树中的m越大，树的高度就越小。<br>内存中的数据，以及磁盘中的数据，操作系统都是按页（一页大小通常是4KB，这个值可以通过getconfig PAGE_SIZE命令查看）来读取的，一次会读取一页的数据。如果要读取的数据超过一页的大小，就会触发多次IO操作。所以选择m大小的时候，尽量让每个节点的大小等于一个页的大小。读取一个节点，只需要一次磁盘IO操作。  </p>
<ul>
<li><p>写入数据效率下降<br>  数据的写入过程，会涉及索引的更新，这是索引导致写入变慢的主要原因。  </p>
<p>  对于一个B+树来说，m值是根据页的大小事先计算好的，每个节点最多只能有m个子节点。在往数据库中写入数据的过程中，可能使索引中某些节点的子节点个数超过m，这个节点的大小超过了一个页的大小，读取这样一个节点，就会导致多次IO操作。  </p>
<p>  需要将这个节点分裂成两个节点。节点分裂之后，其上层父节点的子节点个数有可能超过m个。可以用同样的方法，将父节点也分裂成两个节点。这种级联反应会从下往上，一直影响到根节点。  </p>
</li>
<li><p>删除数据效率下降<br>  删除某个数据的时候，也要对应的更新索引节点。处理思路类似跳表中删除数据的处理思路。频繁的数据删除，就会导致某些节点中，子节点的个数变得非常少，长此以往，如果某个节点的子节点都比较少，势必会影响索引的效率。  </p>
<p>  设置一个阈值，在B+树中，这个阈值等于m/2，如果摸一个节点的子节点个数小于m/2，就将它跟相邻的兄弟节点合并。合并之后的子节点个数有可能会超过m。针对这种情况，可以借助插入数据的时候的处理方法，再分裂节点。  </p>
</li>
</ul>
<p>理论上，对跳表稍加改造也可以替代B+树，作为数据库的索引实现。  </p>
<h3 id="B-树特点"><a href="#B-树特点" class="headerlink" title="B+树特点"></a>B+树特点</h3><ul>
<li>每个节点中子节点的个数不能超过m，也不能小于m/2；</li>
<li>根节点的子节点个数可以不超过m/2，这是一个例外；</li>
<li>m叉树只存储索引，并不真正存储数据，这个类似跳表；</li>
<li>通过链表将叶子节点串联在一起，可以方便按区间查找；</li>
<li>一般情况，根节点会被存储在内存中，其他节点存储在磁盘中。</li>
</ul>
<p>B-树就是B树  </p>
<ul>
<li>B+树中的节点不存储数据，只是索引，而B树中的节点存储数据；</li>
<li>B树中的叶子节点并不需要链表来串联。</li>
<li>B树只是一个每个节点的子节点个数不能小于m/2的m叉树。</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>B+树</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路径</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h3 id="算法解析"><a href="#算法解析" class="headerlink" title="算法解析"></a>算法解析</h3><p><strong>建模</strong>：将复杂的场景抽象成具体的数据结构。  </p>
<p>把地图抽象成图。把每个岔路口看做一个顶点，岔路口与岔路口之间的路看作一条边，路的长度就是边的权重。如果路是单行道，就在两个顶点之间画一条有向边；如果路是双行道，就在两个顶点之间画两条方向不同的边。整个地图被抽象成一个有向有权图。  </p>
<p>地图中起点到终点的最短路径问题转化为在一个有向有权图中，求两个顶点间的最短路径。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        有向有权图
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Edge&gt; adj[];<span class="comment">//邻接表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> v;<span class="comment">//顶点个数</span></span><br><span class="line"></span><br><span class="line">    publicGraph(<span class="keyword">int</span> v) &#123;</span><br><span class="line">        <span class="keyword">this</span>.v = v;</span><br><span class="line">        <span class="keyword">this</span>.adj = <span class="keyword">new</span> LinkedList[v];<span class="comment">//v个链表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) &#123;</span><br><span class="line">            <span class="keyword">this</span>.adj[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();<span class="comment">//每个编号的顶点都存了一个链表</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加一条边</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.add[s].add(<span class="keyword">new</span> Edge(s,t,w));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> sid;<span class="comment">//边的起始顶点编号</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> tid;<span class="comment">//边的终止顶点编号</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> w;<span class="comment">//权重</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">int</span> sid, <span class="keyword">int</span> tid, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.sid = sid;</span><br><span class="line">            <span class="keyword">this</span>.tid = sid;</span><br><span class="line">            <span class="keyword">this</span>.w = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Vertex</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> id;<span class="comment">//顶点编号ID</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> dist;<span class="comment">//从起始顶点到这个顶点的距离</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Vertex</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> dist)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            <span class="keyword">this</span>.dist = dist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p>最短路径算法-单源最短路径算法(一个顶点到一个顶点)。  </p>
<blockquote>
<p>将每个顶点到起始顶点的距离初始化为无穷，然后从起始点开始，将其加入一个优先级队列中，从优先级队列中取出到源点距离最小的顶点，然后比较其周围顶点离源点的距离是否大于其到源点的距离+其到周围顶点的距离，如果大于的话，更新周围顶点到源点的距离为较小的值以及其前序节点，并将其加入优先级队列中(如果已经加入过，就更新)，再取出优先级队列中的距离最小值，循环往复，直到取出终止顶点t，或者优先级队列为空。此时倒序输出终止顶点t的前序节点，前序节点的前序节点。。。直到前序节点为起始顶点s，此路径即为最短路径。  </p>
</blockquote>
<p>Dijkstra算法：<br>动态规划算法，求得的解是全局最优解。  </p>
<p>Dijkstra算法类似BFS算法，每次找到跟起点最近的顶点，往外扩展。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Dijkstra算法
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//带更新数据接口的优先级队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据vertex.dist构建小顶堆</span></span><br><span class="line">    <span class="keyword">private</span> Vertex[] nodes;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nodes = <span class="keyword">new</span> Vertex[v+<span class="number">1</span>];<span class="comment">//从下标1开始存数据</span></span><br><span class="line">        <span class="keyword">this</span>.count = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Vertex <span class="title">poll</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Vertex vertex)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">//更新结点的值，并且从下往上堆化，重新符合堆的定义。时间复杂度O(logn)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Vertex vertex)</span> </span>&#123;</span><br><span class="line">        Vertex v = nodes[vertex.id];</span><br><span class="line">        v.dist = vertex.dist;</span><br><span class="line">        <span class="comment">//todo 堆化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从顶点s到顶点t的最短路径</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] predecessor = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.v];<span class="comment">//还原最短路径</span></span><br><span class="line">    Vertex[] vertexes = <span class="keyword">new</span> Vertex[<span class="keyword">this</span>.v];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.v; +=i) &#123;</span><br><span class="line">        vertexes[i] = <span class="keyword">new</span> Vertex(i, Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    PriorityQueue queue = <span class="keyword">new</span> PriorityQueue(<span class="keyword">this</span>.v);<span class="comment">//小顶堆</span></span><br><span class="line">    <span class="keyword">boolean</span>[] inqueue = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="keyword">this</span>.v];<span class="comment">//标记是否进入过队列</span></span><br><span class="line">    vertexes[s].dist = <span class="number">0</span>;</span><br><span class="line">    queue.add(vertexes[s]);</span><br><span class="line">    inqueue[s] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        Vertex minVertex = queue.poll();<span class="comment">//取堆顶元素并删除</span></span><br><span class="line">        <span class="keyword">if</span>(minVertex.id == t) <span class="keyword">break</span>;<span class="comment">//最短路径产生不在循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj[minVertex.id].size(); ++i) &#123;</span><br><span class="line">            Edge e = adj[minVertex.id].get(i);<span class="comment">//取出一条minVertex相连的边</span></span><br><span class="line">            Vertex nextVertex = vertexes[e.tid];<span class="comment">//minVertex-&gt;nextVertex</span></span><br><span class="line">            <span class="keyword">if</span>(minVertex.dist + e.w &lt; nextVertex.dist) &#123;<span class="comment">//更新next的dist</span></span><br><span class="line">                nextVertex.dist = minVertex.dist + e.w;</span><br><span class="line">                predecessor[nextVertex.id] = minVertex.id;</span><br><span class="line">                <span class="keyword">if</span>(inqueue[nextVertex.is] == <span class="keyword">true</span>) &#123;</span><br><span class="line">                    queue.update(nextVertex);<span class="comment">//更新队列中的dist值，自动更新位置(堆化)</span></span><br><span class="line">                    <span class="comment">//queue.remove(nextVertex);</span></span><br><span class="line">                    <span class="comment">//queue.add(nextVertex);</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    queue.add(nextVertex);</span><br><span class="line">                    inqueue[nextVertex.id] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出最短路径</span></span><br><span class="line">    System.out.print(s);</span><br><span class="line">    print(s,t,predecessor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span>[] predecessor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == t) <span class="keyword">return</span>;</span><br><span class="line">    print(s, predecessor[t], predecessor);</span><br><span class="line">    System.out.print(<span class="string">"-&gt;"</span> + t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p>用vertexes数组，记录从起始顶点到每个顶点的距离(dist)。<br>起始将所有顶点的dist都初始化为无穷大(Integer.MAX_VALUE)。把起始顶点的dist值初始化为0，然后将其放到优先级队列中。  </p>
<p>从优先级队列中取出dist最小的顶点minVertex，然后考察这个顶点可达的所有顶点(nextVertex)。如果minVertex的dist值加上minVertex与nextVertex之间边的权重w小于nextVertex。把nextVertex的dist更新为minVertex的dist值加上w。然后把nextVertex加入到优先级队列中。重复这个过程，直到找到终止顶点t或者队列为空。  </p>
<blockquote>
<p>predecessor数组的作用是为了还原最短路径，它记录每个顶点的前驱顶点。最后通过递归的方式，将这个路径打印出来（深度广度优先搜索）。  </p>
</blockquote>
<blockquote>
<p>inqueue数组是为了避免将一个顶点多次添加到优先级队列中。更新了某个顶点的dist值之后，如果这个顶点已经在优先级队列中了，就不再将它重读添加进去。  </p>
</blockquote>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>在代码实现中，最复杂的是while循环嵌套for循环的代码。while循环最多会执行V此(V表示顶点的个数)，而内部的for循环的执行次数不确定，跟每个顶点的相邻边的个数有关，分别记作E0、E1、E2、…、E(V-1)。如果把这V个顶点的边都加起来，最大也不会超过图中所有边的个数E(E表示边的个数)。  </p>
<p>for循环内部的代码涉及从优先级队列取数据、往优先级队列中添加数据、更新优先级队列中的数据，这三个主要的操作。优先级队列是用堆来实现的，堆中的这几个操作，时间复杂度都是O(logV)(堆中的元素个数不会超多顶点的个数V)。  </p>
<p>综合之后，利用乘法原则，整个代码的时间复杂度为O(E*logV)。  </p>
<h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p>实际问题没有必要非得求出个绝对最优解，很多时候为了兼顾执行效率，只需要计算出一个可行的次优解就可以。  </p>
<ol>
<li><p>超级大地图最短路径<br>超级大地图，两点之间的最短路径或者说较好的出行路径，并不会很“发散”，只会出现在两点之间和两点附近的区块内。可以在整个大地图上，划出一个小的区块，这个小的区块恰好可以覆盖住两个点，但是又不会很大，只需要在这个小区块内部运行Dijkstra算法，这样就可以避免遍历整个大图，也就大大提高了执行效率。  </p>
<p>对于两点之间距离较远的路线规划，先规划大的出行路线，然后再细化每个阶段的小路线。  </p>
</li>
<li><p>最少时间<br>在计算最少时间的时候，算法与最短路径相同，只需要把边的权重，从路的长度变成经过这段路所需要的时间。  </p>
</li>
<li><p>最少红绿灯<br>每经过一条边，就要经过一个红绿灯。关于最少红绿灯的出行方案，只需要把每条边的权值改为1即可，算法还是不变，可以使用Dijkstra算法。边的权值为1，相当于无权图，可以使用广度优先搜索算法，广度优先搜索算法计算出来的两点之间的路径，就是两点的最短路径。  </p>
</li>
<li><p>翻译<br>只针对单个词翻译的翻译系统。<br>翻译一整个句子，将句子拆分成一个一个的单词，再丢给翻译系统。针对每个单词，翻译系统会返回一组可选的翻译列表，并且针对每个翻译打一个分，表示这个翻译的可信程度。<br>针对每个单词，从可选列表中，选择其中一个翻译，组合起来就是整个句子的翻译。每个单词的翻译的得分之和，就是真个句子的翻译得分。随意搭配单词的翻译，会得到一个句子的不同翻译。针对整个句子，编程计算出得分最高的前k个翻译结果。  </p>
<ul>
<li><p>回溯算法，穷举所有的排列组合情况，然后选出得分最高的前k个翻译结果。时间复杂度为O(m<sup>n</sup>)，m表示平均每个单词的可选翻译个数，n表示一个句子中包含的单词数量。  </p>
</li>
<li><p>Dijkstra算法，每个单词的可选翻译是按照分数从大到小排列的，a<sub>0</sub>b<sub>0</sub>c<sub>0</sub>肯定是得分最高组合结果。把其及其得分作为一个对象，放入优先级队列中。  </p>
<p>  每次从优先级队列中取出一个得分最高的组合，并给予这个组合进行扩展。扩展的策略是每个单词的翻译分别替换成下一个单词的翻译。a<sub>0</sub>b<sub>0</sub>c<sub>0</sub>扩展后会得到三个组合，a<sub>1</sub>b<sub>0</sub>c<sub>0</sub>、a<sub>0</sub>b<sub>1</sub>c<sub>0</sub>、a<sub>0</sub>b<sub>0</sub>c<sub>1</sub>。把扩展之后的组合，加到优先级队列中。重复这个过程，直到获取到k个翻译组合或者队列为空。  </p>
<p>  时间复杂度，假设句子包含n个单词，每个单词平均有m个可选的翻译，求得分最高的前k个组合结果。每次一个组合出队列，就对应着一个组合结果，希望得到k个，就对应着k次出队操作。每次有一个组合出队列，就有n个组合入队列。优先级队列中出队和入队操作的时间复杂度都是O(logX)，X表示队列中的组合个数。总的时间复杂度就是O(k*n*logX)。<br>  k次出入队列，队列中的总数据不会超过k*n，也就是说，出队、入队操作的时间复杂度是O(log(k*n))。总的时间复杂度为O(k*n*log(k*n))。</p>
</li>
</ul>
</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>最短路径</tag>
        <tag>Dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title>A*搜索</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/A-%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<p>A*算法是对Dijkstra算法的优化和改造。属于一种<strong>启发式搜索算法</strong>。  </p>
<p>常见的启发式搜索算法：IDA*算法、蚁群算法、遗传算法、模拟退火算法。  </p>
<p>启发式搜索算法利用估价函数，避免“跑偏”，贪心的朝着最有可能到达终点的方向前进。这种算法找出的路线，并不是最短路线。但是能很好的平衡路线质量和执行效率。  </p>
<h3 id="算法解析"><a href="#算法解析" class="headerlink" title="算法解析"></a>算法解析</h3><p>Dijkstra算法类似BFS算法，每次找到跟起点最近的顶点，往外扩展，有些盲目（离起点最近的点可能离终点最远）。<br>在Dijkstra算法的实现思路中，用一个优先级队列，来记录已经遍历到的顶点以及这个顶点与起点的路径长度。顶点与起点路径长度越小，就越先被从优先级队列中取出来扩展。尽管找到是从s到t的路线，但是最先被搜索的路线可能是与期望路线的反方向。  </p>
<p>按照顶点与起点的路径长度的大小，来安排出队列顺序，与起点越近的顶点，就会越早出队列。并没有考虑到这个顶点到终点的距离，所以尽管顶点离起始顶点最近，但离终点却越来越远。  </p>
<p>当遍历到某个顶点的时候，从起点走到这个顶点的路径长度是确定的，记作g(i)(i表示顶点编号)。<br>这个顶点跟终点之间的直线距离-欧几里得距离，可以近似的估计顶点跟 终点的路径长度，记作h(i)(i表示顶点编号)—<strong>启发函数</strong>。更进一步使用两点之间横纵坐标的距离之和-曼哈顿距离来简化。  </p>
<p>原来只是单纯的通过顶点与起点之间的路径长度g(i)，来判断谁先出队列；现在加上顶点到终点的路径长度估计值，通过两者之和f(i)=g(i)+h(i)—<strong>估价函数</strong>。综合两部分，能有效避免跑偏。  </p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>在A*算法的代码实现中，顶点Vertex类的定义，跟Dijkstra算法中的定义相比，多了x,y坐标，以及估价函数f(i)的值。图Graph类的定义跟Dijkstra算法中的定义一样。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        有向有权图
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Edge&gt; adj[];<span class="comment">//邻接表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> v;<span class="comment">//顶点个数</span></span><br><span class="line"></span><br><span class="line">    publicGraph(<span class="keyword">int</span> v) &#123;</span><br><span class="line">        <span class="keyword">this</span>.v = v;</span><br><span class="line">        <span class="keyword">this</span>.adj = <span class="keyword">new</span> LinkedList[v];<span class="comment">//v个链表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) &#123;</span><br><span class="line">            <span class="keyword">this</span>.adj[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();<span class="comment">//每个编号的顶点都存了一个链表</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加一条边</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.add[s].add(<span class="keyword">new</span> Edge(s,t,w));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> sid;<span class="comment">//边的起始顶点编号</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> tid;<span class="comment">//边的终止顶点编号</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> w;<span class="comment">//权重</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">int</span> sid, <span class="keyword">int</span> tid, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.sid = sid;</span><br><span class="line">            <span class="keyword">this</span>.tid = sid;</span><br><span class="line">            <span class="keyword">this</span>.w = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Vertex</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> id;<span class="comment">//顶点编号ID</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> dist;<span class="comment">//从起始顶点到这个顶点的距离</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> f;<span class="comment">//f(i)=g(i)+h(i)</span></span><br><span class="line">        <span class="keyword">public</span> intx,y;<span class="comment">//顶点在地图中的坐标</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Vertex</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            <span class="keyword">this</span>.x = x;</span><br><span class="line">            <span class="keyword">this</span>.y = y;</span><br><span class="line">            <span class="keyword">this</span>.f = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">this</span>.dist = Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Graph类的成员变量，在构造函数中初始化</span></span><br><span class="line">    Vertex[] vertexes = <span class="keyword">new</span> Vertex[<span class="keyword">this</span>.v];</span><br><span class="line">    <span class="comment">//添加顶点的坐标</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addVertex</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        vertexes[id] = <span class="keyword">new</span> Vertex(id,x,y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p>A*算法与Dijkstra算法的区别：  </p>
<ul>
<li>优先级队列的构建方式不同。A*算法是根据f值(f(i)=g(i)+h(i))来构建优先级队列，而Dijkstra算法是根据dist值(g(i))来构建优先级队列。  </li>
<li>A*算法在更新顶点dist值的时候，会同步更新f值。  </li>
<li>循环结束的条件不一样。Dijkstra算法是在终点出队列的时候才结束，A*算法是一旦遍历到终点就结束。  </li>
</ul>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        A*算法
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从顶点s到顶点t的路径</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">astar</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//还原路径</span></span><br><span class="line">    <span class="keyword">int</span>[] predecessor = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.v];</span><br><span class="line">    <span class="comment">//按照vertex的f值构建的小顶堆(Dijkstra按照dist)</span></span><br><span class="line">    PriorityQueue queue = <span class="keyword">new</span> PriorityQueue(<span class="keyword">this</span>.v);</span><br><span class="line">    <span class="comment">//标记是否进入过队列</span></span><br><span class="line">    <span class="keyword">boolean</span>[] inqueue = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="keyword">this</span>.v];</span><br><span class="line">    vertexes[s].dist = <span class="number">0</span>;</span><br><span class="line">    vertexes[s].f = <span class="number">0</span>;</span><br><span class="line">    queue.add(vertexes[s]);</span><br><span class="line">    inqueue[s] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//取堆顶元素并删除</span></span><br><span class="line">        Vertex minVertex = queue.poll();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj[minVertex.id].size(); ++i) &#123;</span><br><span class="line">            <span class="comment">//取出一条minVertex相连的边</span></span><br><span class="line">            Edge e = adj[minVertex.id].get(i);</span><br><span class="line">            <span class="comment">//minVertex --&gt; nextVertex</span></span><br><span class="line">            Vertex nextVertex = vertexes[e.tid];</span><br><span class="line">            <span class="keyword">if</span>(minVertex.dist + e.w &lt; nextVertex.dist) &#123;</span><br><span class="line">                <span class="comment">//更新next的dist,f</span></span><br><span class="line">                nextVertex.dist = minVertex.dist + e.w;</span><br><span class="line">                nextVertex.f = nextVertex.dist + hManhattan(nextVertex, vertexes[t]);</span><br><span class="line">                predecessor[nextVertex.id] = minVertex.id;</span><br><span class="line">                <span class="keyword">if</span>(inqueue[nextVertex.id] == <span class="keyword">true</span>) &#123;</span><br><span class="line">                    queue.update(nextVertex);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    queue.add(nextVertex);</span><br><span class="line">                    inqueue[nextVertex.id] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//只要到达t就可以结束while</span></span><br><span class="line">            <span class="keyword">if</span>(nextVertex.id == t) &#123;</span><br><span class="line">                <span class="comment">//清空queue，才能推出while循环</span></span><br><span class="line">                queue.clear();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出路径</span></span><br><span class="line">    System.out.print(s);</span><br><span class="line">    print(s,t,predecessor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span>[] predecessor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == t) <span class="keyword">return</span>;</span><br><span class="line">    print(s, predecessor[t], predecessor);</span><br><span class="line">    System.out.print(<span class="string">"-&gt;"</span> + t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<h3 id="对比分析"><a href="#对比分析" class="headerlink" title="对比分析"></a>对比分析</h3><p>A*算法可以更加快速的找到从起点到终点的路线，但是它并不能像Dijkstra算法那样，找到最短路线。  </p>
<p>回溯穷举所有从s到达t的不同路径，然后对比找出最短的那个。  </p>
<p>Dijkstra算法在回溯的基础上，利用动态规划的思想，堆回溯搜索进行了剪枝，只保留起点到某个顶点的最短路径，继续往外扩展搜索。动态规划相较于回溯搜索，只是换了一个实现思路，实际上也考察了所有从起点到终点的路线，得到的最优解。  </p>
<p>Dijkstra算法是在终点出队列的时候才结束，A*算法是一旦遍历到终点就结束。对于Dijkstra算法来说，当终点出队列的时候，终点的dist值是优先级队列中所有顶点的最小值，即使再运行下去，终点的dist值也不会再被更新了。对于A*算法来说，一旦遍历到终点，就结束while循环，这个时候，终点的dist值未必是最小值。<br>A*算法利用贪心算法的思路，每次都找f值最小的顶点出队列，一旦搜索到终点就不在继续考察其他顶点和路线了。它并没有考察所有的路线，也就不可能找到最短路径。  </p>
<blockquote>
<p>游戏寻路问题，把地图抽象成图，把岔路口抽象成顶点，把道路抽象成边。  </p>
</blockquote>
<blockquote>
<p>把地图分割成一个个的小方块。在某一个方块上的人物，只能往上下左右四个方向的方块上移动。把每个方块看做一个顶点。两个方块相邻，就在他们之间连两条有向边，并且边的权值都是1。  </p>
</blockquote>
<blockquote>
<p>将问题转化成，在一个有向有权图中，找某一个顶点到另一个顶点的路径问题，将地图抽象成边权值为1的有向图之后，套用A*算法解决人物自动寻路功能。  </p>
</blockquote>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>A*搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>索引</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h3 id="索引定义"><a href="#索引定义" class="headerlink" title="索引定义"></a>索引定义</h3><p>类比书籍的目录。通过目录，可以快速定位相关知识点的页数，查找的速度有质的提高。  </p>
<h3 id="索引的需求定义"><a href="#索引的需求定义" class="headerlink" title="索引的需求定义"></a>索引的需求定义</h3><ol>
<li><p>功能性需求<br><strong>数据是格式化数据还是非格式化数据</strong>。结构化数据，MySQL中的数据；非结构化数据，搜索引擎中网页。非机构化数据需要做预处理，提取出查询关键词，对关键词构建索引。  </p>
<p><strong>数据是静态数据还是动态数据</strong>。静态数据，不会有数据的增加、删除、更新操作，构建索引时只需奥考虑查询效率。动态数据，在原始数据更新的同时，还需要动态的更新索引。  </p>
<p><strong>索引存储在内存还是硬盘</strong>。存储在内存，查询速度高。原始数据量大，索引很大，内存有限，需要将索引存储在磁盘。一部分存储在内存，一部分存储在磁盘，可以兼顾内存消耗和查询效率。  </p>
<p><strong>单值查找还是区间查找</strong>。单值查找，根据查询关键词等于某个值的数据。区间查找，查找关键词处于某个区间值的所有数据。  </p>
<p><strong>单关键词查找还是多关键词组合查找</strong>。多关键词查询：结构化数据，针对多个关键词的组合建立索引；非结构化数据，针对单个关键词构建索引，然后通过集合操作（并集、交集），计算出多个关键词组合的查询结果。</p>
</li>
<li><p>非功能性需求<br><strong>不管是存储在内存中还是磁盘中，索引对存储空间的消耗不能过大</strong>。索引对存储空间的消耗可能会超过原始数据。  </p>
<p><strong>在考虑索引查询效率的同时，还要考虑索引的维护成本</strong>。在原始数据动态增删改的同时，也需要动态的更新索引，索引的更新势必会影响到增删改操作的性能。  </p>
</li>
</ol>
<h3 id="构建索引常用的数据结构"><a href="#构建索引常用的数据结构" class="headerlink" title="构建索引常用的数据结构"></a>构建索引常用的数据结构</h3><p>散列表、红黑树、跳表、B+树，可以作为动态数据集合的索引，位图、布隆过滤器可作为辅助索引，有序数组可以用来对静态数据构建索引。  </p>
<p><strong>散列表</strong>增删改查的时间复杂度为O(1)，一般构建在内存中。如键值数据库（Redis、Memcache）的索引。  </p>
<p><strong>红黑树</strong>数据插入、删除、查找的时间复杂度为O(logn)，适合构建内存索引。如Ext文件系统中，对磁盘块的索引。  </p>
<p><strong>B+树</strong>相比红黑树，更适合构建存储在磁盘中的索引，需要的磁盘IO次数更少。如关系型数据库MySQL、Oracle的索引。  </p>
<p><strong>跳表</strong>支持快速添加、删除、查找数据，通过灵活调整索引结点个数和数据个数之间的比例，可以很好的平衡索引堆内存的消耗及其查询效率。如Redis中的有序集合的索引。  </p>
<p><strong>位图和布隆过滤器</strong>，辅助存储在磁盘中的索引，加速数据查找的效率。<br>布隆过滤器有一定的判错率。对于判定存在的数据，可能并不存在；对于判定不存在的数据，则肯定不存在。但内存占用非常少。<br>针对数据，构建一个布隆过滤器，存储在内存中，当要查询数据的时候，可以先通过布隆过滤器，判定是否存在。若不存在，则没有必要读磁盘中的索引，对于数据不存在的情况，数据查询更加快速。  </p>
<p><strong>有序数组</strong>。静态数据，没有插入、删除、更新操作，可以把数据查询用的关键词抽取出来，组织成有序数据，然后利用二分查找算法来快速查找数据。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串匹配：BF&amp;RK</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%EF%BC%9ABF&amp;RK/</url>
    <content><![CDATA[<h3 id="BF算法"><a href="#BF算法" class="headerlink" title="BF算法"></a>BF算法</h3><p>Brute Force算法，暴力匹配算法，也叫朴素匹配算法。  </p>
<p>在字符串A中查找字符串B，字符串A为<strong>主串</strong>，字符串B为<strong>模式串</strong>。主串的长度记为n，模式串的长度记作m，主串中查找模式串，n&gt;m。  </p>
<p><strong>算法思想：</strong><br>在主串中，检查起始位置分别是0、1、2…n-m且长度为m的n-m+1个子串，看有没有跟模式串匹配的。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        BF算法
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> main 主串</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> pattern 模式串</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 匹配下标的起始值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexBf</span><span class="params">(<span class="keyword">char</span>[] main,<span class="keyword">char</span>[] pattern)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//最大的首个字符的索引</span></span><br><span class="line">    <span class="keyword">int</span> maxFirst = main.length -pattern.length;</span><br><span class="line">    <span class="keyword">char</span> first = pattern[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= maxFirst; i++) &#123;</span><br><span class="line">        <span class="comment">//第一个匹配的字符</span></span><br><span class="line">        <span class="keyword">while</span>(first != main[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(++i &gt; maxFirst) </span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//子串匹配</span></span><br><span class="line">        <span class="keyword">int</span> m = i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; pattern.length; j++,m++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(main[m] != pattern[j])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//匹配成功</span></span><br><span class="line">        <span class="keyword">if</span>(m -i == pattern.length)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    retuen -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<p><strong>时间复杂度：</strong><br>极端情况下，在“aaaa…aaaa”中查找“aaaab”。每次都对比m个字符，要对比n-m+1次，最坏情况时间复杂度是O(n*m)。  </p>
<ol>
<li>实际软件开发中，模式串和主串长度不会太长，每次模式串与主串中的子串匹配时，中途遇到不能匹配的字符的时候就可以停止，不需要把每个字符都比对一下。  </li>
<li>算法思想简单，代码实现简单，不容易出错，有bug容易暴露和修复。KISS原则。</li>
</ol>
<h3 id="RK算法"><a href="#RK算法" class="headerlink" title="RK算法"></a>RK算法</h3><p>Rabin-Karp算法，BF算法升级版。<br>BF算法中，每次检查主串与子串是否匹配，需要依次对比每个字符，BF算法的时间复杂度比较高为O(n*m)。对其稍加改造，引入哈希算法，时间复杂度立刻降低。  </p>
<p><strong>算法思想：</strong><br>通过哈希算法对主串中的n-m+1个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，说明对应的子串和模式串匹配(暂时忽略哈希冲突)。哈希值是一个数字，数字之间比较是否相等非常快速。<br>计算子串的哈希值时，依然需要遍历子串中的每个字符，模式串与子串的比较效率提高，算法整体的效率并未提高。  </p>
<p>哈希算法设计技巧，假设主串的字符集中只包含K个字符，可用一个K进制数来表示一个子串，这个K进制数转化成十进制数，作为子串的哈希值。<br>比如要处理的字符串只包含a~z这26个小写字符，可以用二十六进制来表示一个字符串。把a~z这26个字符映射到0~25这26个数字，a表示0，b表示1，以此类推，z表示25。一个包含a到z这26个字符的字符串，计算哈希；<br>“cba”=’c’*26<sup>2</sup> + ‘b’*26<sup>1</sup> + ‘a’*26<sup>0</sup><br>=2*26<sup>2</sup> + 1*26<sup>1</sup> + 0*26<sup>0</sup><br>=1353  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        RK算法
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> main 主串</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> pattern 模式串</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 匹配下标的起始值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexRk</span><span class="params">(<span class="keyword">char</span>[] main,<span class="keyword">char</span>[] pattern)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mLen = main.length;</span><br><span class="line">    <span class="keyword">int</span> pLen = pattern.length;</span><br><span class="line">    <span class="keyword">int</span> pHash = hash(pattern,<span class="number">0</span>,pLen);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mLen - pLen +<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pHash == hash(main, i, pLen))</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用[a-z] 对应[0-25] 26进制计算hash值</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> chars 字符数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> start 起始下标</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> len 长度</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 匹配下标的起始值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> start, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; start + len; i++,x++) &#123;</span><br><span class="line">        hash += Math.pow(<span class="number">26</span>, len - x - <span class="number">1</span>) * (chars[i] - <span class="string">"a"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<p>哈希算法特点，在主串中，相邻两个子串的哈希值的计算公式有一定关系：相邻连个子串s[i-1,i+m-2]和s[i,i+m-1] (i表示子串在主串中的其实位置，子串的长度都为m)，对应哈希值计算公式有交集，可以使用s[i-1]的哈希值快速计算出s[i]的哈希值：<br>h[i-1]=26<sup>m-1</sup>*(s[i-1]-‘a’) + 26<sup>m-2</sup>*(s[i]-‘a’)  + 26<sup>0</sup>*(s[i+m-2]-‘a’)<br>h[i]=26<sup>m-1</sup>*(s[i]-‘a’)+   + 26<sup>1</sup>*(s[i+m-2]-‘a’)+ 26<sup>0</sup>*(s[i+m-1]-‘a’)  </p>
<p>B=A<em>26;<br>h[i]=(h[i-1]-26<sup>m-1</sup>\</em>(s[i-1]-‘a’))*26 + 26<sup>0</sup>*(s[i+m-1]-‘a’)  </p>
<p>26<sup>m-1</sup>可以进一步通过查表提高计算效率，事先计算好26<sup>0</sup>、26<sup>1</sup>、26<sup>2</sup>…26<sup>m-1</sup>，并存储在一个长度为m的数组中，公式中的次方就对应数组的下标，需要计算26的x次方的时候，可以直接从数组的下标为x的位置取值，节省重复计算时间。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        RK算法优化
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * rk字符串匹配</span></span><br><span class="line"><span class="comment">     * 改良：</span></span><br><span class="line"><span class="comment">     * 1、可以为所有字符串</span></span><br><span class="line"><span class="comment">     * 2、解决存在hash冲突</span></span><br><span class="line"><span class="comment">     * 3、优化hash函数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexRk2</span><span class="params">(<span class="keyword">char</span>[] main, <span class="keyword">char</span>[] pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mLen = main.length;</span><br><span class="line">        <span class="keyword">int</span> pLen = pattern.length;</span><br><span class="line">        <span class="keyword">int</span> pHash = hashPrime(pattern, <span class="number">0</span>, pLen);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mLen - pLen + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pHash == hashPrime(main, i, pLen)) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = <span class="number">0</span>, k = i;</span><br><span class="line">                <span class="keyword">while</span> (main[k++] != pattern[j++] || j &gt; pLen) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 0-255下所有的质数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">char</span>[] PRIME_NUMBERS = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">41</span>, <span class="number">53</span>, <span class="number">59</span>, <span class="number">61</span>, <span class="number">67</span>, <span class="number">71</span>, <span class="number">73</span>, <span class="number">79</span>, <span class="number">83</span>, <span class="number">89</span>, <span class="number">97</span>,</span><br><span class="line">            <span class="number">101</span>, <span class="number">103</span>, <span class="number">107</span>, <span class="number">109</span>, <span class="number">113</span>,</span><br><span class="line">            <span class="number">127</span>, <span class="number">131</span>, <span class="number">137</span>, <span class="number">139</span>, <span class="number">149</span>, <span class="number">151</span>, <span class="number">157</span>, <span class="number">163</span>, <span class="number">167</span>, <span class="number">173</span>,</span><br><span class="line">            <span class="number">179</span>, <span class="number">181</span>, <span class="number">191</span>, <span class="number">193</span>, <span class="number">197</span>, <span class="number">199</span>, <span class="number">211</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用0-255下所有的质数计算hash值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chars 字符数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 起始下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len   长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashPrime</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> start, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> primeLen = PRIME_NUMBERS.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; start + len; i++) &#123;</span><br><span class="line">            hash += PRIME_NUMBERS[Objects.hashCode(chars[i]) % primeLen];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<p><strong>时间复杂度：</strong><br>整个RK算法包含两个部分，计算子串哈希值和模式串哈希值与子串哈希值之间的比较。<br>第一部分通过设计特殊的哈希算法，只需要扫描一遍主串就能计算所有子串的哈希值，时间复杂度为O(n)。<br>第二部分，与每个子串哈希值比较的时间复杂度为O(1)，总共需要比较n-m+1个子串的哈希值，时间复杂度是O(n)<br>RK算法整体的时间复杂度为O(n)。  </p>
<p>其他哈希算法有散列冲突时，再对比一下子串和模式串本身。极端情况下，每次都要再对比子串和模式串本身，时间复杂度退化成O(n*m)。  </p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>一维字符串-&gt;二位字符串矩阵  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>字符串匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串匹配：BM</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%EF%BC%9ABM/</url>
    <content><![CDATA[<h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p>把模式串和主串的匹配过程，看做模式串在主串中不停地往后滑动。当遇到不匹配的字符时，BF和RK算法的做法是，模式串往后滑动一位，然后从模式串的第一个字符开始重新匹配。  </p>
<p>主串中的某个字符，在模式串中不存在，模式串向后滑动的时候，只要该字符与模式串有重合，肯定无法匹配，可以一次性把模式串往后多滑动几位，跳过一些肯定不会匹配的情况，以此来减少不必要的字符比较，提高匹配的效率。</p>
<h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p>BM算法包含两部分，分别是<strong>坏字符规则</strong>和<strong>好后缀规则</strong>。  </p>
<h4 id="坏字符规则"><a href="#坏字符规则" class="headerlink" title="坏字符规则"></a>坏字符规则</h4><p>BM算法的匹配顺序是按照模式串下标从大到小的顺序，倒着匹配的。<br>从模式串的末尾往前倒着匹配，当发现某个字符没法匹配的时候，把这个没有匹配的字符叫做<strong>坏字符</strong>(主串中的字符)。  </p>
<ol>
<li><p>拿坏字符在模式串中查找，发现模式串中并不存在这个字符，也就是说，主串中该字符与模式串中的任何字符都不可能匹配。这个时候，可以将模式串直接滑动到主串中该字符后面的位置，再从模式串的末尾字符开始比较。  </p>
</li>
<li><p>坏字符在模式串中是存在的。可以将模式串往后移动到坏字符与之匹配的字符对齐的地方，然后再从模式串的末尾字符开始，重新匹配。  </p>
</li>
</ol>
<blockquote>
<p>当发生不匹配的时候，把坏字符对应的模式串中的字符下标记作si。<br>如果坏字符在模式串中存在，把这个坏字符在模式串中的下标记作xi。如果不存在，把xi记作-1。模式串往后移动的位数就等于si-xi。(这里的下标，都是字符在模式串的下标。)<br>如果坏字符在模式串中里多处出现，在计算xi的时候，选择最靠后的那个，不会让模式串滑动过多，导致本来可能匹配的请款被滑动略过。  </p>
</blockquote>
<p>利用坏字符规则，BM算法在最好情况下的时间复杂度为O(n/m)。  </p>
<p>单纯使用坏字符规则，根据si-xi计算出来的移动位数，有可能是负数。不但不会向后滑动模式串，还有可能倒退。  </p>
<h4 id="好后缀规则"><a href="#好后缀规则" class="headerlink" title="好后缀规则"></a>好后缀规则</h4><p>把已经匹配的字符叫做好后缀，记作{u}。拿它在模式串中查找，如果找到了另一个跟{u}相匹配的子串{u<sup>*</sup>}，就将模式串滑动到子串{u<sup>*</sup>}与主串中{u}对齐的位置。<br>如果在模式串中找不到另一个等于{u}的子串，就直接将模式串滑动到主串中{u}的后面。<del>(之前的任何一次往后滑动，都不会有匹配主串中{u}的情况。)</del>  </p>
<p>当模式串中不存在等于{u}的子串时（好后缀在模式串中不存在可匹配的子串），直接将模式串滑动到主串{u}的后面，太过头。尽管在模式串中没有另外一个相匹配的子串{u<sup>*</sup>}，在一步步往后滑动模式串的过程中，只要主串中的{u}与模式串有重合，那肯定就无法完全匹配。但当模式串滑动到<strong>前缀</strong>与主串中{u}的<strong>后缀</strong>有部分重合的时候({u}可能是多个字符)，并且重合的部分相等，就有可能存在完全匹配的情况。  </p>
<p>不仅要看好后缀在模式串中，是否有另一个匹配的子串，还要考察好后缀的后缀子串，是否存在跟模式串的前缀子串匹配的。<br>所谓某个字符串s的后缀子串，就是最后一个字符跟s对齐的子串。<br>所谓前缀子串，就是其实字符跟s对齐的子串。<br>从好后缀的后缀子串中，找一个最长的并且能跟模式串的前缀子串匹配的，然后将模式串滑动到他们重合的位置。  </p>
<h4 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h4><p>档模式串和主串中的某个字符不匹配的时候，可以分别计算好后缀和坏字符往后滑动的位数，然后去两个数中最大的，作为模式串往后滑动的位数。可以避免，值根据坏字符规则，计算得到的往后滑动的位数，有可能是负数的情况。  </p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="坏字符"><a href="#坏字符" class="headerlink" title="坏字符"></a>坏字符</h4><p>拿坏字符在模式串中顺序遍历查找比较低效，将模式串中的每个字符及其下标都存到散列表中。<br>假设字符串的字符集不大，每个字符长度是1字节，用大小为256的数组，记录每个字符在模式串中出现的位置。数组的下标对应字符的ASCII码值，数组中存储这个字符在模式串中出现的位置。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        散列表预处理
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//b模式串，m模式串的长度，bc散列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">256</span>;<span class="comment">//全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">generateBC</span><span class="params">(<span class="keyword">char</span>[] b, <span class="keyword">int</span> m, <span class="keyword">int</span>[] bc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; ++i) &#123;</span><br><span class="line">        bc[i] = -<span class="number">1</span>;<span class="comment">//初始化bc</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> ascii = (<span class="keyword">int</span>)b[i];<span class="comment">//计算b[i]的ASCII值</span></span><br><span class="line">        bc[ascii] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        坏字符
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bm</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> n ,<span class="keyword">char</span>[] b, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bc[] = <span class="keyword">new</span> <span class="keyword">int</span>[SIZE];<span class="comment">//记录模式串中每个字符最后出现的位置</span></span><br><span class="line">    generateBC(b, m, bc);<span class="comment">//构建坏字符哈希表</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">//i表示主串与模式串对齐的第一个字符</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= n-m) &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;<span class="comment">//模式串从后往前匹配</span></span><br><span class="line">            <span class="keyword">if</span>(a[i+j] != b[j]) <span class="keyword">break</span>;<span class="comment">//坏字符对应模式串中的下标是j</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;<span class="comment">//匹配成功，返回主串与模式串第一个匹配的字符的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//相当于将模式串往后滑动j-bc[(int)a[i+j]]位</span></span><br><span class="line">        i = i + (j - bc[(<span class="keyword">int</span>)a[i+j]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<h4 id="好后缀"><a href="#好后缀" class="headerlink" title="好后缀"></a>好后缀</h4><ul>
<li>在模式串中，查找跟好后缀匹配的另一个子串；  </li>
<li>在好后缀的后缀子串中，查找最长的、能跟模式串前缀匹配的后缀子串；  </li>
</ul>
<p>好后缀也是模式串本身的后缀子串，可以在模式串和主串正式匹配之前，通过预处理模式串，预先计算好模式串的每个后缀子串，对应的另一个可匹配子串的位置。<br>后缀子串的最后一个字符的位置是固定的，下标为m-1，只需要纪录长度就可以了。通过长度，可以确定一个唯一的后缀子串。  </p>
<p>引入变量<strong>suffix数组</strong>。suffix数组的下标k，表示后缀子串的长度，下标对应的数组值存储的是，在模式串中跟好后缀(u)相匹配的子串(u*)的起始下标值。<br>如果模式串中有多个(大于1个)子串跟后缀子串{u}匹配，为了避免模式串往后滑动得过头了，suffix数组中存储模式串中最靠后的那个子串的起始位置，也就是下标最大的那个子串的其实位置。(滑动的距离小)  </p>
<p>引入另外一个boolean类型的<strong>prefix数组</strong>，记录模式串的后缀子串是否能匹配模式串的前缀子串。  </p>
<p>计算并填充两个数组的值。<br>拿下标从0到i的子串(i可以是0到m-2)与整个模式串，求公共后缀子串，如果公共后缀子串的长度是k，那就记录suffix[k]=j(j表示公共后缀子串的起始下标)。<br>如果j=0，说明，公共后缀子串也是模式串的前缀子串，记录prefix[k]=true。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        计算suffix与prefix
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//b表示模式串，m表示模式串长度</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">generateGS</span><span class="params">(<span class="keyword">char</span>[] b, <span class="keyword">int</span> m, <span class="keyword">int</span>[] suffix, <span class="keyword">boolean</span>[] predix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;<span class="comment">//初始化</span></span><br><span class="line">        suffix[i] = -<span class="number">1</span>;</span><br><span class="line">        prefix[i] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; m - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;<span class="comment">//公共后缀子串长度</span></span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; b[j] == b[m-<span class="number">1</span>-k]) &#123;<span class="comment">//与b[0,m-1]求公共后缀子串</span></span><br><span class="line">            --j;</span><br><span class="line">            ++k;</span><br><span class="line">            suffix[k] = j+<span class="number">1</span>;<span class="comment">//j+1表示公共后缀子串在b[0,i]中的起始下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j == -<span class="number">1</span>) prefix[k] = <span class="keyword">true</span>;<span class="comment">//如果公共后缀子串也是模式串的前缀子串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p>假设好后缀的长度是k。先拿好后缀在suffix数组中查找其匹配的子串，如果suffix[k]不等于-1(-1表示不存在匹配的子串)，就将模式串往后移动j-suffix[k]+1位(j表示坏字符对应的模式串中的字符下标)。如果suffix[k]等于-1，表示模式串中不存在另一个跟好后缀匹配的子串片段。<br>好后缀的后缀子串b[r,m-1]（r取值从j+2到m-1）的长度k=m-r，如果prefix[k]=true，表示长度为k的后缀子串，有可匹配的前缀子串，可以把模式串后移r位。<br>如果两条规则都没有找到可以匹配好后缀及其后缀子串的子串，就将整个模式串后移m位。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        BM算法
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a,b表示主串和模式串；n,m表示主串和模式串的长度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bm</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> n, <span class="keyword">char</span>[] b, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] bc = <span class="keyword">new</span> <span class="keyword">int</span>[SIZE];<span class="comment">//记录模式串中每个字符最后出现的位置</span></span><br><span class="line">    generateBC(b,m,bc);<span class="comment">//构建坏字符哈希表</span></span><br><span class="line">    <span class="keyword">int</span>[] suffix = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">    <span class="keyword">boolean</span>[] prefix = <span class="keyword">new</span> <span class="keyword">boolean</span>[m];</span><br><span class="line">    generateGS(b,m,suffix,prefix);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">//j表示主串与模式串匹配的第一个字符</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n-m) &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;<span class="comment">//模式串从后往前匹配</span></span><br><span class="line">            <span class="keyword">if</span>(a[i+j] != b[j]) <span class="keyword">break</span>;<span class="comment">//坏字符对应模式串中的下标是j</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;<span class="comment">//匹配成功，返回主串与模式串第一个匹配的字符的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> x = j - bc[(<span class="keyword">int</span>)a[i+j]];</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(j &lt; m-<span class="number">1</span>) &#123;<span class="comment">//如果有好后缀的话</span></span><br><span class="line">            y = moveByGS(j,m,suffix,prefix);</span><br><span class="line">        &#125;</span><br><span class="line">        i = i + Math.max(x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//j表示坏字符对应的模式串中的字符下标;m表示模式串长度</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">moveByGS</span><span class="params">(<span class="keyword">int</span> j, <span class="keyword">int</span> m, <span class="keyword">int</span>[] suffix, <span class="keyword">boolean</span>[] prefix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = m - <span class="number">1</span> -j;<span class="comment">//好后缀长度</span></span><br><span class="line">    <span class="keyword">if</span>(suffix[k] != -<span class="number">1</span>) <span class="keyword">return</span> j-suffix[k]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> r = j+<span class="number">2</span>; r &lt;= m-<span class="number">1</span>; ++r) &#123;</span><br><span class="line">        <span class="keyword">if</span>(prefix[m-r] == <span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<h3 id="性能分析及优化"><a href="#性能分析及优化" class="headerlink" title="性能分析及优化"></a>性能分析及优化</h3><h4 id="内存消耗"><a href="#内存消耗" class="headerlink" title="内存消耗"></a>内存消耗</h4><p>整个算法用到了额外的3个数组，其中bc数组的大小跟字符集大小有关，suffix数组和prefix数组的大小跟模式串长度m有关。  </p>
<p>处理字符集很大的字符串匹配问题，bc数组对内存的消耗会比较多，<strong>好后缀和坏字符规则是独立的</strong>，如果对内存要求苛刻，可以只是用好后缀规则，不使用坏字符规则，可以避免bc数组过多的内存消耗。  </p>
<h4 id="执行效率"><a href="#执行效率" class="headerlink" title="执行效率"></a>执行效率</h4><p>极端情况下，suffix数组、prefix数组的预处理的时间复杂度为O(m<sup>2</sup>)。<br>优化待扩展。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>字符串匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>拓扑排序</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="算法依赖的数据结构"><a href="#算法依赖的数据结构" class="headerlink" title="算法依赖的数据结构"></a>算法依赖的数据结构</h3><p>一个完整的项目会包含很多代码源文件。编译器在编译整个项目的时候，需要按照依赖关系，依次编译每个源文件。<br>把源文件与源文件之间的依赖关系，抽象成一个有向图。每个源文件对应图中的一个顶点，源文件之间的依赖关系就是顶点之间的边。  </p>
<p>如果a先于b执行，也就是说b依赖于a，那么就在顶点a和顶点b之间，构建一条从a指向b的边。这个图不仅要是有向图，还要是一个有向无环图，不能存在循环依赖关系。图中一旦出现环，拓扑排序就无法工作了。拓扑排序是基于<strong>有向无环图</strong>的算法。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        拓扑排序-数据结构- 图
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> v;<span class="comment">//顶点个数</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; adj[];<span class="comment">//邻接表，存放顶点指向的其他顶点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.v = v;</span><br><span class="line">        adj = <span class="keyword">new</span> LinkedList[v];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) &#123;</span><br><span class="line">            adj[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//s先于t，边 s-&gt;t</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        adj[s].add(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h3 id="算法的实现"><a href="#算法的实现" class="headerlink" title="算法的实现"></a>算法的实现</h3><p>拓扑排序有两种实现方法：<strong>Kahn算法</strong>和<strong>DFS深度优先搜索算法</strong>。  </p>
<ol>
<li><p>Kahn算法<br>Kahn算法实际上用的是贪心算法思想。<br>定义数据结构的时候，如果s需要先于t执行，那就添加一条s指向t的边。如果某个顶点入度为0，表示没有任何顶点必须先于这个顶点执行，那么这个顶点就可以执行了。  </p>
<p>先从图中找出一个入度为0的顶点，将其输出到拓扑排序的结果列中，并且把这个顶点从图中删除（把这个顶点可达的顶点的入度都减一）。循环执行上面的过程，直到所有的顶点都被输出。最后输出的序列，就是满足局部依赖关系的拓扑排序。  </p>
 <div class='spoiler collapsed'>
    <div class='spoiler-title'>
        拓扑排序-Kahn算法
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">topoSortByKahn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//统计每个顶点的入度</span></span><br><span class="line">    <span class="keyword">int</span>[] inDegree = <span class="keyword">new</span> <span class="keyword">int</span>[v];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; adj[i].size(); ++j) &#123;</span><br><span class="line">            <span class="comment">//顶点对应的邻接表，存放着该顶点指向的所有其他顶点（每个顶点的链表独立存储）</span></span><br><span class="line">            <span class="keyword">int</span> w = adj[i].get(j);<span class="comment">//i-&gt;w</span></span><br><span class="line">            inDegree[w]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkedList&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">//将入度为0的顶点加入队列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(inDegree[i] == <span class="number">0</span>) queue.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//从队列中取出一个入度为0的顶点</span></span><br><span class="line">        <span class="keyword">int</span> i = queue.remove();</span><br><span class="line">        System.out.print(<span class="string">"-&gt;"</span>+i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; adj[i].size(); ++j) &#123;</span><br><span class="line">            <span class="comment">//将该顶点指向的所有顶点的入度减1</span></span><br><span class="line">            <span class="keyword">int</span> k = adj[i].get(j);</span><br><span class="line">            inDegree[k]--;</span><br><span class="line">            <span class="comment">//处理后入度为0的顶点加入队列</span></span><br><span class="line">            <span class="keyword">if</span>(inDegree[k] == <span class="number">0</span>) queue.add(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>
</li>
<li><p>DFS算法<br>拓扑排序可以用深度优先搜索来实现。<br>深度优先遍历，遍历图中的所有顶点，并非只是搜索一个顶点到另一个顶点的路径。  </p>
 <div class='spoiler collapsed'>
    <div class='spoiler-title'>
        拓扑排序-DFS算法
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">topoSortByDFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先构建逆邻接表，边s-&gt;表示，s依赖于t，t先于s(与kahn相反)</span></span><br><span class="line">    LinkedList&lt;Integer&gt; inverseAdj[] = <span class="keyword">new</span> LinkedList[v];</span><br><span class="line">    <span class="comment">//申请空间</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) &#123;</span><br><span class="line">        inverseAdj[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++j) &#123;</span><br><span class="line">        <span class="comment">//通过邻接表生成逆邻接表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; adj[i].size(); ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> w = adj[i].get(j);<span class="comment">//i-&gt;w存在一条订单i到顶点w的有向边</span></span><br><span class="line">            inverseAdj[w].add(i);<span class="comment">//w-&gt;i</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[v];</span><br><span class="line">    <span class="comment">//深度优先遍历图</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[i] == <span class="keyword">false</span>) &#123;</span><br><span class="line">            visited[i] = <span class="keyword">true</span>;</span><br><span class="line">            dfs(i, inverseAdj, visited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> vertex, LinkedList&lt;Integer&gt; inverseAdj[], <span class="keyword">boolean</span>[] visited)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inverseAdj[vertex].size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> w = inverseAdj[vertex].get(i);</span><br><span class="line">        <span class="keyword">if</span>(visited[w] == <span class="keyword">true</span>) <span class="keyword">continue</span>;</span><br><span class="line">        visited[w] = <span class="keyword">true</span>;</span><br><span class="line">        dfs(w, inverseAdj, visited);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先把vertex这个顶点可达的所有顶点都打印出来之后，再打印它自己</span></span><br><span class="line">    System.out.print(<span class="string">"-&gt;"</span>+vertex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<p>算法包含两个关键部分<br>第一部分是通过邻接表构造逆邻接表。邻接表中，边s-&gt;t表示s先于t执行，也就是t要依赖s。在逆邻接表中，边s-&gt;t表示s依赖于t，s后于t执行。  </p>
<p>第二部分算法的核心，递归处理每个顶点。对于顶点vertex来说，先输出它可达的所有顶点，也就是先把它依赖的所有的顶点输出了，然后再输出自己。  </p>
</li>
</ol>
<p>时间复杂度分析：<br>Kahn代码中，每个顶点被访问了一次，每个边也被访问了一次，所以，Kahn算法的时间复杂度是O(V+E)（V表示顶点个数，E表示边的个数）。  </p>
<p>DFS算法中，每个顶点被访问两次，每条边被访问依次，时间复杂度为O(V+E)。</p>
<p>图可以是不连通的，有可能是好几个不连通的子图构成，所以E不一定大于V，两者大小关系不确定。在表示时间复杂度的时候，V、E都要考虑在内。  </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>凡是需要通过局部顺序来推导全局顺序的，一般都能用拓扑排序来解决。  </p>
<p>拓扑排序还能检测图中环的存在。<br>在Kahn算法中，如果最后输出出来的顶点个数，少于图中顶点个数，图中还有入度不是0的顶点，那就说明图中存在环。  </p>
<p>递归中，查找最终推荐人。每一次只查找一个用户的最终推荐人，不需要动用拓扑排序算法，只需要纪录已经访问过的用户ID，当用户ID第二次被访问的时候，说明存在环。  </p>
<p>如果求数据库中所有用户之间的推荐关系，有没有存在环的情况。把用户之间的推荐关系，从数据库中加载到内存中，然后构建成有向图数据结构，再利用拓扑排序快速检测出是否存在环。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>拓扑排序</tag>
        <tag>Kahn</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串匹配：KMP</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%EF%BC%9AKMP/</url>
    <content><![CDATA[<h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>KMP核心思想与BM类似，假设主串是a，模式串是b。在模式串与主串匹配的过程中，当遇到不可匹配的字符的时候，找到一些规律，将模式串往后多滑动几位，跳过那些肯定不会匹配的情况。  </p>
<p>在模式串和主串匹配的过程中，把不能匹配的那个字符叫做<strong>坏字符</strong>，把已经匹配的那段字符叫做<strong>好前缀</strong>。<br>当遇到坏字符的时候，把模式串往后滑动，在滑动的过程中，只要模式串和好前缀有上下重合，前面几个字符的比较，就相当于拿好前缀的后缀字符串，跟模式串的前缀子串在比较。  </p>
<p>拿到好前缀本身，在它的后缀子串中，查找最长的那个可以跟好前缀的前缀子串匹配。<br>假设最长的可匹配的那部分前缀子串是{v}，长度是k。把模式串一次性往后滑动j-k位，相当于，每次遇到坏字符的时候，就把j更新为k，i不变，然后继续比较。<br>把好前缀的所有后缀子串中，最长的可匹配前缀子串的那个后缀子串，叫做<strong>最长可匹配后缀子串</strong>；对应的前缀子串，叫做<strong>最长可匹配前缀子串</strong>。</p>
<p>模式串a b a b a c d<br>前缀子串a b a b a c  </p>
<table>
<thead>
<tr>
<th>子串</th>
<th>前缀</th>
<th>后缀</th>
<th>最大公共元素长度</th>
<th>前缀结尾字符下标</th>
<th>最长可匹配前缀子串结尾字符下标</th>
<th>next值</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>空</td>
<td>空</td>
<td>0</td>
<td>0</td>
<td>-1</td>
<td>next[0]=-1</td>
</tr>
<tr>
<td>ab</td>
<td>a</td>
<td>b</td>
<td>0</td>
<td>1</td>
<td>-1</td>
<td>next[1]=-1</td>
</tr>
<tr>
<td>aba</td>
<td><strong>a</strong>,ab</td>
<td><strong>a</strong>,ba</td>
<td>1</td>
<td>2</td>
<td>0</td>
<td>next[2]=0</td>
</tr>
<tr>
<td>abab</td>
<td>a,<strong>ab</strong>,aba</td>
<td>b,<strong>ab</strong>,bab</td>
<td>2</td>
<td>3</td>
<td>1</td>
<td>next[3]=1</td>
</tr>
<tr>
<td>ababa</td>
<td>a,ab,<strong>aba</strong>,abab</td>
<td>a,ba,<strong>aba</strong>,baba</td>
<td>3</td>
<td>4</td>
<td>2</td>
<td>next[4]=2</td>
</tr>
<tr>
<td>ababac</td>
<td>a,ab,aba,abab,ababc</td>
<td>c,ac,bac,abac,babac</td>
<td>0</td>
<td>5</td>
<td>0</td>
<td>next[5]=-1</td>
</tr>
</tbody></table>
<p>提前构建一个数组，用来存储模式串中每个前缀（这些前缀都有可能是好前缀）的最长可匹配前缀子串的结尾字符下标。把这个数组定义为<strong>next数组（失效函数）</strong>。<br>数组的下标是每个前缀结尾字符下标，数组的值是这个前缀的最长可以匹配前缀子串的结尾字符下标（子字符串的前缀集合与后缀集合的交集中最长元素的长度）。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        KMP算法框架
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a,b分别是主串和模式串；n,m分别是主串和模式串的长度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> n, <span class="keyword">char</span>[] b, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] next = getNext(b,m);</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; a[i] != b[j]) &#123;<span class="comment">//一直找到a[i]和b[j]</span></span><br><span class="line">            j = next[j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == b[j]) &#123;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j == m) &#123;<span class="comment">//找到匹配模式串的了</span></span><br><span class="line">            <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<blockquote>
<p>i始终是主串的下标；j始终是模式串的下标。（i是坏字符，j是坏字符对应模式串字符的下标）<br>在匹配中的任何时候，主串下标为i的字符永远和模式串下标为j的字符对齐。  </p>
</blockquote>
<h3 id="失效函数"><a href="#失效函数" class="headerlink" title="失效函数"></a>失效函数</h3><p>按照下标从小到大，依次计算next数组的值，当要计算next[i]的时候，前面的next[0],next[1],…,next[i-1]已经计算出来了，利用已经计算出来的next值，推导next[i]的值。（动态规划的思想）  </p>
<blockquote>
<p>前一个b[i-1]的最长串的下一个字符与最后一个b[i]相等，那next[i]=next[i-1]+1；否则就找前一个的次长串，递归迭代这个过程，直到找到或者完全没有。</p>
</blockquote>
<p>如果next[i-1]=k-1，也就是说，子串b[0,k-1]是b[0,i-1]的最长可匹配前缀子串，如果子串b[0,k-1]的下一个字符b[k]，与b[0,i-1]的下一个字符b[i]匹配，那子串b[0,k]就是b[0,i]的最长可匹配前缀子串。所以next[i]=k。  </p>
<p>如果b[0,k-1]的下一个字符b[k]跟b[0,i-1]的下一个字符b[i]不相等。<br>假设b[0,i]的最长可匹配后缀子串是[r,i]。如果把最后一个字符去掉，那b[r,i-1]肯定是b[0,i-1]的可匹配后缀子串，但不一定是最长可匹配后缀子串。所以，既然b[0,i-1]最长可匹配后缀子串对应的模式串的前缀子串的下一个字符并不等于b[i]，那么就可以考察b[0,i-1]的次长可匹配后缀子串b[x,i-1]对应的可匹配前缀子串b[0,i-1-x]的下一个字符b[i-x]是否等于b[i]。如果等于，那b[x,i]就是b[0,i]的最长可匹配后缀子串。  </p>
<p>次长可匹配后缀子串肯定被包含在最长可匹配后缀子串中，而最长可匹配后缀子串又对应最长可匹配前缀子串b[0,y]。查找b[0,i-1]的次长可匹配后缀子串，转化为查找b[0,y]的最长匹配后缀子串。  </p>
<p>考察完所有的b[0,i-1]的可匹配后缀子串b[y,i-1]，直到找到一个可匹配的后缀子串，它对应的前缀子串的下一个字符等于b[i]，那这个b[y,i]就是b[0,i]的最长可匹配后缀子串。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        失效函数
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getNexts(<span class="keyword">char</span>[] b, <span class="keyword">int</span> m) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(k != -<span class="number">1</span> &amp;&amp; b[k+<span class="number">1</span>] != b[i]) &#123;</span><br><span class="line">            k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b[k+<span class="number">1</span>] == b[i]) &#123;</span><br><span class="line">            ++k;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>KMP算法只需要一个额外的next数组，数组的大小跟模式串相同，空间复杂度为O(m)，m表示模式串的长度。  </p>
<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>KMP算法包含两部分，第一部分是构建next数组，第二部分是借助next数组匹配。  </p>
<p>第一部分，for循环i从1开始一直增加到m，而k并不是每次for循环都会增加，所以k累计增加的值肯定小于m。而while循环里k=next[k]，实际上是在减少k的值，k累积都没有增加超过m，所以while循环里面k=next[k]总的执行次数也不可能超过m。next数组计算的时间复杂度是O(m)。  </p>
<p>第二部分，i从0循环增长到n-1，j的增长量不可能超过i，所以肯定小于n。next[j-1]的值肯定小于j-1，所以while循环中的j=next[j-1]+1实际上也是在让j的值减少。而j总共增长的量都不会超过n，减少的量也不可能超过n，所以while循环中的这条语句总的执行次数也不会超过n。这部分的时间复杂度是O(n)。  </p>
<p>综合两部分的时间复杂度，KMP算法的时间复杂度为O(m+n)。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>字符串匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>Trie树</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Trie%E6%A0%91/</url>
    <content><![CDATA[<h3 id="Trie树定义"><a href="#Trie树定义" class="headerlink" title="Trie树定义"></a>Trie树定义</h3><p>Tire树-字典树。一个树形结构，专门处理字符串匹配的数据结构，用来解决在一组字符串集合中快速查找某个字符串的问题。  </p>
<p>Trie树的本质，利用字符串之间的公共前缀，将重复的前缀合并在一起。<br>根节点不包含任何信息，每个节点表示一个字符串中的字符，从根节点到各个“结尾节点”（不一定都是叶子节点）的一条路径表示一个字符串。  </p>
<p>Trie树的构造过程的每一步都相当于往Trie树中插入一个字符串，当所有字符串都插入完成之后，Trie树就构造好了。<br>在Trie树中查找一个字符串的时候，将要查找的字符串分割成单个的字符，然后从Trie树的根节点开始匹配。  </p>
<h3 id="实现Trie树"><a href="#实现Trie树" class="headerlink" title="实现Trie树"></a>实现Trie树</h3><ol>
<li>将字符串集合构造成Trie树（将字符串插入到Trie树）。<br>Trie树是一个多叉树，借助散列表的思想，通过一个下标与字符一一映射的数组，来存储子节点的指针。<br>假设字符串中只有从a-z这26个小写字母，在数据中下标为0的位置，存储指向子节点a的指针，下标为1的位置存储指向子节点b的指针，以此类推，下标为25的位置，存储的是指向子节点z的指针，如果某个字符的子节点不存在，在对应下标的位置存储null。</li>
<li>在Trie树中查询一个字符串<br>在trie树中查找字符串的时候，通过字符的ASCII码减去“a”的ASCII码，迅速找到匹配的字节点的指针。  </li>
</ol>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        BF算法
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span> data;</span><br><span class="line">    <span class="keyword">public</span> TrieNode[] children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isEndingChar = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">(<span class="keyword">char</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TrieNode root = <span class="keyword">new</span> TrieNode(<span class="string">'/'</span>);</span><br><span class="line">    <span class="comment">//往Trie树中插入一个字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span>[] text)</span> </span>&#123;</span><br><span class="line">        TrieNode p = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; text.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = text[i] - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(p.children[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                TrieNode newNode =<span class="keyword">new</span> TrieNode(text[i]);</span><br><span class="line">                p.children[index] = newNode;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        p.isEndingChar = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在Trie树中查找一个字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">select</span><span class="params">(<span class="keyword">char</span>[] pattern)</span> </span>&#123;</span><br><span class="line">        TrieNode p = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pattern.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = pattern[i] - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(p.children[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p.isEndingChar == <span class="keyword">false</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<p>构建Trie树的过程要扫描所有字符串，时间复杂度为O(n)，n表示虽有字符串的长度和。<br>构建好Trie树后，在其中查找字符串的时间复杂度为O(k)，k表示要查找的字符串的长度。  </p>
<h3 id="Trie树缺点及优化"><a href="#Trie树缺点及优化" class="headerlink" title="Trie树缺点及优化"></a>Trie树缺点及优化</h3><p>用数组存储一个节点的字节点的指针，如果字符串中包含从a到z这26个字符，那每个节点都要存储一个长度为26的数组，并且数组每个元素要存储一个8或者4字节指针。浪费内存。  </p>
<p><strong>优化</strong>：将每个节点的数组换成其他数据结构，来存储一个节点的子节点指针，有序数组、跳表、散列表、红黑树。<br>有序数组中的指针按照所指向的子节点中的字符的大小顺序排列。查询的时候，通过二分查找的方法，快速查找到某个字符应该匹配的子节点的指针。但是在往Trie树中插入一个字符串的时候，需要维护数组中数据的有序性。  </p>
<p><strong>变体</strong>：缩点优化，对于只有一个子节点的节点，而且此节点不是一个串的结束节点，可以将此节点与子节点合并。节省空间增加编码难度。  </p>
<p><strong>扩展</strong>：后缀树、DAT（双数组trie树）。  </p>
<h3 id="Trie树的使用场景"><a href="#Trie树的使用场景" class="headerlink" title="Trie树的使用场景"></a>Trie树的使用场景</h3><p>动态数据高效操作的数据结构：散列表、红黑树、跳表  </p>
<ul>
<li>字符串中包含的字符集不能太大。浪费存储空间。  </li>
<li>字符串的前缀重合比较多。  </li>
<li>需要从零开始实现一个Trie树。  </li>
<li>用到了指针，数据块不连续，堆缓存不友好。  </li>
</ul>
<p>Trie树不适合精确匹配查找（散列表、红黑树），比较适合查找前缀匹配的字符串。搜索引擎提示关键词、输入法自动补全、IDE代码编辑器自动补全、浏览器啊网址输入自动补全、屏蔽字/敏感词检测。  </p>
<h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><ul>
<li>复杂中文实现  </li>
<li>前缀匹配过多，选择展示  </li>
<li>拼写错误，校正提示  </li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>Apache Commons<br>PatriciaTrie<br>AbstractPatriciaTrie  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希算法</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="哈希算法定义"><a href="#哈希算法定义" class="headerlink" title="哈希算法定义"></a>哈希算法定义</h3><p>散列=哈希<br>将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是<strong>哈希算法</strong>，通过原始数据映射之后得到的二进制值串就是<strong>哈希值</strong>。  </p>
<ul>
<li>从哈希值不能反向推导出原始数据（哈希算法也叫单项哈希算法）；  </li>
<li>对输入数据非常敏感，哪怕原始数据只修改了一个Bit，最后得到的哈希值也大不相同；  </li>
<li>散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小；  </li>
<li>哈希算法的执行效率要尽量高效，针对较长的文本，也能快速的计算出哈希值。  </li>
</ul>
<h3 id="哈希算法应用"><a href="#哈希算法应用" class="headerlink" title="哈希算法应用"></a>哈希算法应用</h3><h4 id="安全加密（数字签名-信息摘要）"><a href="#安全加密（数字签名-信息摘要）" class="headerlink" title="安全加密（数字签名/信息摘要）"></a>安全加密（数字签名/信息摘要）</h4><p>最常用于加密的哈希算法是MD5（MD5 Message-Digest Algorithm，MD5消息摘要算法）和SHA（Secure Hash Algorithm，安全散列算法）。  </p>
<p>其他加密算法（非哈希）DES（Data Encryption Standard，数据加密标准）、AES（Advanced Encryption Standard，高级加密标准）。  </p>
<p>第一很难根据哈希值反向推导出原始数据。<br>第二散列冲突的概率要很小。鸽巢原理（抽屉原理）  </p>
<p>哈希算法产生的哈希值的长度是固定且有限的。基于鸽巢原理，必然会存在哈希值相同的情况。一般情况下，哈希值越长的哈希算法，散列冲突的概率越低。<br>没有绝对安全的加密，越复杂、越难破解的加密算法，需要的计算时间也越长。  </p>
<p>针对字典攻击，可以引入一个盐salt，跟用户密码组合在一起，增加密码的复杂度。拿组合之后的字符串来做哈希算法加密，将它存储到数据库中，进一步增加破解的难度。</p>
<h4 id="唯一标识"><a href="#唯一标识" class="headerlink" title="唯一标识"></a>唯一标识</h4><p>哈希算法可以对大数据做信息摘要，通过一个较短的二进制编码来表示很大的数据。<br>将每一个图片开头、中间、结尾分别取一部分字节，通过哈希算法，得到一个哈希字符串，用它作为图片的额唯一标识。通过这个唯一标识来判定图片是否在图库，可以减少很多工作量。  </p>
<h4 id="数据校验"><a href="#数据校验" class="headerlink" title="数据校验"></a>数据校验</h4><p>校验数据的完整性和正确性。<br>BT协议，将一个大文件分成多块小文件，通过哈希算法，对小文件块分别取哈希值，并保存在种子文件中。当文件块下载完成之后，可以通过相同的哈希算算发，对下载好的文件块逐一求哈希值，然后跟种子文件中保存的哈希值比对。如果不同，说明这个文件块不完整或者被篡改了，需要再重新从其他宿主及其上下载这个文件块。  </p>
<h4 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h4><p>散列函数是涉及一个散列表的关键。它直接决定了散列冲突的概率和散列表的性能。<br>散列函数对于散列算法冲突的要求低很多，即便出现个别散列冲突，只要不是过于严重，都可以通过开放寻址法或者链表法解决。<br>散列函数更加关注散列后的值是否能平均分布，使一组数据能均匀的散列在各个槽中。<br>散列函数用的散列算法一般都比较简单，比较追求效率，注重性能。  </p>
<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>轮询、随机、加权轮询等都属于负载均衡算法。<br>在同一个客户端上，在一次绘画中的所有请求都路由到同一个服务器上。需要会话粘滞的负载均衡算法。  </p>
<ul>
<li><p>维护一张映射关系表，表的内容是客户端IP地址或者会话ID与服务器编号的映射关系，客户端发出的每次请求，都要先在映射表中查找应该路由到的服务器编号，然后再请求编号对应的服务器。  </p>
<blockquote>
<p>客户端很多，映射表很大，比较浪费内存空间；客户端下线、上线，服务器扩容、缩容都会导致映射失败，维护映射表的成本会很大。  </p>
</blockquote>
</li>
<li><p>通过哈希算法，对客户端IP地址或者会话ID计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该被路由道德服务器编号。这样就可以把同一个Ip过来的所有请求都路由到同一个后端服务器上。  </p>
</li>
</ul>
<h4 id="数据分片"><a href="#数据分片" class="headerlink" title="数据分片"></a>数据分片</h4><ol>
<li><p>统计搜索关键词出现的次数<br>1T的日志文件，记录了用户的搜索关键词，要快速的统计出每个关键词被搜索的次数 。<br>先对数据进行分片，然后采用多肽及其处理的方法，来提高处理速度。用n台机器进行处理。从搜索记录的日志文件中，依次读出每个搜索关键词，并且通过哈希函数计算哈希值，然后再跟n取模，最终得到的值，就是应该被分配到的机器编号。<br>哈希值相同的搜索关键词就被分配到了同一个机器上。每个机器分别计算关键词出现的次数，最后合并起来就是最终的结果。  </p>
</li>
<li><p>快速判断图片是否在图库中<br>1亿张图片，在单台机器上构建散列表是行不通的。单台机器的内存有限。<br>对数据进行分片，然后采用多机处理。准备n台及其，让每台机器只维护某一部分图片对应的散列表。每次从图库中读取一个图片，计算唯一标识，然后与机器个数n求余取模，得到的值就对应要分配的机器编号，然后将这个图片的唯一标识和图片路径发往对应的及其构架散列表。<br>当要判断一个图片是否在图库中的时候，通过同样的哈希算法，计算这个图片的唯一标识，然后与机器个数n求余取模。假设得到的值是k，那就去编号k的机器构建的散列表中查找。  </p>
</li>
</ol>
<p>针对海量数据的处理问题，都可以采用多机分布式处理。借助分片的思路，突破单机内存、CPU等资源的限制。  </p>
<h4 id="分布式存储"><a href="#分布式存储" class="headerlink" title="分布式存储"></a>分布式存储</h4><p>为了提高互联网海量用户海量数据的读取、写入能力，采用分布式的方式来存储。<br>用数据分片的思想，采用哈希算法对数据取哈希值，然后对机器个数取模，最终值就是应该存储的缓存机器编号。<br>数据增多扩容时，所有的数据都要重新计算哈希值，然后重新搬移到正确的机器上。相当于缓存中的数据一下子都失效了，所有的数据请求都会穿透缓存，直接去请求数据库，这样可能发生雪崩效应，压垮数据库。  </p>
<p>解决方法，一致性哈希算法。<br>假设有k个机器，数据的哈希值的范围是[0,MAX]。将整个分为划分成m个小区间（m远大于k），每个机器负责m/k个小区间。当有新机器加入的时候，就将某几个小区间的数据，从原来的机器中搬移到新的机器中。这样既不用全部重新哈希、搬移数据，也保持了各个机器上数据数量的均衡。  </p>
<p>一致性哈希一般会借助一个虚拟的环和虚拟节点，更加优美的实现出来。  </p>
<p>把服务器映射到hash环，将需要缓存的对象也映射到hash环上，从对象映射的位置开始，沿顺时针方向遇到的第一个服务器，就是要缓存到的服务器。服务器数量发生改变时，并不是所有的缓存都会失效，只有部分缓存会失效（当前服务器位置与其逆时针前一个位置的缓存失效)。<br>服务器映射到hash环上的时候，很有可能出现hash环偏斜的情况，缓存会极不平衡的分布在各个服务器上。虚拟节点解决分配不均问题。虚拟节点是实际节点在hash环上的复制品，均匀的分布在环上，一个实际节点可以对应多个虚拟节点。虚拟节点越多，hash环上的节点就越多，缓存被均匀分布的概率就越大。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>哈希算法</tag>
      </tags>
  </entry>
  <entry>
    <title>跳表</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%B7%B3%E8%A1%A8/</url>
    <content><![CDATA[<p>二分查找底层依赖的是数组随机访问的特性。只能用数组来实现。  </p>
<p>跳表是一种各方面性能都比较优秀的<strong>动态数据结构</strong>，可以支持快速的插入、删除、查找操作。（类似于链表的二分查找实现）  </p>
<h3 id="理解跳表"><a href="#理解跳表" class="headerlink" title="理解跳表"></a>理解跳表</h3><p>对于一个单链表来讲，即使链表中存储的数据是有序的，如果想在其中查找某个数据，也只能从头到尾遍历链表。查找效率低，时间复杂度高，O(n)。  </p>
<p>对链表建立一级“索引”，提高查找效率。每两个结点提取一个结点到上一级，把抽出来的那一级叫作索引或索引层，down指针指向下一级结点。<br>查找某个结点时，可以先在索引层遍历，当遍历到索引层中目标结点附近，通过索引层结点的down指针，下降到原始链表这一层，继续遍历，找到目标值的结点。<br>加一层索引之后，查找一个结点需要遍历的结点个数减少了，查找次数减少了、效率提高了。<br>类似的，可以在第一级索引的基础之上，每两个结点就抽出一个结点到第二级索引，查询效率进一步提升。  </p>
<p><strong>链表加多级索引的结构，就是跳表</strong>。  </p>
<h3 id="跳表查询时间"><a href="#跳表查询时间" class="headerlink" title="跳表查询时间"></a>跳表查询时间</h3><p>查询数据的时间复杂度推算：</p>
<p>每两个结点抽出一个结点作为上一级索引的结点，第一级索引的结点个数大约为n/2，第二级索引的结点个数大约为n/4，第三极结点个数大约为n/8，以此类推，第k级索引的结点个数是第k-1级索引的结点个数的1/2，第k级索引结点的个数就是n/(2<sup>k</sup>)。  </p>
<p>假设索引有h级，最高级的索引有2个结点。通过公式，可以得到n/(2<sup>h</sup>)=2，求得h=log<sub>2</sub>n-1。如果包含原始链表这一层，整个跳表的高度就是log<sub>2</sub>n。<br>在跳表中查询某个数据的时候，如果每一层都要遍历m个结点，那么在跳表中查询一个数据的时间复杂度为O(m*logn)。  </p>
<p>每一级索引最多只需要遍历m个结点，在跳表中查询任意数据的时间复杂度是O(logn)。与二分查找的时间复杂度相同，等同于基于单链表实现了二分查找。  </p>
<h3 id="跳表空间占用"><a href="#跳表空间占用" class="headerlink" title="跳表空间占用"></a>跳表空间占用</h3><p>比起单纯的单链表，跳表需要存储多级索引，肯定要消耗更多的存储空间。<br>假设原始链表大小为n，每2个结点抽一个作为上一级索引的结点。每上升一级索引，结点个数就减少一半，知道剩下2个结点。每层索引的结点数就是一个等比数列，索引结点总和就是n/2+n/4+n/8+…+4+2=n-1。所以跳表的空间复杂度为O(n)。<br>如果将包含n个结点的单链表构造成跳表，需要额外再用接近n个结点的存储空间。<br>每三个结点抽一个，总的索引结点大约是n/3+n/9+n/27+…+9+3+1=n/2。类推可以减少索引节点存储空间。  </p>
<p>实际开发中，原始链表中存储的可能是很大的对象，索引结点只需要存储关键值和几个指针，并不需要存储对象，所以当对象比索引结点大很多时，索引所占用的额外空间可以忽略。  </p>
<h3 id="跳表插入和删除"><a href="#跳表插入和删除" class="headerlink" title="跳表插入和删除"></a>跳表插入和删除</h3><p>跳表插入、删除操作的时间复杂度为O(logn)。  </p>
<p>在单链表中，一旦定位好要插入的位置，插入结点的时间复杂度是很低的为O(1)。但为了保证原始链表中数据的有序性，需要先查找到要插入的位置，这个查找操作比较耗时。<br>对于纯粹的单链表，需要遍历每个节点来查找到插入的位置。但是对于跳表来说，查找到某个结点的时间复杂度为O(logn)，查找到某个数据应该插入的位置的时间复杂度就为O(logn)。</p>
<p>删除操作，如果要删除的结点在索引中也有出现，除了要删除原始链表中的结点，还要删除索引中的。<br>单链表中的删除操作需要拿到要删除结点的前驱节点，然后通过指针操作完成删除，在查找要删除的结点的时候，要获取前驱节点。双向链表不需要。  </p>
<h3 id="跳表索引动态更新"><a href="#跳表索引动态更新" class="headerlink" title="跳表索引动态更新"></a>跳表索引动态更新</h3><p>当不停的往跳表中插入数据时，如果不更新索引，有可能出现某2个索引结点之间数据非常多的情况。极端情况下，跳表会退化成单链表。  </p>
<p>跳表通过随机函数来维护平衡性。<br>往跳表中插入数据的时候，可以选择同时将数据插入到部分索引层中。<br>如随机函数生成了值K，就将这个结点添加到第一级到第K级这K级索引中。  </p>
<h3 id="跳表与红黑树对比"><a href="#跳表与红黑树对比" class="headerlink" title="跳表与红黑树对比"></a>跳表与红黑树对比</h3><p>插入、删除、查找、迭代输出有序序列的操作，跳表与红黑树的时间复杂度相同。<br>按照区间查找数据操作，红黑树的效率没有跳表高。跳表可以做到O(logn)的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以，非常高效。<br>红黑树在编程语言中一般有现成的实现；跳表没有，需要自己实现再使用。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>跳表</tag>
      </tags>
  </entry>
  <entry>
    <title>红黑树</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    <content><![CDATA[<p>二叉查找树，支持快速插入、删除、查找操作，各个操作的时间复杂度跟树的高度成正比，理想情况下，时间复杂度是O(logn)。  </p>
<p>二叉查找树在频繁的动态更新过程中，可能会出现树的高度远大于log<sub>2</sub>n的情况，从而导致各个操作的效率下降。极端情况下，二叉树会退化为链表，时间复杂度会退化到O(n)。<br>需要平衡二叉查找树，解决普通二叉查找树在频繁的插入、删除等动态更新的情况下，出现时间复杂度退化的问题。  </p>
<h3 id="平衡二叉查找树定义"><a href="#平衡二叉查找树定义" class="headerlink" title="平衡二叉查找树定义"></a>平衡二叉查找树定义</h3><p>二叉树中任意一个节点得左右子树的高度相差不能大于1。完全二叉查找树、满二叉树都是<strong>平衡二叉树</strong>。平衡二叉查找树还需要满足二叉查找树的特点。AVL树。  </p>
<p>平衡二叉查找树中“平衡”的意思，其实就是让整棵树左右看起来比较“对称”、比较“平衡”，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些。<br>树的高度不比log<sub>2</sub>n很多。  </p>
<h3 id="红黑树定义"><a href="#红黑树定义" class="headerlink" title="红黑树定义"></a>红黑树定义</h3><p>红黑树”Red-Black Tree”，简称R-B Tree。是一种不严格的平衡二叉查找树。  </p>
<p>红黑树中的节点，一类被标记为黑色，一类被标记为红色。  </p>
<ul>
<li>根节点是黑色的；</li>
<li>每个叶子节点都是黑色的空节点(NIL)，叶子节点不存储数据；<blockquote>
<p>主要是为了简化红黑树的代码实现。（共用一个黑色的、空的叶子节点。避免浪费存储空间。）</p>
</blockquote>
</li>
<li>任何相邻的节点都不能同时为红色，红色节点是被黑色节点隔开的；</li>
<li>每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；</li>
</ul>
<blockquote>
<p>红黑树就是用红链接表示3-节点的2-3树。2-节点(包含一个元素，两条子链接)，3-节点(包含两个元素，三条链接)<br>红链接将两个2-节点连接起来构成一个3-节点，黑链接则是2-3树中的普通链接。<br>红色节点标记代表指向其的链接是红链接，黑色标记的节点就是普通的节点。红色节点可以与其父节点合并为一个3-节点。  </p>
<ul>
<li>红链接均为左链接（左倾红黑树）；</li>
<li>没有任何一个结点同时和两条红链接相连；</li>
<li>该树是完美黑色平衡的，任意空链接到根节点的路径上的黑链接数量相同。  </li>
</ul>
</blockquote>
<blockquote>
<p>将红黑树中所有的红色链接放平，那么它所有的叶子节点到根节点的距离都是相同的。如果将由红链接相连的节点合并，得到的就是一棵2-3树。<br>父节点指向的节点是红节点，那么就认为这两个节点其实就是2-3树里面的3节点。如果有一个黑节点连接了连个红节点，那么就认为这是一个4-节点，因为2-3树不允许4-节点，所以要将其提取出来。<br>所谓的旋转，对于2-3树来说节点并没有变化。因为红节点和指向它的节点本来就被认为是一个节点。  </p>
</blockquote>
<h3 id="实现红黑树"><a href="#实现红黑树" class="headerlink" title="实现红黑树"></a>实现红黑树</h3><p>在插入、删除节点的过程中，第三、第四点要求可能会被破坏。<br>平衡调整实际上就是要把被破坏的第三、第四点回复过来。  </p>
<p>左旋(rotate left)围绕某个节点的左旋。逆时针<br>右旋(rotate right)围绕某个节点的右旋。顺时针  </p>
<h4 id="插入操作的平衡调整"><a href="#插入操作的平衡调整" class="headerlink" title="插入操作的平衡调整"></a>插入操作的平衡调整</h4><p>红黑树规定，<strong>插入的节点必须是红色的</strong>。而且，二叉查找树中<strong>新插入的节点都是放在叶子节点上</strong>。  </p>
<ul>
<li>如果插入结点的父节点是黑色的，那什么都不用做，它仍然满足红黑树的定义。  </li>
<li>如果插入的节点是根节点，那么直接改变它的颜色，把它变成黑色就可以了。  </li>
<li>其他情况都会违背红黑树的定义，需要进行调整，调整的过程包含两种基础的操作：<strong>左右旋转和改变颜色</strong>。  </li>
</ul>
<p>红黑树的平衡调整过程是一个迭代的过程。把正在处理的节点叫做关注节点。关注节点会随着不停的迭代处理，而不断发生变化。最开始的关注节点就是新插入的节点。  </p>
<ol>
<li><p>如果关注节点是a，它的叔叔节点d是红色：  </p>
<ul>
<li>将关注节点a的父节点b、叔叔节点d的颜色都设置成黑色；  </li>
<li>将关注节点a的祖父节点c的颜色设置成红色；  </li>
<li>关注节点变成a的祖父节点c;  </li>
<li>跳到情况2或者情况3。  </li>
</ul>
</li>
<li><p>如果关注节点是a，它的叔叔节点d是黑色，关注节点a是其父节点b的右子节点：  </p>
<ul>
<li>关注节点变成节点a的父节点b；  </li>
<li>围绕新的关注节点b左旋；  </li>
<li>跳到情况3。  </li>
</ul>
</li>
<li><p>如果关注节点是a，它的叔叔节点d是黑色，关注节点a是其父节点b的左子节点：  </p>
<ul>
<li>围绕关注节点a的祖父节点c右旋；  </li>
<li>将关注节点a的父节点b、兄弟节点c的颜色互换。  </li>
<li>调整结束</li>
</ul>
</li>
</ol>
<h4 id="删除操作的平衡调整"><a href="#删除操作的平衡调整" class="headerlink" title="删除操作的平衡调整"></a>删除操作的平衡调整</h4><p>删除操作的平衡调整分为两步，第一步是针对删除节点初步调整。初步调整只是保证整棵红黑树在一个节点删除之后，仍然满足最后一条定义的要求，每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；第二部是针对关注节点进行二次调整，让它满足红黑树的第三条定义，即不存在相邻的两个红色节点。  </p>
<p><strong>第一步，针对删除节点初步调整。</strong><br>经过初步调整之后，为了保证满足红黑树定义的最后一条要求，有些节点会被标记成两种颜色，“红-黑”或者“黑-黑”。如果一个节点被标记为了“黑-黑”，在计算黑色节点个数的时候，要算成两个黑色节点。  </p>
<ol>
<li><p>如果要删除的节点是a，它只有一个子节点b：  </p>
<ul>
<li>删除节点a，并且把节点b替换到节点a的位置，此操作跟普通的二叉查找树的删除操作一样；  </li>
<li>节点a只能是黑色，节点b只能是红色，其他情况均不符合红黑树的定义。把节点b改成黑色；  </li>
<li>调整结束，不需要进行二次调整。  </li>
</ul>
</li>
<li><p>如果要删除的节点a有两个非空子节点，并且它的后继节点就是节点a的右子节点c：  </p>
<ul>
<li>如果节点a的后继节点就是右子节点c，那右子节点c肯定没有左子树。把节点a删除，并且将节点c替换到节点a的位置。此操作与二叉查找树的删除操作一样；</li>
<li>然后把节点c的颜色设置为跟节点a相同的颜色；</li>
<li>如果节点c是黑色，为了不违反红黑树的最后一条定义，给节点c的右子节点d多加一个黑色，此时节点d就成了“红-黑”或者“黑-黑”；</li>
<li>关注节点变成节点d，第二步的调整操作就会针对关注节点来做。  </li>
</ul>
</li>
<li><p>如果要删除的是节点a，它有两个非空子节点，并且节点a的后继节点不是右子节点：  </p>
<ul>
<li>找到后继节点d，并将它删除，删除后继节点d的过程参照情况1；  </li>
<li>将节点a替换成后继节点d；  </li>
<li>把节点d的颜色设置为跟节点a相同的颜色；  </li>
<li>如果节点d是黑色，为了不违反红黑树的最后一条定义，给节点d的右子节点c多加一个黑色，此时节点c就成了“红-黑”或者“黑-黑”；  </li>
<li>关注节点变成了节点c，第二步的调整操作就会针对关注节点来做。  </li>
</ul>
</li>
</ol>
<p><strong>第二步，针对关注节点进行二次调整。</strong><br>经过初步调整之后，关注节点变成了“红-黑”或者“黑-黑”节点。针对关注节点的二次调整是为了让红黑树中不存在相邻的红色节点。  </p>
<ol>
<li><p>关注节点是a，它的兄弟节点c是红色的：  </p>
<ul>
<li>围绕关注节点a的父节点b左旋；  </li>
<li>关注节点a的父节点b和祖父节点c交换颜色；  </li>
<li>关注节点不变；  </li>
<li>继续从四种情况中选择适合的规则来调整。  </li>
</ul>
</li>
<li><p>关注节点是a，它的兄弟节点c是黑色的，并且节点c的左右子节点d、e都是黑色的：  </p>
<ul>
<li>将关注节点a的兄弟节点c的颜色变成红色；  </li>
<li>从关注节点a中去掉一个黑色，此时节点a就是单纯的红色或者黑色；  </li>
<li>给关注节点a的父节点b添加一个黑色，此时节点b就变成了“红-黑”或者“黑-黑”；  </li>
<li>关注节点从a变成其父节点b；  </li>
<li>继续从四种情况中选择符合的规则来调整。  </li>
</ul>
</li>
<li><p>关注节点是a，它的兄弟节点c是黑色，c的左子节点d是红色，c的右子节点e是黑色：  </p>
<ul>
<li>围绕关注节点a的兄弟节点c右旋；  </li>
<li>节点c和节点d交换颜色；  </li>
<li>关注节点不变；  </li>
<li>跳转到情况4，继续调整。  </li>
</ul>
</li>
<li><p>关注节点a的兄弟节点c是黑色的，并且c的右子节点是红色的：  </p>
<ul>
<li>围绕关注节点a的父节点b左旋；  </li>
<li>将关注节点a的兄弟节点c的颜色，跟关注节点a的父节点b设置成相同的颜色；  </li>
<li>将关注节点a的父节点b的颜色设置为黑色；  </li>
<li>从关注节点a中去掉一个黑色，节点a就变成了单纯的红色或者黑色；  </li>
<li>将关注节点a的叔叔节点e设置为黑色；  </li>
<li>调整结束。  </li>
</ul>
</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title>递归树</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92%E6%A0%91/</url>
    <content><![CDATA[<h3 id="递归树"><a href="#递归树" class="headerlink" title="递归树"></a>递归树</h3><p>递归的思想，将大问题分解为小问题来求解，然后再将小问题分解为小小问题。这样一层一层的分解，直到问题的数据规模被分解得足够小，不用继续递归分解为止。<br>如果把这个一层一层分解过程画成图，它其实就是一棵树—递归树。  </p>
<p>归并的时间复杂度、快排的最好情况时间复杂度适合用递推公式分析。<br>快排平均时间复杂度适合用递归树分析。<br>二叉树的前中后序遍历都不适合。  </p>
<h3 id="归并排序的时间复杂度"><a href="#归并排序的时间复杂度" class="headerlink" title="归并排序的时间复杂度"></a>归并排序的时间复杂度</h3><p>归并排序每次会将数据规模一分为二。因为每次分解都是一分为二，所以代价很低，把时间上的消耗记作常量l。归并算法中比较耗时的是归并操作，也就是把连个子数组合并为大数组。每一层归并操作消耗的时间总和是一样的，跟要排序的数据规模有关，把每一层归并操作消耗的时间记作n。  </p>
<p>只需要知道这棵树的高度h，用高度h乘以每一层的时间消耗n，就可以得到总的时间复杂度O(n*h)。<br>归并排序递归树是一棵满二叉树，满二叉树的高度大约是log<sub>2</sub>n，归并排序的时间复杂度就是O(nlogn)。  </p>
<h3 id="快速排序的时间复杂度"><a href="#快速排序的时间复杂度" class="headerlink" title="快速排序的时间复杂度"></a>快速排序的时间复杂度</h3><h4 id="递推公式分析时间复杂度"><a href="#递推公式分析时间复杂度" class="headerlink" title="递推公式分析时间复杂度"></a>递推公式分析时间复杂度</h4><p>快速排序在最好情况下，每次分区都能一分为二，此时用递推公式T(n)=2T(n/2)+n，推导出时间复杂度是O(nlogn)。  </p>
<p>平均情况下，每次分区之后，两个分区的大小比例为1:k。当k=9时，如果用递推公式的方法求解时间复杂度，递推公式为T(n)=T(n/10)+T(9n/10)+n。  </p>
<h4 id="递归树分析时间复杂度"><a href="#递归树分析时间复杂度" class="headerlink" title="递归树分析时间复杂度"></a>递归树分析时间复杂度</h4><p>快速排序的过程中，每次分区都要遍历待分区区间的所有数据，每一层分区操作所遍历的数据的个数之和就是n。只要求出递归树的高度h，快排过程遍历的数据个数就是h*n，时间复杂度就是O(h*n)。</p>
<p>每次分区并不是均匀的一分为二，递归树并不是满二叉树。<br>快速排序结束的条件是排序的小区间大小为1，即叶子节点里的数据规模是1。从根节点n到叶子节点1，递归树中最短的一个路径每次都乘以1/10，最长的一个路径每次都乘以9/10。计算后可得，从根节点到叶子节点的最短路径是log<sub>10</sub>n，最长路径是log<sub>10/9</sub>n。<br>遍历数据的个数总和就介于nlog<sub>10</sub>n和nlog<sub>10/9</sub>n之间。根据复杂度的大O表示法，对数复杂度的底数不管是多少，统一写成logn。所以当分区大小比例是1:9时，快速排序的时间复杂度仍然是O(nlogn)。  </p>
<p>只要k的值不随n变化，是一个事先确定的常量，快排的时间复杂度就是O(nlogn)。  </p>
<h3 id="斐波那契数列的时间复杂度"><a href="#斐波那契数列的时间复杂度" class="headerlink" title="斐波那契数列的时间复杂度"></a>斐波那契数列的时间复杂度</h3><p>递推公式f(n)=f(n-1)+f(n-2)。<br>递归代码画成递归树。f(n)分解为f(n-1)和f(n-2)，每次数据规模都是-1或者-2，叶子节点的数据规模是1或者2。所以从根节点走到叶子节点，每条路径是长短不一的。如果每次都是-1，那最长路径大约是n；如果每次都是-2，那最短路径大约是n/2。  </p>
<p>每次分解之后的合并操作只需要一次加法运算，把加法运算的时间消耗记作1。从上往下，第一层的总时间消耗是1，第二层的总时间消耗是2，第三层的总时间消耗是2<sup>2</sup>。依次类推，第k层的时间消耗就是2<sup>k-1</sup>，整个算法的总时间消耗就是每一层时间消耗之和。  </p>
<p>如果路径长度都为n，总和就是2<sup>n</sup>-1。<br>如果路径长度都是n/2，那总和是2<sup>n/2</sup>-1。<br>所以算法的时间复杂度介于O(2<sup>n</sup>)和O(2<sup>n/2</sup>)之间。指数级。  </p>
<h3 id="全排列的时间复杂度"><a href="#全排列的时间复杂度" class="headerlink" title="全排列的时间复杂度"></a>全排列的时间复杂度</h3><p>把n个数据的所有排列都找出来，就是全排列的问题。<br>可以用递归来打印一组数据的所有排列。  </p>
<p>如果确定了最后一位数据，就变成求解剩下n-1个数据的排列问题。最后一个数据可以是n个数据中的任意一个，它的取值有n种情况。“n个数据的排列”问题，可以分解成n个“n-1个数据的排列”的子问题。  </p>
<p>递推公式：<br>f(1,2,…n) = {最后一位是1, f(n-1)} + {最后一位是2, f(n-1)} +…+{最后一位是n, f(n-1)}  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        全排列
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printPermutations</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            System.out.print(data[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = data[i];</span><br><span class="line">        data[i] = data[k-<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        printPermutations(data, n, k-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        tmp = data[i];</span><br><span class="line">        data[i] = data[k-<span class="number">1</span>];</span><br><span class="line">        data[k-<span class="number">1</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p>画出递归树<br>第一层分解有n次交换操作，第二层有n个节点，每个节点分解需要n-1次交换，所以第二层总的交换次数是n<em>(n-1)。第三层有n</em>(n-1)个节点，每个节点分解需要n-2次，所以第三层总的交换次数是n<em>(n-1)</em>(n-2)。  </p>
<p>以此类推，第k层总的交换次数就是n<em>(n-1)</em>(n-2)<em>…</em>(n-k+1)。最后一层的交换次数就是n*(n-1)*(n-2)*…*2*1。每一层的交换次数之和就是总的交换次数。  </p>
<p>n + n*(n-1) + n*(n-1)*(n-2) +… + n*(n-1)(n-2)*…*2*1  </p>
<p>最后一个数等于n!，前面n-1个数都小于最后一个数，总和肯定小于n*n!。全排列的递归算法的时间复杂度在O(n!)与O(n*n!)之间。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>递归树</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索引擎</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/2%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<p>搜索引擎大致可以分为四个部分：搜集、分析、索引、查询。<br>搜集：利用爬虫爬取网页；<br>分析：网页内容抽取、分词，构建临时索引，计算PageRank值；<br>索引：通过分析阶段得到的临时索引，构建倒排索引；<br>查询：响应用户的请求，根据倒排索引获取相关网页，计算网页排名，返回查询结果给用户。  </p>
<h3 id="搜集"><a href="#搜集" class="headerlink" title="搜集"></a>搜集</h3><p>对搜索引擎来说，它事先并不知道网页都在哪里。搜索引擎把整个互联网看做数据结构中的有向图，把每个页面看做一个顶点。如果某个页面中包含另外一个页面的链接，就在两个顶点之间连一条有向边。可以利用图的遍历搜索算法，来遍历整个互联网中的网页。  </p>
<p>搜索引擎采用的是<strong>广度优先搜索策略</strong>。先找一些比较知名的网页（权重比较高）的链接，作为种子网页链接，放入到队列中。爬虫按照广度优先的策略，不停的从队列中取出链接，然后去爬取对应的网页，解析出网页里包含的其他网页链接，再将解析出来的链接添加到队列中。  </p>
<ol>
<li><p>待爬取网页链接文件：links.bin<br> 在广度优先搜索爬取页面的过程中，爬虫会不停的解析页面链接，将其放到队列中。队列中的链接会越来越多，可能会多到内存放不下。用一个存储在磁盘中的文件-links.bin来作为广度优先搜索中的队列。爬虫从links.bin文件中，取出链接去爬取对应的页面。等爬取到网页之后，将解析出来的链接，直接存储到links.bin文件中。  </p>
<p> 用文件存储网页链接的方式，支持断点续爬。当机器断点之后，网页链接不会丢失；当机器重启之后，还可以从之前爬取到的位置继续爬取。  </p>
<p> 把整个页面看做一个大的字符串，然后利用字符串匹配算法，在这个大字符串中，搜索<link>这样一个网页标签，然后顺序读取<link></link>之间的字符串，就是网页链接。  </p>
</li>
<li><p>网页判重文件：bloom_filter.bin<br> 采用位图数据结构，使用布隆过滤器快速并且非常节省内存的实现网页的判重。  </p>
<p> 解决机器宕机重启后，存储在内存中的布隆过滤器被清空的问题（导致已经爬取的网易会被重复爬取）。定期（每个半个小时）将布隆过滤器持久化到磁盘中，存储在bloom_filter.bin文件中。即便出现宕机，也只会丢失布隆过滤器中的部分数据，当机器重启后，可以重新读取磁盘中的bloom_filter.bin文件，将其恢复到内容中。  </p>
</li>
<li><p>原始网页存储文件：doc_raw.bin<br> 爬取到网页之后，需要将其存储下来，以备后面离线分析、索引之用。  </p>
<p> 把多个网页存储在一个文件中(避免一个网页对应一个独立文件造成大量文件。同时一个文件不能太大，每个文件大小超过一定的值就创建新的文件)。每个网页之间，通过一定的表示进行分隔，方便后续读取。（网页编号 \t 网页大小 \t 网页 \r\n\r\n）  </p>
</li>
<li><p>网页链接及其编号的对应文件：doc_id.bin<br> 网页编号就是给每个网页分配一个唯一的ID，方便后续对网页进行分析、索引。  </p>
<p> 可以按照网页被爬取的先后顺序，从小到大依次编号。维护一个中心的计数器，每爬取到一个网页之后，就从计数器中拿一个号码，分配给这个网页，然后计数器加一。在存储网页的同时，将网页链接跟编号之间的对应关系，存储在另一个doc_id.bin文件中。  </p>
</li>
</ol>
<p><strong>搜集阶段得到四个文件：links.bin和bloom_filter.bin是爬虫自身所用。<br>doc_raw.bin和doc_id.bin作为搜集阶段的成果，供后面的分析、索引、查询使用。</strong>  </p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>网页爬取下来之后，需要对网页进行离线分析。分析阶段主要包含两个步骤：抽取网页文本信息、分词并创建临时索引。  </p>
<ol>
<li><p>抽取网页文本信息<br> 网页是半结构化数据，里面夹杂着各种标签、JavaScript代码、CSS样式。对于搜索引擎来说，它只关心网页中的文本信息，也就是网页显示在浏览器中时，能被用户肉眼看到的那部分信息。  </p>
<p> 去掉JavaScript代码、CSS格式以及下拉框中的内容。（script、style、option标签之间的内容，利用AC自动机多模式串匹配算法处理，）  </p>
<p> 去掉所有HTML标签。  </p>
</li>
<li><p>分词并创建临时索引<br> 对于英文网页，只需要通过空格、标点符号等分隔符，将每个电磁分割开来就可以。</p>
<p> 对于中文来说，采用基于字典和规则的分词方法。<br> 字典也叫词库，里面包含大量常用的词语，借助词库并采用最长匹配原则（匹配尽可能长的词语），来对文本进行分词。<br> 将词库中的单词，构建成Trie树结构，然后拿网页文本在Trie树中匹配。  </p>
<p> 每个网页的文本信息在分词完成之后，得到一组单词列表。把单词与网页之间的对应关系，写入到一盒临时索引文件中tmp_index.bin，用来构建倒排索引。（单词编号 \t 网页编号 \r\n）  </p>
<p> 在临时索引文件中，存储的是单词编号term_id，而非单词本身，主要是为了节省存储空间。<br> 给单词编号的方式，跟给网页编号类似。维护一个计数器，每当网页文本信息中分割出一个新的单词的时候，就从计数器中取一个编号，分配给他，然后计数器加一。<br> 在这个过程中使用散列表，记录已经变过号的单词。在对网页文本信息分词的过程中，拿分割出来的单词，先到散列表中查找，如果找到就直接使用已有的编号；如果没有找到，再去计数器中拿号码，并且将这个新单词以及编号添加到散列表中。  </p>
<p> 当所有的网页处理完成之后，再将单词跟编号之间的对应关系，吸入到磁盘文件中，命名为term_id.bin。  </p>
</li>
</ol>
<p><strong>分析阶段得到两个文件：临时索引文件tmp_index.bin和单词编号文件term_id.bin。</strong>  </p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>索引阶段主要负责将分析阶段产生的临时索引，构建成倒排索引—Inverted index。倒排索引中记录了每个单词以及包含它的网页列表。（term_id缩写，单词编号 \t did1,…didx表示包含单词的网页编号列表 \r\n）  </p>
<blockquote>
<p>正排-文档中包含哪些单词<br>倒排-单词被哪些文档包含  </p>
</blockquote>
<p>采用多路归并排序的方法，通过临时索引文件，构建出倒排索引文件。  </p>
<p>先对临时索引文件，按照单词编号的大小进行排序。采用归并排序的处理思想，将其分割成多个小文件，先对每个小文件独立排序，最后再合并在一起。（可直接用MapReduce来处理）  </p>
<p>临时索引文件排序完成之后，相同的单词被排列到了一起。只需要顺序地遍历遍历排好序的临时索引文件，就能将每个单词对应的网页编号列表找出来，然后把他们存储在倒排索引文件中。  </p>
<p>除了倒排文件外，需要一个记录每个单词编号在倒排索引文件中的偏移位置的文件—term_offset.bin。这个文件可以快速的查找某个单词编号在倒排索引中存储的位置，进而快速的从倒排索引中读取单词编号对应的网页编号列表。（单词编号 \t 偏移位置 \r\n）  </p>
<p><strong>索引阶段得到两个文件：倒排索引文件index.bin和记录单词编号在索引文件中的偏移位置的文件term_offset.bin。</strong>  </p>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>利用之前产生的几个文件，实现最终的用户搜索功能。  </p>
<ul>
<li>doc_id.bin:记录网页链接和编号之间的对应关系。  </li>
<li>term_id.bin:记录单词和编号之间的对应关系。  </li>
<li>index.bin:倒排索引文件，记录每个单词编号以及对应包含它的网页编号列表。  </li>
<li>term_offset.bin:记录每个单词编号在倒排索引文件中的偏移位置。  </li>
</ul>
<p>除了倒排索引文件比较大之外其他都比较小。将其他三个文件都加载到内存中，并组织成散列表这种数据结构。  </p>
<p>当用户在搜索框中，输入某个查询文本的时候，先对用户输入的文本进行分词处理。假设分词之后，得到k个单词。  </p>
<p>拿这k个单词，去term_id.bin对应的散列表中，查找对应的单词编号，得到这k个单词对应的单词编号。  </p>
<p>拿这k个单词编号，去term_offset.bin对应的散列表中，查找每个单词编号在倒排索引文件中的偏移位置，得到k个偏移位置。  </p>
<p>拿这k个偏移位置，去倒排索引index.bin中，查找k个单词对应的包含它的网页编号列表，得到k个网页编号列表。  </p>
<p>针对k个网页编号列表，统计每个网页编号出现的次数。对统计结果，按照出现的次数的多少，从小到大排序。出现次数越多，说明包含越多的用户查询单词。  </p>
<p>经过这一系列查询，得到一组排好序的网页编号，拿着网页编号，去doc_id.bin文件中查找对应的网页链接，分页显示给用户。  </p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>计算网页权重PageRank算法<br>计算查询结果排名th-idf模型<br>搜索结果展示摘要信息和网页快照  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>搜索引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1Redis/</url>
    <content><![CDATA[<h3 id="Redis-数据库介绍"><a href="#Redis-数据库介绍" class="headerlink" title="Redis 数据库介绍"></a>Redis 数据库介绍</h3><p>Redis是一种键值(Key-Value)数据库。相对于关系型数据库(MySQL、Oracle)，Redis也被叫做非关系型数据库。  </p>
<p>Redis中只包含“键”和“值”两部分，只能通过“键”来查询“值”。存储结构简单，读写效率高。Redis主要作为内存数据库使用，数据存储在内存中，同时支持将数据存储在硬盘中。  </p>
<p>Redis键的数据类型是字符串，值得数据类型包括字符串、列表、字典、集合、有序集合。  </p>
<h3 id="字符串（string）"><a href="#字符串（string）" class="headerlink" title="字符串（string）"></a>字符串（string）</h3><p>对应数据结构的<strong>字符串</strong>。  </p>
<h3 id="列表（list）"><a href="#列表（list）" class="headerlink" title="列表（list）"></a>列表（list）</h3><p>列表数据类型支持存储一组数据，两种实现方法：压缩列表（ziplist）、双向循环链表。  </p>
<ol>
<li>压缩列表<br> 列表中存储数据量比较小  </li>
</ol>
<ul>
<li><p>列表中保存的单个数据（可以是字符串类型）小于64字节；  </p>
</li>
<li><p>列表中数据个数小于512个。  </p>
<p>  压缩列表不是基础数据结构。类似数组，通过一片连续的内存空间来存储数据。允许存储的数据大小不同。但压缩列表不支持随笔访问，类似链表。<br>  Redis一般通过key获取整个value的值—整个压缩列表的数据，并不需要随机访问。访问某个元素的时候需要从头开始遍历。  </p>
<p>  压缩列表一方面比较节省内存，另一方面可以支持不同类型数据的存储。  </p>
</li>
</ul>
<ol start="2">
<li><p>双向循环链表<br> 链表的一种。  </p>
 <div class='spoiler collapsed'>
    <div class='spoiler-title'>
        list-Redis
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//额外定义了一个list结构体，组织链表的首、尾指针，以及长度信息</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listnode</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="keyword">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">listNode *head;</span><br><span class="line">listNode *tail;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line"><span class="comment">// ....省略其他定义</span></span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

</li>
</ol>
<h3 id="字典（hash）"><a href="#字典（hash）" class="headerlink" title="字典（hash）"></a>字典（hash）</h3><p>字典类型用来存储一组数据对。每个数据对又包含键值两部分。两种实现方法：压缩列表、散列表。  </p>
<ol>
<li>压缩列表<br> 存储的数据量比较小  </li>
</ol>
<ul>
<li>字典中保存的键和值的大小都要小于64字节；  </li>
<li>字典中键值对的个数要小于512个。  </li>
</ul>
<ol start="2">
<li>散列表<br> Redis使用MurmurHash2这种运行速度快、随机性好的哈希算法作为哈希函数。<br> Redis使用链表法解决哈希冲突问题。<br> Redis支持散列表的动态扩容（装载因子大于1，散列表扩大为原来的2倍左右）、缩容（装载因子小于0.1，缩小为字典中数据个数的大约2倍大小）。<br> 采用渐进式扩容缩容策略，将数据的搬移分批进行，避免大量数据一次性搬移导致的服务停顿。  </li>
</ol>
<h3 id="集合（set）"><a href="#集合（set）" class="headerlink" title="集合（set）"></a>集合（set）</h3><p>集合类型用来存储一组不重复的数据。两种实现方法：有序数组、散列表。  </p>
<ol>
<li>有序数组  </li>
</ol>
<ul>
<li>存储的数据都是整数；  </li>
<li>存储的数据元素个数不超过512个。  </li>
</ul>
<ol start="2">
<li>散列表  </li>
</ol>
<h3 id="有序集合（sortedset）"><a href="#有序集合（sortedset）" class="headerlink" title="有序集合（sortedset）"></a>有序集合（sortedset）</h3><p>有序集合用来存储一组数据。两种实现方式：压缩列表、跳表。  </p>
<ol>
<li>压缩列表  </li>
</ol>
<ul>
<li>所有数据的大小都要小于64字节；</li>
<li>元素个数要小于128个。  </li>
</ul>
<ol start="2">
<li>跳表<br> 每个数据会附带一个得分。通过得分的大小，将数据组织成跳表这样的数据结构，以支持快速的按照得分值、得分区间获取数据。  </li>
</ol>
<h3 id="数据结构持久化（对象持久化）"><a href="#数据结构持久化（对象持久化）" class="headerlink" title="数据结构持久化（对象持久化）"></a>数据结构持久化（对象持久化）</h3><p>Redis常被用作内存数据库，也支持数据落盘，将内存中的数据存储到磁盘中。  </p>
<p>Redis的数据格式由“键”和“值”两部分组成。“值”支持很多数据类型。两种持久化思路：  </p>
<ul>
<li><p>清除原有的存储结构，只将数据存储到磁盘中。当需要从磁盘还原数据到内存的时候，再重新将数据组织成原来的数据结构。数据从硬盘还原到内存的过程，会耗用比较多的时间。（重新构建散列表时，需要重新计算每个数据的哈希值。）</p>
</li>
<li><p>保留原来的存储格式，将数据按照原有的格式存储在磁盘中。将散列表的大小、每个数据被散列到的槽的编号等信息，都保存在磁盘中。从磁盘中将数据还原到内存中的时候，可以避免重新计算哈希值。  </p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>MurmurHash</tag>
      </tags>
  </entry>
  <entry>
    <title>AC自动机</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    <content><![CDATA[<h3 id="基于单模式串和Trie树实现"><a href="#基于单模式串和Trie树实现" class="headerlink" title="基于单模式串和Trie树实现"></a>基于单模式串和Trie树实现</h3><p>单模式串匹配算法，是在一个模式串和一个主串之间进行匹配，在一个主串中查找一个模式串。<br>多模式串匹配算法，是在多个模式串和一个主串之间进行匹配，在一个主串中查找多个模式串。  </p>
<p>Trie树是一种多模式串匹配算法。<br>对敏感词字典进行预处理，构建成Trie树结构。预处理操作只需要做一次，敏感词字典动态更新（删除、添加），只需要动态更新一下Trie树。  </p>
<p>当用户输入一个文本内容后，把用户输入的内容作为主串，从第一个字符(假设字符C)开始，在Trie树中匹配。当匹配到Trie树的叶子节点，或者中途遇到不匹配字符的时候，将主串的开始匹配位置后移一位，也就是从字符C的下一个字符开始，重新在Trie树中匹配。  </p>
<p>类似单模式串匹配的BF算法。  </p>
<h3 id="多模式串匹配算法"><a href="#多模式串匹配算法" class="headerlink" title="多模式串匹配算法"></a>多模式串匹配算法</h3><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>AC自动机算法（Aho-Corasick算法）。<br>Trie树跟AC自动机之间的关系，类似于单串匹配中朴素的串匹配算法跟KMP算法之间的关系。<br>AC自动机实际上就是再Trie树之上，加了类似KMP的next数组，只不过此处的next数组时构建在树上罢了。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        AC自动机
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AcNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span> data;</span><br><span class="line">    <span class="keyword">public</span> AcNode[] children = <span class="keyword">new</span> AcNode[<span class="number">26</span>];<span class="comment">//字符集只包含a-z这26个字符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isEndingChar = <span class="keyword">false</span>;<span class="comment">//结尾字符为true</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> length = -<span class="number">1</span>;<span class="comment">//当isEndingChar=true时，记录模式串长度</span></span><br><span class="line">    <span class="keyword">public</span> AcNode fail;<span class="comment">//失败指针</span></span><br><span class="line">    <span class="function">punlic <span class="title">AcNode</span><span class="params">(<span class="keyword">char</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p>AC自动机的构建，包含两个操作：</p>
<ul>
<li>将多个模式串构建成Trie树；</li>
<li>在Trie树上构建失败指针（相当于KMP中的失败函数next数组）。</li>
</ul>
<p>Trie树中的每一个节点都有一个失败指针，它的作用和构建过程，跟KMP算法中的next数组极其相似。  </p>
<p>沿Trie树走到p节点，p的失败指针就是从root走到p节点形成的字符串abc，跟所有模式串前缀匹配的最长可匹配后缀子串。  </p>
<p>字符串abc的后缀子串有两个bc、c，拿它们与其他模式串匹配，如果某个后缀子串可以匹配某个模式串的前缀，就把这个后缀子串叫做<strong>可匹配后缀子串</strong>。  </p>
<p>从匹配后缀子串中，找出最长的一个。将p节点的失败指针指向那个最长匹配后缀子串对应的模式串的前缀的最后一个节点。  </p>
<p>把树中相同深度的节点放到同一层，那么某个节点的失败指针只有可能出现在它所在层的上一层。  </p>
<p>当要求某个节点的失败指针的时候，通过已经求得的、深度更小的那些节点的失败指针来推导。也就是说可以逐层依次来求解每个节点的失败指针。失败指针的构建过程，是一个按层遍历树的过程。  </p>
<h4 id="失败指针"><a href="#失败指针" class="headerlink" title="失败指针"></a>失败指针</h4><p>root的失败指针为NULL，就是指向自己。  </p>
<p>假设节点p的失败指针指向节点q，看节点p的子节点pc对应的字符，是否也可以在节点q的子节点中找到。如果找到了节点q的一个子节点qc，对应的字符跟节点pc对应的字符相同，则将节点pc的失败指针指向节点qc。  </p>
<p>如果节点q中没有子节点的字符等于节点pc包含的字符，则令q=q-&gt;fail(fail表示失败指针)，继续上面的查找，直到q是root为止，如果还没有找到相同字符的子节点，就让节点pc的失败指针指向root。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        失败指针
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildFailurePointer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Queue&lt;AcNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    root.fail = <span class="keyword">null</span>;</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        AcNode p = queue.remove();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            AcNode pc = p.children[i];</span><br><span class="line">            <span class="keyword">if</span>(pc == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(p == root) &#123;</span><br><span class="line">                pc.fail = root;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                AcNode q = p.fail;</span><br><span class="line">                <span class="keyword">while</span>(q != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    AcNode qc = q.children[pc.data - <span class="string">'a'</span>];</span><br><span class="line">                    <span class="keyword">if</span>(qc != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        pc.fail = qc;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    q = q.fail;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(q == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    pc.fail = root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            queue.add(pc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p>按层计算每个节点的子节点的失效指针。  </p>
<h4 id="匹配主串"><a href="#匹配主串" class="headerlink" title="匹配主串"></a>匹配主串</h4><p>在匹配过程中，主串从i=0开始，AC自动机从指针p=root开始，假设模式串是b，主串是a。  </p>
<ul>
<li>如果p指向的节点有一个等于b[i]的子节点x，就更新p指向x，这个时候需要通过失败指针，检测一系列失败指针为结尾的路径是否是模式串。处理完之后，将i加一，继续这两个过程。  </li>
<li>如果p指向的节点没有等于b[i]的子节点，那失败指针就派上用场了，让p=p-&gt;fail，然后继续这两个过程。  </li>
</ul>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        匹配主串
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>[] text)</span> </span>&#123;<span class="comment">//text是主串</span></span><br><span class="line">    <span class="keyword">int</span> n = text.length;</span><br><span class="line">    AcNode p = root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> idx = text[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">while</span>(p.children[idx] == <span class="keyword">null</span> &amp;&amp; p != root) &#123;</span><br><span class="line">            p = p.fail;<span class="comment">//失败指针发挥作用的地方</span></span><br><span class="line">        &#125;</span><br><span class="line">        p = p.children[idx];</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span>) p = root;<span class="comment">//如果没有匹配的，从root开始重新匹配</span></span><br><span class="line">        AcNode tmp = p;</span><br><span class="line">        <span class="keyword">while</span>(tmp != root) &#123;<span class="comment">//打印出可以匹配的模式串</span></span><br><span class="line">            <span class="keyword">if</span>(tmp.isEndingChar == <span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> pos = i - tmp.length + <span class="number">1</span>;</span><br><span class="line">                System.out.println(<span class="string">"匹配起始下标"</span> + pos + <span class="string">"；长度"</span> + tmp.length);</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = tmp.fail;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<h3 id="效率分析"><a href="#效率分析" class="headerlink" title="效率分析"></a>效率分析</h3><h4 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h4><p>将敏感词构建成AC自动机，包括构建Trie树以及构建失败指针。  </p>
<p>Trie树构建的时间复杂度是O(m*len)，其中len表示敏感词的平均长度，m表示敏感词的个数。  </p>
<p>假设Trie树中总的节点个数是k，每个节点构建失败指针的时候，最耗时的环节是while循环中的q=q-&gt;fail，每次运行一次这个语句，q指向节点的深度都会减少1，而树的高度最高也不会超过len，所以每个节点构建失败指针的时间复杂度是O(len)。整个失败指针的构建过程为O(k*len)。  </p>
<p>AC自动机的构建过程都是预先处理好的，构建好之后，并不会频繁的更新，不会影响到敏感词过滤的运行效率。  </p>
<h4 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h4><p>for循环依次遍历主串中的每个字符，for循环内部最耗时的部分也是while循环，这一部分的时间复杂度是O(len)，总的匹配的时间复杂度就是O(n*len)。敏感词一般不长，实际情况近似于O(n)。  </p>
<p>从时间复杂度上看，AC自动机匹配的效率跟Trie树一样。但是失效指针大部分情况下都指向root节点，所以大部分情况下，在AC自动机上做匹配的效率要远高于理论时间复杂度。只有在极端情况边，AC自动机的性能才会退化的根Trie树一样（每个节点的失效指针分别指向自己的父节点）。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>短网址系统</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/5%E7%9F%AD%E7%BD%91%E5%9D%80%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>短网址服务的核心功能，就是把原始的长网址转化成短网址；当用户点击短网址的时候，短网址服务会将浏览器重定向为原始网址。  </p>
<h3 id="哈希算法生成短网址"><a href="#哈希算法生成短网址" class="headerlink" title="哈希算法生成短网址"></a>哈希算法生成短网址</h3><p>哈希算法可以将一个不管多长的字符串，转化成一个长度固定的哈希值。<br>生成短网址，不需要考虑反向解密的难度，只需要关心哈希算法的计算速度和冲突概率。  </p>
<p>MurmurHash算法提供了两种长度的哈希值，一种是32bits，一种是128bits。对原始网址进行hash计算之后，得到的哈希值再品尚短网址服务的域名，就构成最终的短网址。  </p>
<h4 id="让短网址更短"><a href="#让短网址更短" class="headerlink" title="让短网址更短"></a>让短网址更短</h4><p>将10进制的哈希值，转化成更高进制的哈希值。<br>16进制中，用A~E来表示10~15。在网址URL中，常用的合法字符有0~9、a~z、A~Z这样62个字符。so将10进制的哈希值转化成62进制。（10进制除以62取余，余数相应字符）  </p>
<h4 id="解决哈希冲突问题"><a href="#解决哈希冲突问题" class="headerlink" title="解决哈希冲突问题"></a>解决哈希冲突问题</h4><p>一般情况下，保存短网址跟原始网址之间的对应关系（数据库），以便后续用户在访问短网址的时候，可以根据对应关系，查找到原始网址。  </p>
<p>当有一个新的原始网址需要生成短网址的时候，先利用MurmurHash算法生成短网址，然后拿生成的短网址在数据库中查找。如果没有找到相同的短网址，表明此短网址没有冲突，将对应关系存到数据库，并将短网址返回给用户。  </p>
<p>如果在数据库中找到了相同的短网址，将其对应的原始网址也取出来，跟正在处理的原始网址对比，相同则直接用；若不同则说明发生哈希冲突。<br>给原始网址拼接一串特殊的字符（DUPLICATED），重新计算哈希值，极端情况再次出现冲突就继续拼接字符串。最终把哈希值和原始网址拼接了特殊字符串之后的文本分别存在数据库中。  </p>
<p>当用户访问短网址的时候，短网址服务先通过短网址在数据库中查找对应的原始网址。如果原始网址中有凭借特殊字符，就先将特殊字符去掉再返回给浏览器。  </p>
<h4 id="优化哈希算法性能"><a href="#优化哈希算法性能" class="headerlink" title="优化哈希算法性能"></a>优化哈希算法性能</h4><p>给<strong>短网址字段添加B+树索引</strong>。提高通过短网址查询原始网址的速度。  </p>
<p>在短网址生成的过程中，会跟数据库打两次交到，执行两条SQL语句。<br>通过短网址查询短网址与原始网址的对应关系；将新生成的短网址和原始网址之间的对应关系存储到数据库。<br>给数据库中的<strong>短网址字段添加唯一索引</strong>。当有新的原始网址需要生成短网址时，直接将生成的短网址与对应的原始网址尝试存储到数据库中。如果数据库能将数据正常写入，则说明没有违反唯一索引，新生成的短网址没有冲突。如果范围违反唯一索引异常，则按正常的“查询-写入过程”。  </p>
<p>将已经生成的<strong>短网址构建成布隆过滤器</strong>。当有新的短网址生成的时候，先拿短网址在布隆过滤器中查找。如果查找的结果是不存在的，说明没有冲突，只需要执行写入的SQL语句。  </p>
<h3 id="ID生成器生成短网址"><a href="#ID生成器生成短网址" class="headerlink" title="ID生成器生成短网址"></a>ID生成器生成短网址</h3><p>维护一个ID自增生成器，可以生成自增的整数ID。当短网址服务接收到一个原始网址转化成短网址的请求之后，它先从ID生成器中取一个号码，然后将其转化成62进制表示法，拼接到短网址服务的域名后面，就形成了最终的短网址。最后将生成的短网址和对应的原始网址存储到数据库中。  </p>
<h4 id="相同的原始网址可能会对应不同的短网址"><a href="#相同的原始网址可能会对应不同的短网址" class="headerlink" title="相同的原始网址可能会对应不同的短网址"></a>相同的原始网址可能会对应不同的短网址</h4><p>每次新来一个原始网址，就生成一个新的短网址，会导致两个相同的原始网址生成了不同的短网址。解决方案：  </p>
<ul>
<li><p>不做处理。相同的原始网址对应不同的短网址，可以接受。大部分短网址的应用场景中，用户只关心短网址能否正确的跳转到原始网址，并不关心短网址长什么样。同一个原始网址，两次生成的短网址不一样，并不会影响到用户的使用。  </p>
</li>
<li><p>借助哈希算法生成短网址的处理思想。要给一个原始网址生成短网址的时候，先拿原始网址在数据库中查找，看数据库中是否已经存在相同的原始网址。若存在就取出对应的短网址，直接返回给用户。  </p>
<blockquote>
<p>需要给数据库中的短网址和原始网址两个字段都添加索引。</p>
</blockquote>
</li>
</ul>
<h4 id="高性能ID生成器"><a href="#高性能ID生成器" class="headerlink" title="高性能ID生成器"></a>高性能ID生成器</h4><p>低性能：数据库自增字段、计数器等。  </p>
<p>高性能：</p>
<ul>
<li><p>借助Disruptor的思想，给ID生成器装多个前置发号器。批量的给每个前置发号器发送ID号码。当接收到短网址生成请求时，就选择一个前置发号器来取号码，通过多个前置发号器，提高并发发号能力。  </p>
</li>
<li><p>实现多个ID生成器同时服务。为了保证每个ID生成器生成的ID不重复。要求每个ID生成器按照一定的规则，生成ID号码。（第一个ID生成器只能生成尾号为0的ID，第二个只能生成尾号为1的ID，以此类推）。</p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>MurmurHash</tag>
        <tag>短网址</tag>
      </tags>
  </entry>
  <entry>
    <title>高性能队列Disruptor</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/3%E9%AB%98%E6%80%A7%E8%83%BD%E9%98%9F%E5%88%97Disruptor/</url>
    <content><![CDATA[<p>Disruptor是<strong>线程</strong>之间用于消息传递的队列。比另一种内存消息队列ArrayBlockingQueue性能高一个数量级。  </p>
<h3 id="基于循环队列的“生产者-消费者模型”"><a href="#基于循环队列的“生产者-消费者模型”" class="headerlink" title="基于循环队列的“生产者-消费者模型”"></a>基于循环队列的“生产者-消费者模型”</h3><p>生产者生产数据，并将数据放到一个中心存储容器中。<br>消费者从中心存储容器中，取出数据消费。  </p>
<p>实现中心存储容器最常用的数据结构是队列。队列支持数据的先进先出，使得数据被消费的顺序性可以得到保证，早被生产的数据就会早被消费。  </p>
<p>队列有两种实现思路：<br>基于链表实现的<strong>链式队列</strong>。  </p>
<blockquote>
<p><strong>无界队列</strong>，队列的大小事先不确定，理论上可以支持无线大。<br>基于数组实现的<strong>顺序队列</strong>。<br><strong>有界队列</strong>，队列的大小事先确定，当队列中数据满了之后，生产者就需要等待，直到消费者消费了数据，队列有空闲位置的时候，生产者才能将数据放入。<br><strong>循环队列</strong>，特殊的顺序队列。<br>非循环的顺序队列在添加、删除数据的工程中，会涉及数据的搬移操作，导致性能变差。  </p>
</blockquote>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        内存消息队列-循环队列
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long[] data;</span><br><span class="line">    <span class="keyword">private</span> in size = <span class="number">0</span>, head = <span class="number">0</span>, tail = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Queue</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = <span class="keyword">new</span> Long[size];</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Long element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((tail + <span class="number">1</span>) % size == head) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        data[tail] = element;</span><br><span class="line">        tail = (tail + <span class="number">1</span>) % size;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == tail) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">long</span> ret = data[head];</span><br><span class="line">        head = (head + <span class="number">1</span>) % size;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue queue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Queue queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">(<span class="keyword">long</span> data)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!queue.add(data)) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue queue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Queue queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            Long data = queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(data == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//<span class="doctag">TODO:</span>...消费数据的业务逻辑...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<h3 id="基于加锁的并发“生产者-消费者模型”"><a href="#基于加锁的并发“生产者-消费者模型”" class="headerlink" title="基于加锁的并发“生产者-消费者模型”"></a>基于加锁的并发“生产者-消费者模型”</h3><p>多个生产者并发往队列中写入数据，多个消费者并发从队列中消费数据。  </p>
<ul>
<li>多个生产者写入的数据可能会互相覆盖；  </li>
<li>多个消费者可能会读取重复的数据。  </li>
</ul>
<p>两个线程同时往队列中添加数据，相当于两个线程同时执行Queue中的add()函数。add函数中的操作并非原子操作。导致判断后插入数据时被覆盖。<br>消费时同理。  </p>
<p>简单处理方法：给代码加锁，同一时间只允许一个线程执行add()函数。加锁将并行改成串行，导致多个生产者同时生产数据的时候执行效率下降。  </p>
<p>优化处理方法：CAS(compare and swap，比较并交换)，减少加锁的粒度。  </p>
<h3 id="基于无锁的并发“生产者-消费者模型”"><a href="#基于无锁的并发“生产者-消费者模型”" class="headerlink" title="基于无锁的并发“生产者-消费者模型”"></a>基于无锁的并发“生产者-消费者模型”</h3><p>Disruptor采用的是RingBuffer和AvailableBuffer这两个结构实现并发的“生产者-消费者模型”。  </p>
<p>对生产者来说，它往队列中添加数据之前，先申请可用空闲存储单元，并且是批量地申请连续的n个（n&gt;=1）存储单元。当申请到这组连续的存储单元之后，后续往队列中添加元素，就可以不用加锁了，因为这组存储单元是这个线程独享的。不过，申请存储单元的过程是需要加锁的。  </p>
<p>对消费者来说，先去申请一批连续可读的存储单元（这个申请的过程也是需要加锁的），当申请到这批存储单元之后，后续的读取操作就可以不用加锁了。  </p>
<p>如果生产者A申请到了一组连续的存储单元，假设是下标为3-6的存储单元，生产者B紧跟着申请到了下标7-9的存储单元，在3-6没有完全写入数据之前，7-9的数据是无法读取的。  </p>
<p>常见的内存队列通常采用循环队列来实现。<br>Disruptor采用两阶段写入的方法解决并发产生的问题。在写入数据之前，先加锁申请批量的空闲存储单元，之后往队列中写入数据的操作就不需要加锁了，写入的性能提高。在消费数据之前，先加锁申请批量的可读取的存储单元，之后从队列中读取数据的操作也就不需要加锁了，读取的性能提高。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Disruptor</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务接口鉴权限流</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/4%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3%E9%89%B4%E6%9D%83%E9%99%90%E6%B5%81/</url>
    <content><![CDATA[<p>服务治理，管理微服务，保证平台整体正常、平稳的运行。服务治理涉及鉴权、限流、降级、熔断、监控告警等。  </p>
<h3 id="鉴权"><a href="#鉴权" class="headerlink" title="鉴权"></a>鉴权</h3><p>不同的接口提供给不同的应用，并不是所有应用都可以访问该服务，也不是每个有访问权限的应用都可以访问该服务的所有接口。  </p>
<p>要实现接口鉴权功能，需要事先将应用对接口的访问权限规则设置好。当某个应用访问其中一个接口的时候，可以拿应用的请求URL，在规则中进行匹配。如果匹配成功，就说明允许访问；如果没有可以匹配的规则，那就说明这个应用没有这个接口的访问权限，就拒绝服务。  </p>
<p>接口格式格式：类似Dubbo的RPC接口，类似Spring Cloud的HTTP接口。  </p>
<h4 id="精确匹配规则"><a href="#精确匹配规则" class="headerlink" title="精确匹配规则"></a>精确匹配规则</h4><p>只有当请求URL跟规则中配置的某个接口精确匹配时，这个请求才会被接受、处理。  </p>
<p>不同的应用对应不同的规则集合。可以采用散列表来存储这种对应关系。<br>将每个应用对应的权限规则，存储在一个字符串数组中。当用户请求到来时，拿用户的请求URL，在这个字符串数组中逐一匹配，匹配的算法对应字符串匹配算法（KMP、BM、BF）。  </p>
<p>规则不会经常变动，可以按照字符串的大小给规则排序，把它组织成有序数组这种数据结构，加快匹配速度。当要查找某个URL能否匹配其中某条规则的时候，可以采用二分查找算法，在有序数组中进行匹配。  </p>
<h4 id="前缀匹配规则"><a href="#前缀匹配规则" class="headerlink" title="前缀匹配规则"></a>前缀匹配规则</h4><p>只要某条规则可以匹配请求URL的前缀，这个请求就可以被接受处理。  </p>
<p>不同的应用对应不同的规则集合。同样采用散列表来存储这种对应关系。<br>将每个应用的规则集合，组织成Trie树这种数据结构。Trie树非常适合用来做前缀匹配。Trie树中的每个节点不是存储单个字符，而是存储接口被“/”分割之后的子目录。  </p>
<p>规则并不会经常变动，在Trie树中，可以把每个节点的子节点门，组织成有序数组这种数据结构。当在匹配的过程中，可以利用二分查找算法，决定从一个节点应该跳到哪一个子节点。  </p>
<h4 id="模糊匹配规则"><a href="#模糊匹配规则" class="headerlink" title="模糊匹配规则"></a>模糊匹配规则</h4><p>规则中包含通配符（“**”匹配任意多个子目录，“*”匹配任意一个子目录），只要请求URL可以跟某条规则模糊匹配，就可以被接受处理。  </p>
<p>不同的应用对应不同的规则集合。依然采用散列表来存储这种对应关系。  </p>
<ul>
<li>借助正则表达式的解决思路，采用回溯算法，拿请求URL跟每条规则逐一进行模糊匹配。  </li>
<li>并不是每条规则都包含通配符，包含通配符的只是少数。把不包含通配符的规则和包含通配符的规则分开处理。<br>把不包含通配符的规则，组织成<strong>有序数组或者Trie树</strong>。剩下的少数包含通配符的规则，简单存储在一个<strong>普通数组</strong>中。<br>当接收到一个请求URL之后，可以先在不包含通配符的有序数组或者Trie树中查找。如果能够匹配，就不需要继续在通配符规则中匹配；如果不能匹配，就继续在通配符规则中查找匹配。  </li>
</ul>
<h3 id="限流1"><a href="#限流1" class="headerlink" title="限流1"></a>限流<a href="#refer-anchor-1"><sup>1</sup></a></h3><p><span id="back-1"></span><br>对接口调用的频率进行限制。例如每秒钟不能超过100次调用，超过之后就拒绝服务。  </p>
<p>按照不同的限流粒度，限流可以分为很多种类型。给每个接口限制不同的访问频率；给所有接口限制总的访问频率；限制某个应用对某个接口的访问频率等。  </p>
<h4 id="固定时间窗口限流算法"><a href="#固定时间窗口限流算法" class="headerlink" title="固定时间窗口限流算法"></a>固定时间窗口限流算法</h4><p>首先需要选定一个时间起点，之后每当有接口请求到来，就将计数器加一。如果在当前时间窗口内，根据限流规则，出现累加访问次数超过限流值的情况时，就拒绝后续的访问请求。当进入下一个时间窗口之后，计数器就清零重新计数。  </p>
<p>缺点：限流策略过于粗略，无法应对两个时间窗口临界时间内的突发流量。  </p>
<h4 id="滑动时间窗口限流算法"><a href="#滑动时间窗口限流算法" class="headerlink" title="滑动时间窗口限流算法"></a>滑动时间窗口限流算法</h4><p>限制任意时间窗口内，接口请求数都不能超过某个阈值。从流量曲线上来看会更加平滑。  </p>
<p>假设限流的规则为，在任意1s内，接口的请求次数都不能大于K次。就维护一个大小为K+1的循环队列，用来记录1s内到来的请求。（循环队列的大小等于限流次数加一，循环队列存储数据时浪费一个存储单元）  </p>
<p>当有新的请求到来时，将与这个新请求的时间间隔超过1s的请求，从队列中删除，然后再来开队列中是否有空闲位置，如果有，则把新请求存储在队列尾部（tail指针所指的位置）；如果没有，则说明这1s内的请求次数已经超多了限流值K，这个请求被拒绝服务。  </p>
<p>缺点：滑动时间窗口限流算法，依然不能防止，在细粒度上访问过于集中的问题。  </p>
<p>其他：</p>
<ul>
<li>维护成优先级队列（根据请求时间构建小顶堆），最早的请求时间放在堆顶。当有新的请求进来时相当于在小顶堆内插入数据，判断此时跟堆顶的时间差是否小于1s，并且堆的大小小于请求限制次数。每次插入数据时，删除1s外的数据，重新排序，确定新的堆顶。时间复杂度较高。  </li>
</ul>
<h4 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h4><p>基于时间窗口的限流算法，不管是固定时间窗口还是滑动时间窗口，只能在选定的时间粒度上限流，对选定时间粒度内的更加细粒度的访问频率不做限制。无法应对细时间粒度的突发流量。  </p>
<ol>
<li>接口限制t秒内最大访问次数为n，则每隔t/n秒会放一个token到桶中；  </li>
<li>桶中最多可以存放b个token，如果token到达时令牌桶已经满了，那么这个token会被丢弃；  </li>
<li>接口请求会先从令牌桶中取token，拿到token则处理接口请求，拿不到token则执行限流。  </li>
</ol>
<p>改进思路：</p>
<ul>
<li>预热桶  </li>
<li>一次性放入多个令牌<blockquote>
<p>不需要专门起一个线程每隔固定时间放token到桶中。每次在取token之前，根据上次放入token的时间戳和现在的时间戳，计算出这段时间需要放多少token进去，一次性放进去。  </p>
</blockquote>
</li>
<li>支持一次性取多个令牌</li>
</ul>
<p>缺点：对于没有预热的令牌桶，做否决式限流会导致误杀很多请求。间隔一定时间才向桶中放入一个令牌，但接口的访问在1s内的随机性很强。</p>
<h4 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h4><p>漏桶算法相当于令牌桶算法的改进。<br>对于取令牌的频率也有限制，要按照t/n固定的速度来取令牌。漏桶算法对流量的整形效果更加好，流量更佳平滑，任何突发流量都会被限流。  </p>
<h4 id="总结延伸"><a href="#总结延伸" class="headerlink" title="总结延伸"></a>总结延伸</h4><p>令牌桶和漏桶算法比较适合阻塞式限流，超过最大访问频率后，请求不会被拒绝，而是被阻塞到有令牌后再继续执行。<br>对相应时间比较敏感的限流场景（微服务），适合选择基于时间窗口的否决式限流算法。滑动时间窗口限流算法空间复杂度较高，内存占用较多。固定时间窗口算法适合微服务接口限流场景，简单、性能好、不易出错。  </p>
<div id="refer-anchor-1"></div>  

<p>[<a href="#back-1">1</a>] <a href="https://mp.weixin.qq.com/s?__biz=MzI4MTY5NTk4Ng==&mid=2247488993&amp;idx=1&amp;sn=4b9d5deedd0e626c456744f04b499bbb&source=41#wechat_redirect" target="_blank" rel="noopener">微服务接口限流的设计与思考</a>  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>鉴权</tag>
        <tag>限流</tag>
      </tags>
  </entry>
  <entry>
    <title>日志系统</title>
    <url>/MySQL/2%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>更新语句的执行链路与查询语句类似。多两个日志模块：redo log(重做日志)和binlog(归档日志)。  </p>
<h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><ul>
<li>每一次的更新操作都要写进磁盘，磁盘需要找到对应的那条记录，然后再更新，IO成本、查找成本高。  </li>
<li>WAL技术(Write-Ahead Logging)，先写日志并更新内存（同时），再写磁盘。<blockquote>
<p>将磁盘随机写变成顺序写，避免了数据的随机写。并且可以组提交(合并写)。  </p>
</blockquote>
</li>
</ul>
<p>当有一条记录需要更新的时候，InnoDB引擎先把记录写到redo log里面，并更新数据内存(同时)。InnoDB引擎会在适当的时候(系统比较空闲的时候)，将这个操作记录更新到磁盘中（落盘前的其他查询直接从内存返回最新数据）。  </p>
<blockquote>
<p>数据库更新操作基于内存页，默认大小16K，更新时不直接更新磁盘，内存中存在就直接更新内存页，不存在就从磁盘再取到内存，再更新内存。  </p>
</blockquote>
<img src="/img/MySQL redo log结构图.png">

<p>InnoDB的redo log大小固定，可配置为一组4个文件，每个文件的大小是1G，总共可以记录4GB的操作。从头开始写，写到末尾就又回到开头循环写(环形)。</p>
<p>write pos是当前记录的位置，一边写一边后移，写到3号文件末尾后回到0号文件开头。<br>checkpoint是当前要擦除的位置，往后推移并循环，擦除记录前要把记录更新到数据文件。  </p>
<p>write pos与checkpoint之间的部分空余，用来记录新的操作。如果write pos追上checkpoint，不能再执行新的更新。  </p>
<p>InnoDB通过redo log保证数据库发生异常重启时，之前提交的记录不会丢失。<strong>crash-safe</strong>能力。<br>redo log保证了事务ACID。  </p>
<h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><p>Server层，负责功能层面的事情；引擎层，负责存储相关的事情。<br>redo log是InnoDB引擎特有的日志，Server层的日志称为binlog(归档日志)。  </p>
<p>不同点：  </p>
<ul>
<li>redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。  </li>
<li>redo log是物理日志，记录的是“在某个数据页上作了什么修改”，只能独享；binlog是逻辑日志，记录的是语句的原始逻辑，可以共享(其他数据库，其他引擎)，比如“给ID=2的行的C字段加1”。  <blockquote>
<p>redo log记录这个页“做了什么改动”；binlog两种模式：<strong>statement格式记录sql语句、row格式记录行的内容</strong>(两条：更新前&amp;更新后)。  </p>
</blockquote>
</li>
<li>redo log是循环写的，空间固定会用完；binlog是可以追加写入的。binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。记录所有的逻辑操作。  <blockquote>
<p>set sql_log_bin=0;关闭本线程的binlog日志，只依赖binlog恢复数据不可靠。  </p>
</blockquote>
</li>
</ul>
<p>update语句执行流程：  </p>
<ul>
<li><strong>执行器先找引擎取ID=2这一行</strong>，ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。  </li>
<li><strong>执行器拿到引擎给的行数据，把这个值加1，得到新的一行数据，调用引擎接口写入这行新数据。</strong>  </li>
<li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log中，此时redo log处于prepare状态，然后告知执行器执行完成，随时可以提交事务。  </li>
<li><strong>执行器生成这个操作的binlog，并把binlog写入磁盘</strong>。  </li>
<li><strong>执行器调用引擎的提交事务接口</strong>，引擎把写入的redo log改成commit(提交)状态，更新完成。  <blockquote>
<p>prepare写日志的最后一个512字节，会在commit时被改掉，不是追加写。<br>update语句执行流程，将redo log的写入拆成了两个步骤：prepare和commit。<strong>两阶段提交</strong>。  </p>
</blockquote>
</li>
</ul>
<h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p>两阶段提交，保证两份日志之间的逻辑一致。  </p>
<blockquote>
<p>redo log和binlog都可以用于表示事务的提交状态，两阶段提交让这两个状态保持逻辑上的一致。  </p>
</blockquote>
<p>两阶段提交也是跨系统维持数据逻辑一致性时常用的一个方案。  </p>
<p><strong>恢复数据</strong>：  </p>
<ul>
<li>找到最近一次全量备份，从这个备份恢复到临时库。  </li>
<li>从备份的时间点开始，将备份的binlog依次取出来，重放到指定时刻。  </li>
</ul>
<blockquote>
<p>崩溃恢复时，接受“redo log prepare并且binlog完整的情况。”。一个事务的完整binlog有固定的格式—固定的结尾。<br>如果redo log是完整的包含prepare和commit，直接认为成功，恢复时不需要去判断binlog。(binlog写失败时，让innoDB引擎给 该事务打上rollback标签，不用回滚日志。)  </p>
</blockquote>
<p>假设当前ID=2的行，字段c的值是0，执行update语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了crash。  </p>
<ol>
<li><p>先写redo log后写binlog。<br> redo log写完之后，系统即使崩溃，仍然能够把数据恢复回来，恢复后这一行c的值是1。<br> 由于binlog没写完，没有记录这个update语句，如果需要用到binlog恢复临时库时，临时库就少了这一次更新，恢复出来的这一行c的是0，与原库的值不同。  </p>
</li>
<li><p>先写binlog后写redo log。<br> binlog写完之后crash，redo log还没写完，崩溃恢复之后这个事务无效，这一行的值是0。<br> 由于binlog中已经有update语句记录，之后用binlog恢复时多了一个事务，恢复出来的这一行c的值是1，与原库的值不同。  </p>
</li>
</ol>
<p><strong>备份/扩容</strong>：<br>使用两阶段提交，保证数据库的状态和用它的日志恢复出来的库的状态一致。扩容时可以使用全量备份加上binlog来实现。  </p>
<p><strong>对比</strong>：<br>redo log的crash-safe是崩溃恢复；binlog恢复制造副本。<br>redo log循环使用，会被覆盖，数据不全，不能用作备份、同步等。<br>binlog恢复不了，WAL机制中“已经提交但是还没落盘”的数据。没有crash-safe能力。  </p>
<blockquote>
<p>innodb_flush_log_at_trx_commit=1;（默认值）表示每次事务提交时，redo log都直接持久化到磁盘。<br>innodb_flush_log_at_trx_commit=2;表示每次事务提交都写redo log文件，但是没有持久化，由系统来进行fsync操作。如果数据库宕机，不会丢失redo log；如果服务器宕机，文件系统的缓存还没同步到磁盘中的数据丢失。<br><strong>redolog buffer在事务执行过程中，先把要写的内容在内存中存起来，在commit阶段，一次性写入redolog file。</strong><br>commit时确保redo log持久化到磁盘。  </p>
</blockquote>
<blockquote>
<p>sync_binlog=1;表示每次事务的binlog都持久化到磁盘。N表示事物提交次数。<br>sync_binlog=0;（默认值）由文件系统控制缓存的刷新，系统crash会丢失部分数据。  </p>
</blockquote>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>事务隔离</title>
    <url>/MySQL/3%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/</url>
    <content><![CDATA[<p>事务保证一组数据库操作，要么全部成功，要么全部失败。<br>MySQL中，事务支持是在引擎层实现的。InnoDB引擎支持事务。<br>ACID(Atomicity原子性、Consistency一致性、Isolation隔离性、Durability持久性)  </p>
<h3 id="隔离性与隔离级别"><a href="#隔离性与隔离级别" class="headerlink" title="隔离性与隔离级别"></a>隔离性与隔离级别</h3><p>解决数据库上多个事务同时执行的时候，可能出现的脏读direty read、不可重复读non-repeatable read、幻读phantom read问题。  </p>
<p>SQL标准的事务隔离级别：<br>并行性能依次降低，安全性依次提高。  </p>
<ul>
<li>读未提交read uncommitted  <blockquote>
<p>一个事务还没提交时，它做的变更就能被别的事务看到。  </p>
</blockquote>
</li>
<li>读提交read committed  <blockquote>
<p>一个事务提交之后，它做的变更才会被其他事务看到。  </p>
</blockquote>
</li>
<li>可重复读repeatable read  <blockquote>
<p>一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的（事务在执行期间看到的数据前后是一致的）。未提交的变更对其他事务也是不可见的。<strong>事务启动时的视图想当于是静态的，不受其他事务的影响</strong>。  </p>
</blockquote>
</li>
<li>串行化serializable.  <blockquote>
<p>对于同一行记录，写会加写锁，读会加读锁。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。  </p>
</blockquote>
</li>
</ul>
<p>具体实现，数据库会创建一个视图，访问的时候以视图的逻辑结果为准。（建立视图没什么成本的，就是拷贝一个事务数组）<br><strong>视图的创建时间和并发事务的开始时间没关系，和事务首次read的时间有关；</strong>  </p>
<blockquote>
<p>RR下，事务在第一个Read操作时，会建立Read View<br>RC下，事务在每次Read操作时，都会建立Read View<br>在可重复读隔离级别下，这个视图<del>是在事务启动时创建的</del>(实际是<strong>在事务内第一次查询时</strong>被创建)，整个事务存在期间都用这个视图。<br>在读提交隔离级别下，这个视图是在每个<strong>SQL语句开始执行的时候</strong>创建的。<br>读未提交隔离级别下，直接返回记录上的最新值，没有视图概念。<br>串行化隔离级别下，直接用加锁的方式来避免并行访问。  </p>
</blockquote>
<p>Oracle数据库的默认隔离级别是“读提交”。<br>transaction-isolation=READ-COMMITTED。<br>MySQL数据库的默认隔离级别是“可重复度”。<br>transaction-isolation=repeatable-read。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看事务命令，MySQL5.7引入替换tx_isolqtion</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'transaction_isolation'</span>;</span><br></pre></td></tr></table></figure>

<h3 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h3><p>以可重复读为例  </p>
<p>在MySQL中，每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。  </p>
<p>一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录。<br><img src="/img/MySQL回滚日志与事务视图.png"></p>
<p>同一条记录在系统中可以存在多个版本—数据库的<strong>多版本并发控制MVCC</strong>。<br>某一时刻的视图中，要得到它的值，就必须将当前值倒序依次执行该时刻视图之后的各个回滚操作得到（read_view不存数据的值。视图数据也会变动，值不是物理存在的，为了得到视图A,需要执行回滚操作才能得到）。<br>即使当前有另一个事务在改当前值，这个事务跟原视图中对应的事务也不会冲突。  </p>
<p>表结构不在一致性视图的保护里面。  </p>
<hr>
<p>回滚日志在不需要的时候才删除。系统会判断，当没有事务再需要用到这些回滚日志时(当系统里没有比这个回滚日志更早的read-view的时候—更早启动的事务)，回滚日志会被删除（不是完全删除？）。（回滚日志在事务执行期间都会保留，事务提交后就无法回滚了）<br>对于在同一个事务里对同一个字段进行了多次修改，相应的回滚日志是记录多条。  </p>
<p>尽量不要使用长事务。长事务意味着系统里面会存在很老的事务视图。这些事务随时可能访问数据库里面的任何数据，在这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，就会导致大量占用存储空间。(回滚日志跟数据字典一起放在ibdata文件中(MySQL5.5之前版本)，即使长事务最终提交，回滚段被清理(逻辑上这些文件位置可以复用，但是并没有删除文件)，文件也不会变小。)<br>长事务占用锁资源，也可能会拖垮整个库。  </p>
<h3 id="事务的启动方式"><a href="#事务的启动方式" class="headerlink" title="事务的启动方式"></a>事务的启动方式</h3><p>数据库有默认的隔离级别，但是只针对单条语句。<br>多个语句要作为一个原子逻辑需要开启事务。  </p>
<ol>
<li>set autocommit=1，begin/start transaction显示的启动事务，commit提交，rollback回滚。  </li>
</ol>
<blockquote>
<p>autocommit=1的情况下，用begin显式启动的事务，如果执行commit则提交事务。如果执行commit work and chain，则提交事务并自动启动下一个事务，省去了再次执行begin语句的开销。（如果 set autocommit=1;并且没有begin的话，一个语句执行完成后就会直接提交事务）另外begin不是事务启动， 之后第一个DML才是。  </p>
</blockquote>
<ol start="2">
<li>set autocommit=0，关闭当前线程的自动提交，但是自动开启。只要执行了一个select语句，事务就自动启动了，但不会自动提交，这个事务持续存在直到主动执行commit或rollback语句，或者断开链接。  </li>
</ol>
<blockquote>
<p>没有显式开启事务的情况下，每个sql的执行都是一个事务。(不用begin启动事务，但需要手动commit，否则连接保持着可能变成长事务。)  </p>
</blockquote>
<p>start transaction 和 begin语义上是一样的<br>start transaction WITH CONSISTENT SNAPSHOT 才是会直接创建read-view ，也就是快照。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 在information_schema库的innodb_trx表中查询长事务  </span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> information_schema.innodb_trx <span class="keyword">where</span> TIME_TO_SEC(<span class="keyword">timediff</span>(<span class="keyword">now</span>(),trx_started))&gt;<span class="number">60</span>;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>基础架构</title>
    <url>/MySQL/1%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<img src="/img/MySQL逻辑架构图.png">

<p>MySQL可以分为Server层(连接、鉴权、计算)和存储引擎层(读写、存取数据)两部分。  </p>
<h2 id="Server层"><a href="#Server层" class="headerlink" title="Server层"></a>Server层</h2><p>涵盖MySQL的大多数核心服务功能，以及所有的内置函数（日期、时间、数学、加密），所有跨存储引擎的功能（存储过程、触发器、视图）。  </p>
<h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>管理连接，权限验证  </p>
<p>负责跟客户建立连接、获取权限(从权限表中获取并保存在变量中，供后续查询缓存、优化器、执行器等阶段权限校验时使用)、维持和管理连接。  </p>
<blockquote>
<p>mysql -h$ip -P$port -u$user -p  </p>
</blockquote>
<p>一个用户成功建立连接后，即使用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。只有新建的链接才会使用新的权限设置。  </p>
<blockquote>
<p>show processlist命令可查看当前存在的各连接列表及状态  </p>
</blockquote>
<p>客户端长时间没动静(wait_timeout默认8小时)，连接器会自动断开。  </p>
<blockquote>
<p>wait_timeout是非交互式连接的空闲超时，interactive_timeout是交互式连接的空闲超时。执行时间不计入空闲时间。<br>connect_timeout是连接过程中的等待时间，wait_timeout是连接完成后，使用过程中的等待时间。  </p>
</blockquote>
<p>长连接：连接成功后，客户端持续有请求则一直使用同一个链接。<br>短连接：每次执行完很少的几次查询就断开链接，下次查询再重新建立一个。  </p>
<blockquote>
<p>衡量标准，一次连接持续期内，执行了多少个sql语句。  </p>
</blockquote>
<p>MySQL在执行过程中临时使用的内存是管理在连接对象里面的(大量数据排序、变量、复杂存储过程等)，资源在连接断开时才释放。容易导致OOM。  </p>
<ul>
<li>定期断开长连接。  </li>
<li>执行mysql_reset_connection(为编程语言提供的api，不是sql语句)重新初始化当前链接资源(MySQL5.7以上)，不需要重连和重新做权限验证。  </li>
</ul>
<h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p>一种数据结构<br>命中则直接返回结果(MySQL8.0以上该功能删除)  </p>
<p>MySQL拿到查询请求，先到查询缓存查看是否执行过。之前执行过的语句及其结果以key-value对的形式缓存在内存中。若有则直接返回给客户端。  </p>
<p>查询缓存失效太频繁，对表的更新，会清空该表上所有的查询缓存。只适用于静态表(如系统配置表)。  </p>
<blockquote>
<p>query_cache_type=DEMAND不使用查询缓存。(或者query_cache_size=0)。<br>query_cache_limit单个结果集的大小上限；总量上限query_cache。<br>select SQL_CACHE * from test;显式指定该SQL使用查询缓存。  </p>
</blockquote>
<h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><p>词法分析，语法分析<br>解决做什么的问题  </p>
<p>词法分析：识别SQL语句中的字符串及其代表意义。(关键字验证和解析，查询语句/更新语句/删除语句；表名和字段名验证和解析，此处没有打开表，从information schema中直接读取，不需要打开表)。  </p>
<p>语法分析：依据语法规则，根据词法分析的结果，判断输入的SQL是否满足MySQL语法。  </p>
<blockquote>
<p>You have an error in your SQL syntax;//错误时提示  </p>
</blockquote>
<h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>执行计划生成，索引选择<br>解决怎么做的问题  </p>
<p>多个索引决定使用哪个索引；多表连接决定各个表的连接顺序等。(同一条SQL多次执行，不会重用优化策略，每次都要重新优化)  </p>
<blockquote>
<p>扩展 index_merge(先筛选再join连接，MySQL暂不支持跨表)</p>
</blockquote>
<h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>操作引擎，返回结果  </p>
<p>先判断用户对表的执行权限（命中查询缓存，返回结果时做权限验证；优化器前调用precheck验证权限；涉及触发器权限，只有在执行阶段才知道有哪些触发器）<br>无权限返回没有权限错误；有权限<strong>打开表</strong>(读取表的定义，获取表的结构)获取数据继续执行，根据表的引擎定义，使用对应引擎提供的接口。  </p>
<ul>
<li>调用InnoDB引擎接口取表的第一行，判断where条件中对应字段的值是不是符合，不是则跳过，是则将该行存在结果集中；  </li>
<li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到该表的最后一行；  </li>
<li>执行器将上述遍历过程中所有满足条件的行组成记录集作为结果集返回给客户端，并写入查询缓存。  <blockquote>
<p>存储引擎在找到一行合适的数据后，先返回给server层处理，server层处理完再读下一个。<br>对于使用索引的表，第一次调用“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”接口。  </p>
</blockquote>
</li>
</ul>
<p>数据库慢查询日志rows_examined字段，表示语句执行过程中扫描了多少行。执行器每次调用引擎获取数据行的时候累加。(同步调用)<br>执行器调用一次，在引擎内部可能扫描多行，引擎扫描行数跟rows_examined并不完全相同。  </p>
<h2 id="存储引擎层"><a href="#存储引擎层" class="headerlink" title="存储引擎层"></a>存储引擎层</h2><p>插件式的架构模式，负责数据的存储和提取。<br>不同的存储引擎共用一个Server层（从连接器到执行器部分）。  </p>
<h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>MySQL5.5.5以上默认存储引擎。<br>buffer_pool</p>
<h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>深入浅出索引</title>
    <url>/MySQL/4%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p><a href="/数据结构与算法/索引">数据结构与算法-索引</a></p>
<p>索引的出现是为了提高查询的效率，类似书的目录。对于数据库的表而言，索引就是它的目录。  </p>
<h3 id="索引的常见模型"><a href="#索引的常见模型" class="headerlink" title="索引的常见模型"></a>索引的常见模型</h3><p>哈希表、有序数组、搜索树。  </p>
<h4 id="哈希表-Memcached"><a href="#哈希表-Memcached" class="headerlink" title="哈希表-Memcached"></a>哈希表-Memcached</h4><p>哈希表是一种以键-值(key-value)存储数据的结构，只需要输入待查找的键，就可以找到其对应的值。把值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置。支持随机增删改查，key不是递增有序的，书序读取区间查找速度慢。  </p>
<p>多个key值经过哈希函数的换算，会出现同一个值的情况。哈希冲突，链表/开放寻址。</p>
<p><strong>哈希表适用于只有等值查询的场景。</strong>  </p>
<h4 id="有序数组"><a href="#有序数组" class="headerlink" title="有序数组"></a>有序数组</h4><p>数组按照id递增的顺序保存，在等值查询和范围查询场景中的性能都非常优秀用。二分查找可以快速找到指定id对应的数据时间复杂度为O(logn)。范围查询，先用二分法找到左区间开始位置，然后向后遍历即可。插入数据必须挪动后面所有的记录，成本贵太高。  </p>
<p><strong>有序数组使用于静态存储引擎。</strong>  </p>
<h4 id="二叉搜索树-MySQL"><a href="#二叉搜索树-MySQL" class="headerlink" title="二叉搜索树-MySQL"></a>二叉搜索树-MySQL</h4><p>每个节点的左儿子小于父节点，父节点又小于右儿子。查找指定id对应的数据的时间复杂度为o(logn)。为了维持O(logn)的查询复杂度，需要保持树是平衡二叉树，更新的时间复杂度为O(logn)。  </p>
<p>二叉树，大数据量树高过高，会产生多次磁盘IO。<br>扩展为N叉树，<strong>N叉树中的N取决于数据块的大小。</strong><br>树高取决于叶子树（数据行数）和“N叉树”的N。 而N是由页大小和索引大小决定的。</p>
<blockquote>
<p>N叉树N的值。5.6以后可以通过page的大小（默认16KB）来间接控制。<br>（键为整型4个字节（长整形8个字节）时，加上辅助数据（指针固定6个字节）及其他，差不多每个键key占13字节，16KB/13B，非叶子节点能存储1200个建，1200叉树）  </p>
</blockquote>
<p><strong>N叉树读写性能优良，适配磁盘的访问模式，广泛应用于数据库引擎。</strong>  </p>
<blockquote>
<p>B+树支持顺序扫描。能够很好的配合磁盘的读写特性（局部性原则-缓存），减少单次查询的磁盘访问次数。树根的数据块存储在内存中(少一次磁盘IO)。  </p>
</blockquote>
<p><a href="/数据结构与算法/B+树">数据结构与算法-B+树</a></p>
<h4 id="跳表-Redis"><a href="#跳表-Redis" class="headerlink" title="跳表-Redis"></a>跳表-Redis</h4><p><a href="/数据结构与算法/跳表">数据结构与算法-跳表</a></p>
<h4 id="LSM树-HBase"><a href="#LSM树-HBase" class="headerlink" title="LSM树-HBase"></a>LSM树-HBase</h4><p>牺牲读性能，提高写性能。<br>LSM(Log Structured Merge Tree)将磁盘随机写转化为顺序写。把一棵大树拆分成N棵小树，将对数据的修改增量保存在内存中，达到指定大小限制后批量把数据flush到磁盘中，磁盘中定期做merge操作，合并成一棵大树，以优化读性能。  </p>
<h3 id="InnoDB的索引模型"><a href="#InnoDB的索引模型" class="headerlink" title="InnoDB的索引模型"></a>InnoDB的索引模型</h3><p>在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为<strong>索引组织表</strong>。InnoDB使用了B+树索引模型，数据都是存储在B+树中的（有序）。（树中的节点并不存储数据本身，而是只是作为索引。叶子节点存储数据，把每个叶子节点串在一条链表上，链表中的数据是从小到大有序的。）  </p>
<blockquote>
<p>B+树的每个节点都是一页，最上层的根节点单独一页。<br><strong>B+树的叶子节点存储的是page(页，默认大小16k)，一个页里面可以存多个行。</strong><br>索引只能定位到page，page内部有个有序数组，二分法定位行数据。  </p>
</blockquote>
<p>每一个索引在InnoDB里面对应一棵B+树。一张表可以有多个索引。  </p>
<hr>
<p>根据叶子节点的内容，索引类型分为<strong>主键索引</strong>和<strong>非主键索引</strong>。  </p>
<h4 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h4><p>主键索引的叶子节点value存的是整行数据（一页16K，可以存多行。整张表的数据其实存在主键索引中。是数据不是地址）。在InnoDB里，主键索引也被称为<strong>聚簇索引</strong>(clustered index)。  </p>
<blockquote>
<p>主键查询方式，只需要搜索主键对应的B+树，就可以获得数据。(树节点的key是某行主键，value是该行数据。)  </p>
</blockquote>
<h4 id="非主键索引"><a href="#非主键索引" class="headerlink" title="非主键索引"></a>非主键索引</h4><p>非主键索引的叶子节点内容是主键的值（每个叶子节点是一个数据页，每个数据页16K,存放多个主键值）。在InnoDB里，非主键索引也被称为<strong>二级索引</strong>(secondary index)。  </p>
<blockquote>
<p>普通索引查询方式，需要先搜索普通索引树，得到主键的值，再到主键索引树搜索一次。这个过程称为<strong>回表</strong>。(基于非主键索引的查询多扫描一棵索引树，每条查出的数据都要分别回表。当然只需要主键的值，就不需要回表)  </p>
</blockquote>
<p>InnoDB会把主键字段放在普通索引字段后面，同时会去重。(二级索引中的主键会依次进行排序)  </p>
<blockquote>
<p>当主键是(a,b)的时候，<br>定义为c的索引，实际上是(c,a,b);<br>定义为(c,a)的索引，实际上是(c,a,a,b)–&gt;(c,a,b);<br>定义为(c,b)的索引，实际上是(c,b,a,b)–&gt;(c,b,a);– 回表时自动交换a,b列来查找对应的主键值  </p>
</blockquote>
<h3 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h3><h4 id="页分裂"><a href="#页分裂" class="headerlink" title="页分裂"></a>页分裂</h4><p>B+树为了维护索引有序性，在插入新值的时候需要做必要的维护—移动数据(追加新增递增插入时，不需要移动数据，不会页分裂)。如果原来所在的数据页已经满了，根据B+树的算法，需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为<strong>页分裂</strong>。（每个页面之间是用指针串的。分裂时只需要改指针指向。）  </p>
<p>页分裂操作不仅影响性能，还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约50%。  </p>
<h4 id="页合并"><a href="#页合并" class="headerlink" title="页合并"></a>页合并</h4><p>当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。  </p>
<hr>
<p>没有主键的表，InnoDB会默认创建一个Rowid做主键。  </p>
<h4 id="自增主键"><a href="#自增主键" class="headerlink" title="自增主键"></a>自增主键</h4><p>自增主键的插入数据模式：插入新纪录的时候可以不指定ID的值，系统会获取当前ID最大值加1作为下一条记录的ID值。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。（一个页满了，就申请另外一个页面从左边开始写数据。）  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 自增主键是指自增列上定义的主键。主键天然是索引，不用显示指定index  </span></span><br><span class="line">not null primary key quto_increment</span><br></pre></td></tr></table></figure>

<h4 id="业务逻辑主键"><a href="#业务逻辑主键" class="headerlink" title="业务逻辑主键"></a>业务逻辑主键</h4><p>业务逻辑的字段做主键，不容易保证有序插入，写数据成本高。<br>每个非主键索引的叶子节点上都是主键的值。如果用业务逻辑字段做主键，叶子节点占用空间一般比整型（4字节）或长整型（8字节）自增主键占用的空间大。  </p>
<p>只有一个索引；该索引必须是唯一索引。适合用业务字段直接做主键。<br>典型的KV场景（没有range操作），由于没有其他索引，不用考虑其他索引的叶子节点大小的问题。利用尽量使用主键查询的原则，直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树。  </p>
<hr>
<p>索引可能因为删除、或者页分裂等原因，导致数据页有空洞，重建索引的过程会创建一个新的索引，把数据按顺序插入，这样页面利用率最高，索引更紧凑、更省空间。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 关键字index 与 key无区别</span></span><br><span class="line"><span class="comment">-- 删除并重建普通索引  </span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> T <span class="keyword">drop</span> <span class="keyword">index</span> k;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> T <span class="keyword">add</span> <span class="keyword">index</span>(k);</span><br><span class="line"><span class="comment">-- 删除重建主键索引  </span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> T <span class="keyword">drop</span> primary <span class="keyword">key</span>;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> T <span class="keyword">add</span> primary <span class="keyword">key</span>(<span class="keyword">id</span>);</span><br><span class="line"><span class="comment">-- 删除主键或者创建主键，都会将整个表重建，导致普通索引失效  </span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> T <span class="keyword">engine</span> = <span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>

<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>回到主键索引树搜索的过程，称为<strong>回表</strong>。查询结果所需要的的数据只在主键索引上有，不得不回表。  </p>
<p>在查询里面，要查询的值已经在普通索引树上了，可以直接提供查询结果，不需要回表。普通索引已经“覆盖了”查询需求，称为<strong>覆盖索引</strong>。（select返回部分的列+where条件条件的列）<br>覆盖索引可以减少树的搜索次数，显著提升查询性能，使用覆盖索引是一个常用的性能优化手段。（维护性能下降）  </p>
<p>基于B+树的结构，对于范围查找between and，索引定位到左边界后遍历直到不满足条件。(且对于二级索引边扫描边回表搜索，有mrr(Multi-Range Read Optimization)优化就一起回表)<br>where条件in语句走对应字段的索引，把in里面的条件挨个循环走一遍索引。  </p>
<h3 id="最左前缀原则-联合索引"><a href="#最左前缀原则-联合索引" class="headerlink" title="最左前缀原则-联合索引"></a>最左前缀原则-联合索引</h3><p>B+树这种索引结构，可以利用索引的“最左前缀”，来定位记录。  </p>
<p>不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。<br>最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。  </p>
<p><strong>InnoDB的每个普通索引（叶子节点存的是主键值），都相当于这个索引字段和主键字段的联合索引。联合索引按照联合字段定义的先后顺序，依次进行排序存储。</strong>(避免order by再排序，先排序再回表)<del>非叶子节点只是第一个关键字的索引(所以只有第一个关键字能用到快速定位)</del>。非叶子节点存储的对应联合索引各个字段，叶子节点在非叶子基础上加上主键字段。  </p>
<p>建立联合索引，安排索引内字段顺序的原则：  </p>
<ul>
<li>如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。  </li>
<li>既有联合查询，又有基于各个字段的各自查询，查询条件只有后面字段的查询无法用到联合索引，需要针对后面字段再单独建立索引。联合索引字段的先后顺序，考虑空间占用，字段大的放前面跟小字段建立联合索引，字段小的再建立单字段索引。  </li>
</ul>
<blockquote>
<p><strong>如果查询顺序和联合索引的顺序不一致，优化器会自动做优化。查询语句中的where里面各个判断调换顺序无影响。</strong>  </p>
</blockquote>
<blockquote>
<p>index_merge，合并索引优化，有临时表消耗。</p>
</blockquote>
<hr>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'j'</span> 或 <span class="string">'j%'</span> 或 <span class="string">'%j'</span> 或 <span class="string">'%j%'</span> 使用<span class="keyword">name</span>索引的问题(主键<span class="keyword">id</span>)：</span><br><span class="line">a. 只有 <span class="keyword">id</span> 和 <span class="keyword">name</span> 字段。</span><br><span class="line">b. 添加了 age 字段，即 <span class="keyword">id</span>、<span class="keyword">name</span>、age 字段。</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> <span class="keyword">like</span> <span class="string">'j'</span> 或 <span class="string">'j%'</span> 可以使用<span class="keyword">name</span>索引，并且快速定位记录。</span><br><span class="line"><span class="number">2.</span> <span class="keyword">like</span> <span class="string">'%j'</span> 或 <span class="string">'%j%'</span>，只是在<span class="keyword">name</span>二级索引树上遍历查找记录，并不能快速定位（扫描了整棵索引树）。</span><br><span class="line"><span class="number">3.</span> 只有 <span class="keyword">id</span> 和 <span class="keyword">name</span> 字段时，上述 <span class="number">4</span> 种 <span class="keyword">like</span> 查询，<span class="keyword">name</span> 索引能满足 <span class="keyword">id</span> 和 <span class="keyword">name</span> 的查询情况，不需要回表，所以选择了使用 <span class="keyword">name</span> 的索引树解决问题。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 添加了 age 但无联合索引 (<span class="keyword">name</span>, age) 的情况，如果使用 <span class="keyword">name</span> 索引树，需要回表。再 <span class="keyword">like</span> <span class="string">'%j'</span> 或 <span class="string">'%j%'</span> 直接扫描主键索引树，现象就是没有使用 <span class="keyword">name</span> 索引。</span><br><span class="line"><span class="number">5.</span> 添加了 age 字段，也添加了 (<span class="keyword">name</span>, age) 索引，和第 <span class="number">3</span> 点同理，使用覆盖索引就能满足 <span class="keyword">select</span> * 的字段查询，不需要回表，因此使用了 (<span class="keyword">name</span>, age) 索引树。但是只有 <span class="keyword">like</span> <span class="string">'j'</span> 和 <span class="string">'j%'</span>能快速定位记录，而 <span class="keyword">like</span> <span class="string">'%j'</span> 和 <span class="string">'%j%'</span> 也能使用该索引树，但是不能快速定位，需要顺序遍历。</span><br><span class="line"><span class="comment">-- 针对联合索引，左侧字段的条件必须是=，不能是大于或者小于等范围值、不等于（!= &lt;&gt;）、is null is not null，否则右侧字段用不上。  </span></span><br><span class="line"><span class="comment">-- 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。（不能用索引快速定位）</span></span><br></pre></td></tr></table></figure>

<h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>不符合最左前缀的部分。索引下推（index condition pushdown）需要server层和引擎层配合。<br>联合索引（name,age），查询 name like ‘张%’ and age = 10的记录。  </p>
<ol>
<li>用到联合索引找到张开头的记录。  </li>
<li>判断其他条件<br> 2.1 MySQL5.6之前，只能从得到的‘张’开头的记录开始（根本不看联合索引中其他字段的值），一个个回表，到主键索引上找出数据行，再对比其他字段值。<br> 2.2 MySQL5.6引入索引下推（引擎层）优化(index condition pushdown)，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录（不是快速定位，只是快速过滤），减少回表次数。（索引下推其实是把条件判断提前了）  </li>
</ol>
<blockquote>
<p>扫描行数问题，在引擎内部读取了多条记录，在server层只拿到了符合条件的记录，而扫描行数统计结果以server层的为主了。  </p>
</blockquote>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>开发实践</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h3 id="时间、空间复杂度不能跟性能划等号"><a href="#时间、空间复杂度不能跟性能划等号" class="headerlink" title="时间、空间复杂度不能跟性能划等号"></a>时间、空间复杂度不能跟性能划等号</h3><p>在实际的软件开发中，复杂度不能与性能简单划等号，不能表示执行时间和内存消耗的确切数据量。  </p>
<ul>
<li><p>复杂度不是执行时间和内存消耗的精确值<br>  在用大O表示法表示复杂度的时候，会忽略掉低阶、常数、系数，只保留高阶，并且它的度量单位是语句的执行频度。每条语句的执行时间，并非是相同、确定的。复杂度给出的只能是一个非精确度量值的趋势</p>
</li>
<li><p>代码的执行时间有时不跟时间复杂度成正比<br>  对于小规模数据的处理，算法的执行效率并不一定跟时间复杂度成正比，有时还会跟复杂度成正比。  </p>
</li>
<li><p>对于处理不同问题的不同算法，其复杂度大小没有可比性<br>  复杂度只能用来表征不同算法，在处理同样的问题，以及同样数据类型的情况下的性能表现。对于不同的问题、不同的数据类型，不同算法之间的复杂度大小并没有可比性。  </p>
</li>
</ul>
<h3 id="抛开数据规模谈数据结构和算法都是“耍流氓”"><a href="#抛开数据规模谈数据结构和算法都是“耍流氓”" class="headerlink" title="抛开数据规模谈数据结构和算法都是“耍流氓”"></a>抛开数据规模谈数据结构和算法都是“耍流氓”</h3><p>在数据规模很小的情况下，普通算法和高级算法之间的性能差距会非常小。如果代码执行频率不高，又不是核心代码，这个时候，选择数据结构和算法的主要依据是，其是否简单、容易维护、容易实现。大部分情况下，直接用最简单的存储结构和最暴力的算法就可以了。<br>小数据规模，对于处理时间是毫秒量级敏感的系统来说，高级算法的性能提升并不大，反而会陡增编码的难度，还容易产生bug。  </p>
<h3 id="结合数据特征和访问方式来选择数据结构"><a href="#结合数据特征和访问方式来选择数据结构" class="headerlink" title="结合数据特征和访问方式来选择数据结构"></a>结合数据特征和访问方式来选择数据结构</h3><p>最考验能力的并不是数据结构和算法本身，而是对问题需求的挖掘、抽象、建模。如何将一个背景复杂、开放的问题，通过细致的观察、调研、假设，理清楚要处理数据的特征与访问方式，才是解决问题的重点。将问题转化成合理的数据结构模型，进而找到满足需求的算法。  </p>
<h3 id="区别对待IO密集、内存密集和计算密集"><a href="#区别对待IO密集、内存密集和计算密集" class="headerlink" title="区别对待IO密集、内存密集和计算密集"></a>区别对待IO密集、内存密集和计算密集</h3><p>如果要处理的数据存储在磁盘，那代码的性能瓶颈有可能在磁盘IO，而非算法本身，需要合理的选择数据存储格式和存取方式，减少磁盘IO的次数。  </p>
<p>数据存储在内存中，需要考虑代码时内存密集型的还是CPU密集型的。<br>CPU密集型，从内存中读取一次数据，到CPU缓存或者寄存器之后，会进行多次频繁的CPU计算，CPU计算耗时占大部分。在选择数据结构和算法的时候，要尽量减少逻辑计算的复杂度 ，用位运算道题加减乘除运算。<br>内存密集型，计算比较简单，每次从内存中读取数据之后，只需要进行一次简单的比较操作。内存数据的读取速度，是比较操作的瓶颈。在选择数据结构和算法的时候，要考虑是否能减少数据的读取量，数据是否在内存中连续存储，是否能利用CPU缓存预读。  </p>
<h3 id="善用语言提供的类，避免重复造轮子"><a href="#善用语言提供的类，避免重复造轮子" class="headerlink" title="善用语言提供的类，避免重复造轮子"></a>善用语言提供的类，避免重复造轮子</h3><p>对于大部分常用的数据结构和算法，编程语言都提供了现成的类和函数实现。Java中，HashMap—散列表；TreeMap—红黑树。  </p>
<p>编程语言提供的类和函数，都是经过无数验证付的，不管是正确性、健壮性。  </p>
<h3 id="千万不要漫无目的地过度优化"><a href="#千万不要漫无目的地过度优化" class="headerlink" title="千万不要漫无目的地过度优化"></a>千万不要漫无目的地过度优化</h3><p>对普通情况下的数据规模和性能压力做估算，同时对异常以及将来一段时间内，可能达到的数据规模和性能压力做估算。<br>优化代码时，先做基准测试，避免想当然的换了更高效的算法，但真实情况下，性能反倒下降。  </p>
<img src="/img/数据结构与算法图谱.jpg">

<img src="/img/数据结构与算法学习路线.png"><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>普通索引和唯一索引</title>
    <url>/MySQL/%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h3 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h3><p>查询语句select * from T where k = 5;在索引树上查找的过程。（表T中id为主键列，字段k上有索引）。<br>先是通过B+树从树根开始，按层搜索到叶子节点-数据页，然后数据页内部通过二分法来定位记录。  </p>
<ul>
<li>对于普通索引来说，查找到满足条件的第一个记录后，需要查找下一个记录，直到碰到第一个不满足k=5条件的记录。  </li>
<li>对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。  </li>
</ul>
<p>InnoDB的数据是按数据页为单位来读写的。当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在InnoDB中，每个数据页的大小默认是16KB。  </p>
<p>因为引擎是按页读写的，所以当找到k=5的记录的时候，它所在的数据页就都在内存里了。对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。（如果k=5这个记录刚好是这个数据页的最后一个记录，那么要取下一个记录，必须读取下一个数据页，这个操作会稍微复杂一些。）  </p>
<p>整体来说，普通索引和唯一索引的查询性能差距微乎其微。  </p>
<h3 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h3><h4 id="change-buffer定义"><a href="#change-buffer定义" class="headerlink" title="change buffer定义"></a>change buffer定义</h4><p>change buffer的主要目的是将对二级索引的数据操作缓存下来（二级索引数据页存储索引和主键信息），以此减少二级索引的随机IO，达到操作合并的效果。</p>
<p>当需要更新一个数据页时：  </p>
<ul>
<li>如果数据页在内存中就直接更新；  </li>
<li>如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InnoDB会将这些更新操作缓存在change buffer中(同时记录新增一条change buffer的redo log)，这样就不需要从磁盘中读入这个数据页了，此时内存中没有这个物理页，不存在脏页。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作（merge，只有merge才会触发更新数据，同时记录数据变更的redo log和change buffer变更的redo log）。通过这种方法就能保证这个数据逻辑的正确性。  </li>
</ul>
<p>数据页没在内存，才能用上change buffer。</p>
<hr>
<p>将change buffer中的操作应用到原数据页，得到最新结果的过程称为merge。(只有merge操作才会更新数据，其余change buffer、redo log只是记录操作)  </p>
<ul>
<li>访问数据页出发merge；  </li>
<li>系统后台线程定期merge；  </li>
<li>数据库正常关闭（shutdown）的过程中执行merge操作。  </li>
</ul>
<p>merge的执行流程：  </p>
<ol>
<li>从磁盘读入数据页到内存（老版本的数据页）；  </li>
<li>从change buffer里找到这个数据页的change buffer记录（可能有多个），<strong>依次</strong>应用，得到新版数据页；  </li>
<li>写redo log。这个redo log包含了数据的变更和change buffer的变更。  </li>
</ol>
<p>merge过程结束。此时数据页（数据表空间）和内存中change buffer对应的磁盘位置（系统表空间）都还没有修改，属于脏页，之后各自刷回自己的物理数据，属于另外一个过程。  </p>
<hr>
<p>change buffer是可以持久化的数据。change buffer在内存中有拷贝，也会被写入到磁盘。<br>change buffer的写盘策略跟数据一样（WAL记日志），内存放不下会触发落盘，还有checkpoint推进的时候也是可能会触发。  </p>
<p>如果能够将更新操作先记录在change buffer，减少读磁盘，语句的执行速度会得到明显的提升。而且数据读入内存是需要占用buffer pool的，所以这种方式还能够避免占用内存，提高内存利用率。（change buffer只是记录了更新过程，占用的内存比数据页读入内存的占用要小的多）  </p>
<h4 id="change-buffer使用条件"><a href="#change-buffer使用条件" class="headerlink" title="change buffer使用条件"></a>change buffer使用条件</h4><ul>
<li>唯一索引，所有的更新操作都要先判断这个操作是否违反唯一性约束。插入记录时，要先判断现在表中是否已经存在索引对应的记录，而这必须要将数据页读入内存才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用change buffer了。<strong>唯一索引的更新不能使用change buffer。</strong>  </li>
<li><strong>只有普通索引可以使用change buffer。</strong>  </li>
</ul>
<p>innodb_change_buffer_max_size参数设置change buffer占用内存的大小，change buffer用的是buffer pool里的内存。</p>
<h4 id="change-buffer插入流程"><a href="#change-buffer插入流程" class="headerlink" title="change buffer插入流程"></a>change buffer插入流程</h4><ol>
<li>这个记录要更新的目标页在内存中：  </li>
</ol>
<ul>
<li>唯一索引，找到内存中相应位置，判断没有冲突，插入这个值，语句执行结束；  </li>
<li>普通索引，找到内存中相应位置，插入这个值，语句执行结束。  </li>
</ul>
<ol start="2">
<li>这个记录要更新的目标页不在内存中：  </li>
</ol>
<ul>
<li>唯一索引，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束；  </li>
<li>普通索引，将更新记录在change buffer，语句执行结束。  </li>
</ul>
<blockquote>
<p>针对同一行记录的多次更改，对应多条change buffer记录，并不是在已有记录上更改。  </p>
</blockquote>
<p>将数据从磁盘读入内存涉及随机IO的访问，是数据库里面成本最高的操作之一。change buffer因为减少了随机磁盘访问，所以对更新性能的提升很明显。  </p>
<p>对于唯一索引，大量更新数据（插入）的操作，引起大量磁盘IO操作，容易使整个系统处于阻塞状态，更新语句全部堵住。  </p>
<h4 id="change-buffer使用场景"><a href="#change-buffer使用场景" class="headerlink" title="change buffer使用场景"></a>change buffer使用场景</h4><p>并不是普通索引的所有场景，使用change buffer都可以起到加速作用。  </p>
<p>merge的时候是真正进行数据更新的时刻，而change buffer的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做merge之前，change buffer记录的变更越多，这个页面上要更新的次数越多，收益就越大。  </p>
<p>对于写多读少的业务，页面在写完以后马上被访问到的概率比较小，此时change buffer的使用效果最好。（账单类、日志类系统）。  </p>
<p>假设一个业务的更新模式是写入之后马上做查询，那么及时满足了条件，将更新先记录在change buffer，但之后由于马上要访问这个数据页，会立即出发merge过程。这样随机访问IO的次数不会减少，反而增加了change buffer的维护代价。反而起到了副作用。  </p>
<h3 id="索引选择"><a href="#索引选择" class="headerlink" title="索引选择"></a>索引选择</h3><p>普通索引和唯一索引，在查询能力上没差别，主要考虑的是对更新性能的影响。尽量选择普通索引（业务代码保证不会写入重复数据）。  </p>
<p>如果所有的更新后面，都马上伴随着对这个记录的查询，那么应该关闭change buffer。而在其他情况下，change buffer都能提升更新性能。  </p>
<p>普通索引和change buffer的配合使用，对于数据量大的表的更新优化很明显。（归档库）  </p>
<h3 id="change-buffer和redo-log"><a href="#change-buffer和redo-log" class="headerlink" title="change buffer和redo log"></a>change buffer和redo log</h3><p>WAL(write-ahead logging)预写日志系统，提升性能的核心机制，是尽量减少随机读写。  </p>
<p><strong>redo log主要节省的是随机写磁盘的IO消耗(顺序写磁盘)，而change buffer主要节省的则是随机读磁盘的IO消耗。</strong>  </p>
<p>change buffer记录索引页的变化，此时内存中是没有对应数据的物理页的；redo log记录内存中数据页的变更（产生脏页），也记录change buffer的变化（只有change buffer的merge操作才会更新数据）。（参考下面的图）  </p>
<p>redo log有几十种类型。redo记录页的变化（WAL将页变化的乱序写转换成顺序写）。页分很多种，B+树索引页、undo页、change buffer页等，这些页被redo记录后就不着急刷盘。所以change buffer也用了WAL机制。  </p>
<hr>
<p>crash safe:<br>虽然只更新内存，但是在事务提交的时候，把change buffer的操作也记录到redo log里了，所以崩溃恢复的时候，change buffer也能找回来。  </p>
<ol>
<li>change buffer更新完成并且相应事务提交的情况下，首先要保证redo log落盘（二阶段提交），若此时掉电重启，则可以根据redo进行恢复。  </li>
<li>若change buffer更新完成但是相应事务未提交的情况下，redo有可能落盘了(redo的组提交)，也有可能未落盘。  </li>
</ol>
<ul>
<li>redo落盘，读取redo发现没有commit标志（还会进行lsn(log sequence number日志序列号)，和binlog对比），则回滚。  </li>
<li>redo未落盘，则不会出现前滚和回滚的情况，数据依旧一致。  </li>
</ul>
<p>服务器掉电重启对change buffer的影响。  </p>
<ol>
<li>如果掉电，持久化的change buffer数据已经merge，不用恢复。  </li>
<li>未持久化的change buffer：  </li>
</ol>
<ul>
<li>change buffer写入，redo log写入但未commit，binlog未同步到磁盘，数据丢失。  </li>
<li>change buffer写入，redo log写入但未commit，binlog已经同步到磁盘，先从binlog恢复redo log，再从redo log恢复change buffer。  </li>
<li>change buffer写入，redo log和binlog都已经同步，那么直接从redo log里恢复。</li>
</ul>
<h4 id="change-buffer写过程"><a href="#change-buffer写过程" class="headerlink" title="change buffer写过程"></a>change buffer写过程</h4><blockquote>
<p>insert into t(id,k) values(id1,k1),(id2,k2);  </p>
</blockquote>
<img src="/img/MySQL带change buffer的写过程.png">

<p>当前索引树的状态，查找到位置后，k1所在的数据页在内存中（InnoDB buffer pool），k2所在的数据页不在内存中。  </p>
<p>插入语句涉及四个部分：<br>内存、redo log(ib_log_fileX)、数据表空间(t.tid)、系统表空间(ibdata1)。  </p>
<ol>
<li>Page1在内存中，直接更新内存；  </li>
<li>Page2没有在内存中，就在内存的change buffer区域，记录下“往Page2插入一行”这个信息；  </li>
<li>将上述两个动作记入redo log中(3,4)。  </li>
</ol>
<p>做完上述操作，事务完成。执行这条语句的成本很低，写了两处内存，写了一处磁盘(两次操作合在一起写了一次磁盘)，而且是顺序写磁盘redolog。两个虚线箭头，系统表和数据表时后台操作，不影响更新的相应时间。  </p>
<blockquote>
<p>insert时，写主键无法使用change buffer（主键唯一），但是同时也会写其它索引，其它索引中的“非唯一索引”可以用到change buffer的优化机制，不用立即更新磁盘上的普通索引。  </p>
</blockquote>
<h4 id="change-buffer读过程"><a href="#change-buffer读过程" class="headerlink" title="change buffer读过程"></a>change buffer读过程</h4><blockquote>
<p>select * from t where k in(k1,k2);  </p>
</blockquote>
<img src="/img/MySQL带change buffer的读过程.png">

<p>如果读语句发生在更新语句后不久，内存中的数据都还在，此时读操作与系统表空间(ibdata1)和redo log(ib_log_fileX)无关。  </p>
<ol>
<li>读Page1的时候，直接从内存返回。虽然磁盘上还是之前的数据，但是直接从内存返回结果，结果是正确的。（此处WAL之后读数据，不需要读盘，不用从redo log里面把数据更新以后再返回）  </li>
<li>读Page2的时候，需要把Page2从磁盘读入内存中，然后应用change buffer里面的操作日志，生成一个正确的版本并返回结果。  </li>
</ol>
<p>直到需要读Page2的时候，这个数据页才会被读入内存。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>全局锁+表锁+行锁</title>
    <url>/MySQL/5%E5%85%A8%E5%B1%80%E9%94%81+%E8%A1%A8%E9%94%81+%E8%A1%8C%E9%94%81/</url>
    <content><![CDATA[<p>根据加锁的范围，MySQL里面的锁大致可以分成全局锁、表锁、行锁三类。<br><strong>全局锁和表锁都是在Server层（基本是在执行器阶段）实现的</strong>，与及具体的存储引擎无关。<br><strong>行锁是在引擎层由各个引擎自己实现的</strong>，并不是所有的引擎都支持行锁。</p>
<h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p>全局锁就是对整个数据库实例加锁。  </p>
<h4 id="1-Flush-tables-with-read-lock-FTWRL"><a href="#1-Flush-tables-with-read-lock-FTWRL" class="headerlink" title="1. Flush tables with read lock;(FTWRL)"></a>1. Flush tables with read lock;(FTWRL)</h4><p>加全局读锁，让整个库处于只读状态，其他线程的：数据更新语句（数据的增删改）、数据定义语句（建表、修改表结构）、更新类事务的提交语句，会被阻塞。(FTWRL前有读写的话，FTWRL会等待读写执行完毕后才执行。)  </p>
<p><strong>全局锁的典型使用场景是，做全库逻辑备份</strong>。（把整库每个表都select出来存成文本）。风险：  </p>
<ul>
<li>在主库上备份，在整个备份期间都不能执行更新，业务基本上就得停摆。</li>
<li>在从库上备份，备份期间从库不能执行主库同步过来的binlog，会导致主从延迟。  </li>
</ul>
<p>不加锁的话，备份系统备份得到的库不是一个逻辑时间点，这个视图是逻辑不一致的。（在可重复读隔离级别下开启一个事务，可以拿到一致性视图。）  </p>
<h4 id="2-mysqldump-–single-transaction"><a href="#2-mysqldump-–single-transaction" class="headerlink" title="2. mysqldump –single-transaction;"></a>2. mysqldump –single-transaction;</h4><p>官方逻辑备份工具mysqldump。导数据之前会启动一个事务，来确保拿到一致性视图。基于MVCC(多版本并发控制)，保证<strong>备份过程中数据可以正常更新</strong>。  </p>
<p>single-transaction只适用于所有的表使用事务引擎的库(InnoDB)。如果有的表使用了不支持事务的引擎(MyISAM)，那么备份就只能通过FTWRL方法。  </p>
<p>表结构不在一致性视图的保护里面，表结构数据不支持一致性读。<br>备份时启动了可持续读的事务，在整个备份过程中都是在这个视图下执行的，其他事务的变更不会影响它的备份。但是master传过来的DDL影响，会得到DDL后的表结构。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        备库用–single-transaction 做逻辑备份
    </div>
    <div class='spoiler-content'>
        <p>从主库的binlog传来一个DDL语句。  </p>
<pre><code class="sql">Q1:<span class="keyword">SET</span> <span class="keyword">SESSION</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> REPEATABLE <span class="keyword">READ</span>; <span class="comment">-- 确保RR（可重复读）隔离级别</span>
Q2:<span class="keyword">START</span> <span class="keyword">TRANSACTION</span>  <span class="keyword">WITH</span> <span class="keyword">CONSISTENT</span> <span class="keyword">SNAPSHOT</span>；<span class="comment">-- 确保得到一个一致性视图</span>
<span class="comment">/* other tables */</span>
Q3:<span class="keyword">SAVEPOINT</span> sp;<span class="comment">-- 设置一个保存点</span>
<span class="comment">/* 时刻 1 */</span>
Q4:<span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> <span class="string">`t1`</span>;<span class="comment">-- 拿到表结构</span>
<span class="comment">/* 时刻 2 */</span>
Q5:<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`t1`</span>;<span class="comment">-- 正式导数据</span>
<span class="comment">/* 时刻 3 */</span>
Q6:<span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> <span class="keyword">SAVEPOINT</span> sp;<span class="comment">-- 回滚到sp---释放t1的MDL锁</span>
<span class="comment">/* 时刻 4 */</span>
<span class="comment">/* other tables */</span></code></pre>
<ol>
<li>如果在 Q4 语句执行之前到达，现象：没有影响，备份拿到的是 DDL 后的表结构。  </li>
<li>如果在“时刻 2”到达，则表结构被改过，Q5 执行的时候，报 Table definition has changed, please retry transaction，现象：mysqldump 终止；  </li>
<li>如果在“时刻 2”和“时刻 3”之间到达，mysqldump 占着 t1 的 MDL 读锁，binlog 被阻塞，现象：主从延迟，直到 Q6 执行完成。  </li>
<li>从“时刻 4”开始，mysqldump 释放了 MDL 读锁，现象：没有影响，备份拿到的是 DDL 前的表结构。</li>
</ol>

    </div>
</div>  


<h4 id="3-set-global-readonly-true"><a href="#3-set-global-readonly-true" class="headerlink" title="3.set global readonly=true;"></a>3.set global readonly=true;</h4><p>让全库进入只读状态。  </p>
<ul>
<li>有些系统中，readonly的值会被用来做其他逻辑：判断一个库是主库还是备库。修改global变量的方式影响面太大。  </li>
<li>在异常处理机制上。执行FTWRL命令后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。将整个库设置成readonly之后，如果客户端发生异常，则数据库会一直保持readonly状态，会导致整个库长时间处于不可写状态，风险较高。  </li>
<li>如果用户有超级权限，readonly是失效的。执行binlog的线程（主从复制）是super权限，不影响主从复制。  </li>
</ul>
<hr>
<p>业务的更新不仅有增删改数据DML(Data Manipulation Language)（select … lock in share mode;select … for update;行锁），还可能有加字段等修改表结构的操作DDL(Data Definition Language)。都会被全局锁锁住。</p>
<h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>MySQL表级别的锁有两种不同维度：表锁、元数据锁(meta data lock,MDL)。  </p>
<h4 id="1-表锁lock-tables-…-read-write"><a href="#1-表锁lock-tables-…-read-write" class="headerlink" title="1. 表锁lock tables … read/write;"></a>1. 表锁lock tables … read/write;</h4><p>与FTWRL类似，可以用unlock tables主动释放锁，也可以在客户端断开的时候自动释放。lock tables语法除了会限制别的线程的读写锁外，也限定了本线程接下来的操作对象。  </p>
<blockquote>
<p>如果在某个线程A中执行了lock tabes t1 read, t2 write;则其他线程写t1、读写t2的语句都会被阻塞。同时，线程A在执行unlock tables之前，也只能执行读t1、读写t2的操作，不允许写t1，更不能访问其他表。  </p>
</blockquote>
<p>InnoDB引擎支持行锁，一般不使用lock tables命令来控制并发，锁住整个表的影响太大。(lock tables&amp;unlock tables–&gt;begin commit)  </p>
<h4 id="2-元数据锁MDL-metadata-lock"><a href="#2-元数据锁MDL-metadata-lock" class="headerlink" title="2. 元数据锁MDL(metadata lock);"></a>2. 元数据锁MDL(metadata lock);</h4><p><strong>MDL不需要显式使用，在访问一个表的时候会被自动加上</strong>。MDL保证读写的正确性。<strong>MDL防止DDL(表结构)和DML(增删改)并发的冲突。</strong>  </p>
<p>MySQL5.5引入MDL锁，当对一个表做增删改查操作的时候(DML)，加MDL读锁；当要对表做数据结构变更操作的时候(DDL)，加MDL写锁。  </p>
<ul>
<li>读锁之间不互斥，可以有多个线程同时对一张表增删改查。(对同一行数据更新导致的互斥是行锁发挥作用)。（InnoDB做数据的增删改查不需要加表锁）  </li>
<li>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完成才能开始执行。  </li>
</ul>
<p><strong>事务中的MDL锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交之后再释放。</strong>  </p>
<p>给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据，加MDL写锁。（加普通字段不用重建全表，加主键要重建）  </p>
<p>一个连接就是一个session，一个连接里可以先后创建多个事务（必须前一个结束才能启动下一个）。事务是无处不在的，大事务会造成额外的处理开销。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        dml与ddl之间交互容易出现不可读写的情况
    </div>
    <div class='spoiler-content'>
        <pre><code class="sql">session A:<span class="keyword">select</span> * <span class="keyword">from</span> t;  
session B:<span class="keyword">select</span> * <span class="keyword">from</span> t;  
session C:<span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> f <span class="built_in">int</span>;  
session D:<span class="keyword">select</span> * <span class="keyword">from</span> t;  </code></pre>
<p>dml与ddl之间交互容易出现不可读写的情况：  </p>
<ol>
<li>session A先启动begin，会对表t加MDL读锁。session B需要的也是MDL读锁，可以正常执行。(不显式begin,不用显式commit,查询完自动释放)  </li>
<li>session C需要的是MDL写锁，session A的读锁还未释放，session C只能被阻塞。  </li>
<li>之后所有要在表t上新申请MDL读锁的请求(session D)会被session C阻塞(锁队列，先来先得，一进去等待时就开始影响后面，申请不到也占着)。所有对表的增删改查操作都需要先申请MDL读锁，都被锁住，整个表t完全不可读写了。  </li>
<li>若表t上的查询语句频繁+客户端重试机制(超时后再起一个新的session再请求)，整个库的线程会很快爆满。  </li>
</ol>

    </div>
</div>  

<p>MySQL5.6支持online ddl(不堵塞增删改查mdl读锁，ddl执行的大部分时间，占着的也是mdl读锁)：  </p>
<blockquote>
<p>1.拿MDL写锁<br>2.降级成MDL读锁<br>3.真正做DDL<br>4.升级成MDL写锁<br>5.释放MDL锁  </p>
</blockquote>
<hr>
<p>安全的给小表加字段：  </p>
<ul>
<li>非热点表：首先解决长事务，事务不提交，就会一直占用MDL锁。在MySQL的information_schema库的innodb_trx表中，可以查到当前执行中的事务。如果要做DDL变更的表有长事务执行，需要先暂停DDL，或者kill掉这个长事务。  </li>
<li>热点表：在alter table语句中设定等待时间。如果在指定的等待时间里面能够拿到MDL写锁就执行，拿不到就不要阻塞后面的业务语句，先放弃。之后再通过重试命令重复这个过程。  </li>
</ul>
<p>MariaDB和AliSQL这两个开源分支都支持DDL NOWWAIT/WAIT N语法（语句级别。对应session级别的lock_wait_timeout）；</p>
<pre><code class="sql"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name NOWWAIT <span class="keyword">add</span> <span class="keyword">column</span> ...;
<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">WAIT</span> N <span class="keyword">add</span> <span class="keyword">column</span> ...;</code></pre>
<p>大表加字段：<br>pt-online-schema-change<br>gh-ost  </p>
<h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><p>行锁是针对数据表中行记录的锁。事务A更新了一行，而这时候事务B也要更新同一行，则必须等事务A的操作完成后才能进行更新。  </p>
<p>MySQL的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁。<strong>不支持行锁意味着并发控制只能使用表锁</strong>，对于(MyISAM)这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。  </p>
<blockquote>
<p>dml语句会产生MDL读锁，MDL锁和表锁是两个不同的结构。<br>在MyISAM表上更新一行，那么会加MDL读锁和表的写锁；同时另外一个线程要更新这个表上另外一行，也要加MDL读锁和表的写锁。第二个线程的MDL读锁能成功加上，但是表写锁堵住。第二个线程要等第一个线程执行完成。  </p>
</blockquote>
<p><strong>InnoDB行级锁是通过锁索引记录来实现的</strong>，如果update的列没建索引，即使只update一条记录也会锁定整张表。InnoDB内部是全表根据主键索引逐行扫描、逐行加锁，事务提交时统一释放。  </p>
<p>InnoDB中没有不开启事务的更新update，没写默认就是单语句事务，语句结束的地方释放锁。insert、delete都是行锁。  </p>
<h4 id="两阶段锁"><a href="#两阶段锁" class="headerlink" title="两阶段锁"></a>两阶段锁</h4><p>在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这就是<strong>两阶段锁协议</strong>。  </p>
<p><strong>如果事务中需要锁多行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</strong>  </p>
<h4 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a>死锁和死锁检测</h4><p>当并发系统中不同线程出现循环资源，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。（多个事务更新同一行，只是锁等待；如果还要更新别的行，可能造成循环依赖，导致死锁。一个事务自己跟自己不会死锁。）<br>一个表有多个索引的话，并发插入，也可能会导致死锁。  </p>
<blockquote>
<p>show engine innodb status;– 查看死锁信息。记录“之后一个死锁”的地方  </p>
</blockquote>
<h5 id="直接进入等待，直到超时。"><a href="#直接进入等待，直到超时。" class="headerlink" title="直接进入等待，直到超时。"></a>直接进入等待，直到超时。</h5><p>超时时间可以通过参数innodb_lock_wait_timeout来设置。  </p>
<p>innoDB中，innodb_lock_wait_timeout的默认值是50s。当出现死锁以后，第一个被锁住的线程要过50s才会超时退出，然后其他线程才有可能继续执行。超时时间设置太短的话，会出现很多误伤。  </p>
<h5 id="发起死锁检测。"><a href="#发起死锁检测。" class="headerlink" title="发起死锁检测。"></a>发起死锁检测。</h5><p>发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on（默认值on），表示开启这个逻辑。  </p>
<p>在发生死锁的时候，是能够快速发现并进行处理的，但是有额外负担–耗费大量的CPU资源。每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。死锁检测的时间复杂度是O(n<sup>2</sup>)，单个事务为O(n)。  </p>
<blockquote>
<p>如果新的事务要加锁访问的行上有锁（一个事务更新一条记录时发现被阻塞了），才会进行死锁检测。1一致性读不会加锁，不需要做死锁检测。2并不是每次死锁检测都要扫描所有事务。  </p>
</blockquote>
<ol>
<li><p><strong>如果能确保业务一定不会出现死锁，可以临时把死锁检测关掉。</strong><br>业务设计的时候一般不会把死锁当做一个严重错误，出现死锁了就回滚，然后通过业务重试一般就没问题了，业务无损。关掉死锁检测意味着可能会出现大量的超时，业务有损。  </p>
</li>
<li><p><strong>控制并发度。</strong><br>在客户端做并发控制。同一行同时最多只有10个线程在更新。若客户端很多，即使每个客户端控制到只有个位数并发线程，汇总到数据库服务端以后，峰值并发数也很高。<br>在服务端做并发控制。如果有中间件，可以考虑在中间件中实现；也可以在MySQL源码里。对于相同行的更新，在进入引擎之前排队。这样在InnoDB内部就不会有大量的死锁检测工作。  </p>
</li>
<li><p><strong>通过将一行改成逻辑上的多行来减少锁冲突。</strong><br>将总账户放在多条记录上，账户总额等于这多条记录的值的总和，每次给账户加金额的时候，随机选其中一条记录来加。冲突概率变成原来的1/n，可以减少锁等待个数，也就减少了死锁检测的CPU消耗。业务复杂度可能大大提高()。  </p>
</li>
</ol>
<hr>
<ol>
<li>直接执行delete fron T limit 10000;<br>单个语句占用时间长，事务相对较长，占用锁的时间较长，会导致其他客户端等待资源时间较长。大事务还会导致主从延迟。  </li>
<li>在一个连接中循环执行20次delete from T limit 500;（默认每次独立提交）<br>串行化执行，将相对长的事务分成多次相对短的事务，则每次事务占用锁的时间相对较短，其他客户端在等待相应资源的时间也较短。这样的操作意味着将资源分片使用(每次使用不同片段的资源)，可以提高并发性。  </li>
<li>在20个连接中同时执行delete from T limit 500;<br>人为制造锁竞争，造成锁冲突，加剧并发量。  </li>
<li>添加主键，根据主键删除。  </li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>索引选择异常及处理</title>
    <url>/MySQL/%E7%B4%A2%E5%BC%95%E9%80%89%E6%8B%A9%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>MySQL中一张表可以支持多个索引。使用哪个索引是由MySQL来确定的。  </p>
<p>explain + sql;查看语句的执行情况。<br>set long_query_time=0;设置慢查询阈值，单位秒。<br>set slow_query_log=1;开启慢查询日志，0表示关闭。<br>slow_query_log_file;慢查询日志存放路径。  </p>
<h3 id="优化器的逻辑"><a href="#优化器的逻辑" class="headerlink" title="优化器的逻辑"></a>优化器的逻辑</h3><p>选择索引是优化器的工作。<br>优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。（扫描行数、临时表、排序等影响）  </p>
<h4 id="扫描行数"><a href="#扫描行数" class="headerlink" title="扫描行数"></a>扫描行数</h4><p>MySQL在真正开始执行语句之前，并不能精确的知道满足这个条件的记录有多少条，只能根据统计信息来估算记录数。  </p>
<p>这个统计信息就是索引的“区分度”。一个索引上不同的值越多，这个索引的区分度就越好。而一个索引上不同的值的个数，称之为“基数”(cardinality)。这个基数越大，索引的区分度越好。  </p>
<blockquote>
<p>show index from t;可以查看一个索引的基数。并不是准确的数字。  </p>
</blockquote>
<hr>
<p>MySQL索引的基数通过采样统计的方法得到。<br>InnoDB默认会选择N个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，得到这个索引的基数。  </p>
<p>数据表会持续更新，索引统计信息也不会固定不变，当变更的数据行数超过1/M的时候，会自动触发重新做一次索引统计。<br><strong>统计信息不会每次更新都重新统计。</strong>  </p>
<p>在MySQL中，有两种存储索引统计的方式，可以通过innodb_stats_persistent的值来选择：  </p>
<ul>
<li>设置为on的时候，表示统计信息会持久化存储。默认的N是20，M是10.  </li>
<li>设置为off的时候，表示统计信息只存储在内存中。默认的N是8，M是16。  </li>
</ul>
<hr>
<p>索引统计只是一个输入，对于一个具体的语句，优化器还要判断，执行这个语句本身要扫描多少行。<br><strong>explain SQL;其中rows字段表示的是预计扫描行数。</strong>真正需要扫描多少行，得执行了才知道。  </p>
<p>使用普通索引，每次从索引上拿到一个值，都要回到主键索引上查出整行数据，这个回表的代价优化器也计算。而如果扫描全部的行，是直接在主键索引上扫描的，没有额外的代价。  </p>
<h3 id="索引选择异常处理"><a href="#索引选择异常处理" class="headerlink" title="索引选择异常处理"></a>索引选择异常处理</h3><p>join、group、order、limit等操作都是在server层执行器中进行。<strong>执行器调用存储层的接口只能获取最原始的数据</strong>。然后一条一条的进行过滤，然后再调引擎层获取下一条。  </p>
<p>1属于索引统计信息不准确<br>234属于优化器误判  </p>
<h4 id="1-analyze-table"><a href="#1-analyze-table" class="headerlink" title="1.analyze table"></a>1.analyze table</h4><p><strong>analyze table t;– 执行过程中会加MDL读锁。</strong><br>修正统计信息，重新统计索引信息。<br>实践中，explain的结果预估的rows值跟实际情况差距比较大，可以采用这个方法处理。  </p>
<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
</tr>
</thead>
<tbody><tr>
<td>start transaction with consistent snapshot</td>
<td></td>
</tr>
<tr>
<td></td>
<td>delete from t;  call idata();– 存储过程，insert十万条数据</td>
</tr>
<tr>
<td></td>
<td>explain select * from t where a between 10000 and 20000;</td>
</tr>
<tr>
<td>commit</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>1.为什么没有session A,session B扫描的行数是1W<br>由于mysql是使用<strong>标记删除</strong>来删除记录的,并不从索引和数据文件中真正的删除（加索引慢，删索引秒删）。<br>如果delete和insert中间的间隔相对较小,merge线程还没有来得及清理该记录。<br>如果主键相同的情况下,新插入的insert会沿用之前删除的delete的记录的空间。（看上去是覆盖了原来的10万行）。<br>由于相同的数据量以及表大小,所以导致了统计信息没有变化。  </p>
</blockquote>
<blockquote>
<p>2.为什么开启了session A,session B扫描行数变成3W<br>由于session A开启了一致性读,目的为了保证session A的可重复读,insert只能另起炉灶,不能占用delete的空间。所以出现的情况就是delete虽然删除了,但是未释放空间,insert又增加了空间。导致统计信息有误。<br>为了保证sessionA的可重复读(未提交)，数据页并没有实际删除，undo log也还没有回收，新的insert又产生了新的数据页，之前的数据每一行数据都有两个版本，旧版本是delete之前的数据，新版本是标记为delete的数据，这样索引a上的数据其实就有两份。索引的统计选择了N个数据页进行采样，这部分数据页不受到前台事务的影响，索引整体统计值会变大，直接影响了索引选择的准确性。  </p>
</blockquote>
<h4 id="2-force-index"><a href="#2-force-index" class="headerlink" title="2.force index"></a>2.force index</h4><p>select * from t force index(a) where …;  </p>
<p>采用force index强行选择一个索引。起到“矫正”的作用。<br>MySQL会根据词法分析的结果分析出可能可以使用的索引作为候选项，然后在候选索引列表中依次判断每个索引需要扫描多少行。如果force index指定的索引在候选索引列表中，就直接选择这个索引，不再评估其他索引的执行代价。（不触发索引重新统计，不会改变explain 中预估扫描行数的值）  </p>
<h4 id="3-修改sql语句"><a href="#3-修改sql语句" class="headerlink" title="3.修改sql语句"></a>3.修改sql语句</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> (a <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">1000</span>)  <span class="keyword">and</span> (b <span class="keyword">between</span> <span class="number">50000</span> <span class="keyword">and</span> <span class="number">100000</span>) <span class="keyword">order</span> <span class="keyword">by</span> b <span class="keyword">limit</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>优化器放弃使用索引a，说明a还不够合适。<br>优化器选择使用索引b，是因为它认为使用索引b可以避免排序(b本身是索引，已经是有序的了，如果选择索引b的话，不需要再做排序，只需要遍历)，所以即使扫描行数多，也判定为代价更小。<br>但是变更不及时。  </p>
<blockquote>
<p>如果使用索引a进行查询，就扫描索引a的1000个值，然后取到对应的主键id，再到主键索引上去查出每一行，然后根据字段b来过滤。  </p>
</blockquote>
<blockquote>
<p>如果索引索引b进行查询，就扫描索引b的50001个值，取到对应的主键id，<strong>依次</strong>回到主键索引上取值再判断。一条过滤完再获取并处理下一条数据。  </p>
</blockquote>
<p>没有order by则<strong>默认按照“查询使用的索引”排序。</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> (a <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">1000</span>)  <span class="keyword">and</span> (b <span class="keyword">between</span> <span class="number">50000</span> <span class="keyword">and</span> <span class="number">100000</span>) <span class="keyword">order</span> <span class="keyword">by</span> b,a <span class="keyword">limit</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>order by b,a;要求按照b,a排序，就意味着使用这两个索引都需要排序。扫描行数成了影响决策的主要条件。<br>但是修改了语句语义。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span>  (<span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> (a <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">1000</span>)  <span class="keyword">and</span> (b <span class="keyword">between</span> <span class="number">50000</span> <span class="keyword">and</span> <span class="number">100000</span>) <span class="keyword">order</span> <span class="keyword">by</span> b <span class="keyword">limit</span> <span class="number">100</span>)<span class="keyword">alias</span> <span class="keyword">limit</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>用limit 100 让优化器意识到，使用b索引的代价很高。??优化器计算代价的细节待补充。<br>不具备通用性。  </p>
<h4 id="4-新建一个更合适的索引-删掉误用的索引"><a href="#4-新建一个更合适的索引-删掉误用的索引" class="headerlink" title="4.新建一个更合适的索引|删掉误用的索引"></a>4.新建一个更合适的索引|删掉误用的索引</h4><p>经过索引优化过的库，再碰到这种bug，找到一个更合适的索引一般比较难。<br>优化器错误选择的索引若没有必要存在，就删掉这个索引。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>重建表回收空间</title>
    <url>/MySQL/%E9%87%8D%E5%BB%BA%E8%A1%A8%E5%9B%9E%E6%94%B6%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<p>一个InnoDB表包含两部分：表结构定义和数据。<br>MySQL8.0以前，表结构是存在以.frm为后缀的文件里。MySQL8.0版本，允许把表结构定义放在系统数据表中。表结构定义占用的空间很小。  </p>
<h3 id="表数据存储位置"><a href="#表数据存储位置" class="headerlink" title="表数据存储位置"></a>表数据存储位置</h3><p>表数据既可以存在共享表空间中，也可以是单独的文件。  </p>
<ol>
<li>innodb_file_per_table=OFF，表示表的数据放在系统共享表空间，也就是跟数据字典放在一起。  </li>
<li>innodb_file_per_table=ON，（建议）表示每个InnoDB表数据存储在一个以.ibd为后缀的文件中。  </li>
</ol>
<p>MySQL5.6.6版本开始，该参数默认值为ON。<br>一个表单独存储为一个文件更容易管理，而且在不需要这个表的时候，通过drop table命令，系统就会直接删除这个文件。而如果是放在共享表空间，即使表删掉了，空间也是不会回收的。  </p>
<p>针对表中某些行被删除，表空间没有被回收。  </p>
<h3 id="数据页空洞"><a href="#数据页空洞" class="headerlink" title="数据页空洞"></a>数据页空洞</h3><p>InnoDB里的数据都是用B+树的结构组织的。  </p>
<p>如果要删掉某个记录，InnoDB引擎只会把这个记录标记为删除，但磁盘文件的大小并不会缩小，后续有符合其前后范围的新记录插入，可能会复用这个位置。InnoDB的数据是按页存储的，如果删掉了一个数据页上的所有记录（被标记），整个数据页就可以被复用了（任意数据都可复用）。  </p>
<p><strong>记录的复用与数据页的复用是不同的</strong>。记录的复用，只限于符合范围条件的数据。而当整个页从B+树里面摘掉以后，可以复用到任何位置。如果相邻的两个数据页利用率都很小，系统还会把这两个页上的数据合到其中一个页上，另外一个数据页就被标记为可复用。  </p>
<p>如果用delete命令把整个表的数据删除，所有的数据页都会被标记为可复用，但是磁盘上，文件不会变小。delete命令是不能回收表空间的，这些可以复用，而没有被使用的空间，看起来就像是空洞。  </p>
<hr>
<p>插入数据也会造成空洞。  </p>
<p>如果数据是按照索引递增顺序插入的，那么索引是紧凑的。如果数据是随机插入的，就可能造成索引的数据页分裂。  </p>
<p>由于一个page1满了，再插入一个page1数值大小范围内的数据时，就不得不再申请一个新的页面page2来保存数据，并将page1上的后部分数据挪到page2，页分裂完成后，page1的末尾就留下了空洞。  </p>
<p>更新索引上的值，可以理解为删除一个旧的值，再插入一个新的值，明显也会造成空洞。经过大量增删改的表，都是可能存在空洞的。把这些空洞去掉，才能达到收缩表空间的目的。  </p>
<h3 id="重建表"><a href="#重建表" class="headerlink" title="重建表"></a>重建表</h3><p>重建表可以达到收缩表空间的目的。<br>在重建表的时候，InnoDB不会把整张表占满，每个页留了1/16给后续的更新用。重建表之后不是“最”紧凑的。  </p>
<blockquote>
<p>删除主键或者创建主键都会将整个表重建。<br>更改表结构(加字段)会重建主键索引，主键索引树叶子节点的值要更新。普通索引不用重建。  </p>
</blockquote>
<p>新建一个与表A(原始表)结构相同的临时表B，然后按照主键ID递增的顺序，把数据一行一行地从表A里读出来再插入到表B中。交换表名，删除临时表。  </p>
<blockquote>
<p>MySQL5.5版本前使用alter table A engine=InnoDB;命令来重建表。</p>
</blockquote>
<p>表B是新建的表，表A主键索引上的空洞，在表B中都不存在了。表B的主键索引更紧凑，数据页的利用率页更高。从效果上看，起到了收缩表A空间的作用。  </p>
<hr>
<p>DDL花时间最多的步骤是往临时表插入数据的过程，如果在这个过程中，有新的数据要写入到表A的话，就会造成数据丢失。在整个DDL过程中，表A中不能有更新，阻塞MDL，这个DDL不是Online的。  </p>
<p>MySQL5.6版本引入了OnlineDDL：  </p>
<ol>
<li>建立一个临时文件，扫描表A主键的所有数据页；  </li>
<li>用数据页中表A的记录生成B+树，存储到临时文件中；  </li>
<li>生成临时文件的过程中，将所有对A的操作记录在一个日志文件(row log)中。  </li>
<li>临时文件生成后，将日志文件中的操作应用到临时文件(可能会引入新的空洞)，得到一个逻辑数据上与表A相同的数据文件。  </li>
<li>用临时文件替换表A的数据文件。  </li>
</ol>
<p>由于日志文件记录和重放操作这个功能的存在，在重建表的过程冲，允许对表A(旧表)做增删改操作。  </p>
<p>alter语句（DDL操作）在启动的时候需要获取MDL写锁，在真正拷贝数据之前退化成读锁，MDL读锁不会阻塞增删改操作，同时禁止其他线程对这个表同时做DDL。最后临时文件替换表A的数据文件时重新加上MDL写锁。  </p>
<p>Online DDL最耗时的过程就是拷贝数据到临时表的过程，这个步骤的执行期间可以接收增删改操作。相对于整个DDL过程来说，写锁的时间非常短，对业务来说，相当于是Online的。  </p>
<p>重建表会扫描原表结构和构建临时文件。对于很大的表很消耗IO和CPU资源。线上服务要很小心的控制操作时间。<br>比较安全的操作是使用GitHub开源的gh-ost做。  </p>
<h3 id="Online和inplace"><a href="#Online和inplace" class="headerlink" title="Online和inplace"></a>Online和inplace</h3><p>MySQL5.5版本重建表，把表A中的数据导出来存放在tmp_table。这是一个临时表，是在server层创建的。  </p>
<blockquote>
<p>alter table t engine=innodb,ALGORITHM=copy;– 强制拷贝表  </p>
</blockquote>
<p>MySQL5.6版本重建表，根据表A重建出来的数据是放在tmp_file里的，这个临时文件是InnoDB在内部创建出来的。整个DDL过程都在InnoDB内部完成。对于server层来说，没有把数据挪动到临时表，是一个原地操作。称之为inplace。  </p>
<blockquote>
<p>alter table t engine=innodb,ALGORITHM=inplace;</p>
</blockquote>
<p>区别（都需要占用临时空间）：  </p>
<ul>
<li>DDL过程如果是Online的，就一定是inplace的；  </li>
<li>反过来未必，inplace的DDL，有可能不是Online的。添加全文索引(FULLTEXT index)和空间索引(SPATIAL index)。8.0  <blockquote>
<p>给InnoDB表的一个字段加全文索引：alter table t add FULLTEXT(field_name);<br>这个过程是inplace的，但是会阻塞增删改操作，是非Online的。  </p>
</blockquote>
</li>
</ul>
<hr>
<p>optimize table、analyze table、alter table三种重建表区别：</p>
<ul>
<li>MySQL5.6版本开始，alter table t engine=InnoDB;（recreate）默认ALGORITHM=inplace。（no-rebuild主键索引不用重建）  <blockquote>
<p>在事务里面显式用alter table语句，会默认提交前面的事务，然后自己独立执行。  </p>
</blockquote>
</li>
<li>analyze table t;不是重建表，只是对表的索引信息做重新统计，没有修改数据，这个过程中加了MDL读锁。  </li>
<li>optimize table t;等于recreate+analyze。（recreate后全新的表，极端情况下才需要analyze）  </li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>刷脏页抖动</title>
    <url>/MySQL/%E5%88%B7%E8%84%8F%E9%A1%B5%E6%8A%96%E5%8A%A8/</url>
    <content><![CDATA[<p>一条SQL语句，正常执行的时候特别快，但是有时候就会变得特别慢，这样的场景很难复现，它不只随机，而且持续时间还很短。  </p>
<h3 id="SQL语句变慢原因"><a href="#SQL语句变慢原因" class="headerlink" title="SQL语句变慢原因"></a>SQL语句变慢原因</h3><p>WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘。数据库将随机写转换成了顺序写，大大提升了数据库的性能。  </p>
<blockquote>
<p>随机写：每次更新，都直接将数据写到磁盘。  </p>
</blockquote>
<p>InnoDB在处理更新语句的时候，只做了写日志这一个<strong>磁盘</strong>操作。这个日志叫做redo log（重做日志），在更新内存写完redo log后，就返回给客户端本次更新成功。  </p>
<blockquote>
<p>redo log其实是“磁盘页到内存页的diff”，记录了“这是哪个页面的修改”。<br>undo log,每一行存了一个位置可以直接找到undo log，是MVCC的基础。</p>
</blockquote>
<p>把内存里的数据写入磁盘的过程，称为<strong>flush</strong>。在这个flush操作执行之前内存里的数据和磁盘上数据文件记录的数据是不一致的。  </p>
<blockquote>
<p>flush 一般是说刷脏页；<br>purge一般是指清undo log；<br>merge一般是指应用change buffer。（change buffer只对非唯一索引有效）  </p>
</blockquote>
<p>当内存数据页跟磁盘数据页内容不一致的时候，称这个内存页为“<strong>脏页</strong>”。内存数据写入磁盘后，内存和磁盘上的数据页的内容就一致了，称为“<strong>干净页</strong>”。(checkpoint往前推进只是把脏页变成干净页，干净页还在内存，只有淘汰时才会逐出内存)  </p>
<p>平时执行很快的更新操作，其实就是在写内存和日志，而MySQL偶尔“抖”一下的那个瞬间，可能就是再刷脏页（flush）。<br>刷脏页的时候要将内存页写入磁盘(直接将脏页数据覆盖到对应磁盘上的数据)。无论是查询语句在需要内存的时候要求淘汰一个脏页，还是由于刷脏页的逻辑会占用IO资源影响到了更新语句，都可能是业务端感知到MySQL抖一下的原因。  </p>
<blockquote>
<p>刷脏页不用动redo log，redo log在“重放”的时候，如果一个数据页已经是刷过的，会识别出来并跳过。（每个数据页头部有LSN，8字节，每次修改都会变大(更新这个page的最后一个lab)。对比这个LSN跟redo log的checkpoint的LSN，比checkpoint小的一定是干净页。）  </p>
</blockquote>
<blockquote>
<p>redolog buffer在事务执行过程中，先把要写的内容在内存中存起来，在commit阶段，一次性写入redolog file（磁盘上固定空间循环使用）。  innodb_flush_log_at_trx_commit=1;（默认值）表示每次事务提交时，redo log都直接持久化到磁盘。  </p>
</blockquote>
<h3 id="引发数据库flush的场景"><a href="#引发数据库flush的场景" class="headerlink" title="引发数据库flush的场景"></a>引发数据库flush的场景</h3><ul>
<li>场景一：InnoDB的redo log写满了。此时系统会停止所有更新操作，把checkpoint往前推进，redo log留出空间可以继续写。  <img src="/img/MySQL redo log结构图.png">  
checkpoint往前推进时，需要将推进过程中的日志，对应的所有脏页都flush到磁盘上。之后write pos到checkpoint新位置之间就可以再写入redo log。  

</li>
</ul>
<blockquote>
<p>每次事务提交都要写redo log，如果设置太小，很快就会被写满，write pos一直追着CP。这时系统不得不停止所有更新，去推进checkpoint。磁盘压力很小，但是数据库出现间歇性的性能下跌。  </p>
</blockquote>
<ul>
<li><p>场景二：系统内存不足。当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰掉的是脏页，就要先将脏页写到磁盘。刷脏页一定会写盘，保证每个数据页有两种状态：  </p>
<pre><code>- 内存里存在，内存里就肯定是正确的结果，直接返回；  
- 内存里没有数据，就可以肯定数据文件上是正确的结果，读入内存后返回。  </code></pre></li>
<li><p>场景三：MySQL认为系统空闲的时候。当然MySQL一直很忙时，也要合理的安排时间，即使是忙的时候，也要见缝插针的找时间，只要有机会就刷一点“脏页”。  </p>
</li>
<li><p>场景四：MySQL正常关闭的情况。这时，MySQL会把内存的脏页都flush到磁盘上，这样下次MySQL启动的时候，就可以直接从磁盘上读数据，启动速度会很快。  </p>
</li>
</ul>
<h3 id="不同flush场景对性能影响"><a href="#不同flush场景对性能影响" class="headerlink" title="不同flush场景对性能影响"></a>不同flush场景对性能影响</h3><ul>
<li><p>情况三，属于MySQL空闲时的操作。这时系统没什么压力。  </p>
</li>
<li><p>情况四，属于数据库本来就要关闭了。不太关注性能问题。  </p>
</li>
<li><p>情况一，是InnoDB要尽量避免的。出现这种情况时，整个系统就不能再接受更新了，所有的更新都必须堵住。从监控上看，此时更新数会跌为0。  </p>
</li>
<li><p>情况二，是常态。InnoDB用缓冲池buffer pool管理内存（查询缓存innodb buffer pool是server层的，存储的是SQL语句的查询结果），缓冲池中的内存页有三种状态：  </p>
<pre><code>- 第一种，还没有使用的；
- 第二种，使用了并且是干净页；
- 第三种，使用了并且是脏页。  </code></pre></li>
</ul>
<p>InnoDB的策略是尽量使用内存，因此对于一个长时间运行的库来说，未被使用的页面很少（第一种）。<br>当要读入的数据页没有在内存的时候，就必须到缓冲池中申请一个数据页。此时只能把最久不使用的数据页从内存中淘汰掉：如果要淘汰的是一个干净页，就直接释放出来复用（第二种）；但是如果是脏页，就必须将脏页先刷到磁盘，变成干净页后才能复用（第三种）。  </p>
<p>明显影响性能的两种情况：  </p>
<ol>
<li>一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长；  </li>
<li>日志写满，更新全部堵住，写性能跌为0，这种情况对敏感业务来说，是不能接受的。  </li>
</ol>
<p>InnoDB需要有控制脏页比例的机制，来尽量避免上面的这两种情况。  </p>
<h3 id="InnoDB刷脏页的控制策略"><a href="#InnoDB刷脏页的控制策略" class="headerlink" title="InnoDB刷脏页的控制策略"></a>InnoDB刷脏页的控制策略</h3><h4 id="正确的告诉InnoDB所在主机的IO能力"><a href="#正确的告诉InnoDB所在主机的IO能力" class="headerlink" title="正确的告诉InnoDB所在主机的IO能力"></a>正确的告诉InnoDB所在主机的IO能力</h4><p>这样InnoDB才能知道需要全力刷脏页的时候，可以刷多块。  </p>
<p>通过innodb_io_capacity参数告诉InnoDB磁盘能力。这个值设置成磁盘的IOPS。磁盘的IOPS可以通过fio工具测试(磁盘随机读写)：（机械硬盘的随机 IOPS 一般只有几百）</p>
<blockquote>
<p>fio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting  -name=mytest  </p>
</blockquote>
<p>设置太小，则InnoDB认为这个系统的能力差，所以刷脏页刷的特别慢（频率慢），甚至比脏页生成的速度还慢，这样就造成了脏页累积，影响了查询和更新性能。（要读取的数据不在内存中，但是脏页过多导致新页必须等待脏页刷新盘后，淘汰掉再加载到内存）  </p>
<p>磁盘能力不能只用来刷脏页，还需要服务用户请求。  </p>
<h4 id="InnoDB控制引擎按照“全力”的百分比来刷脏页"><a href="#InnoDB控制引擎按照“全力”的百分比来刷脏页" class="headerlink" title="InnoDB控制引擎按照“全力”的百分比来刷脏页"></a>InnoDB控制引擎按照“全力”的百分比来刷脏页</h4><p>InnoDB的刷盘速度参考两个因素：脏页比例、redo log写盘速度。  </p>
<p><strong>脏页比例</strong><br>参数innodb_max_dirty_pages_pct是脏页比例上限，默认值是75%。InnoDB会根据当前的脏页比例（假设为M），算出一个范围在0到100之间的数字。  </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">F1(M)</span><br><span class="line">&#123;</span><br><span class="line">      if M&gt;=innodb_max_dirty_pages_pct then</span><br><span class="line">            return 100;</span><br><span class="line">      return 100*M/innodb_max_dirty_pages_pct;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>脏页比例是通过innodb_buffer_pool_pages_dirty/innodb_buffer_pool_pages_tital得到的：  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">user information_schema;</span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> @a <span class="keyword">from</span> global_status <span class="keyword">where</span> VARIABLE_NAME = <span class="string">'Innodb_buffer_pool_pages_dirty'</span>;  </span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> @b <span class="keyword">from</span> global_status <span class="keyword">where</span> VARIABLE_NAME = <span class="string">'Innodb_buffer_pool_pages_total'</span>;  </span><br><span class="line"><span class="keyword">select</span> @a/@b;</span><br></pre></td></tr></table></figure>

<p>平时要多关注脏页比例，不要让它经常接近75%（max值）。  </p>
<p><strong>写盘速度</strong><br>InnoDB每次写入的日志都有一个序号，当前写入的序号跟checkpoint对应的序号之间的差值，设为N。InnoDB会根据这个N算出一个范围在0到100之间的数字，这个计算公式可以即为F2(N)。N越大，算出来的值越大。  </p>
<p><strong>根据上述算的的F1(M)和F2(N)两个值，取其中较大的值记为R，之后引擎就可以按照innodb_io_capacity定义的能力乘以R%来控制刷脏页的速度。</strong>  </p>
<h4 id="脏页连坐"><a href="#脏页连坐" class="headerlink" title="脏页连坐"></a>脏页连坐</h4><p>一旦一个查询请求需要在执行过程中先flush掉一个脏页时，这个查询就可能要比平时慢。MySQL中的一个机制会让查询更慢：在准备刷一个脏页的时候，如果这个数据页旁边的数据页刚好是脏页，就会把这个“邻居”也带着一起刷掉；而且把这个邻居拖下水的逻辑还可以继续蔓延，也就是对于每个邻居数据页，如果跟它相邻的数据页也还是脏页的话，也会被放到一起刷。  </p>
<p>innodb_flush_neighbors=1;时会有连坐机制；  </p>
<blockquote>
<p>（适合机械硬盘，可以减少随机IO，提升系统性能）  </p>
</blockquote>
<p>innodb_flush_neighbors=0;时不找邻居，自己刷自己的（随机IO）。(MySQL8.0默认值)  </p>
<blockquote>
<p>（适合固态硬盘，IOPS不是瓶颈，只刷自己，能更快的执行完必要的刷脏页操作，减少SQL语句相应时间）  </p>
</blockquote>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>count(*)</title>
    <url>/MySQL/count%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h3 id="count-的实现方式"><a href="#count-的实现方式" class="headerlink" title="count(*)的实现方式"></a>count(*)的实现方式</h3><p>在不同的MySQL引擎中，count(*)有不同的实现方式：  </p>
<ul>
<li>MyISAM引擎把一个表的总行数存在了磁盘上(实时改变)，执行count(*)的时候会直接返回这个数，效率很高。  <blockquote>
<p>没有过滤条件的count(*)，如果加了where条件的话，MyISAM表也不能直接返回。  </p>
</blockquote>
</li>
<li>InnoDB执行count(*)的时候，需要把数据一行一行的从引擎里面读出来，然后累积计数。遍历全表，结果准确，性能不高。  </li>
</ul>
<p>由于多版本并发控制(MVCC)的原因，即使是在同一时刻的多个查询，InnoDB表“应该返回多少行”是不确定的。<br>这和InnoDB的事务设计有关，可重复读是它默认的隔离级别，在代码上就是通过多版本并发控制(MVCC)来实现的。每一行记录都要判断自己是否对这个会话可见，因此对于count(*)请求来说，InnoDB只好把数据一行一行的读出依次判断，可见的行才能够用于计算“基于这个查询”的表的总行数。  </p>
<p>InnoDB是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值。普通索引树比主键索引树小很多。对于count(<em>)这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的。MySQL优化器会找到最小的那棵树来遍历。*</em>在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。**  </p>
<hr>
<p>show table status;命令的输出结果，table_rows用于显示这个表当前有多少行。索引统计的值是通过采样来估算的。table_rows是从这个采样估算得来的，不够准确。<strong>show table status命令显示的行数不能直接使用。</strong>  </p>
<p>information_schema.tables;可以查看表记录数。  </p>
<h3 id="用缓存系统保存计数"><a href="#用缓存系统保存计数" class="headerlink" title="用缓存系统保存计数"></a>用缓存系统保存计数</h3><p>用一个Redis服务来保存这个表的总行数。这个表每被插入一行Redis计数就加1，每被删除一行Redis计数就减1。读和更新操作都很快，但缓存系统可能会丢失更新。  </p>
<p>Redis的数据不能永久的留在内存里，需要把这个值定期的持久化存储起来。Redis异常重启时，未持久化的加1计数操作丢失。Redis异常重启后，在数据库里面单独执行一次count(*)获取真实的行数，再把这个值写回到Redis里。异常重启非经常出现的情况，偶尔一次全表扫描的成本可以接受。  </p>
<p>将计数保存在缓存系统，不只丢失更新的问题，即使Redis正常工作，这个值还是逻辑上不精确的。在并发系统里，无法精确控制不同线程的执行时刻，在会话先后执行表中插入记录与Redis计数加一两个操作期间，其他会话执行计数与记录的查询（一致性读/快照读，可以并发执行），会出现数据不一致的情况。  </p>
<p><strong>两个不同的存储构成的系统，不支持分布式事务，无法拿到精确一致的视图。</strong>  </p>
<h3 id="在数据库保存计数"><a href="#在数据库保存计数" class="headerlink" title="在数据库保存计数"></a>在数据库保存计数</h3><p>把计数放到数据库里单独的一张计数表中，利用事务的原子性和隔离性解决了一致性视图的问题。  </p>
<ul>
<li>解决了崩溃丢失的问题，InnoDB支持崩溃恢复不丢失数据。  </li>
<li>利用InnoDB支持事务的特性，表中插入数据与计数表中对应表的计数值加1两个操作在同一个事务中，未提交前其他事务不可见，保证了数据逻辑上的一致。  </li>
</ul>
<h3 id="count用法对比-InnoDB"><a href="#count用法对比-InnoDB" class="headerlink" title="count用法对比(InnoDB)"></a>count用法对比(InnoDB)</h3><p>count()是一个聚合函数，对于返回的结果集，一行行的判断，如果count函数的参数不是NULL，累计值就加1，否则不加，最后返回累积值。  </p>
<p>count(*)、count(主键id)和count(1)都表示返回满足条件的结果集的总行数；count(字段)表示返回满足条件的数据行里面，参数”字段”不为NULL的总个数。  </p>
<ul>
<li>server层要什么就给什么；  </li>
<li>InnoDB只给必要的值；  </li>
<li>目前优化器只优化了count(*)的语义为“取行数”，其他显而易见的优化并没有做。  </li>
</ul>
<hr>
<p><strong>count(主键id)</strong>，InnoDB引擎会遍历整张表，把每一行的id值都取出来，返回给server层。server层拿到id后，判断是不可能为空的(主键id一定不为空，但是未优化)，就按行累加。  </p>
<blockquote>
<p>count(id)不一定选主键索引进行统计。可能会选择最小的索引(占用空间比较小，磁盘读的少)，走全索引的扫描，就算索引是null，对应的主键id不是null，不影响统计结果；  </p>
</blockquote>
<p><strong>count(1)</strong>，InnoDB引擎遍历整张表，但不取值(返回一个空行，但在server层”不是空值，可以计数”。server层调用引擎接口，一行一样取)。server层对于返回的每一行，放一个数字“1”进去(返回了一行，但是0个字段)，判断不可能为空的，按行累加。  </p>
<blockquote>
<p>count(1)执行的要比count(主键id)快。从引擎返回id会涉及到(扫描树里的数据)解析数据行，以及拷贝字段值的操作。  </p>
</blockquote>
<p><strong>count(字段)</strong>：  </p>
<ul>
<li>如果这个“字段”是定义为not null的，一行行的从记录里面读出这个字段，判断不能为null(一定不为null，但未优化)，按行累加；</li>
<li>如果这个“字段”定义允许为null，执行的时候，判断到有可能是null，还要把值取出来再判断一下，不是null才累加。  </li>
</ul>
<blockquote>
<p>count(字段)如果字段上没有索引，只能选主键索引来进行统计。  </p>
</blockquote>
<p><strong>count(*)，并不会把全部字段取出来，而是专门做了优化，不取值(返回一个“空的行”)。count(*)肯定不是null，按行累加。</strong>  </p>
<p>按照效率排序：count(字段)&lt;count(主键id)&lt;count(1)≈count(*)。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>日志与索引</title>
    <url>/MySQL/%E6%97%A5%E5%BF%97%E4%B8%8E%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h3 id="两阶段提交的不同时刻，MySQL异常重启。"><a href="#两阶段提交的不同时刻，MySQL异常重启。" class="headerlink" title="两阶段提交的不同时刻，MySQL异常重启。"></a>两阶段提交的不同时刻，MySQL异常重启。</h3><p>崩溃恢复crash safe:  </p>
<ol>
<li>如果redo log里面的事务是完整的，也就是已经有了commit标识，则直接提交。  </li>
<li>如果redo log里面的事务只有完整的prepare，则判断对应的事务binlog是否存在并完整（提交标记）：  <ul>
<li>a. 如果是完整的，则提交事务；  </li>
<li>b. 否则，回滚事务。  </li>
</ul>
</li>
</ol>
<h4 id="MySQL怎么知道binlog是完整的"><a href="#MySQL怎么知道binlog是完整的" class="headerlink" title="MySQL怎么知道binlog是完整的"></a>MySQL怎么知道binlog是完整的</h4><p>一个事务的binlog是有完整格式的：</p>
<ul>
<li>statement格式的binlog，最后会有commit；  </li>
<li>row格式的binlog，最后会有一个XID event。  </li>
</ul>
<p>MySQL5.6.2版本后，引入binlog-checksum参数，用来验证binlog内容的正确性。对于binlog日志由于磁盘原因，可能会在日志中间出错的情况，MySQL可以通过校验checksum的结果来发现。  </p>
<h4 id="redo-log和binlog是怎么关联起来的"><a href="#redo-log和binlog是怎么关联起来的" class="headerlink" title="redo log和binlog是怎么关联起来的"></a>redo log和binlog是怎么关联起来的</h4><p>他们有一个共同的数据字段—XID。崩溃恢复的时候，会按顺序扫描redo log；  </p>
<ul>
<li>如果碰到既有prepare、又有commit的redo log，就直接提交；  </li>
<li>如果碰到只有prepare、而没有commit的redo log，就拿着XID去binlog找对应的事务。  </li>
</ul>
<h4 id="处于prepare阶段的redo-log加上完整binlog，重启就能恢复，MySQL为什么要这么设计"><a href="#处于prepare阶段的redo-log加上完整binlog，重启就能恢复，MySQL为什么要这么设计" class="headerlink" title="处于prepare阶段的redo log加上完整binlog，重启就能恢复，MySQL为什么要这么设计"></a>处于prepare阶段的redo log加上完整binlog，重启就能恢复，MySQL为什么要这么设计</h4><p>binlog写完以后MySQL发生崩溃，这时候binlog已经写入了，之后就会被从库(或者用这个binlog恢复出来的库)使用。  </p>
<p>所以在主库上也要提交这个事务。采用这个策略，主库和备库的数据就保证了一致性。  </p>
<h4 id="只用binlog就能恢复，为什么需要两阶段提交"><a href="#只用binlog就能恢复，为什么需要两阶段提交" class="headerlink" title="只用binlog就能恢复，为什么需要两阶段提交"></a>只用binlog就能恢复，为什么需要两阶段提交</h4><p>两阶段提交是经典的分布式系统问题。  </p>
<p>对于InnoDB引擎来说，如果redo log提交完成了，事务就不能回滚(如果还允许回滚，就可能覆盖掉别的事务的更新)。如果redo log直接提交，然后binlog写入的时候失败，InnoDB又回滚不了，数据和binlog日志不一致。  </p>
<p>两阶段提交是为了给所有人一个机会，当每个人都OK的时候，再一起提交。  </p>
<h4 id="不引入两个日志，也就没有两阶段提交的必要了。只用binlog来支持崩溃恢复，又能支持归档"><a href="#不引入两个日志，也就没有两阶段提交的必要了。只用binlog来支持崩溃恢复，又能支持归档" class="headerlink" title="不引入两个日志，也就没有两阶段提交的必要了。只用binlog来支持崩溃恢复，又能支持归档"></a>不引入两个日志，也就没有两阶段提交的必要了。只用binlog来支持崩溃恢复，又能支持归档</h4><p><strong>历史原因</strong>：<br>InnoDB并不是MySQL的原生存储引擎。MySQL的原生引擎是MyISAM，设计之初就没有支持崩溃恢复。  </p>
<p>InnoDB在作为MySQL的插件加入MySQL的引擎家族之前，就已经是一个提供了崩溃恢复和事务支持的引擎了。  </p>
<p>InnoDB接入了MySQL后，发现binlog没有崩溃恢复的能力，就用InnoDB原有的redo log。(redo log是在innodb引擎实现的，binlog是在server层实现的)  </p>
<p><strong>实现原因</strong>：<br>binlog没有能力恢复”数据页”。<br>InnoDB引擎使用的是WAL技术，执行事务的时候，写完内存和日志，事务就算完成了。如果之后崩溃，要依赖于日志来恢复数据页。<br>未提交的事务，重启后引擎内部事务会回滚，然后应用binlog可以补回来；已经提交了的事务是可能丢失的(MySQL写数据写在内存里已提交但未落盘，恢复只关注未提交但已写binlog的数据)，而且是数据页级的丢失。<br>binlog里面并没有记录数据页的更新细节，只记录了逻辑操作，数据页是补不回来的。  </p>
<blockquote>
<p>一个事务的binlog如果回放，就是重做整个事务，一个事务更新的可能不止一个page。  </p>
</blockquote>
<h4 id="只用redo-log，不要binlog"><a href="#只用redo-log，不要binlog" class="headerlink" title="只用redo log，不要binlog"></a>只用redo log，不要binlog</h4><p>如果只从崩溃恢复的角度来讲可以。可以把binlog关掉，这样就没有两阶段提交了，但系统依然是crash-safe的。  </p>
<p>正式的生产库上，binlog有着redo log无法替代的功能。  </p>
<ul>
<li>归档，redo log是循环写，写到末尾是要回到开头继续写的。这样历史日志没法保留，redo log也就起不到归档的作用。  </li>
<li>MySQL系统以来binlog。binlog作为MySQL一开始就有的功能，被用在了很多地方。其中MySQL系统高可用的基础就是binlog复制。  </li>
<li>异构系统(数据分析类系统)，这些系统依靠消费MySQL的binlog来更新自己的数据。关掉binlog的话，下游系统没有输入。  </li>
</ul>
<h4 id="redo-log一般设置多大"><a href="#redo-log一般设置多大" class="headerlink" title="redo log一般设置多大"></a>redo log一般设置多大</h4><p>redo log太小的话，会导致很快就被写满，然后不得不强行刷redo log，这样WAL机制的能力发挥不出来。  </p>
<p>对于几个TB的磁盘，redo log设置为4个文件，每个文件1GB。  </p>
<h4 id="正常运行中的实例，数据写入后的最终落盘，是从redo-log更新过来的还是从buffer-pool更新过来的-rodo-log里面到底是什么"><a href="#正常运行中的实例，数据写入后的最终落盘，是从redo-log更新过来的还是从buffer-pool更新过来的-rodo-log里面到底是什么" class="headerlink" title="正常运行中的实例，数据写入后的最终落盘，是从redo log更新过来的还是从buffer pool更新过来的(rodo log里面到底是什么)"></a>正常运行中的实例，数据写入后的最终落盘，是从redo log更新过来的还是从buffer pool更新过来的(rodo log里面到底是什么)</h4><p>redo log并没有记录数据页的完整数据，它并没有能力去更新磁盘数据页，页不存在“数据最终落盘，是由redo log更新过去”的情况。  </p>
<ul>
<li>如果是正常运行的实例，数据页被修改以后，跟磁盘的数据页不一致，称为脏页。最终数据落盘，就是把内存中的数据页写盘。这个过程跟redo log毫无关系。  </li>
<li>在崩溃恢复场景中，InnoDB如果判断到一个数据页可能在崩溃恢复的时候丢失了更新，就会将它督导内存，然后让redo log更新内存内容，更新完成后，内存页变成脏页，就回到了第一种情况的状态。  </li>
</ul>
<h4 id="redo-log-buffer是什么，是先修改内存，还是先写redo-log文件"><a href="#redo-log-buffer是什么，是先修改内存，还是先写redo-log文件" class="headerlink" title="redo log buffer是什么，是先修改内存，还是先写redo log文件"></a>redo log buffer是什么，是先修改内存，还是先写redo log文件</h4><p>在一个事务的更新过程中，日志是要写多次的。每次生成的日志都得先保存起来，但又不能在还没commit的时候就直接写到redo log文件里。  </p>
<p>redo log buffer就是一块内存，用来先存redo 日志的。真正把日志写到redo log文件(文件名是id_logfile+ 数字)，是在执行commit语句的时候做的。  </p>
<blockquote>
<p>prepare的时候就要落盘一次(包含一次写数据到盘)。一个大事务中，如果生成的redo log很多，在事务未提交之前，log也会从redo log buffer写到redo log file里。  </p>
</blockquote>
<p>事务执行过程中不会“主动去刷盘”，以减少不必要的IO消耗。但是可能会出现“被动写入磁盘”，比如内存不够、其他事务提交等情况。  </p>
<p>单独执行一个更新语句的时候，InnoDB会自己启动一个事务，在语句执行完成的时候提交。过程跟上面一样，只不多是“压缩”到了一个语句里面完成。  </p>
<p>binlo 有对应的binlog cache，binlog写完磁盘就发送给从库。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>字符串加索引</title>
    <url>/MySQL/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> f1, f2 <span class="keyword">from</span> SUser <span class="keyword">where</span> email=<span class="string">'xxx'</span>;</span><br></pre></td></tr></table></figure>

<p>若email字段上没有索引，那么这个语句只能做全表扫描。  </p>
<h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p>MySQL支持前缀索引，可以定义字符串的一部分作为索引。默认的，如果创建索引的语句不指定前缀长度，那么索引就包含整个字符串。  </p>
<blockquote>
<p>取字符串中间部分作为子串来建索引—fulltext索引。like ‘%name%’模糊查询使用全文检索索引。  </p>
</blockquote>
<p>前缀索引占用的空间会更小，但是会增加额外的扫描次数。使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。  </p>
<h4 id="确定前缀长度"><a href="#确定前缀长度" class="headerlink" title="确定前缀长度"></a>确定前缀长度</h4><p>建立索引时关注的是区分度，区分度越高越好。区分度越高，意味着重复的键值越少。通过统计索引上有多少个不同的值来判断要使用多长的前缀。  </p>
<ul>
<li>首先，统计出改列上有多少个不同的值：  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> email) <span class="keyword">as</span> L <span class="keyword">from</span> suser;</span><br></pre></td></tr></table></figure></li>
<li>依次选取不同长度的前缀再来统计该值：  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">4</span>)) <span class="keyword">as</span> L4,</span><br><span class="line">        <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">5</span>)) <span class="keyword">as</span> L5,</span><br><span class="line">        <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">6</span>)) <span class="keyword">as</span> L6,</span><br><span class="line">        <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">7</span>)) <span class="keyword">as</span> L7</span><br><span class="line"><span class="keyword">from</span> suser;</span><br></pre></td></tr></table></figure>
使用前缀索引会损失区分度，预先设定一个可以接受的损失比例：5%，然后再返回的L4~L7中，找出不小于L*95%的值。  </li>
</ul>
<p>索引选取的越长，占用的磁盘空间就越大，相同的数据页能放下的索引值就越少，搜索的效率也就会越低。  </p>
<blockquote>
<p>char（N）表示“最长存N，但是如果字符串小于N，用空格补到N”。<br>varchar（N）表示“最长存N，如果字符串小于N，按照实际长度来存”。</p>
</blockquote>
<h4 id="影响覆盖索引"><a href="#影响覆盖索引" class="headerlink" title="影响覆盖索引"></a>影响覆盖索引</h4><p>使用前缀索引用不上覆盖索引对查询性能的优化。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,email <span class="keyword">from</span> suser <span class="keyword">where</span> email = <span class="string">'abcdefg@xyz.com'</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span>,email <span class="keyword">from</span> suser <span class="keyword">where</span> email = <span class="string">'abcdefg@xyz.com'</span>;</span><br></pre></td></tr></table></figure>
<p>如果使用index1(email整个字符串的索引结构)，可以利用覆盖索引，从index1查到结果后直接就返回了，不需要回到主键ID索引再去查一次；<br>如果使用index2(email(n)前缀索引结构)，不得不回到主键ID索引再去判断email字段的值。  </p>
<p>即使将index2的定义修改为email(11)的前缀索引，这时虽然index2已经包含了所有的信息，但是InnoDB还是要回到id索引再查一下，拿到该主键值对应的行，再判断email是否正确。因为系统并不确定前缀索引的定义是否截断了完整信息，以防email字段返回的值不对。  </p>
<h3 id="倒序存储"><a href="#倒序存储" class="headerlink" title="倒序存储"></a>倒序存储</h3><p>身份证号，一共18位，其中前6位是地址码，同一个县的人的身份证号前6位一般是相同的。<br>对身份证号做长度为6的前缀索引的话，区分度非常低；创建长度为12以上的前缀索引能满足区分度要求，但是占用的磁盘空间过大。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> field_list <span class="keyword">from</span> t <span class="keyword">where</span> id_card = <span class="keyword">reverse</span>(<span class="string">'input_id_card_string'</span>);</span><br></pre></td></tr></table></figure>
<p>存储身份证号的时候把它倒过来存，每次查询的时候将输入的字符串反转后再查。<br>身份证的最后6位没有地址码这样的重复逻辑，做前缀索引提供了足够的区分度。  </p>
<h3 id="使用hash字段"><a href="#使用hash字段" class="headerlink" title="使用hash字段"></a>使用hash字段</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> id_card_crc <span class="built_in">int</span> <span class="keyword">unsigned</span>, <span class="keyword">add</span> <span class="keyword">index</span>(id_card_crc);</span><br><span class="line"><span class="keyword">select</span> field_list <span class="keyword">from</span> t <span class="keyword">where</span> id_card_crc=<span class="keyword">crc32</span>(<span class="string">'input_id_crad_string'</span>) <span class="keyword">and</span> id_card=<span class="string">'input_id_card_string'</span>;</span><br></pre></td></tr></table></figure>
<p>在表上再创建一个整数字段，来保存身份证的校验码，同时在这个字段上创建索引。  </p>
<p>每次插入新纪录的时候，都同时用crc32()这个函数得到检验码填到这个新字段。校验码可能存在冲突，查询语句where部分要判断id_card的值是否精确相同。  </p>
<p>索引长度比原来小，只需要四个字节。</p>
<h3 id="倒序存储和使用hash字段对比"><a href="#倒序存储和使用hash字段对比" class="headerlink" title="倒序存储和使用hash字段对比"></a>倒序存储和使用hash字段对比</h3><p>相同点：不支持范围查询。<br>倒序存储的字段上创建的索引是按照倒序字符串的方式排序的，已经没有办法利用索引方式查出身份证号码在[ID_X,ID_Y]的所有市民了，同样hash字段的方式也只能支持等值查询。  </p>
<p>不同点：  </p>
<ol>
<li>从占用的额外空间来看，倒序存储方式在主键索引上，不会消耗额外的存储空间，而hash字段方法需要增加一个字段。倒序存储方式使用4个字节的前缀长度应该是不够的，如果再长一点，这个消耗跟额外这个hash字段差不多抵消。  </li>
<li>在CPU消耗方面，倒序方式每次写和读的时候，都需要额外调用依次reverse函数，而hash字段的方式需要额外调用依次crc32()函数。如果只从这两个函数的计算复杂度来看，reverse函数额外消耗的CPU资源会更小一些。  </li>
<li>从查询效率看，使用hash字段方式的查询性能相对稳定。crc32算出来的值虽有冲突的概率，但是比较小，可以认为每次查询的平均扫描函数接近1.而倒序存储方式毕竟还是用的前缀索引的方式，还会增加扫描行数。  </li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>order by工作原理</title>
    <url>/MySQL/order%20by%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`city`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`addr`</span> <span class="built_in">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`city`</span> (<span class="string">`city`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;<span class="comment">-- 市民表，city字段建普通索引city</span></span><br></pre></td></tr></table></figure>
<p>查询城市是“杭州”的所有人名字，并且按照姓名排序返回前1000个人的姓名、年龄。  </p>
<blockquote>
<p>select city,name,age from t where city=’杭州’ order by name limit 1000;  </p>
</blockquote>
<h3 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h3><table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>partitions</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>filtered</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>T</td>
<td>NULL</td>
<td>ref</td>
<td>city</td>
<td>city</td>
<td>51</td>
<td>const</td>
<td>4000</td>
<td>100.00</td>
<td>Using index condition;Using filesort</td>
</tr>
</tbody></table>
<p>Extra字段中的”Using filesort”表示需要排序，MySQL会给每个线程分配一块内存用于排序，称为sort_buffer。  </p>
<p>语句执行流程：  </p>
<ol>
<li>初始化sort_buffer，确定放入name、city、age这三个字段；  </li>
<li>从索引city找到第一个满足city=’杭州’条件的主键id；  </li>
<li>到主键id索引取出整行，取name、city、age三个字段的值，存入sort_buffer中；  </li>
<li>从索引city取下一个记录的主键id；  </li>
<li>重复步骤3、4直到city的值不满足查询条件为止；  </li>
<li>对sort_buffer中的数据按照字段name做快速排序；(<strong>全字段排序</strong>)  </li>
<li>按照排序结果取前1000行返回给客户端。  </li>
</ol>
<p>按照name排序这个动作，可能在内存中完成，也可能需要使用外部排序，取决于排序所需的内存和参数sort_buffer_size。<br>sort_buffer_size就是MySQL为排序开辟的内存(sort_buffer)的大小。如果要排序的数据量小于sort_buffer_size，排序就在内存中完成。如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序。  </p>
<hr>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 打开optimizer_trace，只对本线程有效 */</span></span><br><span class="line"><span class="keyword">SET</span> optimizer_trace=<span class="string">'enabled=on'</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* @a保存Innodb_rows_read的初始值 */</span></span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> @a <span class="keyword">from</span>  performance_schema.session_status <span class="keyword">where</span> variable_name = <span class="string">'Innodb_rows_read'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 执行语句 */</span></span><br><span class="line"><span class="keyword">select</span> city, <span class="keyword">name</span>,age <span class="keyword">from</span> t <span class="keyword">where</span> city=<span class="string">'杭州'</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">limit</span> <span class="number">1000</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查看 OPTIMIZER_TRACE 输出 */</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`information_schema`</span>.<span class="string">`OPTIMIZER_TRACE`</span>\G</span><br><span class="line"></span><br><span class="line"><span class="comment">/* @b保存Innodb_rows_read的当前值 */</span></span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> @b <span class="keyword">from</span> performance_schema.session_status <span class="keyword">where</span> variable_name = <span class="string">'Innodb_rows_read'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计算Innodb_rows_read差值 */</span></span><br><span class="line"><span class="keyword">select</span> @b-@a;<span class="comment">-- 4000</span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">通过查看OPTIMIZER_TRACE的结果来确认，可以从number_of_tmp_files中看到是否使用了临时文件。  </span><br><span class="line">``` json  </span><br><span class="line">"filesort_execution":[],</span><br><span class="line">"filesort_summary":&#123;</span><br><span class="line">    "rows":4000,</span><br><span class="line">    "examined_rows":4000,</span><br><span class="line">    "number_of_tmp_files":12,</span><br><span class="line">    "sort_buffer_size":32664,</span><br><span class="line">    "sort_mode":"&lt;sort_key,packed_additional_fields&gt;"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>examined_rows表示参与排序的行数。市民表中有4000条满足city=’杭州’的记录。  </li>
<li>number_of_tmp_files表示排序过程使用的临时文件数。内存放不下时，就需要使用外部排序，外部排序一般使用归并排序算法。  <blockquote>
<p>如果sort_buffer_size超过了需要排序的数据量的大小，number_of_tmp_files就是0，表示排序可以直接在内存中完成。否则就需要再临时文件中排序。sort_buffer_size越小，需要分成的份数越多，number_of_tmp_files的值就越大。  </p>
</blockquote>
</li>
<li>sort_mode中的packed_additional_fields的意思是排序过程对字符串做了”紧凑”处理。即使name字段的定义是varchar(16)，在排序过程中还是要按照实际长度来分配空间。</li>
<li>select @b-@a的结果为4000，整个执行过程只扫描了4000行。(MyISAM)  <blockquote>
<p>查询optimizer_trace这个表时，需要用到临时表，而internal_tmp_disk_storage_engine的默认值是InnoDB。把数据从临时表取出来的时候，会让innodb_rows_read的值加1。  </p>
</blockquote>
</li>
</ul>
<h3 id="rowid排序"><a href="#rowid排序" class="headerlink" title="rowid排序"></a>rowid排序</h3><p>原始算法过程中，只对原表的数据读了一遍，剩下的操作都是在sort_buffer和临时文件中执行的。如果查询要返回的字段很多的话，那么sort_buffer里面要放的字段数太多，这样内存里能同时放下的行数很少，要分成很多个临时文件，排序的性能会很差。  </p>
<blockquote>
<p>set max_length_for_sort_data=16;– 控制用于排序的行数据的长度(需要的字段的定义大小的和)，如果单行的长度超过这个值，MySQL就认为单行太大，要换一个算法。(city\name\age一共36)  </p>
</blockquote>
<p>新的算法放入sort_buffer的字段，只有要排序的列(name字段)和主键id。(因为排序的结果少了city和age字段的值，就不能直接返回了)  </p>
<ol>
<li>初始化sort_buffer，确定放入两个字段，name和id；  </li>
<li>从索引city找到第一个满足city=’杭州’条件的主键id；  </li>
<li>到主键id索引取出整行，取name、id这两个字段，存入sort_buffer中；  </li>
<li>从索引city取下一个记录的主键id；  </li>
<li>重复步骤3、4直到不满足city=’杭州’条件为止；  </li>
<li>对sort_buffer中的数据按照字段name进行排序；(<strong>rowid排序</strong>)  </li>
<li>遍历排序结果，取前1000行，并按照id的值回到原表中取出city、name、age三个字段返回给客户端。  </li>
</ol>
<p>rowid排序多访问了一次表t的主键索引。(回表)<br>MySQL服务端从排序后的sort_buffer中依次取出id，然后到原表查到city、name、age三个字段的结果，不需要在服务端再耗费内存存储结果，是直接返回给客户端的。  </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"filesort_execution":[],</span><br><span class="line">"filesort_summary":&#123;</span><br><span class="line">    "rows":4000,</span><br><span class="line">    "examined_rows":4000,</span><br><span class="line">    "number_of_tmp_files":10,</span><br><span class="line">    "sort_buffer_size":32728,</span><br><span class="line">    "sort_mode":"&lt;sort_key,rowid&gt;"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>examined_rows的值还是4000，表示用于排序的数据是4000行。但是select @b-@a的结果为5000。除了排序过程外，在排序完成后，还要根据id去原表取值。语句limit 1000，会多读1000行。  <blockquote>
<p>rows_examined。server层调用引擎取一行的时候加1；引擎内部自己调用读取行不加1。  </p>
</blockquote>
</li>
<li>number_of_tmp_file变小，参与排序的行数虽然是4000行，但是每一行都变小了，需要排序的总数据量就变小了，需要的临时问价也变小。  </li>
<li>sort_mode变成了&lt;sort_key,rowid&gt;表示参与排序的只有name和id这两个字段。  </li>
</ul>
<h3 id="对比与优化"><a href="#对比与优化" class="headerlink" title="对比与优化"></a>对比与优化</h3><p>如果MySQL是在使担心排序内存太小，会影响排序效率，才会采用rowid排序算法，这样排序过程中依次可以排序更多行，但是需要再回到原表去取数据。  </p>
<p>如果MySQL认为内存足够大，会优先选择全字段排序，把需要的字段都放到sort_buffer中，这样排序后就会直接从内存里返回查询结果，不用再回到原表去取数据。  </p>
<p>MySQL做排序是一个成本比较高的操作。并不是所有的order by语句，都需要排序操作。因为原来的数据是无序的，所以MySQL需要生成临时表，并且在临时表上做排序操作。  </p>
<h4 id="创建查询条件字段和排序字段的联合索引"><a href="#创建查询条件字段和排序字段的联合索引" class="headerlink" title="创建查询条件字段和排序字段的联合索引"></a>创建查询条件字段和排序字段的联合索引</h4><blockquote>
<p>alter table t add index city_user(city, name);  </p>
</blockquote>
<p>在联合索引里面，可以用树搜索的方式定位到第一个满足city=’杭州’的记录，并且额外保证了，接下来按顺序取”下一条记录”的遍历过程中，只要city的值是杭州，name的值就一定是有序的。  </p>
<ol>
<li>从索引(city,name)找到第一个满足city=’杭州’条件的主键id;  </li>
<li>到主键id索引取出整行，取name、city、age三个字段的值，作为结果集的一部分直接返回；  </li>
<li>从索引(city,name)取下一条记录主键id；  </li>
<li>重复步骤2、3，直到查到第1000条记录，或者是不满足city=’杭州’条件时循环结束。  </li>
</ol>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>partitions</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>filtered</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>T</td>
<td>NULL</td>
<td>ref</td>
<td>city,city_user</td>
<td>city_user</td>
<td>51</td>
<td>const</td>
<td>4000</td>
<td>100.00</td>
<td>Using index condition</td>
</tr>
</tbody></table>
<p>这个查询过程不需要临时表，也不需要排序。<br>Extra字段中没有Using filesort，不需要排序。而且由于(city,name)这个联合索引本身有序，所以查询也不用把4000行全都读一遍，只要找到满足条件的前1000条记录就可以退出了，只需要扫描1000次。  </p>
<h4 id="创建覆盖索引避免回表"><a href="#创建覆盖索引避免回表" class="headerlink" title="创建覆盖索引避免回表"></a>创建覆盖索引避免回表</h4><blockquote>
<p>alter table t add index city_user_age(city,name,age);  </p>
</blockquote>
<p>对于city字段的值相同的行来说，还是按照name字段的值递增排序的，此时的查询语句也不再需要排序了。  </p>
<ol>
<li>从索引(city、name、age)找到第一个满足city=’杭州’条件的记录，取出其中的city、name、age三个字段的值，作为结果集的一部分直接返回；  </li>
<li>从索引(city、name、age)取下一个记录，同样取出这三个字段的值，作为结果集的一部分直接返回；  </li>
<li>重复执行步骤2，直到查到第1000条记录，或者是不满足city=’杭州’条件时循环结束。  </li>
</ol>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>partitions</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>filtered</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>T</td>
<td>NULL</td>
<td>ref</td>
<td>city,city_user,city_user_age</td>
<td>city_user_age</td>
<td>51</td>
<td>const</td>
<td>4000</td>
<td>100.00</td>
<td>Using where;Using index</td>
</tr>
</tbody></table>
<p>Extra字段多了”Using index”，表示使用了覆盖索引，性能上会快很多。<br>索引维护代价需要权衡。  </p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><blockquote>
<p>select * from t where city in (“杭州”,”苏州”) order by name limit 100;  </p>
</blockquote>
<p>联合索引(city,name)对于单个city内部，name是递增的；对于多个city则所有满足条件的name不是递增的，需要排序。  </p>
<p>避免排序：  </p>
<ol>
<li>执行select * from t where city = “杭州” order by name limit 100;这个语句不需要排序，客户端用一个长度为100的内存数组A保存结果。  </li>
<li>执行select * from t where city = “苏州” order by name limit 100;同上，结果存在内存数组B。  </li>
<li>对于两个有序数组A、B，用归并排序的思想，得到name最小的前100值。  </li>
</ol>
<p>进一步limit 100–&gt;limit 10000,100;处理方式类似。但数据库返回给客户端的数据量变大。<br>优化select *–&gt;select id,name;取值并排序后，拿到100个id值再到数据中查出所有记录。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>简单查询执行慢解析</title>
    <url>/MySQL/%E7%AE%80%E5%8D%95%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C%E6%85%A2%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        样例
    </div>
    <div class='spoiler-content'>
        <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `c` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="built_in">int</span>;</span><br><span class="line">  <span class="keyword">set</span> i=<span class="number">1</span>;</span><br><span class="line">  while(i&lt;=100000) do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(i,i);</span><br><span class="line">    <span class="keyword">set</span> i=i+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> idata();</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<h3 id="第一类：查询长时间不返回"><a href="#第一类：查询长时间不返回" class="headerlink" title="第一类：查询长时间不返回"></a>第一类：查询长时间不返回</h3><p>select * from t where id = 1;查询结果长时间不返回。  </p>
<p>一般碰到这种情况，大概率是表t被锁住了。<br>使用show processlist命令查看当前语句处于什么状态。  </p>
<blockquote>
<p>show processlist;<br>或者select * from information_schema.processlist;  </p>
</blockquote>
<h4 id="等MDL锁"><a href="#等MDL锁" class="headerlink" title="等MDL锁"></a>等MDL锁</h4><table>
<thead>
<tr>
<th>Id</th>
<th>User</th>
<th>Host</th>
<th>db</th>
<th>Command</th>
<th>Time</th>
<th>State</th>
<th>Info</th>
</tr>
</thead>
<tbody><tr>
<td>5</td>
<td>root</td>
<td>localhost:61558</td>
<td>test</td>
<td>Query</td>
<td>0</td>
<td>init</td>
<td>show processlist</td>
</tr>
<tr>
<td>7</td>
<td>root</td>
<td>localhost:63852</td>
<td>test</td>
<td>Sleep</td>
<td>31</td>
<td></td>
<td>NULL</td>
</tr>
<tr>
<td>8</td>
<td>root</td>
<td>localhost:63870</td>
<td>test</td>
<td>Query</td>
<td>25</td>
<td>Waiting for table metadata lock</td>
<td>select * from t where id = 1</td>
</tr>
</tbody></table>
<p><strong>Waiting for table metadata lock；表示有一个线程正在表t上请求或者持有MDL写锁，把select语句堵住了。</strong>（MySQL5.7修改了MDL的加锁策略，尽量避免此类问题。)  </p>
<h5 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h5><table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
</tr>
</thead>
<tbody><tr>
<td>lock table t write;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>select * from t where id=1;</td>
</tr>
</tbody></table>
<p>sessionA通过<strong>lock table命令持有表t的MDL写锁</strong>(MySQL5.5，阻止其他线程访问)(InnoDB中除非明确些lock table，否则不会锁表)，sessionB的查询需要获取MDL读锁。sessionB进入等待状态。  </p>
<h5 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h5><p>找到谁持有MDL写锁，kill掉。通过performance_schema和sys系统库处理。(MySQL启动时设置performance_schema=on；相比于设置为off会有10%左右的性能损失)。  </p>
<p><strong>select blocking_pid from sys.schema_table_lock_waits;</strong><br>select * from performance_schema.metadata_locks;  </p>
<blockquote>
<p>通过查询sys.schema_table_lock_waits这张表，直接找出造成阻塞的process id（blocking_pid），把这个连接用kill命令断开即可。  </p>
</blockquote>
<h4 id="等flush"><a href="#等flush" class="headerlink" title="等flush"></a>等flush</h4><table>
<thead>
<tr>
<th>Id</th>
<th>User</th>
<th>Host</th>
<th>db</th>
<th>Command</th>
<th>Time</th>
<th>State</th>
<th>Info</th>
</tr>
</thead>
<tbody><tr>
<td>4</td>
<td>root</td>
<td>localhost:49548</td>
<td>test</td>
<td>Query</td>
<td>38</td>
<td>User sleep</td>
<td>select sleep()1 from t</td>
</tr>
<tr>
<td>5</td>
<td>root</td>
<td>localhost:49604</td>
<td>test</td>
<td>Query</td>
<td>35</td>
<td>Waiting for table flush</td>
<td>sflush tables t</td>
</tr>
<tr>
<td>6</td>
<td>root</td>
<td>localhost:49634</td>
<td>test</td>
<td>Query</td>
<td>30</td>
<td>Waiting for table flush</td>
<td>select * from t where id=1</td>
</tr>
<tr>
<td>7</td>
<td>root</td>
<td>localhost:49726</td>
<td>test</td>
<td>Query</td>
<td>0</td>
<td>starting</td>
<td>show processlist</td>
</tr>
</tbody></table>
<p><strong>Waiting for table flush：表示有一个线程正要对表t做flush操作。有一个flush tables命令被别的语句堵住了(flush之前必须等待所有语句执行完成(包括select))，然后它又堵住了select语句。</strong>MySQL对表做flush操作有两种用法  </p>
<ul>
<li>flush tables t with read lock;– 只关闭表t；  </li>
<li>flush tables with read lock;– 关闭MySQL里所有打开的表(FTWRL加全局读锁，让整个库处于只读状态。flush过程中(关闭表)，查询也不行???)；  </li>
</ul>
<h5 id="复现-1"><a href="#复现-1" class="headerlink" title="复现"></a>复现</h5><table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
<th>sessionC</th>
</tr>
</thead>
<tbody><tr>
<td>select sleep(1) from t;</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>flush tables t;</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>select * from t where id=1;</td>
</tr>
</tbody></table>
<p>sessionA中每行都调用一次sleep(1)，这个语句默认要执行10W秒，在这期间表t一直是被sessionA“打开”着。sessionB的flush tables t命令要去关闭表t，就需要等sessionA的查询结束。sessionC再次查询的话，会被flush命令堵住。  </p>
<h5 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h5><p>同上</p>
<h4 id="等行锁-InnoDB引擎"><a href="#等行锁-InnoDB引擎" class="headerlink" title="等行锁(InnoDB引擎)"></a>等行锁(InnoDB引擎)</h4><table>
<thead>
<tr>
<th>Id</th>
<th>User</th>
<th>Host</th>
<th>db</th>
<th>Command</th>
<th>Time</th>
<th>State</th>
<th>Info</th>
</tr>
</thead>
<tbody><tr>
<td>4</td>
<td>root</td>
<td>localhost:65224</td>
<td>test</td>
<td>Query</td>
<td>0</td>
<td>starting</td>
<td>show processlist</td>
</tr>
<tr>
<td>8</td>
<td>root</td>
<td>localhost:10354</td>
<td>test</td>
<td>Query</td>
<td>1</td>
<td>statistics</td>
<td>select * from t where id=1 lock in share mode</td>
</tr>
<tr>
<td>10</td>
<td>root</td>
<td>localhost:11276</td>
<td>test</td>
<td>Sleep</td>
<td>52</td>
<td></td>
<td>NULL</td>
</tr>
</tbody></table>
<p>访问id=1这个记录时要加读锁，如果这时已经有一个事务在这行记录上持有一个写锁，select语句就会被堵住。  </p>
<h5 id="复现-2"><a href="#复现-2" class="headerlink" title="复现"></a>复现</h5><table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
</tr>
</thead>
<tbody><tr>
<td>begin;</td>
<td></td>
</tr>
<tr>
<td>update t set c=c+1 where id=1;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>select * from t where id=1 lock in share mode;</td>
</tr>
</tbody></table>
<p>sessionA启动了事务，占有写锁，还不提交，导致sessionB被堵住。</p>
<h5 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h5><p>MySQL5.7，通过sys.innodb_lock_waits表查到谁占着写锁，kill掉链接。  </p>
<p><strong>select blocking_pid from t sys.innodb_lock_waits where locked_table=’<code>test</code>.<code>t</code>‘;</strong>  </p>
<blockquote>
<p>假设4号线程是造成堵塞的罪魁祸首，”kill query 4”命令表示停止4号线程当前正在执行的语句，这个方法没有用。占行锁的是update语句，这个语句已经是之前执行完成了的，执行kill query无法让这个事务去掉id=1上的行锁。<br>“kill 4”命令表示直接断开这个链接。隐含的逻辑是，连接被断开的时候，会自动回滚这个链接里面正在执行的线程，也就释放了id=1上的行锁。  </p>
</blockquote>
<h3 id="第二类：查询慢"><a href="#第二类：查询慢" class="headerlink" title="第二类：查询慢"></a>第二类：查询慢</h3><h4 id="扫描行数多"><a href="#扫描行数多" class="headerlink" title="扫描行数多"></a>扫描行数多</h4><blockquote>
<p>set long_query_time=0;– 慢查询日志的时间阈值设置为0;</p>
</blockquote>
<p>select * from t where c=50000 limit 1;  </p>
<blockquote>
<p>Query_time:0.011543 Lock_time:0.000104 Rows_sent:1 Rows_examined:50000 SET timestamp=1544723147;– slow log慢查询日志  </p>
</blockquote>
<p>字段c上没有索引，这个语句只能走id主键顺序扫描，需要扫描5w行。  </p>
<h4 id="扫描一行，一致性读事务期间大量更新"><a href="#扫描一行，一致性读事务期间大量更新" class="headerlink" title="扫描一行，一致性读事务期间大量更新"></a>扫描一行，一致性读事务期间大量更新</h4><p>select * from t where id=1;  </p>
<blockquote>
<p>Query_time:0.804400 Lock_time:0.000132205 Rows_sent:1 Rows_examined:1 SET timestamp=1544728393;</p>
</blockquote>
<p>select * from t where id=1 lock in share mode;  </p>
<blockquote>
<p>Query_time:0.000258 Lock_time:0.000132 Rows_sent:1 Rows_examined:1 SET timestamp=1544728398;</p>
</blockquote>
<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
</tr>
</thead>
<tbody><tr>
<td>start transaction with consistent snapshot</td>
<td></td>
</tr>
<tr>
<td></td>
<td>update t set c=c+1 where id=1;//执行100W次</td>
</tr>
<tr>
<td>select * from t where id=1;</td>
<td></td>
</tr>
<tr>
<td>select * from t where id=1 lock in share mode;</td>
<td></td>
</tr>
</tbody></table>
<p>sessionA先用start transaction with consistent snapshot命令启动了一个事务，之后sessionB才开始执行update语句。<br>sessionB更新完100W次，生成了100W个回滚日志(undo log)。  </p>
<p>带lock in share mode的SQL语句，是当前读，直接读到1000001这个结果，所以速度很快；而select * from t where id=1这个语句，是一致性读，需要从当前1000001开始，依次执行undo log，执行100W次后，才将1这个结果返回，所以速度慢。  </p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>只要访问表，增删改查就要加MDL读锁。快照读没有读锁。  </p>
<p>read-commited隔离级别下，update语句有一个“semi-consistent”read优化:<br>一个update语句，如果读到一行已经加锁的记录，此时InnoDB返回记录最近提交的最新版本，由MySQL上层判断此版本是否满足update的where条件。若满足(需要更新)，则MySQL会重新发起一次读操作，此时会读取行的最新版本并加锁(锁等待)；对于扫描返回的不满足条件的记录，会提前释放锁。  </p>
<blockquote>
<p>(如果update语句碰到一个已经被锁了的行，会读入最新的版本，然后判断一下是不是满足查询条件，如果不满足则直接跳过，如果满足就进入锁等待。在语句执行完成后，只有行锁，而且语句执行完成后，InnoDB就会把不满足条件的行的行锁去掉，满足条件的行锁等到commit的时候才会释放)  </p>
</blockquote>
<p>repeatable-read隔离级别下，对于具有唯一搜索条件的唯一索引，InnoDB只锁定找到的索引记录，而不锁定其前面的间隙。对于update或delete语句，InnoDB只对其更新或者删除的行持有锁。在MySQL评估where条件之后，将释放非匹配行的记录锁，大大降低了死锁的可能性，但死锁仍可能发生。<br>为了保证binlog记录顺序，<strong>非索引更新则会锁住全表记录</strong>(无索引字段，一行一行逐一给所有行加行锁(在主键索引上)，不会加表锁)，且事务结束前不会对不符合条件记录有逐步释放的过程。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>随机排序</title>
    <url>/MySQL/%E9%9A%8F%E6%9C%BA%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>随机选择三个记录。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        单词表
    </div>
    <div class='spoiler-content'>
        <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `words` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `word` varchar(64) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="built_in">int</span>;</span><br><span class="line">  <span class="keyword">set</span> i=<span class="number">0</span>;</span><br><span class="line">  while i&lt;10000 do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> words(word) <span class="keyword">values</span>(<span class="keyword">concat</span>(<span class="built_in">char</span>(<span class="number">97</span>+(i <span class="keyword">div</span> <span class="number">1000</span>)), <span class="built_in">char</span>(<span class="number">97</span>+(i % <span class="number">1000</span> <span class="keyword">div</span> <span class="number">100</span>)), <span class="built_in">char</span>(<span class="number">97</span>+(i % <span class="number">100</span> <span class="keyword">div</span> <span class="number">10</span>)), <span class="built_in">char</span>(<span class="number">97</span>+(i % <span class="number">10</span>))));</span><br><span class="line">    <span class="keyword">set</span> i=i+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> idata();</span><br></pre></td></tr></table></figure>
    </div>
</div>  
<h3 id="内存临时表-小Memory-大InnoDB"><a href="#内存临时表-小Memory-大InnoDB" class="headerlink" title="内存临时表-小Memory\大InnoDB"></a>内存临时表-小Memory\大InnoDB</h3><p>随机排序取前3个。  </p>
<blockquote>
<p>explain select word from words order by rand() limit 3;  </p>
</blockquote>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>partitions</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>filtered</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>words</td>
<td>NULL</td>
<td>ALL</td>
<td>NULL</td>
<td>NULL</td>
<td>NULL</td>
<td>NULL</td>
<td>9980</td>
<td>100.00</td>
<td>Using temporary;Using filesort</td>
</tr>
</tbody></table>
<ul>
<li>Extra字段显示Using temporary，表示的是需要使用临时表；Using filesort，表示的是需要执行排序操作。（需要临时表，并且需要在临时表上排序）  </li>
</ul>
<p>对于InnoDB表，执行全字段排序会减少磁盘访问。<br>对于内存表，回表过程只是简单的根据数据行的位置，直接访问内存得到数据，根本不会导致多访问磁盘。用于排序的行越小越好，优先选择rowid排序。<br>针对临时表，小的用memory引擎，大的用innodb引擎。  </p>
<p>执行流程：  </p>
<ol>
<li>创建一个临时表。临时表使用的是memory引擎，表里两个字段，第一个字段是double类型，记为字段R，第二个字段是varchar(64)类型，记为字段W。这个表没有建索引。  </li>
<li>从words表中，按主键顺序取出所有word值。对于每一个word值，调用rand()函数生成一个大于0小于1的随机小数，并把这个随机小数和word分别存入临时表R和W字段中，此时扫描行数为10000。  </li>
<li>临时表有10000行数据，接下来在这个没有索引的内存临时表上，按照字段R排序。  </li>
<li>初始化sort_buffer。sort_buffer中有两个字段，一个是double类型，另一个是整型。</li>
<li>从内存临时表中一行一行的取出R值和<strong>位置信息</strong>，分别存入sort_buffer中的两个字段里。这个过程要对内存临时表做全表扫描，此时扫描行数增加10000，为20000。  </li>
<li>在sort_buffer中根据R的值进行排序。这个过程没有涉及到表操作，不会增加扫描行数。  </li>
<li>排序完成后，取出前三个结果的<strong>位置信息</strong>，依次到内存临时表中取出word值，返回给客户端。访问了表的三行数据，总扫描函数变成了20003。  </li>
</ol>
<hr>
<h4 id="MySQL的表定位“一行数据”的方法"><a href="#MySQL的表定位“一行数据”的方法" class="headerlink" title="MySQL的表定位“一行数据”的方法"></a>MySQL的表定位“一行数据”的方法</h4><p>如果创建的表没有主键，或者把一个表的主键删掉了，那么<strong>InnoDB会自己生成一个长度为6字节的rowid来作为主键</strong>(但是这个主键对Server层是透明的，优化器用不上)。<strong>每个引擎用主键来唯一标识数据行的信息</strong>。  </p>
<ul>
<li>有主键的InnoDB表，rowid就是主键ID；  </li>
<li>没有主键的InnoDB表，rowid就是由系统生成的；  </li>
<li>MEMORY引擎不是索引组织表。可以认为它就是一个数组，rowid是数组的下标。  </li>
</ul>
<p>order by rand()使用了内存临时表，内存临时表排序的时候使用了rowid排序方法。  </p>
<h3 id="磁盘临时表-InnoDB"><a href="#磁盘临时表-InnoDB" class="headerlink" title="磁盘临时表-InnoDB"></a>磁盘临时表-InnoDB</h3><p>tmp_table_size这个配置限制了内存临时表的大小，默认值是16M。如果临时表大小超过了tmp_table_size，那么内存临时表就会转成磁盘临时表。  </p>
<p>磁盘临时表使用的引擎默认是InnoDB，由参数internal_tmp_disk_storage_engine控制。  </p>
<p>当使用磁盘临时表的时候，对应的就是一个没有显式索引的InnoDB表的排序过程。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        磁盘临时表
    </div>
    <div class='spoiler-content'>
        <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 单位字节(Byte)。1Byte=8bit</span></span><br><span class="line"><span class="keyword">set</span> tmp_table_size=<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">set</span> sort_buffer_size=<span class="number">32768</span>;</span><br><span class="line"><span class="keyword">set</span> max_length_for_sort_data=<span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打开 optimizer_trace，只对本线程有效 */</span></span><br><span class="line"><span class="keyword">SET</span> optimizer_trace=<span class="string">'enabled=on'</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 执行语句 */</span></span><br><span class="line"><span class="keyword">select</span> word <span class="keyword">from</span> words <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">rand</span>() <span class="keyword">limit</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查看 OPTIMIZER_TRACE 输出 */</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`information_schema`</span>.<span class="string">`OPTIMIZER_TRACE`</span>\G</span><br><span class="line"><span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span> <span class="keyword">json</span>  </span><br><span class="line"><span class="string">"filesort_priority_queue_optimization"</span>:&#123;</span><br><span class="line">    <span class="string">"limit"</span>:<span class="number">3</span>,</span><br><span class="line">    <span class="string">"rows_estimate"</span>:<span class="number">1213</span>,</span><br><span class="line">    <span class="string">"row_size"</span>:<span class="number">14</span>,</span><br><span class="line">    <span class="string">"memory_available"</span>:<span class="number">32768</span>,</span><br><span class="line">    <span class="string">"chosen"</span>:<span class="literal">true</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"filesort_execution"</span>:[],</span><br><span class="line"><span class="string">"filesort_summary"</span>:&#123;</span><br><span class="line">    <span class="string">"rows"</span>:<span class="number">4</span>,</span><br><span class="line">    <span class="string">"examined_rows"</span>:<span class="number">10000</span>,</span><br><span class="line">    <span class="string">"number_of_tmp_files"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="string">"sort_buffer_size"</span>:<span class="number">88</span>,</span><br><span class="line">    <span class="string">"sort_mode"</span>:<span class="string">"&lt;sort_key,rowid&gt;"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<ul>
<li>将max_length_for_sort_data=16，小于word字段的长度定义。sort_mode显示的是rowid排序，参与排序的是随机值R字段和rowid字段组成的行。  </li>
<li>R字段存放的随机值是8个字节，rowid是6个字节，数据总行数是10000，总共140000字节，超过sort_buffer_size为32768字节。number_of_tmp_files为0，表示不使用临时文件。  </li>
</ul>
<p>MySQL5.6引入优先队列排序算法。没有使用临时文件算法—归并排序算法(所有数据有序，浪费计算量)。  </p>
<p>执行流程：  </p>
<ol>
<li>对于10000个准备排序的(R,rowid)，先取前三行，构造一个堆；  </li>
<li>取下一个行(R’,rowid’)，跟当前堆里最大的R比较，如果R’小于R，把这个(R,rowid)从堆中去掉，换成(R’,rowid’)；   </li>
<li>重复第2步，直到第10000个(R’,rowid’)完成比较。  </li>
</ol>
<p>流程结束，堆中就是10000行中R值最小的三行，依次取出rowid，到临时表中拿到word字段。  </p>
<p>OPTIMIZER_TRACE结果中，filesort_priority_queue_optimization.chosen=true；表示使用优先级队列排序算法，不需要临时文件，对应的filesort_summary.number_of_tmp_files=0。  </p>
<blockquote>
<p>limit参数，影响排序算法，最小堆的维护代价小于sort_buffer_size时采用优先队列排序。  </p>
</blockquote>
<h3 id="随机排序方法"><a href="#随机排序方法" class="headerlink" title="随机排序方法"></a>随机排序方法</h3><p>无论使用哪种类型的临时表，order by rand()都会让计算过程非常复杂，需要大量的的扫描行数，排序过程的资源消耗也很大。  </p>
<h4 id="随机算法1"><a href="#随机算法1" class="headerlink" title="随机算法1"></a>随机算法1</h4><ol>
<li>取表的主键ID的最大值M和最小值N；  </li>
<li>用随机函数生成一个最大值到最小值之间的数X=(M-N)*rand()+N;  </li>
<li>取不小于X的第一个ID的行。  </li>
</ol>
<blockquote>
<p>select max(id),min(id) into @M,@N from t;<br>set @X= floor((@M-@N+1)*rand() + @N);<br>select * from t where id &gt;= @X limit 1;  </p>
</blockquote>
<p>取max(id)和min(id)走索引但不需要扫描索引，第三步的select可以用索引快速定位，综合扫描3行。  </p>
<h4 id="随机算法2"><a href="#随机算法2" class="headerlink" title="随机算法2"></a>随机算法2</h4><ol>
<li>取整个表的行数，记为C。  </li>
<li>取得Y=floor(C*rand())。floor函数取整数部分。  </li>
<li>用limitY,1取得一行。  </li>
</ol>
<blockquote>
<p>select count(*) into @C from t;<br>set @Y = floor(@C * rand());<br>set @sql = concat(“select * from t limit “, @Y, “,1”);<br>prepare stmt from @sql;<br>execute stmt;<br>DEALLOCATE prepare stmt;  </p>
</blockquote>
<p>解决了算法1的概率不均匀问题。(算法1要求ID中间没有空洞，否则选择不同行的概率不一样)  </p>
<p><strong>MySQL处理limit Y,1的做法是按顺序一个一个的读出来，丢掉前Y个，然后把下一个记录作为返回结果，这一步需要扫描Y+1行。</strong>加上第一步扫描的C行，总共需要扫描C+Y+1行，执行代价比算法1高，比直接order by rand()低。  </p>
<blockquote>
<p>limit获取数据的时候是根据主键排序获取的，主键索引天然有序，比order by rand()方法组成临时表R字段排序再获取rowid代价小。</p>
</blockquote>
<h4 id="随机算法3"><a href="#随机算法3" class="headerlink" title="随机算法3"></a>随机算法3</h4><ol>
<li>取整个表的行数，记为C。  </li>
<li>根据相同的随机方法得到Y1、Y2、Y3。  </li>
<li>执行三个limitY,1语句得到三行数据。  </li>
</ol>
<blockquote>
<p>select count(*) into @C from t;<br>set @Y1 = floor(@C * rand());<br>set @Y2 = floor(@C * rand());<br>set @Y3 = floor(@C * rand());<br>select * from t limit @Y1，1； //在应用代码里面取Y1、Y2、Y3值，拼出SQL后执行<br>select * from t limit @Y2，1；<br>select * from t limit @Y3，1；  </p>
</blockquote>
<p>总的扫描行数C+(Y1+1)+(Y2+1)+(Y3+1)。  </p>
<h4 id="随机算法4"><a href="#随机算法4" class="headerlink" title="随机算法4"></a>随机算法4</h4><p>取Y1、Y2、Y3里面最大的一个数，记为M，最小的一个数记为N。</p>
<blockquote>
<p>select * from t limit N,M-N+1;  </p>
</blockquote>
<p>总的扫描行数C+M+1。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>隔离事务</title>
    <url>/MySQL/6%E9%9A%94%E7%A6%BB%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<p>可重复读隔离级别，事务T启动的时候（start transaction with consistent snapshot）会创建一个视图read-view，之后事务T执行期间，即使有其他事务修改了数据，事务T看到的仍然跟启动时看到的是一致的，称之为一致性读。（一个在可重复读隔离级别下执行的事务，与世无争，不受外界影响。）  </p>
<p>一个事务要更新一行，如果刚好有另外一个事务拥有这一行的行锁，会被锁住，进入等待状态。  </p>
<h3 id="事务的启动时机"><a href="#事务的启动时机" class="headerlink" title="事务的启动时机"></a>事务的启动时机</h3><p>默认 autocommit = 1;（需要显式的开启事务和提交事务）  </p>
<ol>
<li><strong>begin/start transaction命令并不是一个事务的起点</strong>，在执行到它们之后的第一个操作InnoDB表的语句，事务才真正启动。  </li>
<li>如果想马上启动一个事务，可以使用start transaction with consistent snapshot命令。  </li>
</ol>
<ul>
<li>第一种启动方式，一致性视图是在执行第一个快照读语句时创建的；  </li>
<li>第二种启动方式，一致性视图是在执行start transaction with consistent snapshot时创建的。（可重复读隔离级别下）  </li>
</ul>
<p>在MySQL里有两个“视图”的概念：  </p>
<ul>
<li>一个是view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是create view…，它的查询方法与表一样。  </li>
<li>一个是InnoDB在实现MVCC(多版本并发控制)时用到的<strong>一致性读</strong>视图，即consistent read view，<strong>用于支持RC(Read Committed，读提交)和RR(Repeatable Read，可重复度)隔离级别的实现</strong>。它没有物理结构，作用是事务执行期间用来定义“我能看到什么数据”。  </li>
</ul>
<h3 id="查询-一致性读-“快照”在MVCC里是怎么工作的"><a href="#查询-一致性读-“快照”在MVCC里是怎么工作的" class="headerlink" title="查询-一致性读-“快照”在MVCC里是怎么工作的"></a>查询-一致性读-“快照”在MVCC里是怎么工作的</h3><p>(MVCC一致性读到的数据对于update这种指令不适用。可以看到别人已提交修改后的数据。)<br>在可重复读隔离级别下，事务在启动(begin不是启动)的时候就“拍了个快照”。这个快照是基于整库的所有InnoDB引擎的表。  </p>
<p>InnoDB里面每个事务有一个唯一的事务ID，叫做transaction id。它是在<strong>事务开始的时候</strong>向InnoDB的事务系统申请的（事务启动时），是按申请顺序严格递增的。  </p>
<p><strong>每行数据有多个版本。每次事务更新数据的时候，都会生成一个新的数据版本，</strong>并且把transaction id赋值给这个数据版本的事务ID，记为row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它（新旧版本与id本身自然数大小无关，与事务提交先后有关，没提交也生成版本，但是未提交的，还加着锁）。  </p>
<p>数据表中的一行记录，可能有多个版本(row)，每个版本有自己的row trx_id。每个事务或者语句有自己的一致性视图。下图对应一个记录被多个事务连续更新后的状态。  </p>
<img src="/img/MySQL行状态变更图.png">

<p>数据版本与事务版本</p>
<p>语句更新会生成undo log(回滚日志)，对应图中的三个虚线箭头。V1、V2、V3并不是物理上真实存在的，而是每次需要的时候根据当前版本和undo log计算出来的。需要前面的版本V，就通过当前版本依次执行回滚日志U算出来。  </p>
<p>回滚就是把最新的版本（还没提交）删掉。</p>
<hr>
<p>根据可重复读的定义，一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。  </p>
<p>一个事务只需要在启动的时候声明说，“以我启动的时刻为准，如果一个数据版本是在我启动之前生成并提交的，就认；如果是我启动以后才生成的，就不认，必须要找到它的上一个版本”。如果上一个版本也不可见，那就继续往前找。如果是这个事务自己更新的数据，自己还是要认的。这个事务的快照，相当于是静态的。  </p>
<hr>
<p><strong>视图数组：</strong><br>在实现上，InnoDB为每个事务构造了一个数组（数组不保证是连续自然数，存在已提交的），用来保存这个事务启动瞬间，当前正在“活跃”的所有事务ID(创建事务，到创建事务视图数组，中间可能有别的事务新建或提交)。“活跃”指的就是，启动了但还没提交（比当前事务的ID还小）。  </p>
<p>数组里面事务ID的最小值记为低水位，当前系统里面已经创建过的事务ID的最大值加1记为高水位。  </p>
<p><strong>这个视图数组和高水位，就组成了当前事务的一致性视图(read-view)</strong>。（高水位不在视图数组中）  </p>
<p>数据版本的可见性规则，就是基于数据的row trx_id和这个一致性视图的对比结果得到的。（同一行数据，最新版本的row trx_id是可能会小于旧版本的row trx_id的）  </p>
<blockquote>
<p>可重复读下，开启一个事务时创建一个数组来记录当前所有活跃的事务id。后续有新的事务也不会再更新该数组。<br>读提交，开启事务时也会创建数组来保存事务id，而且之后每个查询都会更新一次这个数组。  </p>
</blockquote>
<p>视图数组把所有的row  trx_id分成了几种不同的情况。  </p>
<img src="/img/MySQL数据版本可见性规则.png">

<p>对于当前事务的启动瞬间来说，一个数据版本的row trx_id，有以下几种可能：  </p>
<ul>
<li>落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；  </li>
<li>落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；  </li>
<li>落在黄色部分，包括两种情况  <ul>
<li>若row trx_id在数组中，表示这个版本是由还没提交的事务生成的，不可见；  </li>
<li>若row trx_id不在数组中，表示这个版本是已经提交了的事务生成的，可见。（一个比低水位大，但是在当前事务启动前就已经提交了的事务）  </li>
</ul>
</li>
</ul>
<p>InnoDB利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。  </p>
<p>一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况：  </p>
<ul>
<li>版本未提交，不可见；  </li>
<li>版本已提交，但是是在视图创建后提交的，不可见；  </li>
<li>版本已提交，而且是在视图创建前提交的，可见。  </li>
</ul>
<h3 id="更新-当前读-加锁读-Locking-reads"><a href="#更新-当前读-加锁读-Locking-reads" class="headerlink" title="更新-当前读-加锁读(Locking reads)"></a>更新-当前读-加锁读(Locking reads)</h3><p><strong>更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”(current read)。</strong>如果有锁，就等待其他事务提交释放锁再读。（总是读取已经提交完成的最新版本，update语句把数据更新后，对应记录上的数据版本id就变成当前事务的id）  </p>
<p>除了update语句外，select语句如果加锁，也是当前读，会访问最新版本并加锁。（普通查询语句是一致性读）  </p>
<pre><code class="sql">mysql&gt; select k from t where id=1 lock in share mode;-- 读锁(S锁，共享锁)
mysql&gt; select k from t where id=1 for update;-- 写锁(X锁，排它锁)</code></pre>
<p>表结构没有对应的行数据，也没有row trx_id，因此只能遵循当前读的逻辑，不支持可重读读。（MySQL8.0可以把表结构放在InnoDB字典里）  </p>
<hr>
<p><strong>可重复读的核心就是一致性读(consistent read)，但可重复读下select … lock in share mode 是当前读；而且事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待，等待其他事务释放锁才能继续当前读。当前读总是读取已经提交完成的最新版本。</strong>  </p>
<p>读提交的逻辑和可重复读的主要区别：  </p>
<ul>
<li>在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；（查询只承认在事务启动前就已经提交完成的数据）  </li>
<li>在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图，每个视图只管自己一个语句。（查询只承认在语句启动前就已经提交完成的数据）  </li>
</ul>
<p>“start transaction with consistent snapshot;”的意思是从这个语句开始，创建一个持续整个事务的一致性快照。在读提交隔离级别下，这个用法失去意义，等效于普通的start transaction（执行第一个快照语句时才创建一致性视图）。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>幻读</title>
    <url>/MySQL/%E5%B9%BB%E8%AF%BB/</url>
    <content><![CDATA[<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        样例
    </div>
    <div class='spoiler-content'>
        <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">'t'</span> (</span><br><span class="line">    <span class="string">'id'</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="string">'c'</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="string">'d'</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line">    primary <span class="keyword">key</span> (<span class="string">'id'</span>),</span><br><span class="line">    <span class="keyword">key</span> <span class="string">'c'</span> (<span class="string">'c'</span>)</span><br><span class="line">) <span class="keyword">engine</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<blockquote>
<p>begin;<br>select * from t where d=5 for update;<br>commit;  </p>
</blockquote>
<p>这个语句会命中d=5这一行，对应的主键id=5，在select语句执行完成后，id=5这一行会加一个写锁，由于两阶段锁协议，这个写锁会在执行commit语句的时候释放。（由于字段d上没有索引，这条查询语句会做全表扫描。其他被扫描到的，但是不满足条件的记录也会加锁）  </p>
<h3 id="理解幻读"><a href="#理解幻读" class="headerlink" title="理解幻读"></a>理解幻读</h3><p>假设：  </p>
<table>
<thead>
<tr>
<th></th>
<th>sessionA</th>
<th>sessionB</th>
<th>sessionC</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>begin;  select * from t where d=5 for update;– Q1 (5,5,5)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td></td>
<td>update t set d=5 where id=0;</td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td>select * from t where d=5 for update;– Q2 (0,0,5),(5,5,5)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td></td>
<td>insert into t values(1,1,5);</td>
</tr>
<tr>
<td>T5</td>
<td>select * from t where d=5 for update;– Q3 (0,0,5),(1,1,5),(5,5,5)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>T6</td>
<td>commit;</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>sessionA执行了三次查询：Q1、Q2、Q3。它们的SQL语句相同。select * from t where d=5 for update;查所有d=5的行，而且使用的是当前读，能读到所有已经提交的记录的最新值，并且加上写锁。  </p>
<p>Q3读到id=1这一行的现象被称为“幻读”。<br><strong>幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。</strong>  </p>
<ul>
<li>在可重复读隔离级别下，普通的查询时快照读，是不会看到别的事务插入的数据的。幻读在“当前读”下才会出现。  </li>
<li>sessionB的修改结果，被sessionA之后的select语句用“当前读”看到，不能成为幻读。幻读仅专指“新插入的行”。  </li>
</ul>
<h3 id="幻读引发的问题"><a href="#幻读引发的问题" class="headerlink" title="幻读引发的问题"></a>幻读引发的问题</h3><h4 id="语义上的问题"><a href="#语义上的问题" class="headerlink" title="语义上的问题"></a>语义上的问题</h4><p>sessionA在T1时刻声明，把所有d=5的行锁住，不准别的事务进行读写操作，只给id=5这一行加了行锁。sessionB和sessionC中的语句正常修改，会产生新的d=5的行，破坏了sessionA中Q1语句要锁住所有d=5的行的加锁声明。  </p>
<h4 id="数据一致性问题"><a href="#数据一致性问题" class="headerlink" title="数据一致性问题"></a>数据一致性问题</h4><p>锁的设计是为了保证数据的一致性。不只是数据库内部数据状态在此刻的一致性，还包含了数据和日志在逻辑上的一致性。  </p>
<p>sessionA在T1时刻加一个更新语句：update t set d=100 where d=5;<br>数据库中结果：  </p>
<ul>
<li>T1时刻后，id=5这一行变成(5,5,100)，这个最终结果是在T6时刻正式提交的；</li>
<li>T2时刻后，id=0这一行变成(0,0,5);</li>
<li>T4时刻后，表里多了一行(1,1,5);</li>
</ul>
<p>binlog中内容：  </p>
<ul>
<li>T2时刻，sessionB事务提交，写入了一条语句；</li>
<li>T4时刻，sessionC事务提交，写入了一条语句；</li>
<li>T6时刻，sessionA事务提交，写入了update t set d=100 where d=5这条语句。（所有d=5的行，d改成100）</li>
</ul>
<p>使用binlog的语句序列，拿到备库执行或者克隆一个库，这三行结构都变成了(0,0,100),(1,1,100),(5,5,100)。产生了数据不一致。  </p>
<p>数据不一致是因为select * from t where d=5 for update只给d=5这一行，也就是id=5这一行加锁导致的。  </p>
<p>即使把扫描过程中碰到的行，都加上写锁(当前存在的所有行)，也只能解决update语句导致的数据不一致问题(sessionB被锁住，等到sessionA提交后才能继续执行)。但是阻止不了insert语句新插入记录，加锁的时候新插入的记录行不存在，不存在也就加不上锁(无锁可随意修改并先提交，若sessionC中加一条把d改成5的操作并先提交，根据日志语句序列依然会导致主从数据不一致)。</p>
<h3 id="解决幻读"><a href="#解决幻读" class="headerlink" title="解决幻读"></a>解决幻读</h3><h4 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h4><p>产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。为了解决幻读问题，InnoDB引入了新的锁—间隙锁(Gap Lock)。间隙锁锁的是两个值之间的空隙。  </p>
<p>执行select * from t where d=5 for update;时，不止是给数据中已有的6个记录加上了行锁，还同时加了7个间隙锁。确保了无法再插入新的记录。  </p>
<p><strong>行锁分成读锁和写锁。读读兼容，读写、写写冲突。跟行锁有冲突关系的是“另外一个行锁”。</strong>  </p>
<p><strong>间隙锁之间都不存在冲突关系。跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作。</strong>  </p>
<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
</tr>
</thead>
<tbody><tr>
<td>begin;select * from t where c=7 lock in share mode;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>begin;select * from t where c=7 for update;</td>
</tr>
</tbody></table>
<p>sessionB并不会被堵住，表t中没有c=7这个记录，因此sessionA加的是间隙锁(5,10)。而sessionB也是在这个间隙加的间隙锁。它们有共同的目标：保护这个间隙，不允许插入值，但是它们之间是不冲突的。  </p>
<h4 id="next-key-lock"><a href="#next-key-lock" class="headerlink" title="next-key lock"></a>next-key lock</h4><p>间隙锁和行锁合称next-key lock，每个next-key lock是前开后闭区间。示例表可以形成7个next-key lock：(-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20,25]、(25,+suprenum]。  </p>
<blockquote>
<p>间隙锁为开区间，next-key lock为前开后闭区间。<br>+∞是开区间。InnoDB给每个索引加了一个不存在的最大值supremum，符合前开后闭区间。  </p>
</blockquote>
<h4 id="新的问题"><a href="#新的问题" class="headerlink" title="新的问题"></a>新的问题</h4><p><strong>间隙锁和next-key lock的引入，解决了幻读的问题，但可能会导致同样的语句锁住更大的范围，影响了并发度。</strong></p>
<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
</tr>
</thead>
<tbody><tr>
<td>begin;select * from t where id=9 for update;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>begin;select * from t where id=9 for update;</td>
</tr>
<tr>
<td></td>
<td>insert into t values(9,9,9);– blocked</td>
</tr>
<tr>
<td>insert into t values(9,9,9);– error 1213(40001):deadlock found</td>
<td></td>
</tr>
</tbody></table>
<ol>
<li>sessionA执行select…for update语句，由于id=9这一行并不存在，因此会加上间隙锁(5,10)；</li>
<li>sessionB执行select…for update语句，同样会加上间隙锁(5,10)，间隙锁之间不会冲突，这个语句可以执行成功；</li>
<li>sessionB视图插入一行(9,9,9)，被sessionA的间隙锁挡住了，只好进入等待；</li>
<li>sessionA视图插入一行(9,9,9)，被sessionA的间隙锁挡住了。  </li>
</ol>
<p>两个session进入互相等待状态，形成死锁。(InnoDB的死锁检测马上就发现了这对死锁关系，让sessionA的insert语句报错返回)  </p>
<blockquote>
<p>只有一个唯一索引的时候，可以用insert…on duplicate key update语法避免死锁</p>
</blockquote>
<p>间隙锁是可重复读隔离级别下才会生效的。如果把隔离级别设置为读提交，就没有间隙锁了。但要解决可能出现的数据和日志不一致问题，需要把binlog格式设置为row。(set transaction_isolation=’read-committed’;set binlog_format=’row’)  </p>
<blockquote>
<p>innodb_locks_unsafe_for_binlog=1;表示不加间隙锁</p>
</blockquote>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>应急性能提升手段</title>
    <url>/MySQL/%E5%BA%94%E6%80%A5%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87%E6%89%8B%E6%AE%B5/</url>
    <content><![CDATA[<h3 id="短连接风暴"><a href="#短连接风暴" class="headerlink" title="短连接风暴"></a>短连接风暴</h3><p>正常的短连接模式是连接到数据库后，执行很少的SQL语句就断开，下次需要的时候再重连。使用短连接，在业务高峰期的时候，可能出现连接数突然暴涨的情况。MySQL建立连接的过程成本很高，除了网络连接三次握手外，还要做登录权限判断和获取该连接的读取权限。  </p>
<p>max_connextions参数，控制一个MySQL实例同时存在的连接数的上限，超过这个值，系统就会拒绝接下来的连接请求，并报错提示“Too many connections”，对业务来说就是数据库不可用。<br>负载比较高时，单纯调高max_connections的值，让更多的连接进来，会让系统的负载进一步加大，资源耗费在权限验证逻辑上，适得其反，导致已连接线程拿不到CPU资源去执行业务的SQL请求。</p>
<h4 id="1-先处理掉那些占着连接但是不工作的线程"><a href="#1-先处理掉那些占着连接但是不工作的线程" class="headerlink" title="1.先处理掉那些占着连接但是不工作的线程"></a>1.先处理掉那些占着连接但是不工作的线程</h4><p>max_connections的计算，不是看谁在running，只要连着就占用一个计数位置。对于不需要保持的连接，可以通过kill connection主动踢掉。<br>wait_timeout参数，表示一个线程空闲wait_timeout这么多秒之后，就会被MySQL直接断开连接。  </p>
<table>
<thead>
<tr>
<th></th>
<th>sessionA</th>
<th>sessionB</th>
<th>sessionC</th>
</tr>
</thead>
<tbody><tr>
<td>T</td>
<td>begin;</br>insert into t values(1,1);</td>
<td>select * from t where id=1;</td>
<td></td>
</tr>
<tr>
<td>T+30s</td>
<td></td>
<td></td>
<td>show processlist</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>id</th>
<th>user</th>
<th>host</th>
<th>db</th>
<th>command</th>
<th>time</th>
<th>state</th>
<th>info</th>
</tr>
</thead>
<tbody><tr>
<td>4</td>
<td>root</td>
<td>localhost:xxxxx</td>
<td>test</td>
<td>sleep</td>
<td>30</td>
<td></td>
<td>null</td>
</tr>
<tr>
<td>5</td>
<td>root</td>
<td>localhost:yyyyy</td>
<td>test</td>
<td>sleep</td>
<td>30</td>
<td></td>
<td>null</td>
</tr>
<tr>
<td>6</td>
<td>root</td>
<td>localhost:zzzzz</td>
<td>test</td>
<td>query</td>
<td>0</td>
<td>starting</td>
<td>show processlist</td>
</tr>
</tbody></table>
<p>会话4、5都是sleep状态，查询information_schema库的innodb_trx表查看事务具体状态：<br>select * from information_schema.innodb_trx;<br>其中trx_mysql_thread_id=4;表示id=4的线程处在事务中。还未提交不宜断开，会导致对应事务回滚。  </p>
<p>如果连接数过多，优先断开事务外空闲太久的连接；如果还不够，再考虑断开事务内空闲太久的连接。  </p>
<p>使用kill connection+id命令从服务器断开连接。一个客户端处于sleep状态时，它的连接被服务器主动断开后，这个客户端不会马上知道，知道客户端发起下一个请求时，才会收到报错”ERROR 2013(HY000):lost connection to MySQL server during query”。  </p>
<p>从数据库端主动断开连接可能是有损的，若应用端接收到错误后，不重新连接，而是直接用这个已经不能用的句柄重试查询，导致从应用端看上去”MySQL一直没恢复”。（<strong>链接异常断开是常有的事，业务开发的应用代码需要有正确的重连并重试的机制。</strong>）  </p>
<h4 id="2-减少连接过程的消耗"><a href="#2-减少连接过程的消耗" class="headerlink" title="2.减少连接过程的消耗"></a>2.减少连接过程的消耗</h4><p>让数据库跳过权限验证阶段：重启数据库，并使用-skip-grant-tables参数启动。整个数据库会跳过所有的权限验证阶段，包括连接过程和语句执行过程。  </p>
<p>跳过权限验证风险极高，MySQL8.0使用时会默认把–skip-networking参数打开，让数据库只能被本地的客户端连接。  </p>
<h3 id="慢查询性能问题"><a href="#慢查询性能问题" class="headerlink" title="慢查询性能问题"></a>慢查询性能问题</h3><ol>
<li>上线前，在测试环境，把慢查询日志(slow log)打开slow_query_log(默认关闭)，并且把long_query_time设置成0(默认值为10)，确保每个语句都会被记录人慢查询日志；  </li>
<li>在测试表里插入模拟线上的数据，做一遍回归测试；  </li>
<li>观察慢查询日志里每类语句的输出，特别留意Rows_examined字段(server层统计值)是否与预期一致。  </li>
</ol>
<p>开源工具pt-query-digest分析。  </p>
<h4 id="索引没有设计好"><a href="#索引没有设计好" class="headerlink" title="索引没有设计好"></a>索引没有设计好</h4><p>通过紧急创建索引解决。(MySQL5.6版本以后，创建索引支持Online DDL，可以直接执行alter table 语句)。  </p>
<p>主库A、备库B：  </p>
<ol>
<li>在备库B上执行set sql_log_bin=off，也就是不写binlog，然后执行alter table语句加上索引；  </li>
<li>执行主备切换；主库B、备库A。  </li>
<li>在A上执行set sql_log_bin=off，然后执行alter table语句加上索引。  </li>
</ol>
<p>使用gh-ost在线ddl变更。  </p>
<h4 id="SQL语句没有写好"><a href="#SQL语句没有写好" class="headerlink" title="SQL语句没有写好"></a>SQL语句没有写好</h4><p><a href="/MySQL/相同逻辑，不同SQL，性能差异">MySQL-相同逻辑，不同SQL，性能差异</a><br>条件字段函数操作、隐式类型转换、隐式字符编码转换等原因，导致语句没有使用上索引。  </p>
<p>通过改写SQL语句来处理。MySQL5.7提供了query_rewrite功能，可以把输入的一种语句改写成另外一种模式。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> query_rewrite.rewrite_rules(pattern,replacement,pattern_database) <span class="keyword">values</span> (<span class="string">"select * from t where id + 1 = ?"</span>,<span class="string">"select * from t where id = ? - 1"</span>,<span class="string">"db1"</span>);  </span><br><span class="line"><span class="keyword">call</span> query_rewrite.flush_rewrite_rules();<span class="comment">-- 让插入的新规则生效</span></span><br></pre></td></tr></table></figure>

<p>查询重写  </p>
<blockquote>
<p>Query ‘select * from t where id + 1 = 10000 ‘ rewritten to ‘select * from t where id = 10000 - 1’ by a query rewrite plugin;</p>
</blockquote>
<h4 id="MySQL选错了索引"><a href="#MySQL选错了索引" class="headerlink" title="MySQL选错了索引"></a>MySQL选错了索引</h4><p><a href="/MySQL/索引选择异常及处理">MySQL-索引选择异常及处理</a>  </p>
<p>应急方案给这个语句加上force index。<br>使用查询重写功能，给原来的语句佳航force index。  </p>
<h3 id="QPS突增问题"><a href="#QPS突增问题" class="headerlink" title="QPS突增问题"></a>QPS突增问题</h3><p>下掉一个功能，从数据库端处理：  </p>
<ol>
<li>由全新业务的bug导致的，确定业务方会下掉这个功能，从数据库端直接把白名单去掉。  </li>
<li>新功能使用的单独的数据库用户，用管理员账号把这个用户删掉，然后断开现有连接。这样新功能的连接不成功，由它引发的QPS就会变成0。  <blockquote>
<p>方案1、2依赖于规范的运维提下：虚拟化、白名单机制、业务账号分离。  </p>
</blockquote>
</li>
<li>新功能跟主体功能部署在一起，只能通过处理语句来限制，使用查询重写功能，把压力最大的SQL语句直接重写成”select 1”返回。  <blockquote>
<p>如果别的功能也用到了这个SQL语句模板，会有误伤。<br>很多业务并不是靠这一个语句就能完成逻辑的，单独改这一个语句，可能会导致后面的业务逻辑一起失败。  </p>
</blockquote>
</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>相同逻辑，不同SQL，性能差异</title>
    <url>/MySQL/%E7%9B%B8%E5%90%8C%E9%80%BB%E8%BE%91%EF%BC%8C%E4%B8%8D%E5%90%8CSQL%EF%BC%8C%E6%80%A7%E8%83%BD%E5%B7%AE%E5%BC%82/</url>
    <content><![CDATA[<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tradelog`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`tradeid`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`operator`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`t_modified`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`tradeid`</span> (<span class="string">`tradeid`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`t_modified`</span> (<span class="string">`t_modified`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br></pre></td></tr></table></figure>

<h3 id="条件字段函数操作"><a href="#条件字段函数操作" class="headerlink" title="条件字段函数操作"></a>条件字段函数操作</h3><blockquote>
<p>select count(*) from tradelog where month(t_modified)=7;  </p>
</blockquote>
<p>B+树的快速定位能力，来源于同一层兄弟节点的有序性。<br><strong>对索引字段做函数操作，可能会破坏索引值的有序性，优化器决定放弃走树搜索功能(快速定位能力)。但优化器并不是要放弃使用这个索引。</strong>  </p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>partitions</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>filtered</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>tradelog</td>
<td>NULL</td>
<td>index</td>
<td>NULL</td>
<td>t_modified</td>
<td>6</td>
<td>NULL</td>
<td>100335</td>
<td>100.00</td>
<td>Using where;Using index</td>
</tr>
</tbody></table>
<p>放弃了树搜索功能，优化器可以选择遍历主键索引，也可以选择遍历索引t_modified，优化器对比索引大小后发现，索引t_moditied更小，遍历这个索引比遍历主键索引更快，最终会选择索引t_modified。  </p>
<p>key=t_modified表示使用了该索引；测试数据10W行，rows=100335说明扫描了整个索引的所有值；Extra的Using index，表示使用了覆盖索引。<br>由于在t_modified字段加了month()函数操作，MySQL无法再使用索引快速定位功能，只能使用全索引扫描。<br>即使是对于不改变有序性的函数，也不会考虑使用索引。(where id + 1 = 10000;—&gt;where id = 10000 - 1;)  </p>
<h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><blockquote>
<p>select * from tradelog where tradeid=110717;  </p>
</blockquote>
<p>tradeid字段类型是varchar(32)，输入参数是整型，需要做类型转换。  </p>
<p><strong>在MySQL中，字符串和数字做比较的话，是将字符串转换成数字。</strong>（索引字段为整型，条件字段为字符串时，走索引。截断式转换）  </p>
<blockquote>
<p>select * from tradelog where CAST（tradid AS signed int） = 110717;<br>触发对索引字段做函数操作，优化器会放弃走树搜索功能。  </p>
</blockquote>
<h3 id="隐式字符编码转换"><a href="#隐式字符编码转换" class="headerlink" title="隐式字符编码转换"></a>隐式字符编码转换</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `trade_detail` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `tradeid` varchar(32) DEFAULT NULL,</span><br><span class="line">  `trade_step` int(11) DEFAULT NULL, <span class="comment">/*操作步骤*/</span></span><br><span class="line">  `step_info` varchar(32) DEFAULT NULL, <span class="comment">/*步骤信息*/</span></span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `tradeid` (`tradeid`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>select d.* from tradelog l, trade_detail d where d.tradeid=l.tradeid and l.id=2;  </p>
</blockquote>
<ul>
<li>优化器会先在交易记录表tradelog上查到id=2的行，这个步骤用上了主键索引，只扫描一行。  </li>
<li>没有用上交易详情表trade_detail上的tradeid索引，进行了全表扫描。通过遍历主键索引的方式，一个一个的判断tradeid的值是否匹配。  </li>
</ul>
<p>这个执行计划里，从tradelog表中取tradeid字段，再去trade_detail表里查询匹配字段。把tradelog称为驱动表，trade_detail称为被驱动表，把tradeid称为关联字段。  </p>
<p>这两个表的字符集不同，一个是utf8，一个是utf8mb4，做表连接查询的时候用不上关联字段的索引。字符集utf8mb4是utf8的超集，当这两个类型的字符串做比较的时候，MySQL内部的操作是，先把utf8字符串转成utf8mb4字符集，再做比较。  </p>
<blockquote>
<p>select * from trade_detail  where CONVERT(traideid USING utf8mb4)=$L2.tradeid.value;<br>– convert()函数，把输入的字符串转成utf8mb4字符集。<br>触发对索引字段做函数操作，优化器会放弃走树搜索功能。  </p>
</blockquote>
<p><strong>连接过程中要求在被驱动表的索引字段上加函数操作，是直接导致对被驱动表做全表扫描的原因。</strong></p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        样例
    </div>
    <div class='spoiler-content'>
        <blockquote>
<p>select l.operator from tradelog l , trade_detail d where d.tradeid=l.tradeid and d.id=4;</p>
</blockquote>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>partitions</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>filtered</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>d</td>
<td>NULL</td>
<td>const</td>
<td>PRIMARY</td>
<td>PRIMARY</td>
<td>4</td>
<td>const</td>
<td>1</td>
<td>100.00</td>
<td>NULL</td>
</tr>
<tr>
<td>1</td>
<td>SIMPLE</td>
<td>l</td>
<td>NULL</td>
<td>ref</td>
<td>tradeid</td>
<td>tradeid</td>
<td>131</td>
<td>const</td>
<td>1</td>
<td>100.00</td>
<td>NULL</td>
</tr>
</tbody></table>
<p>驱动表trade_detail，被驱动表tradelog。  </p>
<blockquote>
<p>select opterator from tradelog where tradeid = CONVERT($R4.tradeid.value USING utf8mb4);<br>CONVERT函数是加在输入参数上的，可以用上被驱动表的tradeid索引。  </p>
</blockquote>

    </div>
</div>  

<p>原SQL改造：  </p>
<ul>
<li>把trade_detail表上的tradeid字段的字符集改成utf8mb4，避免字符集转换问题。<blockquote>
<p>alter table trade_detail modify tradeid varchar(32) CHARACTER set utf8mb4 default null;  </p>
</blockquote>
</li>
<li>修改SQL语句。<blockquote>
<p>select d.* from tradelog l , trade_detail d where d.tradeid=CONVERT(l.tradeid USING utf8) and l.id=2; </p>
</blockquote>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>主备切换保证系统高可用</title>
    <url>/MySQL/%E4%B8%BB%E5%A4%87%E5%88%87%E6%8D%A2%E4%BF%9D%E8%AF%81%E7%B3%BB%E7%BB%9F%E9%AB%98%E5%8F%AF%E7%94%A8/</url>
    <content><![CDATA[<p>在一个主备关系中，每个备库接受主库的binlog并执行。只要主库执行更新生成的所有binlog，都可以传到备库并被正确的执行，备库就能达到跟主库一致的状态—最终一致性。  </p>
<p>主备切换可能是主动运维动作(软件升级、主库所有机器按计划下线)，也可能是被动操作(主库所在机器掉电)。  </p>
<h3 id="主备延迟"><a href="#主备延迟" class="headerlink" title="主备延迟"></a>主备延迟</h3><p>所谓主备延迟就是同一个事务，在备库执行完成的时间和主库执行完成的时间之间的差值。  </p>
<p>同步延迟：  </p>
<ol>
<li>主库A执行完成一个事务，写入binlog，这个时刻记为T1；  </li>
<li>传给备库B，把备库B接受完成这个binlog的时刻记为T2；  </li>
<li>备库B执行完成这个事务，把这个时刻记为T3。主备延迟=T3-T1。  </li>
</ol>
<p>在备库上执行show slave status命令，返回结果中的seconds_behind_master表示当前备库延迟了多少秒。  </p>
<ol>
<li>每个事务的binlog里面都有一个时间字段，用于记录主库上写入的时间；  </li>
<li>备库取出当前正在执行的事务的时间字段的值，计算它与当前系统的差值，得到seconds_behind_master。  </li>
</ol>
<p>备库链接到主库时，通过执行select unix_timestamp()函数来获得当前主库的系统时间。如果发现主库的时间与自己不一致，备库在执行seconds_behind_master计算的时候会自动扣掉这个差值。  </p>
<blockquote>
<p>SBM不能当做真正的延迟时间。主库没有把日志都发给备库，备库没收到新的binlog时，从库不知道延迟。但主库提交了，从库查不到就算延迟。  </p>
</blockquote>
<p>网络正常，日志从主库传给备库所需的时间很短，T2-T1的值很小(io_thread)，主备延迟的主要来源是备库接收完binlog和执行完这个事务之间的时间差(sql_thread)。最直接表现：备库消费中转日志(relay log)的速度，比主库生产binlog的速度慢。</p>
<h3 id="延迟来源"><a href="#延迟来源" class="headerlink" title="延迟来源"></a>延迟来源</h3><h4 id="备库所在机器的性能比主库所在的机器性能差"><a href="#备库所在机器的性能比主库所在的机器性能差" class="headerlink" title="备库所在机器的性能比主库所在的机器性能差"></a>备库所在机器的性能比主库所在的机器性能差</h4><p>更新请求对IOPS的压力，在主库和备库上是无差别的。备库主机的性能差，一般将备库设置为“非双1”的模式。  </p>
<p>更新过程中触发大量的读操作，备库主机上的多个备库都在争抢中资源时，也可能会导致主备延迟。  </p>
<p>解决：<br>主备可能发生切换，备库随时可能变为主库，主<strong>备选用相同规格的机器，并做对称部署。</strong>  </p>
<h4 id="备库的压力大"><a href="#备库的压力大" class="headerlink" title="备库的压力大"></a>备库的压力大</h4><p>主库提供写能力，备库提供读能力，不影响业务的分析语句在备库上跑。备库查询耗费大量的CPU资源，影响同步速度，造成主备延迟。  </p>
<p>解决：  </p>
<ol>
<li>一主多从。除了备库(可被选成新主库)外，多接几个从库，让从库分担读的压力。(同时从库可以用来做定期全量备份)  </li>
<li>通过binlog输出到外部系统，如Hadoop，让外部系统提供统计类查询的能力。  </li>
</ol>
<h4 id="大事务"><a href="#大事务" class="headerlink" title="大事务"></a>大事务</h4><p>主库必须等事务执行完成才会写入binlog，再传给备库。主库语句执行时间长，就会导致从库延迟。未开并行复制，默认串行导致一个堵全部堵。  </p>
<h5 id="一次性的用delete语句删除太多数据"><a href="#一次性的用delete语句删除太多数据" class="headerlink" title="一次性的用delete语句删除太多数据"></a>一次性的用delete语句删除太多数据</h5><p>归档类数据，平时没有删除历史数据，等到空间快满了，一次性的删除大量历史数据。</p>
<p>解决：<br>避免高峰期操作，同时控制每个事务删除的数据量。  </p>
<h5 id="大表DDL"><a href="#大表DDL" class="headerlink" title="大表DDL"></a>大表DDL</h5><p><a href="/MySQL/重建表回收空间">MySQL-重建表回收空间</a>  </p>
<p>解决：<br>计划内的DDL，建议使用gh-ost方案。  </p>
<h4 id="备库的并行复制能力"><a href="#备库的并行复制能力" class="headerlink" title="备库的并行复制能力"></a>备库的并行复制能力</h4><p>// todo 待补充</p>
<h3 id="可靠性优先"><a href="#可靠性优先" class="headerlink" title="可靠性优先"></a>可靠性优先</h3><img src="/img/MySQL可靠性优先主备切换流程.png" width="500" height="333" >
SBM是seconds_behind_master参数的简写。  

<p>双M结构下，主备切换过程(可靠性优先)：  </p>
<ol>
<li>判断备库B现在的seconds_behind_master，如果小于某个值(5秒)继续下一步，否则持续重试这一步；  </li>
<li>把主库A改成只读状态，readonly=true；  </li>
<li>判断备库B的seconds_behind_master的值，直到整个值变成0为止；(最耗时的步骤，确保步骤1中SBM值足够小)  </li>
<li>把备库B改成可读写状态，readonly=false；  </li>
<li>把业务请求切换到备库B。  </li>
</ol>
<p>步骤2之后，主库A和备库B都处于readonly状态，系统处于不可写状态，直到步骤5完成后才恢复。  </p>
<p>主库掉电时，采用可靠性优先，备库只读，且中转日志未完成应用，系统不可用。且主库可能有来不及传的binlog(通过semi-sync解决)  </p>
<h3 id="可用性优先"><a href="#可用性优先" class="headerlink" title="可用性优先"></a>可用性优先</h3><p>把步骤4、5调整到最开始执行，不等主备数据同步，直接把连接切换到备库B，并且让备库可以读写，系统没有不可用时间。但是可能出现数据不一致的情况。  </p>
<ul>
<li>row格式，数据不一致更容易被发现。主键自动递增，binlog未同步时，连续两条新增语句被主备分别执行，导致主键冲突。(主库新增，binlog未同步，主备切换，备库新增。binlog互相同步时，由于记录了所有字段，发现主键相同的两条不同记录)  </li>
<li>statement格式，数据悄悄的就不一致了。binlog记录的只是SQL语句，先后执行两次，分别生成两条不同的数据。  </li>
</ul>
<p>使用场景：  </p>
<ul>
<li>有一个库的作用是记录操作日志。如果数据不一致可以通过binlog来修补，短暂的不一致不会引发业务问题。  </li>
<li>业务系统依赖于这个日志写入逻辑，如果这个库不可写，会导致线上的业务操作无法执行。  </li>
</ul>
<p>在满足数据可靠性的前提下，MySQL高可用系统的可用性，是依赖于主备延迟的，延迟时间越小(1s)，在主库故障的时候，服务恢复需要的时间就越短，可用性就越高。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>加锁规则</title>
    <url>/MySQL/%E5%8A%A0%E9%94%81%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<p>MySQL新的版本可能会改变加锁策略，当前规则适用于5.x系列&lt;=5.7.24,8.0系列&lt;=8.0.13。  </p>
<p>执行update和delete的时候，要“先读后写”，这个读就开始加锁了。<br>insert的时候要有插入意向锁(跟gap lock冲突)。<br><strong>查询过程中，在 InnoDB 要去找“第一个值”的时候，是按照等值去找的，用的是等值判断的规则；找到第一个值以后，要在索引内找“下一个值”，对应于规则中说的范围查找。</strong>  </p>
<h3 id="加锁规则"><a href="#加锁规则" class="headerlink" title="加锁规则"></a>加锁规则</h3><p>包含两个“原则”、两个“优化”和一个“bug”：  </p>
<ol>
<li>原则1：加锁的基本单位是next-key lock(前开后闭区间)。  </li>
<li>原则2：查找过程中访问到的对象才会加锁(查询过程中访问到的行和间隙，不是查询结果)。  </li>
<li>优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁(若存在等于该值的行则退化为行锁，若不存在则不退化，参考优化2形成间隙锁)。  </li>
<li>优化2：索引上的等值查询，(无论是唯一索引还是不唯一的普通索引)向右遍历到最后一个不满足等值条件的值，next-key lock退化为间隙锁。  </li>
<li>一个bug：唯一索引上的范围查询也会访问到不满足条件的第一个值为止。  </li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`d`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`c`</span> (<span class="string">`c`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),</span><br><span class="line">(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure>

<h3 id="1-唯一索引等值查询"><a href="#1-唯一索引等值查询" class="headerlink" title="1. 唯一索引等值查询"></a>1. 唯一索引等值查询</h3><p>等值条件操作间隙：  </p>
<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
<th>sessionC</th>
</tr>
</thead>
<tbody><tr>
<td>begin;</br>update t set d=d+1 where id=7;</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>insert into t values(8,8,8);</br>(block)</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>update t set d=d+1 where id=10;</br>(Query OK)</td>
</tr>
</tbody></table>
<p>表t中没有id=7的记录：  </p>
<ol>
<li>根据原则1，加锁单位是next-key lock，sessionA加锁范围是(5,10]；  </li>
<li>根据优化2，这是一个等值查询id=7，而id=10不满足查询条件，next-key lock退化成间隙锁，最终加锁范围是(5,10)。  </li>
</ol>
<p>sessionB往间隙中插入id=8的记录会被锁住，sessionC修改id=10这行可以。  </p>
<h3 id="2-非唯一索引等值查询"><a href="#2-非唯一索引等值查询" class="headerlink" title="2. 非唯一索引等值查询"></a>2. 非唯一索引等值查询</h3><p>覆盖索引上的锁：  </p>
<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
<th>sessionC</th>
</tr>
</thead>
<tbody><tr>
<td>begin;</br>select id from t where c=5 lock in share mode;</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>update t set d=d+1 where id=5;</br>(Query OK)</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>insert into t values(7,7,7);</br>(blocked)</td>
</tr>
</tbody></table>
<p>sessionA给非唯一索引c上c=5的这一行加上读锁：  </p>
<ol>
<li>根据原则1，加锁单位是next-key lock，会给(0,5]加上next-key lock。  </li>
<li>c是普通索引，仅访问c=5这一条记录不能马上停下来，需要向右遍历，查到c=10才放弃。根据原则2，访问到的都要加锁，要给(5,10]加next-key lock。  </li>
<li>根据优化2，等值判断，向右遍历，最后一个值不满足c=5这个等值条件，退化成间隙锁(5,10)。  </li>
<li>根据原则2，只有访问到的对象才会加锁，这个查询使用覆盖索引，并不需要访问主键索引，所以主键索引上没有加任何锁，sessionB的update语句可以执行。  </li>
</ol>
<p>sessionC插入c=7的记录，会被sessionA的间隙锁(5,10)锁住。  </p>
<p><strong>锁是加在索引上的</strong>。由于覆盖索引的优化，本例中lock in share mode只锁了覆盖索引。若为了加读锁避免数据被更新，需要再查询字段中加入索引中不存在的字段，绕过覆盖索引优化；或者使用for update，系统认为接下来要更新数据，会顺便给主键索引上满足条件的行加上行锁。  </p>
<h3 id="3-唯一索引范围锁"><a href="#3-唯一索引范围锁" class="headerlink" title="3.唯一索引范围锁"></a>3.唯一索引范围锁</h3><p>范围查询：  </p>
<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
<th>sessionC</th>
</tr>
</thead>
<tbody><tr>
<td>begin;</br>select * from t where id&gt;=10 and id&lt;11 for update;</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>insert into t values(8,8,8);</br>(QueryOK)</br>insert into t values(13,13,13);</br>(blocked)</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>update t set d=d+1 where id=15;</br>(blocked)</td>
</tr>
</tbody></table>
<ol>
<li>开始执行时，要找到第一个id=10的行(等值查询)，加上next-key lock(5,10]。根据优化1，主键id上的等值条件，退化成行锁，只加了id=10这一行的行锁。  </li>
<li>范围查找往后继续找(范围查询)，找到id=15这一行停下来，需要加next-key lock(10,15]。  </li>
</ol>
<p>sessionA锁的范围就是主键索引上，行锁id=10和next-key lock(10,15]，综合为[10,15]。sessionB后半部和sessionC被锁住。  </p>
<h3 id="4-非唯一索引范围锁"><a href="#4-非唯一索引范围锁" class="headerlink" title="4.非唯一索引范围锁"></a>4.非唯一索引范围锁</h3><p>对照案例三：  </p>
<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
<th>sessionC</th>
</tr>
</thead>
<tbody><tr>
<td>begin;</br>select * from t where c&gt;=10 and c&lt;11 for update;</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>insert into t values(8,8,8);</br>(blocked)</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>update t set d=d+1 where c=15;</br>(blocked)</td>
</tr>
</tbody></table>
<p>sessionA用字段c来判断，加锁规则跟案例三不同处：在第一次用c=10定位记录的时候，索引c加上了(5,10]这个next-key lock后，由于索引c是非唯一索引，没有优化规则，不会蜕变为行锁。之后范围查询，扫描到c=15才知道不需要继续往后找了，才停止扫描。  </p>
<p>sessionA加的锁是索引c上的(5,10]和(10,15]这两个next-key lock，综合为(5,15]。sessionB被(5,10]堵住，sessionC被(10,15]堵住。  </p>
<blockquote>
<p>如果sessionA中语句为select * from t where c&gt;=10 and c&lt;=15 for update;加锁范围为(5,20]。  </p>
</blockquote>
<h3 id="5-唯一索引范围锁bug"><a href="#5-唯一索引范围锁bug" class="headerlink" title="5.唯一索引范围锁bug"></a>5.唯一索引范围锁bug</h3><table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
<th>sessionC</th>
</tr>
</thead>
<tbody><tr>
<td>begin;</br>select * from t where id&gt;10 and id&lt;=15 for update;</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>update t set d=d+1 where id=20;</br>(blocked)</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>insert into t values(16,16,16);</br>(blocked)</td>
</tr>
</tbody></table>
<p>sessionA是一个范围查询，按照原则1，索引id上加(10,15]这个next-key lock，(因为id是唯一键，循环判断到id=15这一行就可以停止了)，而InnoDB会继续往前扫描到第一个不满足条件的行id=20为止。由于是范围扫描，索引id上的(15,20]这个next-key lock会被锁上且没有优化。  </p>
<p>sessionB和sessionC被(15,20]锁住。</p>
<hr>
<h3 id="6-非唯一索引上存在“等值”的例子"><a href="#6-非唯一索引上存在“等值”的例子" class="headerlink" title="6.非唯一索引上存在“等值”的例子"></a>6.非唯一索引上存在“等值”的例子</h3><p>insert into t(id,c,d) values(30,10,30);  </p>
<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
<th>sessionC</th>
</tr>
</thead>
<tbody><tr>
<td>begin;</br>delete from t where c=10;</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>insert into t values(12,12,12);</br>(blocked)</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>update t set d=d+1 where c=15;</br>(Query OK)</td>
</tr>
</tbody></table>
<p>sessionA在遍历的时候，先访问第一个c=10的记录，根据原则1，加的是(c=5,id=5)-(c=10,id=10)这个前开后闭的next-key lock。<br>sessionA继续向右查找，直到碰到(c=15,id=15)这一行循环才结束。根据优化2，这是一个等值查询，向右查询到了不满足条件的行，(c=10,id=10)-(c=15,id=15)这个前开后闭的next-key lock会退化成(c=5,id=5)-(c=15,id=15)前后都开的间隙锁。总体索引c上的锁范围是(c=5,id=5)-(c=15,id=15)前后都开的区间。  </p>
<p>所以sessionB会被堵住，sessionC正常更新。  </p>
<h3 id="7-limit语句加锁"><a href="#7-limit语句加锁" class="headerlink" title="7.limit语句加锁"></a>7.limit语句加锁</h3><p>对照案例6：  </p>
<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
</tr>
</thead>
<tbody><tr>
<td>begin;</br>delete from t where c=10 limit 2;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>insert into t values(12,12,12);</br>(Query OK)</td>
</tr>
</tbody></table>
<p>sessionA的delete语句加了limit2，表t中c=10的记录只有两条，加不加limit2，删除效果相同，但加锁效果不同。  </p>
<p>delete语句明确加了limit2的限制，在遍历到(c=10,id=30)这一行之后，满足条件的语句已经有两条了，循环就结束了。索引c上的加锁范围变成了从(c=5,id=5)-(c=10,id=30)这个前开后闭的区间。  </p>
<p>(c=10,id=30)-(c=15,id=15)之间是没有锁的。sessionB没有被堵住。<strong>在删除数据的时候尽量加limit。不仅可以控制删除数据的条数，让操作更安全，还可以减少加锁的范围。</strong>  </p>
<h3 id="8-一个死锁的例子"><a href="#8-一个死锁的例子" class="headerlink" title="8.一个死锁的例子"></a>8.一个死锁的例子</h3><p>next-key lock实际上是间隙锁和行锁加起来的结果：  </p>
<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
</tr>
</thead>
<tbody><tr>
<td>begin;</br>select id from t where c=10 lock in share mode;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>update t set d=d+1 where c=10;</br>(blocked)</td>
</tr>
<tr>
<td>insert into t values(8,8,8);</td>
<td></td>
</tr>
<tr>
<td></td>
<td>ERROR 1213(40001): Deadlock found when trying to get lock;try restarting transaction;</td>
</tr>
</tbody></table>
<ol>
<li>sessionA启动事务后执行查询语句加lock in share mode，在索引c上加了next-key lock(5,10]（非唯一索引不会退化成行锁）和间隙锁(10,15)（优化2，等值查询优化后成为间隙锁）。  </li>
<li>sessionB的update语句先要在索引c上加next-key lock(5,10]，进入锁等待。  </li>
<li>sessionA要在插入(8,8,8)这一行，被sessionB的间隙锁锁住。出现了死锁，InnoDB让sessionB回滚。  </li>
</ol>
<p>sessionB的next-key lock(5,10]操作，实际上分成了两步：先是加(5,10)的间隙锁，加锁成功(间隙锁之间不互斥，只保护间隙，不让insert)；然后加c=10的行锁，加锁失败(行锁之间互斥)等待。若成功后面还要依次加(10,15]的锁。  </p>
<h3 id="9-倒序"><a href="#9-倒序" class="headerlink" title="9.倒序"></a>9.倒序</h3><table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
</tr>
</thead>
<tbody><tr>
<td>begin;</br>select * from t where c&gt;=15 and c&lt;=20 order by c desc lock in share mode;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>insert into t values(6,6,6);</br>(blocked)</td>
</tr>
</tbody></table>
<ol>
<li>由于是order by desc，第一个要定位的是索引c上“最右边的”c=20的行，所以会加上间隙锁(20,25)和next-key lock(15,20]。  </li>
<li>在索引c上向左遍历，要扫描到c=10才停下来(扫描到10，才知道已经不等于15了，找到第一个不等于15的值)，所以next-key lock会加到(5,10]，这是阻塞sessionB的insert语句的原因。  </li>
<li>在扫描过程中，c=20,c=15,c=10这三行都存在值，由于是select *，所以会在主键id上加三个行锁。  </li>
</ol>
<p>sessionA的select语句锁的范围是：  </p>
<ol>
<li>索引c上(5,25)；  </li>
<li>主键索引上id=15、20两个行锁。  </li>
</ol>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>可重复读隔离级别。遵守两阶段锁协议，所有加锁的资源，都是在事务提交或者回滚的时候才释放。next-key lock实际上是由间隙锁加行锁实现的。如果切换到读提交隔离级别，相当于去掉间隙锁的部分，只保留行锁部分。  </p>
<hr>
<p>读提交隔离级别下的优化：语句执行过程中加上的行锁，在语句执行完成后，就把“不满足条件的行”上的行锁直接释放了，不需要等到事务提交。读提交隔离级别下，锁的范围更小，锁的时间更短。  </p>
<p>读提交隔离级别下，update语句有一个“semi-consistent” read优化(delete语句无效)：如果update语句碰到一个已经被锁了的行，会读入最新的版本，然后判断一下是不是满足查询条件：</p>
<ul>
<li>不满足，直接跳过；  </li>
<li>满足，进入锁等待。  </li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>binlog保证主备一致</title>
    <url>/MySQL/binlog%E4%BF%9D%E8%AF%81%E4%B8%BB%E5%A4%87%E4%B8%80%E8%87%B4/</url>
    <content><![CDATA[<p>binlog可以用来归档，也可以用来做主备同步。  </p>
<h3 id="MySQL主备的基本原理"><a href="#MySQL主备的基本原理" class="headerlink" title="MySQL主备的基本原理"></a>MySQL主备的基本原理</h3><p>客户端的读写直接访问的节点为主库，另一个节点是备库，只是将主库的更新都同步过来，到本地执行。保持主库和备库的数据都是相同的。  </p>
<p>备库没有被直接访问，设置成只读(readonly)模式：  </p>
<ol>
<li>有时候一些运营类的查询语句会被放到备库上去查，设置为只读可以防止误操作；  </li>
<li>防止切换逻辑有bug，比如切换过程中出现双写，造成主备不一致；  </li>
<li>可以用readonly状态，来判断节点的角色。  </li>
</ol>
<p>备库设置成只读，依然能跟主库保持同步更新。readonly设置对超级(super)权限用户是无效的，用于同步更新的线程，拥有超级权限。  </p>
<hr>
<h4 id="主备同步流程"><a href="#主备同步流程" class="headerlink" title="主备同步流程"></a>主备同步流程</h4><img src="/img/MySQL主备流程图.png" width="333" height="333" >

<p>主库接收到客户端的更新请求后，执行内部事务的更新逻辑，同时写binlog。  </p>
<p>备库跟主库之间维持了一个长连接，主库A内部有一个线程，专门服务备库的长连接。</p>
<p>一个事务日志同步的完整过程：  </p>
<ol>
<li>在备库B上通过change master命令，设置主库A的IP、端口、用户名、密码，以及要从哪个位置开始请求binlog，这个位置包含文件名和日志偏移量。  </li>
<li>在备库B上执行start slave命令，这时备库会启动两个线程：io_thread和sql_thread。其中io_thread负责与主库建立连接。  </li>
<li>主库A校验完用户名、密码后，开始按照备库B传过来的位置，从本地读取binlog，发给B。(如果这个文件现在还在page cache中，直接读；如果不在page cache里，就去磁盘读)。(binlog write阶段就发起主从同步日志)  </li>
<li>备库B拿到binlog后，写到本地文件，称为中转日志relay log。  </li>
<li>sql_thread读取中转日志，解析出日志里的命令，并执行(relay log应用后就丢弃了)。(多线程复制方案引入，sql_thread演化成为了多个线程。)  </li>
</ol>
<h3 id="binlog的三种格式对比"><a href="#binlog的三种格式对比" class="headerlink" title="binlog的三种格式对比"></a>binlog的三种格式对比</h3><p>binlog有三种格式：statement、row、mixed。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        binlog示例代码
    </div>
    <div class='spoiler-content'>
        <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`t_modified`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`a`</span> (<span class="string">`a`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`t_modified`</span>(<span class="string">`t_modified`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="string">'2018-11-13'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">2</span>,<span class="number">2</span>,<span class="string">'2018-11-12'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">3</span>,<span class="number">3</span>,<span class="string">'2018-11-11'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">4</span>,<span class="number">4</span>,<span class="string">'2018-11-10'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">5</span>,<span class="number">5</span>,<span class="string">'2018-11-09'</span>);</span><br></pre></td></tr></table></figure>

    </div>
</div>  

<blockquote>
<p>delete from t where a&gt;=4 and t_modified&lt;=’2018-11-10’ limit 1;<br>show binlog events in ‘master.000001’;– 查看binlog中的内容。  </p>
</blockquote>
<h4 id="statement"><a href="#statement" class="headerlink" title="statement"></a>statement</h4><p>binlog记录的是SQL语句的原文。  </p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>mater.000001</td>
<td>5889</td>
<td>Anonymous_Gtid</td>
<td>1</td>
<td>5954</td>
<td>SET @@SESSION.GTID_NEXT=’ANONYMOUS’</td>
</tr>
<tr>
<td>mater.000001</td>
<td>5954</td>
<td>Query</td>
<td>1</td>
<td>6041</td>
<td>BEGIN</td>
</tr>
<tr>
<td>mater.000001</td>
<td>6041</td>
<td>Query</td>
<td>1</td>
<td>6197</td>
<td>use ‘test’;delete from t where a&gt;=4 and t_modified&lt;=’2018-11-10’ limit 1</td>
</tr>
<tr>
<td>mater.000001</td>
<td>6197</td>
<td>Xid</td>
<td>1</td>
<td>6228</td>
<td>COMMIT /*xid=61*/</td>
</tr>
</tbody></table>
<ul>
<li>第一行SET@@SESSION.GTID_NEXT=’ANONYMOUS’；  </li>
<li>第二行begin，跟第四行的commit对应，表示中间是一个事务；  </li>
<li>第三行是真实执行的语句。use ‘test’命令是MySQL根据当前要操作做的表所在的数据库，自行添加的。这样可以保证日志传到备库去执行的时候，不论当前的工作线程在哪个库里，都能够正确的更新到test库的表t。  </li>
<li>第四行commit。xid=61可以查找到redo log与binlog对应的事务。  </li>
</ul>
<p>statement存在的问题：<br>当binlog设置的是statement格式，并且语句中有limit，这个命令可能是unsafe的。可能会出现主备数据不一致的情况：  </p>
<ol>
<li>如果delete语句使用的是索引a，那么会根据索引a找到第一个满足条件的行，也就是说删除的是a=4这一行。  </li>
<li>但如果使用的是索引t_moditied，那么删除的就是t_modified=’2018-11-09’也就是a=5这一行。  </li>
</ol>
<h4 id="row"><a href="#row" class="headerlink" title="row"></a>row</h4><p>binlog中么有SQL语句的原文，替换成了两个event:Table_map和Delete_rows。  </p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>mater.000001</td>
<td>8900</td>
<td>Anonymous_Gtid</td>
<td>1</td>
<td>8965</td>
<td>SET @@SESSION.GTID_NEXT=’ANONYMOUS’</td>
</tr>
<tr>
<td>mater.000001</td>
<td>8965</td>
<td>Query</td>
<td>1</td>
<td>9045</td>
<td>BEGIN</td>
</tr>
<tr>
<td>mater.000001</td>
<td>9045</td>
<td>Table_map</td>
<td>1</td>
<td>9092</td>
<td>table_id:226(test.t)</td>
</tr>
<tr>
<td>mater.000001</td>
<td>9092</td>
<td>Delete_rows</td>
<td>1</td>
<td>9140</td>
<td>table_id:226 flags:STMT_END_F</td>
</tr>
<tr>
<td>mater.000001</td>
<td>9140</td>
<td>Xid</td>
<td>1</td>
<td>9171</td>
<td>COMMIT /*xid=68*/</td>
</tr>
</tbody></table>
<ul>
<li>Table_map event，用于说明接下来要操作的表是test库的表t；  </li>
<li>Delete_rows event，用于定义删除的行为。  </li>
</ul>
<p>借助mysqlbinlog工具解析和查看binlog中的内容：  </p>
<blockquote>
<p>mysqlbinlog -vv data/master.000001 –start-position=8900;– start-position参数指定从8900这个位置的日志开始解析。  </p>
</blockquote>
<img src="/img/MySQL row格式binlog示例的详细信息.png">

<ul>
<li><strong>server id 1，表示这个事务是在server_id=1的这个库上执行的</strong>。(避免循环复制)  </li>
<li>每个event都有CRC32的值，参数binlog_checksum设置为CRC32。  </li>
<li>Table_map event显示了接下来要打开的表，map到数字226。当前SQL语句只操作了一张表，如果要操作多张表，每个表都有一个对应的Table_map event、都会map到一个单独的数字，用于区分对不同表的操作。  </li>
<li>mysqlbinlog命令使用-vv参数可以把内容都解析出来，从结果里可以看到各个字段的值。  </li>
<li>binlog_row_image的默认配置是FULL，Delete_event里面包含了删除的行的所有字段的值。如果把binlog_row_image设置为MINIMAL，则只会记录必要的信息。(如本例删除时只记录id=4)  </li>
<li>Xid event用于表示事物被正确的提交了。  </li>
</ul>
<p>binlog记录了真实删除行的主键id，binlog传到备库去的时候，就肯定会删除id=4的行，不会有主备删除不同行的问题。  </p>
<h4 id="mixed"><a href="#mixed" class="headerlink" title="mixed"></a>mixed</h4><ul>
<li>有些statement格式的binlog可能会导致主备不一致，所以要使用row格式。  </li>
<li>row格式的缺点是很占空间。(用一个delete语句删掉10万行数据，用statement就是一个SQL语句被记录到binlog中，占用几十个字节的空间。用row就要把这10万条记录都写到binlog中，不仅占用更大的空间，写binlog也要耗费更多IO资源，影响执行速度)。  </li>
<li>折中方案mixed。MySQL自己会判断这条SQL语句是否可能引起主备不一致，如果有可能，就用row格式，否则就用statement格式。  </li>
</ul>
<hr>
<blockquote>
<p>insert into t values(10,10,now());– binlog设置为mixed格式  </p>
</blockquote>
<img src="/img/MySQL mixed格式和now().png">
<img src="/img/MySQL timestamp命令.png">

<p>binlog选择了statement格式，在记录event的时候，多记了一条命令：SET TIMESTAMP=1546103491。它用set timestamp命令约定了接下来now()函数的返回时间。  </p>
<p>不论这个binlog是一分钟之后被备库执行，还是3天之后用来恢复这个库的备份，这个insert语句插入的行，值都是固定的。通过这条set timestamp命令，MySQL确保了主备数据的一致性。  </p>
<p><strong>有些语句的执行结果是依赖于上下文命令的，直接执行的结果可能是错误的。用binlog来恢复数据的标准做法是，用mysqlbinlog工具解析出来，然后把解析结果整个发给MySQL执行</strong>:  </p>
<blockquote>
<p>mysqlbinlog master.000001 –start-position=2738<br> –stop-position=2973 | mysql -h127.0.0.1 -P13000 -u$user -p@pwd;<br>将master.00001文件里面从第2738字节到第2938字节中间这段内容解析出来，放到MySQL去执行。  </p>
</blockquote>
<h4 id="数据恢复原理"><a href="#数据恢复原理" class="headerlink" title="数据恢复原理"></a>数据恢复原理</h4><p>binlog格式设置为row，便于数据恢复。  </p>
<ul>
<li>delete语句，row格式的binlog会把被删掉的行的整行信息保存起来。在执行完一条delete语句以后，发现删错数据了，可以直接把binlog中记录的delete语句转成insert，把被错删的数据插入回去就可以恢复了。  </li>
<li>insert语句，row格式下，insert语句的binlog里会记录所有的字段信息，这些信息可以用来精确定位刚刚被插入的那一行，直接把insert语句转成delete语句，删除掉这被误插入的一行数据就可以了。  </li>
<li>update语句，binlog会记录修改前整行的数据和修改后的整行数据。只需要被这个event前后两行信息对调一下，再去数据库里执行，就能恢复这个更新操作了。  </li>
</ul>
<p>MariaDB的Flashback工具回滚数据原理与此相同。  </p>
<h3 id="循环复制问题"><a href="#循环复制问题" class="headerlink" title="循环复制问题"></a>循环复制问题</h3><p>binlog的特性确保了再备库执行相同的binlog，可以得到与主库相同的状态。正常情况下主备的数据是一致的。(流式发送，一个事务提交就会发送)  </p>
<p>M-S结构：一主一备；<br>双M结构：互为主备，切换的时候不用修改主备关系。但任何时刻只有一个节点在接受更新。  </p>
<blockquote>
<p>一开始创建主备关系的时候，是由备库指定的。主备复制关系搭建完成以后，是主库来决定“要发数据给备库”的，主库有生成新的日志，就会发给备库。  </p>
</blockquote>
<p>问题:<br>业务逻辑在节点A上更新了一条语句，然后再把生成的binlog发给节点B，节点B执行完这条语句后也会生成binlog。(参数log_slave_updates设置为on，表示备库执行relay log后生成binlog)  </p>
<p>如果节点A同时是节点B的备库，相当于又把节点B新生成的binlog拿过来执行了一次，然后节点AB之间，会不断的循环执行这个更新语句，导致循环复制。  </p>
<p>MySQL在binlog中记录了这个命令第一次执行时所在实例的server id。来解决两个节点间循环复制的问题：  </p>
<ol>
<li>规定两个库的server id必须不同，如果相同，则它们之间不能设定为主备关系；  </li>
<li>一个备库接到binlog并在重放的过程中，生成与原binlog的server id相同的新的binlog；  </li>
<li>每个库在收到从自己的主库发过来的日志后，先判断server id，如果跟自己的相同，表示这个日志时自己生成的，就直接丢弃这个日志。  </li>
</ol>
<p>双M结构，日志的执行流程：  </p>
<ol>
<li>从节点A更新的事务，binlog里面记的都是A的server id；  </li>
<li>传到节点B执行一次以后，节点B生成的binlog的server id也是A的server id；  </li>
<li>再传回给节点A，A判断到这个server id与自己的相同，就不会再处理这个日志。死循环在这里断掉。  </li>
</ol>
<p>双M结构，出现循环复制情况：  </p>
<ol>
<li>在一个主库更新事务后，用命令set global server_id=x修改了server_id。等日志再传回来的时候，发现server_id跟自己的server_id不同，就只能执行了。  </li>
<li>有三个节点，trx在节点B执行，binlog上的server_id就是B，binlog传给节点A，然后A和A’搭建了双M结构，就会出现循环复制。  </li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 数据库迁移。循环复制解决</span></span><br><span class="line"><span class="keyword">stop</span> <span class="keyword">slave</span>;  </span><br><span class="line"><span class="keyword">change</span> <span class="keyword">master</span> <span class="keyword">to</span> ignore_server_ids=(server_id_of_B);  </span><br><span class="line"><span class="keyword">start</span> <span class="keyword">slave</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 迁移</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span> <span class="keyword">slave</span>;  </span><br><span class="line"><span class="keyword">change</span> <span class="keyword">master</span> <span class="keyword">to</span> ignore_server_ids=();  </span><br><span class="line"><span class="keyword">start</span> <span class="keyword">slave</span>;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>一主多从，主备切换逻辑</title>
    <url>/MySQL/%E4%B8%80%E4%B8%BB%E5%A4%9A%E4%BB%8E%EF%BC%8C%E4%B8%BB%E5%A4%87%E5%88%87%E6%8D%A2%E9%80%BB%E8%BE%91/</url>
    <content><![CDATA[<p>A和A’互为主备，从库B、C、D指向的是主库A。一主多从的设置，一般用于读写分离，主库负责所有的写入和一部分读，其他的读请求则由从库分担。相比于一主一备的切换流程，一主多从结构在切换完成后，A’会成为新的主库，从库B、C、D也要改接到A’。  </p>
<h3 id="基于位点的主备切换"><a href="#基于位点的主备切换" class="headerlink" title="基于位点的主备切换"></a>基于位点的主备切换</h3><p>把节点B设置成节点A’的从库的时候，需要执行一条change master命令：  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CHANGE</span> <span class="keyword">MASTER</span> <span class="keyword">TO</span> </span><br><span class="line">MASTER_HOST=$host_name </span><br><span class="line">MASTER_PORT=$port </span><br><span class="line">MASTER_USER=$user_name </span><br><span class="line">MASTER_PASSWORD=$<span class="keyword">password</span> </span><br><span class="line">MASTER_LOG_FILE=$master_log_name </span><br><span class="line">MASTER_LOG_POS=$master_log_pos</span><br></pre></td></tr></table></figure>

<ul>
<li>master_host、master_port、master_user、master_password四个参数，分别代表了主库A’的IP、端口、用户名、密码。  </li>
<li>master_log_file、master_log_pos参数，表示要从主库的master_log_name文件的master_log_pos这个位置的日志继续同步。这个位置就是同步位点，是主库对应的文件名和日志偏移量。  </li>
</ul>
<p>原来节点B是A的从库，本地记录的也是A的位点。但是相同的日志，A的位点和A’的位点是不同的，从库B切换的时候，需要先经过“找同步位点”逻辑。  </p>
<h4 id="同步位点设置"><a href="#同步位点设置" class="headerlink" title="同步位点设置"></a>同步位点设置</h4><p>切换过程中不能丢数据，找位点的时候，总是要找一个“稍微往前”的，然后再通过判断跳过那些在从库上已经执行过的事务：  </p>
<ol>
<li>等待新主库A’把中转日志relay log全部同步完成；  </li>
<li>在A’上执行show master status命令，得到当前A’上最新的File和Position；  </li>
<li>取援助库A故障的时刻T；  </li>
<li>用mysqlbinlog工具解析A’的File，等得到T时刻的位点。  <blockquote>
<p>mysqlbinlog File –stop-datetime=T –start-datetime=T;  </p>
</blockquote>
</li>
</ol>
<p>end_log_pos后面的值假设为’123’，表示的就是A’这个实例，在T时刻写入新的binlog的位置，把这个值123作为$master_log_pos，用在节点B的change master命令里。  </p>
<h4 id="同步位点不精确"><a href="#同步位点不精确" class="headerlink" title="同步位点不精确"></a>同步位点不精确</h4><p>在T时刻，主库A已经执行完成了一个insert语句插入了一行数据R，并且已经将binlog传给了A’和B，然后再传完的瞬间主库A的主机掉电了。  </p>
<ol>
<li>在从库B上，由于同步了binlog，R这一行已经存在；  </li>
<li>在新主库A’上，R这一行也已经存在，日志是写在A的end_log_pos值123对应的位置之后；  </li>
<li>在从库B上执行change master命令，指向A’的File文件的123位置，会把插入R这一行数据的binlog又同步到从库B去执行。  <blockquote>
<p>从库B的同步线程会报告Duplicate entry ‘id_of_R’ for key ‘PRIMARY’错误，提示出现了主键冲突，然后停止同步。  </p>
</blockquote>
</li>
</ol>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>切换任务的时候，主动跳过错误的两种方法：  </p>
<ul>
<li>主动跳过一个事务：  </li>
</ul>
<p><code>set global sql_slave_skip_counter=1;  
start slave;</code></p>
<p>sql_slave_skip_counter跳过的是一个event，但MySQL不能只执行一半的事务，跳过了一个event，就会跳到这个事务的末尾。  </p>
<p>切换过程中，可能会不止重复执行一个事务，需要在从库B刚开始接到新主库A’时，持续观察，每次碰到这些错误就停下来，执行一次跳过命令，直到不再出现停下来的情况，以此来跳过可能涉及的所有事务。  </p>
<ul>
<li>设置slave_skip_errors参数，直接跳过指定的错误：  </li>
</ul>
<p>在执行主备切换时，经常遇到的两类错误：1062错误是插入数据时唯一键冲突；1032错误是删除数据时找不到行。  </p>
<p>把slave_skip_errors设置为“1032,1062”，中间碰到这两个错误时直接跳过。<br>只有主备切换过程中，直接跳过1032和1062错误时无损的，等主备间的同步关系建立按成，并稳定执行一段时间之后，需要把这个参数设置为空，以免之后真的主从数据不一致被跳过。  </p>
<h3 id="GTID"><a href="#GTID" class="headerlink" title="GTID"></a>GTID</h3><p>MySQL5.6版本引入了GTID，解决主备切换复杂易错的问题。  </p>
<p>GTID全称是Global Transaction Identifier，全局事务ID，是一个<strong>事务在提交的时候生成</strong>的，是这个事务的唯一标识，由两部分组成，格式是：GTID=server_uuid:gno;  </p>
<ul>
<li>server_uuid是一个实例第一次启动时自动生成的，是一个全局唯一的值；  </li>
<li>gno是一个整数，初始值是1，每次提交事务的时候分配给这个事务，并加1。  </li>
</ul>
<p>官方文档定义格式：GTID=source_id:transaction_id;  </p>
<ul>
<li>source_id就是server_uuid；  </li>
<li>transaction_id容易造成误解，用gno代替。  <blockquote>
<p>MySQL中transaction_id是指事务id，事务id是在事务执行过程找那个分配的，即使这个事务回滚了，事务id也会递增，而gno是在事务提交的时候才会分配。<br>从效果上看GTID往往是连续的，用gno表示更容易理解。  </p>
</blockquote>
</li>
</ul>
<hr>
<p>启动一个MySQL实例的时候，加上参数gtid_mode=on和enforce_gtid_consistency=on；就可以启动GTID模式。  </p>
<p>在GTID模式下，每个事务都会跟一个GTID一一对应。有两种生成方式，使用哪种方式取决于session变量gtid_next的值:  </p>
<ol>
<li>如果gtid_next=automatic，代表使用默认值。MySQL会把server_uuid:gno分配给这个事务。<br> a. 记录binlog的时候，先记录一行set @@session.gtid_next=’server_uuid:gno’;<br> b. 把这个gtid加入本实例的gtid集合。  </li>
<li>如果gtid_next是一个指定的gtid值，如通过 set gtid_next=’current_gtid’指定为current_gtid，那么有两种可能：<br> a. 如果current_gtid已经存在于实例的gtid集合中，接下来执行的这个事务会直接被系统忽略；<br> b. 如果current_gtid没有存在于实例的gtid集合中，就将整个current_gtid分配给接下来要执行的事务，也就是说系统不需要给这个事务生成新的gtid，因此gno也不用加1。  </li>
</ol>
<p>一个current_gtid只能给一个事务使用。这个事务提交后，如果要执行下一个事务，就要执行set命令，把gtid_next设置成另外一个gtid或者automatic。  </p>
<blockquote>
<p>set gtid_next=’aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee:10’;<br>begin;<br>commit;<br>set gtid_next=automatic;<br>start slave;  </p>
</blockquote>
<p><strong>每个MySQL实例都维护了一个gtid集合，用来对应“这个实例执行过的所有事务”。</strong>通过show master status命令查看，对应的Executed_Gtid_set参数值。  </p>
<p>在binlog文件开头，有一个Previous_gtids，用于记录生成这个binlog的时候，实例的Executed_gtid_set。启动时只需要解析最后一个文件，就可以知道该实例所有的GTID集合，也可以快速的定位GTID在哪个文件。  </p>
<h3 id="基于GTID的主备切换"><a href="#基于GTID的主备切换" class="headerlink" title="基于GTID的主备切换"></a>基于GTID的主备切换</h3><p>在GTID模式下，备库B要设置为新主库A’的从库的语法：  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CHANGE</span> <span class="keyword">MASTER</span> <span class="keyword">TO</span> </span><br><span class="line">MASTER_HOST=$host_name </span><br><span class="line">MASTER_PORT=$port </span><br><span class="line">MASTER_USER=$user_name </span><br><span class="line">MASTER_PASSWORD=$<span class="keyword">password</span> </span><br><span class="line">master_auto_position=<span class="number">1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>master_auto_position=1表示这个准备关系使用的是GTID协议。  </li>
</ul>
<p>当前时刻，实例A’GTID集合记为set_a，实例B的GTID集合记为set_b。在实例B上执行start slave命令，取binlog的逻辑如下：  </p>
<ol>
<li>实例B指定主库A’，基于准备协议建立连接。  </li>
<li>实例B把set_b发给主库A’。  </li>
<li>实例A’算出set_a与set_b的差集，也就是所有存在于set_a，但是不存在于set_b的GTID的集合，判断A’本地是否包含了这个差集需要的所有binlog事务。<br> a. 如果不包含，表示A’已经把实例B需要的binlog给删掉的了，直接返回错误；<br> b. 如果确认全部包含，A’从自己的binlog文件里面，找出第一个不在set_b的事务，发给B；  </li>
<li>之后就从这个事务开始，往后读文件，按顺序取binlog发给B去执行。  </li>
</ol>
<p>设计思想之一：在基于GTID的主备关系里，系统认为只要建立了主备关系，就必须保证主库发给备库的日志是完成的。因此，如果实例B需要的日志已经不存在，A’就拒绝吧日志发给B。  </p>
<p>如果一个新的从库接上主库，但需要的binlog已经没了，解决方案：  </p>
<ol>
<li>如果业务允许主从不一致的情况，可以在主库上先执行show global variables like ‘gtid_purged’，得到主库已经删除的GTID集合，假设是gtid_purger1；然后先在从库上执行reset master，再执行set global gtid_purged=’gtid_purged1’；最后执行start slave，就会从主库现存的binlog开始同步。binlog缺失的那一部分，数据在从库上可能会有丢失，造成主从不一致。  </li>
<li>如果需要主从数据一致，通过重新搭建从库来做。  </li>
<li>如果有其他的从库保留有全量的binlog的话，可以把新的从库先接到这个保留了全量的binlog的从库，追上日志以后，如果有需要，再接回从库。  </li>
<li>如果binlog有备份的情况，可以先在从库上应用缺失的binlog，然后再执行start slave。  </li>
</ol>
<p>对比区别：基于位点的协议，是由备库决定的，备库指定哪个位点，主库就发哪个位点，不做日志的完整性判断。  </p>
<p>GTID同时解决了循环复制的问题。</p>
<hr>
<p>GTID模式下，一主多从主备切换，从库B、C、D只需要分别执行change master命令指向实例A’即可。找位点的工作在实例A’内部已经自动完成。对于HA系统的开发人员非常友好。  </p>
<p>之后整个系统就由新主库A’写入，主库A’的自己生成的binlog中的GTID集合格式是：server_uuid_of_A’:1-M。  </p>
<p>从库(包括备库)的GTID集合的整体格式为：server_uuid_of_A:1-N,server_uuid_of_A’:1-M。  </p>
<h3 id="GTID和在线DDL"><a href="#GTID和在线DDL" class="headerlink" title="GTID和在线DDL"></a>GTID和在线DDL</h3><p>索引缺失引起的性能问题，可以通过在线加索引来解决。考虑到要避免新增索引对主库性能造成影响，可以先在备库加索引，然后再切换。  </p>
<p>在双M结构下，备库执行的DDL语句也会传给主库，为了避免传回后对主库造成影响，要通过set sql_log_bin=off关掉binlog。binlog并没有记录下这一更新，导致数据和日志不一致。  </p>
<p>解决：假设互为主备关系的库是实例X和实例Y，当前主库是X，并且都打开了GTID模式，主备切换流程：  </p>
<ul>
<li><p>在实例X上执行 stop slave。  </p>
</li>
<li><p>在实例Y上执行DDL语句。这里不需要关闭binlog。  </p>
</li>
<li><p>执行完成后，查出这个DDL语句对应的GTID，并记为server_uuid_of_Y:gno。  </p>
</li>
<li><p>到实例X中执行以下语句序列：  </p>
<blockquote>
<p>set GTID_NEXT=”server_uuid_of_Y:gno”;<br>  begin;<br>  commit;<br>  set gtid_next=automatic;<br>  start slave;</p>
</blockquote>
<p>  这样模拟一个空事务既可以让实例Y的更新有binlog记录，同时也可以确保不会在实例X上执行这条更新。  </p>
</li>
<li><p>接下来，执行完主备切换，照着上述流程再执行一遍即可。  </p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>读写分离导致的过期读问题</title>
    <url>/MySQL/%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E5%AF%BC%E8%87%B4%E7%9A%84%E8%BF%87%E6%9C%9F%E8%AF%BB%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>读写分离的主要目标就是分摊主库的压力。两种架构：  </p>
<ul>
<li>客户端(client)主动做负载均衡，这种模式下一般会把数据库的连接信息放在客户端的连接层，由客户端来选择后端数据库进行查询。  </li>
<li>在MySQL和客户端之间有一个中间层proxy，客户端只连接proxy，由proxy根据请求类型和上下文决定请求的分发路由。  </li>
</ul>
<p>架构对比：  </p>
<ol>
<li>客户端直连方案，因为少了一层proxy转发，查询性能稍微好一点，并且整体架构简单，排查问题更方便。缺点由于要了解后端部署细节，在出现主备切换、库迁移等操作时，客户端都会感知到，并且需要调整数据库连接信息。一般采用这样的架构，一定会伴随一个管理后端的组件，比如Zookeeper，处理冗余的配置信息，尽量让业务端只专注于业务逻辑开发。  </li>
<li>带proxy的架构，对客户端比较友好。客户端不需要关注后端细节，连接维护、后端信息维护等工作，都是由proxy完成的。缺点对后端维护团队的要求会更高。而且proxy本身也需要有高可用架构，整体比较复杂。  </li>
</ol>
<hr>
<p>由于主从可能存在延迟，客户端执行完一个更新事务后马上发起查询，如果查询选择的是从库的话，就有可能读到刚刚的事务更新之前的状态。这种<strong>在从库上会读到系统的一个过期状态的现象，称为过期读。</strong>  </p>
<p>主从延迟是不能100%避免。但客户端希望查询从库的数据结果，跟查主库的数据结果时一样的。  </p>
<h3 id="强制走主库方案"><a href="#强制走主库方案" class="headerlink" title="强制走主库方案"></a>强制走主库方案</h3><p>强制走主库方案其实就是，将查询请求做分类：  </p>
<ol>
<li>对于必须要要拿到最新结果的请求，强制将其发到主库上。在一个交易平台上，卖家发布商品以后，马上要返回主页面，看商品是否发布成功。这个请求需要拿到最新的结果，就必须走主库。  </li>
<li>对于可以读到旧数据的请求，才将其发到从库上。在这个交易平台上，买家来逛商铺页面，就算晚几秒看到最新发布的商品，也是可以接受的。这类请求可以走从库。  </li>
</ol>
<p>问题：针对“所有查询都不能是过期读”的需求，金融类业务。需要放弃读写分离，放弃扩展性，所有读写压力都在主库。</p>
<h3 id="sleep方案"><a href="#sleep方案" class="headerlink" title="sleep方案"></a>sleep方案</h3><p>主库更新后，读从库之前先sleep一下，具体方案就是，类似于执行一条select sleep(1)命令。方案的前提是，大多数情况下主备延迟在1秒之内，做一个sleep可以有很大概率拿到最新的数据。  </p>
<p>卖家发布商品，商品发布后，用Ajax(Asynchronous JacaScript + XML,异步JavaScript和XML)直接把客户端输入的内容作为“新的商品”显示在页面上，而不是真正的去数据库做查询。卖家可以通过这个显示，来确认产品已经发布成功了，等卖家再刷新页面，去查看商品的时候，已经过了一段时间，达到了类似sleep的目的，解决了过期读的问题。  </p>
<p>问题：1.如果这个查询请求本来0.5秒就可以在从库上拿到正确结果，也会等1秒；2.如果延迟超过1秒，还是会出现过期读。  </p>
<h3 id="判断主备无延迟方案"><a href="#判断主备无延迟方案" class="headerlink" title="判断主备无延迟方案"></a>判断主备无延迟方案</h3><p>show slave status结果里的seconds_behind_master参数的值，可以用来衡量主备延迟时间的长短。  </p>
<h4 id="判断seconds-behind-master确保主备无延迟"><a href="#判断seconds-behind-master确保主备无延迟" class="headerlink" title="判断seconds_behind_master确保主备无延迟"></a>判断seconds_behind_master确保主备无延迟</h4><p>每次从库执行查询请求前，先判断seconds_behind_master是否已经对于0。如果还不等于0，就必须等到这个参数变为0才能执行查询请求。  </p>
<p>问题：SBM的单位是秒，精度不够。   </p>
<hr>
<img src="/img/MySQL show slave status结果.png" width="600" height="300" >

<h4 id="对比位点确保主备无延迟"><a href="#对比位点确保主备无延迟" class="headerlink" title="对比位点确保主备无延迟"></a>对比位点确保主备无延迟</h4><ul>
<li>Master_Log_File和Read_Master_Log_Pos，表示的是读到的主库的最新位点；  </li>
<li>Relay_Master_Log_File和Exec_Master_Log_Pos，表示的是备库执行的最新位点。  </li>
</ul>
<p>如果这两组值完全相同，就表示接收到的日志已经同步完成。  </p>
<h4 id="对比GTID集合确保主备无延迟"><a href="#对比GTID集合确保主备无延迟" class="headerlink" title="对比GTID集合确保主备无延迟"></a>对比GTID集合确保主备无延迟</h4><ul>
<li>Auto_Position=1，表示这对主备关系使用了GTID协议。  </li>
<li>Retrieved_Gtid_Set，是备库收到的所有日志的GTID集合。  </li>
<li>Executed_Gtid_set，是备库所有已经执行完成的GTID集合。  </li>
</ul>
<p>如果这两个集合相同，也表示备库接收到的日志都已经同步完成。  </p>
<hr>
<p>在执行查询请求前，先判断从库是否同步完成的方法，相比于sleep方案，准确度有提升，但达不到“精确”的程度。  </p>
<p>一个事务的binlog在主备之间的状态：  </p>
<ol>
<li>主库执行完成，写入binlog，并反馈给客户端；  </li>
<li>binlog被从主库发送给备库，备库收到；  </li>
<li>在备库执行binlog完成。  </li>
</ol>
<p>本方案中判断主备无延迟的逻辑，是备库收到的日志都执行完成了。但是还有一部分日志，处于客户端已经收到提交确认，而备库还没收到日志的状态。但从库认为已经没有同步延迟，客户端在从库上执行查询请求却查不到数据。  </p>
<h3 id="配合semi-sync方案"><a href="#配合semi-sync方案" class="headerlink" title="配合semi-sync方案"></a>配合semi-sync方案</h3><p>半同步复制：semi-sync replication。</p>
<ol>
<li>事务提交的时候，主库把binlog发给从库；  </li>
<li>从库收到binlog以后，发回给主库一个ack，表示收到了；  </li>
<li>主库收到这个ack以后，才能给客户端返回“事务完成”的确认。  </li>
</ol>
<p>如果启用了semi-sync，就表示所有给客户端发送过确认的事务，都确保了备库已经收到了这个日志。<br>半同步复制也解决了普通模式下主库掉电，来不及发送给从库的binlog导致系统数据丢失的问题。  </p>
<p>semi-sync配合关于位点(或者GTID)的判断，就能够确定在从库上执行的查询请求，可以避免过期读。  </p>
<p>问题1：半同步复制+位点判断的方案，只对一主一备的场景是成立的。在一主多从场景中，主库只要等到一个从库的ack，就开始给客户端返回确认。此时，在从库上执行查询请求有两种情况：  </p>
<ol>
<li>如果查询是落在这个响应了ack的从库上，是能够确保读到最新数据；  </li>
<li>但如果是查询落到其他从库上，它们可能还没有收到最新的日志，就会产生过期读的问题。  </li>
</ol>
<p>问题2：在业务更新的高峰期，主库的位点或者GTID集合更新很快，那么上面的两个位点等值判断就会一直不成立，很可能出现从库上迟迟无法响应查询请求，而过度等待的情况。  </p>
<h3 id="等主库位点方案"><a href="#等主库位点方案" class="headerlink" title="等主库位点方案"></a>等主库位点方案</h3><p>select master_pos_wait(file, pos[, timeout]);  </p>
<ol>
<li>它是在从库执行的；  </li>
<li>参数file和pos指的是主库上的文件名和位置；  </li>
<li>timeout可选，设置为正整数N，表示这个函数最多等待N秒。  </li>
</ol>
<p>这个命令正常返回的结果是一个正整数M，表示从命令开始执行，到应用完file和pos表示的binlog位置，执行了多少事务。其他异常返回：  </p>
<ol>
<li>如果执行期间，备库同步线程发生异常，则返回NULL；  </li>
<li>如果等待超过N秒，就返回-1；(从库的延迟时间不可控，不能无限等待，等待超时，就应该放弃，然后到主库上去查)  </li>
<li>如果刚开始执行的时候，就发现已经执行过这个位置了，则返回0。  </li>
</ol>
<p>示例：<br>先执行trx1，再执行一个查询请求的逻辑，要保证能够查到正确的数据：  </p>
<ol>
<li>trx1事务更新完成后，马上执行show master status得到当前主库执行到的File和Position；  </li>
<li>选定一个从库执行查询语句；  </li>
<li>在从库上执行select master_pos_wait(File, Position, 1)；(最多等待一秒)  </li>
<li>如果返回值是&gt;=0的正整数，则在这个从库上执行查询语句；  </li>
<li>否则，到主库上执行查询语句。  </li>
</ol>
<p>问题：如果所有的从库都延迟超过了1秒，查询压力都跑到主库上了。否则就超时放弃。  </p>
<h3 id="等GTID方案"><a href="#等GTID方案" class="headerlink" title="等GTID方案"></a>等GTID方案</h3><p>数据库开启了GTID模式，对应等主库位点的等GTID方案。  </p>
<p>select wait_for_executed_gtid_set(gtid_set, 1);  </p>
<ol>
<li>等待，知道这个库执行的事务中包含传入的gtid_set，返回0；  </li>
<li>超时返回1。  </li>
</ol>
<p>对比等主库位点，执行完事务后，还要主动去主库自行show master status。从MySQL5.7.6版本开始，允许在执行完更新类事务后，把这个事务的GTID返回给客户端，这样等GTID的方案可以减少一次查询。  </p>
<p>示例：  </p>
<ol>
<li>trx1事务更新完成后，从返回包直接获取这个事务的GTID，记为gtid1；(将参数session_track_gtids设置为OWN_GTID，然后通过API接口mysql_session_track_get_first从返回包解析出GTID的值)  </li>
<li>选定一个从库执行查询语句；  </li>
<li>在从库上执行select wait_for_executed_gtid_set(gtid1, 1)；  </li>
<li>如果返回值是0，则在这个从库执行查询语句；  </li>
<li>否则，到主库执行查询语句。  </li>
</ol>
<p>问题：与等主库位点一样。超时放弃或者直接到主库查询。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>主备延迟解决方案</title>
    <url>/MySQL/%E4%B8%BB%E5%A4%87%E5%BB%B6%E8%BF%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>对于一个压力持续比较高的主库来说，备库执行日志的速度持续低于主库生成日志的速度，备库可能永远都追不上主库的节奏。  </p>
<p>在主库上，影响并发度的原因是各种锁。InnoDB引擎支持行锁，除了所有并发事务都在更新同一行这种极端场景外，它对业务并发度的支持很友好。  </p>
<p>日志在备库上的执行，sql_thread执行中转日志relay log更新数据的逻辑，如果是用单线程的话，就会导致备库应用日志不够快，造成主备延迟。  </p>
<p>多线程复制机制，把只有一个线程的sql_thread，拆成多个线程。coordinator代替原来的sql_thread，但不再直接更新数据，只负责读取中转日志和分发事务。真正更新日志的，变成worker线程。work线程的个数由参数slave_parallel_workers决定。1/4-1/2的CPU核数最佳，其他的供查询的使用。  </p>
<hr>
<p>事务不能按照轮询的方式分发给各个worker。事务分发给worker以后，不同的worker独立执行，但是CPU的调度策略无法保证更新同一行的两个事务按照主库传过来的顺序执行。  </p>
<p>同一个事务的多个更新语句，不能分给不同的worker执行。一个事务更新了表t1和t2中各一行，如果两条更新语句被分到不同的worker，最终的结果是主备一致的，但是表t1执行完成的瞬间，备库上有一个查询，会看到这个事务更新了一半的结果，破坏了事务逻辑的隔离性。  </p>
<p>coordinator分发要求：  </p>
<ol>
<li>不能造成更新覆盖。要求更新同一行的两个事务，必须被分到同一个worker中。  </li>
<li>同一个事务不能被拆开，必须放到同一个worker中。  </li>
</ol>
<h3 id="MySQL5-5版本并行复制策略"><a href="#MySQL5-5版本并行复制策略" class="headerlink" title="MySQL5.5版本并行复制策略"></a>MySQL5.5版本并行复制策略</h3><p>官方MySQL5.5版本不支持并行复制。  </p>
<h4 id="按表分发策略"><a href="#按表分发策略" class="headerlink" title="按表分发策略"></a>按表分发策略</h4><p>如果两个事务更新不同的表，它们就可以并行。数据是存储在表里的，按表分发可以保证两个worker不会更新同一行。如果有跨表的事务，要把两张表放在一起考虑。  </p>
<p>每个worker线程对应一个hash表，用于保存当前正在这个worker的“执行队列”里的事务所涉及的表。hash表的key是”库名.表名”，value是一个数字，表示队列中有多少个事务修改这个表。  </p>
<p>有事务分配给worker时，事务里面涉及的表会被加到对应的hash表中。worker执行完成后，这个表会被从hash表中去掉。  </p>
<p>每个事务在分发的时候，跟<strong>所有worker中的待执行事务队列</strong>(一个worker可能分配了多个事务，每个事务可能对应多张表，分配前挨个判断)的冲突关系包括三种情况：  </p>
<ol>
<li>如果跟所有worker都不冲突，coordinator线程就会把这个事务分配给最空闲的worker;  </li>
<li>如果跟多于一个worker冲突，coordinator线程就进入等待状态，直到和这个事务存在冲突关系的worker只剩下1个；  </li>
<li>如果只跟一个worker冲突，coordinator线程就会把这个事务分配给这个存在冲突关系的worker。  </li>
</ol>
<p>按表分发的方案，在多个表负载均匀的场景里应用效果很好，但是，碰到热点表，所有事务都会被分配到同一个worker中，变成单线程复制。  </p>
<h4 id="按行分发策略"><a href="#按行分发策略" class="headerlink" title="按行分发策略"></a>按行分发策略</h4><p>如果两个事务没有更新相同的行，它们在备库上可以并行执行。该模式要求binlog格式必须是row。  </p>
<p>为每个worker分配一个hash表。key必须是”库名+表名+唯一键的值”。  </p>
<p>“唯一键”除了主键还有唯一索引列，避免两个事务要更新的行的主键值不同，但被分到不同的worker后，唯一索引列的值后先更新导致唯一键冲突。一条语句可能对应多个hash表项，key=hash_func(db+t+唯一索引+唯一索引值)，value=n。  </p>
<blockquote>
<p>在表 t1 上执行 update t1 set a=1 where id=2 语句，在 binlog 里面记录了整行的数据修改前各个字段的值，和修改后各个字段的值。<br>coordinator 在解析这个语句的 binlog 的时候，这个事务的 hash 表就有三个项(primary主键唯一索引，a普通唯一索引):  </p>
<ol>
<li>key=hash_func(db1+t1+“PRIMARY”+2), value=2; 这里 value=2 是因为修改前后的行 id 值不变，出现了两次。  </li>
<li>key=hash_func(db1+t1+“a”+2), value=1，表示会影响到这个表 a=2 的行。  </li>
<li>key=hash_func(db1+t1+“a”+1), value=1，表示会影响到这个表 a=1 的行。</li>
</ol>
</blockquote>
<hr>
<p>相比于按表并行分发策略，按行并行策略在决定线程分发的时候，需要消耗更多的计算资源：  </p>
<ol>
<li>要能够从binlog里面解析出表名、主键值、唯一索引的值。主库binlog格式必须是row。  </li>
<li>表必须有主键。  </li>
<li>不能有外键。表上如果有外键，级联更新的行不会记录在binlog中，这样冲突检测就不准确。  </li>
</ol>
<p>按行分发问题：  </p>
<ol>
<li>耗费内存。一个语句要删除100万行数据，hash表就要记录100万个项。  </li>
<li>耗费CPU。解析binlog，然后计算hash值，对于大事务，成本很高。  </li>
</ol>
<p>单个事务如果超过行数阈值，就暂时退化为单线程模式：  </p>
<ol>
<li>coordinator暂时先hold住这个事务；  </li>
<li>等待所有worker都执行完成，变成空队列；  </li>
<li>coordinator直接执行这个事务；  </li>
<li>恢复并行模式。  </li>
</ol>
<h3 id="MySQL5-6版本并行复制策略"><a href="#MySQL5-6版本并行复制策略" class="headerlink" title="MySQL5.6版本并行复制策略"></a>MySQL5.6版本并行复制策略</h3><p>官方MySQL5.6版本，支持并行复制。</p>
<h4 id="按库分发策略"><a href="#按库分发策略" class="headerlink" title="按库分发策略"></a>按库分发策略</h4><p>key是数据库名。适用主库上有多个DB，并且各个DB的压力均衡。  </p>
<p>优点：  </p>
<ol>
<li>构造hash值的时候很快，只需要库名；一个实例上DB数也不会很多，不会出现需要构造100W个项的情况。  </li>
<li>不要求binlog的格式。statement格式的binlog可以很容易拿到库名。  </li>
</ol>
<p>问题：  </p>
<ol>
<li>主库上的表都放在同一个DB里，按库并行策略没有效果；  </li>
<li>不同DB的热点不同，如业务逻辑库+系统配置库，没有并行效果。  </li>
</ol>
<p>解决：<br>创建不同的DB，把相同热度的表均匀分到不同的DB中，强行使用该策略。  </p>
<h3 id="MariaDB并行复制策略"><a href="#MariaDB并行复制策略" class="headerlink" title="MariaDB并行复制策略"></a>MariaDB并行复制策略</h3><p>redo log组提交(group commit)优化特性：  </p>
<ol>
<li>能够在同一组里提交的事务，一定不会修改同一行；  </li>
<li>主库上可以并行执行的事务，备库上也一定是可以并行执行的。  </li>
</ol>
<p>MariaDB原理：  </p>
<ol>
<li>在一组里一起提交的事务，有一个相同的commit_id，下一组就是commit_id+1;  </li>
<li>commit_id直接写到binlog里；  </li>
<li>传到备库应用的时候，相同commit_id的事务分发到多个worker中执行；  </li>
<li>这一组全部执行完成后，coordinator再去取下一批。  </li>
</ol>
<p>问题：<br>主库上，一组事务在commit的时候，下一组事务是同时处于“执行中”状态的。<br>在备库上执行的时候，要等第一组事务完全执行完成后，第二组事务才能开始执行，系统的吞吐量不够。<br>容易被大事务拖后腿，同一组的多个事务(多个worker)要等最大的事务完成(只剩一个worker在工作)，下一组才能开始执行。  </p>
<h3 id="MySQL5-7版本并行复制策略"><a href="#MySQL5-7版本并行复制策略" class="headerlink" title="MySQL5.7版本并行复制策略"></a>MySQL5.7版本并行复制策略</h3><p>由参数slave-parallel-type控制并行复制策略：  </p>
<ol>
<li>配置为DATABASE，表示使用MySQL5.6版本的按库并行策略；  </li>
<li>配置为LOGICAL——CLOCK，表示使用类似MariaDB的策略。针对并行度做了优化。  </li>
</ol>
<p>原理：  </p>
<ol>
<li>同时处于“执行状态”的所有事务，可能有由于锁冲突而处于锁等待状态的事务，而并不能并行。这些事务在备库上被分配到不同的worker，会出现备库跟主库不一致的情况。  </li>
<li>MariaDB核心：所有处于commit状态的事务可以并行。事务处于commit转态，表示已经通过了锁冲突的检验。  </li>
<li>根据两阶段提交细化过程，只要能够到达redo log prepare阶段(事务处于开始“提交状态”)，就表示事务已经通过锁冲突的检验。  <ol>
<li>同时处于redo log prepare状态的事务，在备库执行时时可以并行的；  </li>
<li>处于redo log prepare状态的事务，与处于redo log commit状态的事务之间，在备库执行时也是可以并行的。  </li>
</ol>
</li>
</ol>
<p>每个事务都有两个数字表示它在执行提交阶段的时间范围，构成区间(c1,c2)。c1是事务启动的时候，当前系统里最大的commit_id。一个事务提交的时候，才会commit_id+1，+1之前启动的事务拥有相同的commit_id。如果两个事务的区间有交集，就是可以并行的。  </p>
<blockquote>
<p>主库在写binlog的时候，会在binlog里记录commit_id和sequence_no，来说明事务之间在主库上并行prepare的状态。备库里是通过解析binlog拿到commit_id和sequence_no来决定怎么并发。  </p>
</blockquote>
<p>binlog组提交的两个参数：  </p>
<blockquote>
<ul>
<li>binlog_group_commit_sync_delay参数，表示延迟多少微妙后才调用fsync；  </li>
<li>binlog_group_commit_sync_no_delay_count参数，表示累计多少次以后才调用fsync。  </li>
</ul>
</blockquote>
<p>这两个参数，用于故意拉binlog从write到fsync的时间，以此减少binlog的写盘次数。在并行复制策略里，可以用来制造更多的“同时处于prepare阶段的事务”，增加了备库复制的并行度。<br>这两个参数，既可以故意让主库提交的慢些，又可以让备库执行的快些。  </p>
<h3 id="MySQL5-7-22并行复制策略"><a href="#MySQL5-7-22并行复制策略" class="headerlink" title="MySQL5.7.22并行复制策略"></a>MySQL5.7.22并行复制策略</h3><p>基于WRITESET的并行复制。参数binlog-transaction-dependency-tracking控制是否启用该策略(如果同时设置了slave_parallel_type参数，则以该spt参数为准)：  </p>
<ol>
<li>COMMIT_ORDER，表示的是根据同时进入prepare和commit来判断是否可以并行的策略。  </li>
<li>WRITESET，表示的是对于事务涉及更新的每一行，计算出这一行的hash值，组成集合writeset。如果每个事务没有操作相同的行，他们的writeset没有交集，就可以并行。  </li>
<li>WRITESET_SESSION，在writeset的基础上多了一个约束，在主库上同一个线程先后执行的两个事务，在备库执行的时候，要保证相同的先后顺序。  </li>
</ol>
<p>唯一标识hash值是通过“库名+表名+索引名+值”计算出来的。如果一个表上除了有主键索引外，还有其它唯一索引，那么对于每一个唯一索引，insert语句对应的writeset就要多增加一个hash值。(类似5.5的按行分发策略，但有优化)：  </p>
<ol>
<li>writeset是在主库生成后直接写入到binlog里面的，这样在备库执行的时候，不需要解析binlog内容(event里的行数据)，节省了很多计算量；  </li>
<li>不需要把整个事务的binlog都扫一遍才能决定分发到那个worker，更省内存；  </li>
<li>由于备库的分发策略不依赖于binlog内容，所以binlog是statement格式也是可以的。  </li>
</ol>
<p>对于“表上没主键”和“外键约束”的场景，writeset策略无法并行，也会暂时退化为单线程模型。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>数据库异常状态判断</title>
    <url>/MySQL/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%82%E5%B8%B8%E7%8A%B6%E6%80%81%E5%88%A4%E6%96%AD/</url>
    <content><![CDATA[<p>在一主一备的双M架构中，主备切换只需要把客户端流量切到备库；而在一主多从架构中，主备切换除了要把客户端流量切到备库外，还需要把从库接到新主库上。  </p>
<p>主备切换有两种场景，一种是主动切换，一种是被动切换。被动切换，往往是因为主库出问题了，由HA系统发起的。  </p>
<h3 id="select-1-判断"><a href="#select-1-判断" class="headerlink" title="select 1 判断"></a>select 1 判断</h3><p>select 1成功返回，只能说明这个库的进程还在，并不能说明主库没问题。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> innodb_thread_concurrency=<span class="number">3</span>;<span class="comment">-- 控制InnoDB的并发线程上限，一旦并发线程数达到这个值，InnoDB在接收到新请求的时候，就会进入等待状态，直到有线程退出。  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">'t'</span> (</span><br><span class="line">    <span class="string">'id'</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="string">'c'</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line">    primary <span class="keyword">key</span> (<span class="string">'id'</span>)</span><br><span class="line">) <span class="keyword">engine</span>=<span class="keyword">innodb</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
<th>sessionC</th>
<th>sessionD</th>
</tr>
</thead>
<tbody><tr>
<td>select sleep(100) from t;</td>
<td>select sleep(100) from t;</td>
<td>select sleep(100) from t;</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>select 1;</br>(Query OK)</br>select * from t;</br>(blocked)</td>
</tr>
</tbody></table>
<p>sessionD中，select 1是能执行成功的，但是查询表t的语句会被堵住。用select 1来检测实例是否正常的话，是检测不出问题的。  </p>
<p>MHA(Master High Availability)默认使用的方法。另一个可选方案，只做连接，如果连接成功就认为主库没问题。  </p>
<p>在InnoDB中，innodb_thread_concurrency这个参数的默认值是0，表示不限制并发线程数量。一个机器的CPU核数有限，不限制并发数，线程全冲进来，上下文切换的成本太高。通常设置为64~128之间的值(理论上是核数的2倍左右最好)。  </p>
<h4 id="并发连接与并发查询"><a href="#并发连接与并发查询" class="headerlink" title="并发连接与并发查询"></a>并发连接与并发查询</h4><p>show processlist，看到的几千个连接，指的是并发连接；而当前正在执行的语句，才是并发查询。  </p>
<p>并发连接数达到几千个影响并不大，多占一些内存而已。应该关注的是并发查询，并发查询太高才是CPU杀手，必须设置innodb_thread_concurrency参数。  </p>
<p>在线程进入锁等待以后，并发线程的计数会减一，出现同一行热点更新的问题时，等行锁(也包括间隙锁)的线程是不算在128中的。因为，进入锁等待的线程已经不吃CPU了；另外这样设计，也能避免整个系统锁死。  </p>
<ol>
<li>线程1执行begin；update t set c=c+1 where id=1，启动了事务trx1，然后保持这个状态。这个时候，线程处于空闲状态，不算在并发线程里面。  </li>
<li>线程2到线程129都执行update t set c=c+1 where id=1;由于等待行锁，进入等待状态。这样就有128个线程处于等待状态；  </li>
<li>如果处于锁等待状态的线程计数不减一，InnoDB就会认为线程数用满了，会阻止其它语句进入引擎执行，这样线程1不能提交事务，而另外128个线程又处于锁等待状态，整个系统就堵住了。  </li>
</ol>
<p>这时InnoDB不能响应任何请求，整个系统被锁死。而且由于所有线程都处于等待状态，此时占用的CPU却是0，不合理。所以遇到进程进入锁等待的情况时，将并发线程的计数减1的设计，是合理而且是必要的。  </p>
<p>等锁的线程不算在并发线程计数里，但如果它在真正的执行查询(如select sleep(100) from 1)，还是要算进并发线程的计数的。  </p>
<p>问题：<br>同时在执行的语句超过了设置的值，这时候系统其实已经不行了，但是通过select 1来检测系统，会认为系统还是正常的。  </p>
<h3 id="查表判断"><a href="#查表判断" class="headerlink" title="查表判断"></a>查表判断</h3><p>为了能够检测InnoDB并发线程数过多导致的系统不可用情况，需要找一个访问InnoDB的场景。一般的做法是，在系统库(mysql库)里创建一个表，命名为health_check，里面只放一行数据，然后定期执行：<strong>select * from mysql.health_check;</strong>使用这个方法，可以检测出由于并发线程过多导致的数据库不可用的情况。  </p>
<p>问题：<br>空间满了以后，这种方法会变得不好使：更新事务要写binlog，一旦binlog所在磁盘的空间占用率达到100%，那么所有的更新语句和事务提交的commit语句就会被堵住，但是，系统这时候还是可以正常读数据的。  </p>
<h3 id="更新判断"><a href="#更新判断" class="headerlink" title="更新判断"></a>更新判断</h3><p>在表中放一个有意义的字段-timestamp，用来表示最后一次执行检测的时间：<strong>update mysql.health_check set t_modified=now();</strong></p>
<p>节点可用性的检测应该包含主库和备库，如果用更新来检测主库，那么备库也要进行更新检测。  </p>
<p>备库的检测也是要写binlog的，由于一般会把数据库A和B的主备关系设计为双M结构，所以在备库B上执行的检测命令，也要发回给主库A。但是如果主库A和备库B都用相同的更新命令，就可能出现行冲突，可能会导致主备同步停止。  </p>
<p>mysql.health_check这个表就不能只有一行数据了，可以在表上存入多行数据，并用A、B的server_id做主键，保证主、备库各自的检测命令不会发生冲突。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">'health_check'</span>(</span><br><span class="line">    <span class="string">'id'</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="string">'t_modified'</span> <span class="built_in">timestamp</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="keyword">current_timestamp</span>,</span><br><span class="line">    primary <span class="keyword">key</span>(<span class="string">'id'</span>)</span><br><span class="line">) <span class="keyword">engine</span>=<span class="keyword">innodb</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> inro mysql.health_check(<span class="keyword">id</span>,t_modified) <span class="keyword">values</span>(@@server_id, <span class="keyword">now</span>()) <span class="keyword">on</span> <span class="keyword">duplicate</span> <span class="keyword">key</span> <span class="keyword">update</span> t_modified=<span class="keyword">now</span>();</span><br></pre></td></tr></table></figure>

<p>问题：判定慢  </p>
<ul>
<li>所有的检测逻辑都需要一个超时时间N，执行一条update语句，超过N秒后还不返回，就认为系统不可用。  </li>
</ul>
<p>日志盘的IO利用率已经是100%，整个系统响应非常慢，已经需要做主备切换了。  </p>
<p>但是IO利用率100%表示系统的IO是在工作的，每个请求都有机会获得IO资源，执行自己的任务。检测使用的update命令，需要的资源很少，可能在拿到IO资源的时候就可以提交成功，并且在超时时间N秒未到达之前就返回给了检测系统。让检测系统得到”系统正常”的结论。  </p>
<ul>
<li>基于外部检测还有一个天然问题，随机性。  </li>
</ul>
<p>外部检测都需要定时轮询，所以系统可能已经出问题了，但是却要等到下一个检测发起执行语句的时候，才有可能发现问题。而且，可能第一次轮询还不能发现，导致切换更慢。  </p>
<h3 id="内部统计"><a href="#内部统计" class="headerlink" title="内部统计"></a>内部统计</h3><p>MySQL提供内部每一次IO请求的时间，来反映磁盘利用率的问题。  </p>
<p>MySQL5.6版本提供performance_schema库，在file_summary_by_event_name表里统计了每次IO请求的时间。  </p>
<img src='/img/MySQL performance_schema.file_summary_by_event_name.png'>

<p>图中表示的是redo log的写入时间。</p>
<ul>
<li>第一列event_name表示统计的类型。  </li>
<li>接下来有三组数据，显示的是redo log操作的时间统计。  </li>
<li>第一组5列，是所有IO类型的统计。其中count_star是所有IO的总次数。接下来四列是具体的统计项，单位是皮秒；前缀sum、min、avg、max，分别对应总和、最小值、平均值、最大值。  </li>
<li>第二组6列，是读操作的统计。最后一列sum_number_of_bytes_read统计的是，总共从redo log里读了多少个字节。  </li>
<li>第三组6列，统计的是写操作。  </li>
<li>最后四组数据，是对其他类型数据的统计。在redo log里，是对fsync的统计。  </li>
</ul>
<p>binlog对应的是event_name=’wait/io/file/sql/binlog’这一行。  </p>
<hr>
<p>每一次操作数据库，performance_schema都需要额外的统计这些信息，打开统计功能有性能损耗，打开所有的performance_schema项，性能下降10%。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> setup_instruments <span class="keyword">set</span> enabled=<span class="string">'YES'</span>, Timed=<span class="string">'YES'</span> <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'%wait/io/file/innodb/innodb_log_file%'</span>;<span class="comment">-- redo log</span></span><br></pre></td></tr></table></figure>

<p>可以通过max_timer的值来判断数据库是否出问题。假设单次IO请求时间超过200毫秒属于异常：  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> event_name,max_timer_wait <span class="keyword">from</span> performance_schema.file_summary_by_event_name <span class="keyword">where</span> event_name <span class="keyword">in</span> (<span class="string">'wait/io/file/innodb/innodb_log_file'</span>,<span class="string">'wait/io/file/sql/binlog'</span>) <span class="keyword">and</span> max_timer_wait&gt;<span class="number">200</span>*<span class="number">1000000000</span>;</span><br></pre></td></tr></table></figure>

<p>发现异常后，取到需要的信息，把之前的统计信息清空，这样如果后面的监控中，再次出现这个异常，就可以加入监控累计值了（？？）：  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> performance_schema.file_summary_by_event_name;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>用动态的观点看加锁</title>
    <url>/MySQL/%E7%94%A8%E5%8A%A8%E6%80%81%E7%9A%84%E8%A7%82%E7%82%B9%E7%9C%8B%E5%8A%A0%E9%94%81/</url>
    <content><![CDATA[<p>加锁规则：  </p>
<ul>
<li>原则1： 加锁的基本单位是next-key lock。前开后闭区间。  </li>
<li>原则2： 查找过程中访问到的对象才会加锁。  </li>
<li>优化1： 索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁。  </li>
<li>优化2： 索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁。  </li>
<li>一个bug： 唯一索引上的范围查询会访问到不满足条件的第一个值为止。  </li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">'t'</span> (</span><br><span class="line">    <span class="string">'id'</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="string">'c'</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="string">'d'</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line">    primary <span class="keyword">key</span> (<span class="string">'id'</span>),</span><br><span class="line">    <span class="keyword">key</span> <span class="string">'c'</span> (<span class="string">'c'</span>)</span><br><span class="line">) <span class="keyword">engine</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> inro t <span class="keyword">values</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure>

<h3 id="不等号条件里的等值查询"><a href="#不等号条件里的等值查询" class="headerlink" title="不等号条件里的等值查询"></a>不等号条件里的等值查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;  </span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span>&gt;<span class="number">9</span> <span class="keyword">and</span> <span class="keyword">id</span>&lt;<span class="number">12</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">desc</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p>这个语句的加锁范围是主键索引上的(0,5]、(5,10]、(10,15)。id=15这一行，并没有被加上锁。  </p>
<p>加锁单位是next-key lock，都是前开后闭区间，但是这里用到了优化2，索引上的等值查询，向右遍历的时候id=15不满足条件，所以next-key lock退化为了间隙锁(10,15)。  </p>
<p>查询语句中的“等值查询”分析：加锁动作是发生在语句执行过程中的，分析加锁行为需要从索引上的数据结果开始。  </p>
<ol>
<li>首先这个查询语句是order by id desc，要拿到满足条件的所有行，优化器必须先找到“第一个id&lt;12的值”。  </li>
<li>这个过程是通过索引树的搜索过程得到的，在引擎内部，其实是要找到id=12的这个值，只是最终没找到，但找到了(10,15)这个间隙。  </li>
<li>然后向左遍历，在遍历过程中，就不是等值查询了，会扫描到id=5这一行，所以会加一个next-key lock(0,5]。  </li>
</ol>
<p>在执行过程中，通过树搜索的方式定位记录的时候，用的是“等值查询”的方式。  </p>
<h3 id="等值查询的过程"><a href="#等值查询的过程" class="headerlink" title="等值查询的过程"></a>等值查询的过程</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;  </span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> c <span class="keyword">in</span>(<span class="number">5</span>,<span class="number">20</span>,<span class="number">10</span>) <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br></pre></td></tr></table></figure>

<p>in语句explain结果：  </p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>partitions</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>filtered</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>simple</td>
<td>t</td>
<td>null</td>
<td>range</td>
<td>c</td>
<td>c</td>
<td>5</td>
<td>null</td>
<td>3</td>
<td>100.00</td>
<td>Using where, Using index</td>
</tr>
</tbody></table>
<p>这条in语句使用了索引c并且rows=3，说明这三个值都是通过B+树搜索定位的。  </p>
<p>在查找c=5的时候，先锁住了(0,5]。但是因为c不是唯一索引，为了确认还有没有别的记录c=5，就要向右遍历，找到c=10才确认没有了，这个过程满足优化2，所以加了间隙锁(5,10)。 </p>
<p>同样，执行c=10这个逻辑的时候，加锁的范围是(5,10]和(10,15)；执行c=20这个逻辑的时候，加锁的范围是(15,20]和(20,25)。  </p>
<p>综上，语句在索引c上加的三个记录锁的顺序是：先加c=5的记录锁，再加c=10的记录锁，最后加c=20的记录锁。  </p>
<p>这些锁是“在执行过程中一个一个假的”，而不是一次性加上去的。  </p>
<hr>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> c <span class="keyword">in</span>(<span class="number">5</span>,<span class="number">20</span>,<span class="number">10</span>) <span class="keyword">order</span> <span class="keyword">by</span> c <span class="keyword">desc</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p>间隙锁是不互锁的，以上两条语句都会在索引c上的c=5、10、20这三行记录上加记录锁。  </p>
<p>由于语句里的order by c desc，这三个记录锁的加锁顺序，是先锁c=20，然后c=10，最后是c=5。  </p>
<p>以上两条语句要加锁相同的资源，但是加锁顺序相反。当这两条语句并发执行的时候，可能出现死锁。  </p>
<p>关于死锁的信息，MySQL只保留了最后一个死锁的现场，不完备。  </p>
<h3 id="死锁-select"><a href="#死锁-select" class="headerlink" title="死锁(select)"></a>死锁(select)</h3><p>出现死锁后，执行show engine innodb status命令得到部分输出。其中一节latest detected deadlock，记录的就是最后一次死锁信息。  </p>
<ul>
<li>lock_mode X waiting表示next-key lock；  </li>
<li>lock_mode X locks rec but not gap只有行锁；  </li>
<li>locks gap before rec只有间隙锁。  </li>
</ul>
<img src='/img/MySQL死锁现场.png'>

<ol>
<li>这个结果分成三个部分：  <ul>
<li>(1)transaction，是第一个事务的信息；  </li>
<li>(2)transaction，是第二个事务的信息；  </li>
<li>we roll back transaction(1)，是最终的处理结果，表示回滚了第一个事务。  </li>
</ul>
</li>
<li>第一个事务的信息中：  <ul>
<li>waiting for this lock to be granted，表示的是这事务在等待的锁信息；  </li>
<li>record lock说明这是一个记录锁；  </li>
<li>index c of table ‘test’.’t’，说明在等的是表t的索引c上面的锁；  </li>
<li>lock mode S waiting表示这个语句要自己加一个读锁，当前的状态时等待中；  </li>
<li>n_field 2表示这个记录是两列，也就是字段c和主键字段id；  </li>
<li>0:len 4; hex 0000000a; asc;;是第一个字段，也就是c。值是十六进制a，也就是10；  </li>
<li>1:len 4; hex 0000000a; asc;;是第二个字段，也就是主键id，值也是10；  </li>
<li>这两行里面的asc表示的是，接下来要打印出值里面的“可打印字符”，但10不是可打印字符，因此就显示空格。  </li>
<li>第一个事务信息就只显示出了等锁的状态，在等待(c=10,id=10)这一行的锁。  </li>
<li>既然出现死锁了，就表示这个事务也占有别的锁，但是没有显示出来。  </li>
</ul>
</li>
<li>第二个事务显示的信息多一些：  <ul>
<li>‘holds the lock(s)’用来显示这个事务持有哪些锁；  </li>
<li>index c of table ‘test’.’t’表示锁是在表t的索引c上；  </li>
<li>hex 0000000a和hex 00000014表示这个事务持有c=10和c=20这两个记录锁；  </li>
<li>waiting for this lock to be granted，表示在等(c=5,id=5)这个记录锁。  </li>
</ul>
</li>
</ol>
<p>综上：  </p>
<ol>
<li>‘lock in share mode’这条语句，持有c=5的记录锁，在等c=10的锁；  </li>
<li>‘for update’这个语句，持有c=20和c=10的记录锁，在等c=5的记录锁。  </li>
</ol>
<hr>
<ol>
<li>由于锁是一个个加的，要避免死锁，对同一组资源，要按照尽量相同的顺序访问；  </li>
<li>在发生死锁的时刻，for update语句占有的资源更多，回滚的成本更大，所以InnoDB选择了回滚成本更小的lock in share mode语句来回滚。  </li>
</ol>
<h3 id="锁等待-delete-amp-insert"><a href="#锁等待-delete-amp-insert" class="headerlink" title="锁等待(delete&amp;insert)"></a>锁等待(delete&amp;insert)</h3><table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
</tr>
</thead>
<tbody><tr>
<td>begin;</br>select * from t where id&gt;10 and id&lt;=15 for update;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>delete from t where id=10;</br>(Query OK)</br>insert into t values(10,10,10);(blocked)</td>
</tr>
</tbody></table>
<p>由于<strong>sessionA并没有锁住c=10这个记录</strong>，所以sessionB删除c=10这一行是可以的，但是之后，sessionB再想insert id=10这一行回去就不行了。  </p>
<blockquote>
<p>根据id&gt;10得到的第一个记录是id=15，所以不会加(5,10]这个next-key lock，又由于id是主键索引，只加了(10,15]这个next-key lock。  </p>
</blockquote>
<img src='/img/MySQL锁等待信息.png'>

<p>执行show engine innodb status命令，锁信息在transactions这一节：  </p>
<ol>
<li>index primary of table ‘test’.’t’，表示这个语句被锁住是因为表t主键上的某个锁。  </li>
<li>lock_mode X locks gap before rec before rec insert intenting waiting里有几个信息：  <ul>
<li>insert intention表示当前线程准备插入一个记录，这是一个<strong>插入意向锁</strong>。可以理解为插入动作本身。  </li>
<li>gap before rec表示这是一个间隙锁，而不是记录锁。  </li>
</ul>
</li>
<li>接下来的0~4这5行的内容是这个间隙的记录信息。  </li>
<li>n_fields 5也表示了，这一个记录有5列:  <ul>
<li>0:len 4; hex 0000000f; asc ;;第一列是主键id字段，十六进制f就是id=15。这个间隙锁值id=15之前的，因为id=10已经不存在了，它表示的就是(5,15)。  </li>
<li>1:len 6; hex 000000000513; asc;;第二列是长度为6字节的事务id，表示最后修改这一行的是trx id为1299的事务。  </li>
<li>2:len 7; hex b0000001250134; asc %4;;第三列长度为7的字节的回滚段信息。可以看到，这里的asc后面有显示内容(%和4)，这是因为刚好这个字节是可打印字符。  </li>
<li>后面两列是c和d的值，都是15。  </li>
</ul>
</li>
</ol>
<p>综上：<br>由于delete操作把id=10这一行删掉了，原来的两个间隙(5,10)、(10,15)变成了一个(5,15)。<strong>删除前间隙锁只有一个(10,15)</strong>，删除后间隙锁左侧扩张成了5，得到间隙锁(5,15)  </p>
<hr>
<ol>
<li>sessionA执行完select语句之后，什么都没做，但它加锁的范围突然变大了；  </li>
<li>对比，当执行select * from t where c&gt;=10 and c&lt;=25 order by c desc lock in share mode;倒序向左扫描到c=5(非唯一索引，一直扫描到第一个不符合条件的值)的时候才会停止，要把(0,5]锁起来。所谓“间隙”，是由“这个间隙右边的那个记录”定义的。  </li>
</ol>
<h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
</tr>
</thead>
<tbody><tr>
<td>begin;</br>select c from t where c&gt;5 lock in share mode;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>update t set c=1 where c=5;</br>(Query OK)</br>update t set c=5 where c=1;</br>(blocked)</td>
</tr>
</tbody></table>
<p>sessionA的加锁范围是索引C上的(5,10]、(10,15]、(15,20]、(20,25]、(25,supremum]。  </p>
<blockquote>
<p>根据c&gt;5查到的第一个记录是c=10，因此不会加(0,5]这个next-key lock。  </p>
</blockquote>
<p>之后sessionB的第一个update语句，要把c=5改成c=1，分为两步：  </p>
<ol>
<li>插入(c=1,id=5)这个记录；  </li>
<li>删除(c=5,id=5)这个记录。  </li>
</ol>
<p>索引c上(5,10)间隙是由这个间隙右边的记录c=10定义的(锁等待中的总结)。<br>执行第一个操作后，锁为(c=1,id=5)~(25,supremum]。  </p>
<p>sessionB的第二个update语句，要把c=1改成c=5，分为两步：  </p>
<ol>
<li>插入(c=5,id=5)这个记录；  </li>
<li>删除(c=1,id=5)这个记录。  </li>
</ol>
<p>第一步试图在已经加了间隙锁的(c=1,id=5)~(c=10,id=10)中插入数据，所以就被堵住了。  </p>
<h3 id="空表的间隙"><a href="#空表的间隙" class="headerlink" title="空表的间隙"></a>空表的间隙</h3><p>一个空表只有一个间隙。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;  </span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span>&gt;<span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;  </span><br><span class="line"><span class="comment">-- 这个查询语句加锁的范围是next-key lock(-∞,supremum]。</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
</tr>
</thead>
<tbody><tr>
<td>create table t(id int primary key) engine=innodb;</br>begin;</br>select * from t where id&gt;1;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>insert into t values(2);</br>(blocked)</td>
</tr>
<tr>
<td>show engine innodb status;</td>
<td></td>
</tr>
</tbody></table>
<img src='/img/MySQL锁等待-空表.png'>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>WAL保证数据不丢</title>
    <url>/MySQL/WAL%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2/</url>
    <content><![CDATA[<p>WAL(write ahead log)机制:先写内存，然后写日志(redo log&amp;binlog)，后台有机会将内存的数据写到数据盘。只要redo log和binlog保证持久化到磁盘，就能保证MySQL异常重启后，数据可以恢复。  </p>
<h3 id="binlog的写入机制"><a href="#binlog的写入机制" class="headerlink" title="binlog的写入机制"></a>binlog的写入机制</h3><p>事务执行过程中，先把日志写到binlog cache，事务提交的时候，再把binlog cache写到binlog文件中。  </p>
<p>一个事务的binlog是不能被拆开的，不论这个事务多大，都要确保一次性写入。  </p>
<blockquote>
<p>执行一条事务所产生的binlog准备写到binlog file时，都会先判断当前文件写入这条binlog之后是否会超过设置的max_binglog_size值，若超过，则rotate自动生成下个binlog file来记录这条binlog信息。<br>如果单条事务产生的binlog大于max_binlog_size，不会被拆到连个binlog文件，等到这个事务的日志写完再rotate，存在超过配置大小上限的binlog文件。  </p>
</blockquote>
<p>系统给binlog cache分配了一片内存，每个线程一个，参数binlog_cache_size用于控制单个线程内binlog cache所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。  </p>
<p>事务提交的时候，执行器把binlog cache里的完整事务写入到binlog中，并清空binlog cache。  </p>
<img src="/img/MySQL binlog写盘状态.png" width="500" height="500" >

<p>每个线程都有自己的binlog cache，但是共用同一份binlog文件。  </p>
<ol>
<li>图中的write，指的是<strong>把日志binlog cache写入到文件系统的page cache</strong>(文件系统向内核申请的一块内存，缓存读写文件)，并没有把数据持久化到磁盘，速度比较快。(<strong>此时commit标识完成write，响应客户端，client收到commit成功</strong>，主机掉电重启，事务会回滚)  </li>
<li>图中的fsync，指的是将数据持久化到磁盘的操作。一般情况下，fsync才占磁盘的IOPS。  </li>
</ol>
<p>write和fsync的时机，由参数sync_binlog控制：  </p>
<ol>
<li>sync_binlog=0时，表示每次提交事务都只write，不fsync；(可能会丢失日志)  </li>
<li>sync_binlog=1时，表示每次提交事务都会执行fsync；  </li>
<li>sync_binlog=N(N&gt;1)时，表示每次提交事务都write，但是累积N个事务后才fsync。(如果主机发生异常重启，会丢失最近N个事务的binlog日志)  </li>
</ol>
<p>出现IO瓶颈的场景里，将sync_binlog设置成一个比较大的值，可以提升性能。常见100~1000。  </p>
<h3 id="redo-log的写入机制"><a href="#redo-log的写入机制" class="headerlink" title="redo log的写入机制"></a>redo log的写入机制</h3><p><a href="/MySQL/2日志系统">MySQL-2日志系统</a>  </p>
<p>事务在执行过程中，生成的redo log是要先写到redo log buffer对应的内存中，在commit阶段，一次性写入redo log file。(redo log buffer中的内容，并不是每次生成后都直接持久化到磁盘。但一个还没有提交的事务，其部分日志也有可能被提前持久化到磁盘。)  </p>
<p>如果事务执行期间MySQL发生异常重启，那这部分日志就丢了。但由于事务并没有提交，这时日志丢了也不会有损失。  </p>
<p>redo log可能存在三种状态：</p>
<img src="/img/MySQL redo log存储状态.png" width="500" height="313" >

<ol>
<li>存在redo log buffer中，物理上是在MySQL进程内存中，对应图中红色部分；  </li>
<li>写到磁盘(write)，但是没有持久化(fsync)，物理上是在文件系统的page cache中，对应图中黄色部分；  </li>
<li>持久化到磁盘hard disk，对应图中的绿色部分。  </li>
</ol>
<p>日志写到redo log buffer是很快的，wirte到page cache也差不多，但是持久化到磁盘的速度较慢。  </p>
<p>InnoDB提供了innodb_flush_log_at_trx_commit参数，控制redo log的写入策略：  </p>
<ol>
<li>=0时，表示每次事务提交时都只是把redo log留在redo log buffer中；(MySQL本身异常重启就会丢数据)  </li>
<li>=1时，表示每次事务提交时都将redo log直接持久化到磁盘；  </li>
<li>=2时，表示每次事务提交时都只是把redo log写到page cache。(主机掉电重启才会丢数据)  </li>
</ol>
<p>出现IO瓶颈的场景里，将innodb_flush_log_at_trx_commit设置成2，性能跟设置成0差不多，但是MySQL异常重启时不会丢数据。  </p>
<p>其他操作：</p>
<ol>
<li>InnoDB有一个后台线程，每隔1秒，就会把redo log buffer中的日志，调用write写到文件系统的page cache，然后调用fsync持久化到磁盘。(事务执行中间过程的redo log也是直接写在redo log buffer中的，这些还未提交的事务的redo log也会被后台线程一起持久化到磁盘。checkpoint)  </li>
<li>redo log buffer占用的空间即将达到innodb_log_buffer_size一半的时候，后台线程会主动写盘。这个事务并没有提交，这个写盘动作只是write，而没有调用fsync，也就是只留在了文件系统的page cache。  </li>
<li>并行的其他事务提交的时候，顺带将这个事务的redo log buffer持久化到磁盘(参数设置=1)。(事务A执行到一半，已经写了一些redo log到buffer中，这时事务B提交，就会带上事务A在redo log buffer里的日志一起全部持久化到磁盘。)</li>
</ol>
<hr>
<h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p>两阶段提交(事务提交时，才会走到事务的redo log prepare阶段—属于事务提交的一个阶段)，时序上redo log先prepare，再写binlog，最后再把redo log commit。(事务提交过程中的最后一个步骤，这个步骤执行完成后，这个事务就提交完成了。)  </p>
<p>如果innodb_flush_log_at_trx_commit=1，那么<strong>redo log在提交的prepare阶段就会持久化一次</strong>(崩溃恢复逻辑之一是要依赖于prepare的redo log，再加上binlog来恢复的)。</p>
<p>每秒一次后台轮询刷盘，再加上崩溃恢复这个逻辑，InnoDB就认为redo log在commit的时候就不需要fsync了，只write到文件系统的page cache中就足够了。  </p>
<p>“双1”配置：指的是sync_binlog和innodb_flush_log_at_trx_commit都设置成1。<br>一个事务完整提交前，需要等待两次刷盘，一次是redo log(prepare阶段)，一次是binlog。  </p>
<p>“非双1”配置：innodb_flush_logs_at_trx_commit=2;sync_binlog=1000;</p>
<ul>
<li>业务高峰期。  </li>
<li>备库延迟，为了让备库尽快赶上主库。(追上后改回双1)  </li>
<li>用备份恢复主库的副本，应用binlog的过程。  </li>
<li>批量导入数据的时候。  </li>
</ul>
<h4 id="组提交优化"><a href="#组提交优化" class="headerlink" title="组提交优化"></a>组提交优化</h4><p>日志逻辑序列号(log sequence number，LSN)。LSN是单调递增的，用来对应redo log的一个个写入点。每次写入长度为length的redo log，LSN的值就会加上length。  </p>
<p><strong>LSN也会写到InnoDB的数据页中，来确保数据页不会被多次执行重复的redo log。</strong>（crash后恢复）  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        redo log组提交示例
    </div>
    <div class='spoiler-content'>
        <img src="/img/MySQL redo log组提交.png" width="500" height="1000" >

<p>三个并发事务(trx1,trx2,trx3)在prepare阶段，都写完redo log buffer，持久化到磁盘的过程中，对应的LSN分别是50、120、160。  </p>
<ol>
<li>trx1是第一个到达的，会被选为这组的leader；  </li>
<li>等trx1要开始写盘的时候，这个组里面已经有了三个事务，这时候LSN变成了160；  </li>
<li>trx1去写盘的时候带的就是LSN=160，因此等trx1返回时，所有LSN小于等于160的redo log都已经被持久化到磁盘；  </li>
<li>这时trx2和trx3就可以直接返回了。  </li>
</ol>

    </div>
</div>  

<p>一次组提交里面，组员越多，节约磁盘IOPS的效果越好。(单线程则只能一个事务对应一次持久化操作)  </p>
<p>在并发更新场景下，第一个事务写完redo log buffer以后，接下来这个fsync越晚调用，组员可能越多，节约IOPS的效果就越好。  </p>
<p>MySQL通过“拖时间”，让一次fsync带更多的组员。  </p>
<h4 id="组提交优化两阶段提交"><a href="#组提交优化两阶段提交" class="headerlink" title="组提交优化两阶段提交"></a>组提交优化两阶段提交</h4><p>写binlog也是分成两步的：  </p>
<ol>
<li>先把binlog从binlog cache中写到磁盘上的binlog文件(文件系统的page cache)；(write)(此时commit标识完成write，但没有落盘，就响应客户端，client收到commit成功，主机掉电重启，事务会回滚，数据会丢失)  </li>
<li>调用fsync持久化到磁盘。(fsync)  </li>
</ol>
<img src="/img/MySQL两阶段提交细化.png" width="500" height="500" >

<p>多个事务的binlog写完了也可以一起持久化(组提交)，进一步减少IOPS消耗：  </p>
<ol>
<li>binlog_group_commit_sync_delay参数，表示延迟多少微妙后才调用fsync；  </li>
<li>binlog_group_commit_sync_no_delay_count参数，表示累积多少次以后才调用fsync。  </li>
</ol>
<p>只要有一个条件满足就会调用fsync。(当delay=0时，no_delay_count就无效了)。(sync_binlog也受组提交参数影响，sync_delay和sync_no_delay_count的逻辑先走，等满足这两个条件之一，就进入sync_binlog阶段，如果sync_binlog=0,就直接跳过，不调fsync不刷盘)</p>
<hr>
<h3 id="WAL预写日志机制"><a href="#WAL预写日志机制" class="headerlink" title="WAL预写日志机制"></a>WAL预写日志机制</h3><p>WAL机制减少磁盘写，主要得益于两个方面：  </p>
<ol>
<li>redo log和binlog都是顺序写，磁盘的顺序写比随机写速度要快；  </li>
<li>组提交机制，可以大幅度降低磁盘的IOPS消耗。  </li>
</ol>
<p>MySQL出现IO性能瓶颈解决方案：  </p>
<ol>
<li>设置binlog_group_commit_sync_delay和binlog_group_commit_sync_no_delay_count参数，减少binlog的写盘次数。(基于“额外的故意等待”实现，可能会增加语句的响应时间，但没有丢失数据的风险)  </li>
<li>将sync_binlog设置为大于1的值(100-1000)。存在主机掉电时会丢binlog日志的风险。  </li>
<li>将innodb_flush_log_at_trx_commit设置为2。存在主机掉电时丢数据的风险。  </li>
</ol>
<hr>
<p>binlog cache是每个线程自己维护的，redo log buffer是全局共用的。  </p>
<ul>
<li><p>binlog是不能“被打断的”，一个事务的binlog必须连续写，因此要整个事务完成后，再一起写到文件里。(连续性是write的时候保证的)  </p>
<blockquote>
<p>一个线程只能同时有一个事务在执行。每当执行一个begin/start transaction时，就会默认提交上一个事务，如果一个事务的binlog被拆开，在备库执行就会被当做多个事务分段进行，破坏了原子性。  </p>
</blockquote>
</li>
<li><p>redo log没有连续的要求，中间生成的日志可以写到redo log buffer中。redo log buffer中的内容还可以“搭便车”，其他事务提交的时候可以被一起写到磁盘中。  </p>
</li>
<li><p>binlog存储是以statement或者row格式存储的，而redo log是以page页格式存储的。page格式，天生就是共有的，而row格式只跟当前事务相关。  </p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>误删数据处理</title>
    <url>/MySQL/%E8%AF%AF%E5%88%A0%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>误删数据分类：  </p>
<ol>
<li>使用delete语句误删数据行；  </li>
<li>使用drop table或者truncate table语句误删数据表；  </li>
<li>使用drop database语句误删数据库；  </li>
<li>使用rm命令误删整个MySQL实例。  </li>
</ol>
<h3 id="误删行"><a href="#误删行" class="headerlink" title="误删行"></a>误删行</h3><p>如果使用delete语句误删了数据行，可以用Flashback工具通过闪回把数据恢复回来。  </p>
<p>Flashback恢复数据的原理，是修改binlog的内容，拿回原库重放。前提要确保binlog_format=row和binlog_row_image=FULL。  </p>
<h4 id="单个事务"><a href="#单个事务" class="headerlink" title="单个事务"></a>单个事务</h4><ol>
<li>对于insert语句，对应的binlog event类型是Write_rows event，把它改成Delete_rows event即可；  </li>
<li>对于delete语句，将Delete_rows event改为Write_rows event；  </li>
<li>如果是Update_rows，binlog里面记录了数据行修改前后修改后的值，对调这两行的位置即可。  </li>
</ol>
<h4 id="多个事务"><a href="#多个事务" class="headerlink" title="多个事务"></a>多个事务</h4><blockquote>
<p>(A)delete …<br>(B)insert …<br>(C)update …  </p>
</blockquote>
<p>写回主库的命令是：  </p>
<blockquote>
<p>(reverse C)update …<br>(reverse B)delete …<br>(reverse A)insert …  </p>
</blockquote>
<p>误删数据涉及多个事务的话，需要将事务的顺序倒过来再执行。  </p>
<h4 id="事后处理"><a href="#事后处理" class="headerlink" title="事后处理"></a>事后处理</h4><p>恢复数据比较安全的做法，恢复出一个备份，或者找一个从库作为临时库，在临时库上执行这些操作，然后再讲确认过的临时库的数据，恢复回主库。  </p>
<p>一个在执行线上逻辑的主库，数据状态的变更往往是有关联的。发现数据问题的时间晚一点，容易导致已经在之前误操作的基础上，业务代码逻辑又继续修改了其他数据。单独恢复这几行数据，又未经过确认，可能会出现对数据的二次破坏。  </p>
<h4 id="事前预防"><a href="#事前预防" class="headerlink" title="事前预防"></a>事前预防</h4><ol>
<li>把sql_safe_updates参数设置为on。如果忘记delete或者update语句中写where条件，或者where条件里面没有包含索引字段的话，这条语句的执行就会报错。  <blockquote>
<p>设置为on后确实要删，可以在delete语句中加上where条件，where id&gt;=0。  </p>
</blockquote>
</li>
<li>代码上线前，做SQL审计。  </li>
</ol>
<hr>
<p>delete全表很慢，需要生成回滚日志undo、写redo、写binlog。从性能角度考虑，应该优先考虑使用truncate table或者drop table命令。  </p>
<p>使用delete命令删除的数据，可以用Flashback来恢复，而使用truncate/drop table和drop database命令删除的数据，就没办法通过Flashback来恢复了。即使配置了binlog_format=row，执行这三个命令时，记录的binlog还是statement格式，binlog里面只有一个truncate/drop语句，这些信息是恢复不出数据的。  </p>
<h3 id="误删库-表"><a href="#误删库-表" class="headerlink" title="误删库/表"></a>误删库/表</h3><p>这种情况下，要想恢复数据，就需要使用全量备份，加增量日志的方式，这个方案要求线上有定期的全量备份，并且实时备份binlog。  </p>
<h4 id="binlog备份应用到临时库"><a href="#binlog备份应用到临时库" class="headerlink" title="binlog备份应用到临时库"></a>binlog备份应用到临时库</h4><p>中午12点误删后恢复流程：  </p>
<ol>
<li>取最近一次全量备份，假设这个库是一天一备，上次备份是当天0点；  </li>
<li>用备份会付出一个临时库；  </li>
<li>从日志备份里面，取出0点之后的日志；  </li>
<li>把这些日志，除了误删数据的语句外，全部应用到临时库。  </li>
</ol>
<p>优化：  </p>
<ol>
<li>为了加速数据恢复，如果这个临时库上有多个数据库，可以在使用mysqlbinlog命令时，加上一个database参数，用来指定误删表所在的库，避免了在恢复数据时还要应用其他库日志的情况。  </li>
<li>在应用日志的时候，需要跳过12点误操作的那个语句的binlog：  <ul>
<li>如果原实例没有使用GTID模式，只能在应用到包含12点的binlog文件的时候，先用-stop-position参数执行到误操作之前的日志，然后再用-start-position从误操作之后的日志继续执行；  </li>
<li>如果实例使用了GTID模式，假设误操作命令的GTID是gtid1，那么只需要执行set gtid_next=gtid1;begin;commit;先把这个GTID加到临时实例的GTID集合，之后按顺序执行binlog的时候，就会自动跳过误操作的语句。  </li>
</ul>
</li>
</ol>
<p>问题：  </p>
<ol>
<li>如果是误删表，最好就是只恢复出这张表，也就是只重放这张表的操作，但是mysqlbinlog工具并不能指定只解析一个表的日志；  </li>
<li>用mysqlbinlog解析出日志应用，应用日志的过程只能是单线程。并行复制的方法用不上。  </li>
</ol>
<h4 id="临时库接到备库上"><a href="#临时库接到备库上" class="headerlink" title="临时库接到备库上"></a>临时库接到备库上</h4><p>在备份恢复出临时实例之后，将这个临时实例设置成线上备库的从库：  </p>
<ol>
<li>在start slave之前，先通过执行change replication filter replicate_do_table=(tbl_name)命令，就可以让临时库只同步误操作的表；  </li>
<li>同时可以用上并行复制技术，来加速整个数据恢复过程。</li>
</ol>
<p>如果由于时间太久，备库上(show binlogs最小的binlog文件master.00007)已经删除了临时实例需要的binlog(master.000005)，可以从binlog备份系统中找到需要的binlog，再放回备库中。  </p>
<ol>
<li>从备份系统下载master.000005和master.000006这两个文件，放到备库的日志目录下；  </li>
<li>打开日志目录下的master.index文件，在文件开头加入两行，内容分别是“./master.000005”和“./master.000006”；  </li>
<li>重启备库，目的是让备库重新识别这两个日志文件；  </li>
<li>备库上备齐临时库需要的所有binlog，建立主备关系，可以正常同步。  </li>
</ol>
<hr>
<p>误删库或者表后，恢复数据的思路主要就是通过备份，再加上应用binlog的方式。两个方案都要求备份系统定期备份全量日志，而且需要确保binlog在被从本地删除之前已经做了备份。但一个系统不可能备份无限的日志。  </p>
<p>数据恢复功能做成自动化工具，并且经常拿出来演练。</p>
<h3 id="延迟复制备库"><a href="#延迟复制备库" class="headerlink" title="延迟复制备库"></a>延迟复制备库</h3><p>利用并行复制来加速恢复数据的过程，依然存在恢复时间不可控的问题。  </p>
<p>如果一个库的备份特别大，或者误操作的时间距离上一个全量备份的时间较长，恢复时间较长。如果有非常核心的业务，不允许太长的恢复时间，可以考虑搭建延迟复制的备库。MySQL5.6引入。  </p>
<p>一般的主备复制结果存在的问题，如果主库上有个表被误删了，这个命令很快也会被发给所有的从库，进而导致所有从库的数据表也都一起被误删。  </p>
<p>延迟复制的备库是一种特殊的备库，通过change master to master_delay=n命令，可以执行这个备库持续保持跟主库有N秒的延迟。  </p>
<p>发现误删后，在备库上执行stop slave，在通过之前介绍的方法，跳过误操作命令，可以得到一个只延迟n秒就可以恢复出数据的临时实例。  </p>
<h3 id="预防误删库-表的方法"><a href="#预防误删库-表的方法" class="headerlink" title="预防误删库/表的方法"></a>预防误删库/表的方法</h3><h4 id="账号分离"><a href="#账号分离" class="headerlink" title="账号分离"></a>账号分离</h4><p>目的是避免写错命令  </p>
<ul>
<li>只给业务开发同学DML权限，而不给truncate/drop权限。如果业务开发人员有DDL需求，可以通过开发管理系统得到支持。  </li>
<li>即使是DBA团队成员，日常也都规定只使用只读账号，必要的时候才使用有更新权限的账号。  </li>
</ul>
<p>show grants命令查看账户的权限。  </p>
<h4 id="指定操作规范"><a href="#指定操作规范" class="headerlink" title="指定操作规范"></a>指定操作规范</h4><p>目的是避免写错要删除的表名  </p>
<ul>
<li>在删除数据表之前，必须先对表做改名操作。然后，观察一段时间，确保对业务无影响以后再删除这张表。  </li>
<li>改表名的时候，要求给表名加固定的后缀(如_to_be_deleted)，然后删除表的动作必须通过管理系统执行。并且管理系统删除表的时候，只能删除固定后缀的表。  </li>
</ul>
<h3 id="rm删除数据"><a href="#rm删除数据" class="headerlink" title="rm删除数据"></a>rm删除数据</h3><p>高可用MySQL集群。不怕rm删除数据。只要不是恶意的把整个集群删除，而只是删掉了其中某一个节点的数据，HA系统会开始工作，选出一个新的主库，从而保证整个集群的正常工作。个人只需要在这个节点上把数据恢复回来，再接入整个集群。  </p>
<p>备份跨机房，跨城市保存。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>kill query threadId与kill [connection] threadId</title>
    <url>/MySQL/%20kill%20query%20threadId%E4%B8%8Ekill%20%5Bconnection%5D%20threadId/</url>
    <content><![CDATA[<p>在MySQL中有两个kill命令：一个是kill query +线程id，表示终止这个线程中正在执行的语句；一个是kill [connection] +线程id，表示断开这个线程的连接，如果这个线程有语句正在执行，是要先停止正在执行的语句的。  </p>
<p>有时使用了kill命令，却没能断开这个连接。再执行show processlist命令，看到这条语句的Command列显示的是Killed。  </p>
<p>大多数情况下，kill query/connection命令是有效的。  </p>
<ul>
<li>执行一个查询的过程中，发现执行时间太久，要放弃继续查询，可以用kill query命令，终止这条查询语句。  </li>
<li>语句处于锁等待的时候，直接使用kill命令。  </li>
</ul>
<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
<th>sessionC</th>
</tr>
</thead>
<tbody><tr>
<td>begin;</br>update t set c=c+1 where id=1;</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>update t set c=c+1 where id=1;</br>(blocked)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>ERROR 1317(70100):Query execution was interrupted</td>
<td>kill query thread_id_B;</td>
</tr>
</tbody></table>
<h3 id="收到kill以后，线程做什么"><a href="#收到kill以后，线程做什么" class="headerlink" title="收到kill以后，线程做什么"></a>收到kill以后，线程做什么</h3><p>当对一个表做增删改查操作时，会在表上加MDL读锁。sessionB虽然处于blocked状态，但还是拿着一个MDL读锁，如果线程被kill的时候，直接终止，那之后这个MDL读锁就没机会被释放了。  </p>
<p>kill并不是马上停止的意思，而是告诉执行线程说，这条语句已经不需要继续执行了，可以开始执行停止的逻辑了。  </p>
<blockquote>
<p>跟Linux的kill命令类似，kill -N pid并不是让进程直接停止，而是给进城发一个信号，然后进程处理这个信号，进入终止逻辑。只是对于MySQL的kill命令来说，不需要传信号量参数，就只有“停止”这个命令。  </p>
</blockquote>
<p>当用户执行kill query Thread_id_B时，MySQL里处理kill命令的线程做了两件事：  </p>
<ol>
<li>把sessionB的运行状态改成THD::KILL_QUERY(将变量killed赋值为THD::KILL_QUERY)；  </li>
<li>给sessionB的执行线程发一个信号。  <blockquote>
<p>sessionB处于锁等待状态，如果只是把sessionB的线程状态设置THD::KILL_QUERY，线程B并不知道这个状态变化，还是会继续等待。发一个信号的目的，就是让sessionB退出等待，来处理这个THD::KILL_QUERY状态。  </p>
</blockquote>
</li>
</ol>
<ul>
<li>一个语句执行过程中有多处“埋点”，在这些“埋点”的地方判断线程状态，如果发现线程状态时THD::KILL_QUERY，才开始进入语句终止逻辑；  </li>
<li>如果处于等待状态，必须是一个可以被唤醒的等待，否则根本不会执行到“埋点”处；  </li>
<li>语句从开始进入终止逻辑，到终止逻辑完全完成，是有一个过程的。  </li>
</ul>
<h3 id="kill-query无效"><a href="#kill-query无效" class="headerlink" title="kill query无效"></a>kill query无效</h3><p><a href="/MySQL/数据库异常状态判断">MySQL-数据库异常状态判断</a> 中innodb_thread_concurrency参数讲解，不够用例子。  </p>
<h4 id="线程没有执行到判断线程状态的逻辑"><a href="#线程没有执行到判断线程状态的逻辑" class="headerlink" title="线程没有执行到判断线程状态的逻辑"></a>线程没有执行到判断线程状态的逻辑</h4><p>执行set global innodb_thread_concurrency=2，将InnoDB的并发线程上限数设置为2；  </p>
<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
<th>sessionC</th>
<th>sessionD</th>
<th>sessionE</th>
</tr>
</thead>
<tbody><tr>
<td>select sleep(100) from t;</td>
<td>select sleep(100) from t;</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>select * from t;</br>(blocked)</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>kill query C;</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>ERROR 2013(HY000):Lost connection to MySQL server during query</td>
<td></td>
<td>kill C;</td>
</tr>
</tbody></table>
<ol>
<li>sessionC执行的时候被堵住了；  </li>
<li>但是sessionD执行的kill query C命令却没什么效果；  </li>
<li>直到sessionE执行了kill connection命令，才断开了sessionC的连接，提示”Lost connection to MySQL server during query”；  </li>
<li>但是这时，如果在sessionE中执行show processlist，展示的sessionC对应的线程的Command列显示的是Killed。客户端虽然断开了连接，但实际上服务端上这条语句还在执行过程中。  </li>
</ol>
<p>对比：<br>在实现上，例子1中update语句等行锁时，使用的是pthread_cond_timedwait函数，这个等待状态可以被唤醒。但是例子2，sessionC对应的线程等待逻辑是这样的，每10毫秒判断一下是否可以进入InnoDB执行，如果不行，就调用nanosleep函数进入sleep状态。  </p>
<p>虽然sessionC对应的线程的状态已经被设置成了KILL_QUERY，但是在这个等待进入InnoDB的循环过程中，并没有去判断线程的状态，因此根本不会进入终止逻辑阶段。  </p>
<p>当sessionE执行kill connection命令时：  </p>
<ol>
<li>把sessionC对应的线程状态设置为KILL_CONNECTION；  </li>
<li>关掉sessionC对应线程的网络连接。因为这个操作，可以看到此时sessionC收到了断开连接的提示。  </li>
</ol>
<p><strong>kill connection本质上只是把客户端的sql断开，后面的执行流程还是要走kill query的。另外执行show processlist时，有一个特别的逻辑：如果一个线程的状态时KILL_CONNECTION，就把Command列显示成killed。</strong>  </p>
<p>即使是客户端退出了，这个线程的状态仍然是在等待中。<br>只有等待满足进入InnoDB的条件后，sessionC的查询语句继续执行，然后才有可能判断到线程状态已经变成了kill_query或者kill_connection，再进入终止逻辑阶段。  </p>
<p>其他情况：<br>IO压力过大，读写IO的函数一直无法返回，导致不能及时判断线程的状态。  </p>
<h4 id="终止逻辑耗时较长"><a href="#终止逻辑耗时较长" class="headerlink" title="终止逻辑耗时较长"></a>终止逻辑耗时较长</h4><p>从show processlist结果上看是Command=killed，需要等到终止逻辑完成，语句才算真正完成。  </p>
<ol>
<li>超大事务执行期间被kill。这时，回滚操作需要对事务执行期间生成的所有新数据版本做回收操作，耗时很长。  </li>
<li>大查询回滚。如果查询过程中生成了比较大的临时文件，加上此时文件系统压力大，删除临时文件可能需要等待IO资源，导致耗时较长。  </li>
<li>DDL命令执行到最后阶段，如果被kill，需要删除中间过程的临时文件，也可能受IO资源影响耗时较久。  </li>
</ol>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>要kill掉一个线程，涉及到后端的很多操作。<br><strong>发送kill命令的客户端，并没有强行停止目标线程的执行，只是设置了个状态，并唤醒对应的线程。而被kill的线程，需要执行到判断状态的“埋点”，才会开始进入终止逻辑阶段。并且，终止逻辑本身也是需要耗费时间的。导致出现“kill不掉”的情况。</strong>  </p>
<p>如果发现一个线程处于killed状态，可以通过影响系统环境，让整个killed状态尽快结束。  </p>
<ul>
<li>InnoDB并发度的问题，可以临时调大innodb_thread_concurrency的值，或者停掉别的线程，让出位子给这个线程执行。  </li>
<li>回滚逻辑由于受到IO资源限制执行得比较慢，通过减少系统压力让它加速。  </li>
</ul>
<p>其他情况只能等待流程自己完成。  </p>
<h3 id="Ctrl-C"><a href="#Ctrl-C" class="headerlink" title="Ctrl+C"></a>Ctrl+C</h3><p>直接在客户端通过Ctrl+C命令，不会直接终止线程。<br>在客户端的操作只能操作到客户端的线程，客户端和服务端只能通过网络交互，是不可能直接操作服务端线程的。  </p>
<p>由于MySQL是停等协议，所以这个线程执行的语句还没有返回的时候，再往这个连接里面继续发命令也是没有用的。实际上，执行Ctrl+C的时候，是MySQL客户端另外启动了一个连接，然后发送一个kill query命令。  </p>
<h3 id="关于客户端的其他误解"><a href="#关于客户端的其他误解" class="headerlink" title="关于客户端的其他误解"></a>关于客户端的其他误解</h3><h4 id="A参数-如果库里面的表特别多，连接就会很慢"><a href="#A参数-如果库里面的表特别多，连接就会很慢" class="headerlink" title="-A参数 如果库里面的表特别多，连接就会很慢"></a>-A参数 如果库里面的表特别多，连接就会很慢</h4><p>有些线上的库，会包含很多表。每次用客户端连接都会卡在界面上：  </p>
<blockquote>
<p>mysql -h127.0.0.1 -uu1 -pp1 db1<br>Reading table information for completion of table and column names<br>You can turn off this feature to get a quicker startup with -A  </p>
</blockquote>
<p>如果db1这个库里表很少的话，连接起来就会很快，可以很快进入输入命令的状态。误认为是表的数目影响了连接性能。  </p>
<p>每个客户端在和服务端建立连接的时候，需要做的事情就是TCP握手、用户校验、获取权限。但这几个操作，显然跟库中表的个数无关。  </p>
<p>实际上，当使用默认参数连接的时候，MySQL客户端会提供一个本地库名和表名补全的功能。为了实现这个功能，客户端连接成功后，需要多做一些操作：  </p>
<ol>
<li>执行show database；  </li>
<li>切到db1库，执行show tables；  </li>
<li>把这两个命令的结果用于构建一个本地的哈希表。  </li>
</ol>
<p>在这些操作中，最花时间的就是第三步在本地构建哈希表的操作，所以，当一个库中的表个数非常多的时候，这一步会花比较长的时间。<br>感知到的连接过程慢，并不是连接慢，也不是服务端慢，而是客户端慢。  </p>
<p>自动补全的效果就是，在输入库名或者表名的时候，输入前缀，可以使用Tab建自动补全表名或者显示提示。在连接命令中加上-A，可以关掉这个自动补全的功能。  </p>
<h4 id="quick参数"><a href="#quick参数" class="headerlink" title="-quick参数"></a>-quick参数</h4><p>除了加-A以外，加-quick(简写为-q)参数，也可以跳过这个阶段。  </p>
<p>设置了这个参数可能会降低服务端的性能。  </p>
<p>MySQL客户端发送请求后，接收服务端返回结果的方式有两种：  </p>
<ol>
<li>一种是本地缓存，也就是在本地开一片内存，先把结果存起来。如果用API开发，对应的就是mysql_store_result方法。  </li>
<li>一种是不缓存，读一个处理一个。如果用API开发，对应的就是mysql_use_result方法。  </li>
</ol>
<p>MySQL客户端默认采用第一种方式，而如果加上-quick参数，就会使用第二种不缓存的方式。采用不缓存的方式时，如果本地处理的很慢，就会导致服务端发送结果被阻塞，因此会让服务端变慢。  </p>
<p>quick参数的意思是让客户端变快：  </p>
<ol>
<li>跳过表名自动补全功能。  </li>
<li>mysql_store_result需要申请本地内存来缓存查询结果，如果查询结果太大，会耗费较多的本地内存，可能会影响客户端本地机器的性能。  </li>
<li>不会把执行命令记录到本地的命令历史文件。  </li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>全表扫描对内存的影响</title>
    <url>/MySQL/%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F%E5%AF%B9%E5%86%85%E5%AD%98%E7%9A%84%E5%BD%B1%E5%93%8D/</url>
    <content><![CDATA[<h3 id="全表扫描对server层的影响"><a href="#全表扫描对server层的影响" class="headerlink" title="全表扫描对server层的影响"></a>全表扫描对server层的影响</h3><p>对一个200G的InnoDB表db1.t，执行一个全表扫描，把扫描结果保存在客户端：  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql -h$host -P$port -u$user -p$pwd -e "<span class="keyword">select</span> * <span class="keyword">from</span> db1.t<span class="string">" &gt; $target_file</span></span><br></pre></td></tr></table></figure>

<p>InnoDB的数据是保存在主键索引上的，全表扫描实际上是直接扫描表t的主键索引。查询语句中没有其他的判断条件，查到的每一行都可以直接放到结果集里，然后返回给客户端。但服务端并不需要保存一个完整的结果集。  </p>
<p>服务端取数据和发数据的流程：  </p>
<ol>
<li>获取一行，写到net_buffer中，这块内存的大小是有参数net_buffer_length定义的，默认是16K。  </li>
<li>重复获取行，直到net_buffer写满，调用网络接口发出去。  </li>
<li>如果发送成功，就清空net_buffer，然后继续取下一行，并写入net_buffer。  </li>
<li>如果发送函数返回EAGAIN或者WSAEWOULDBLOCK，就表示本地网络栈(socket send buffer)写满了，进入等待(对应客户端Socket receive buffer)。直到网络栈重新可写，再继续发送。  </li>
</ol>
<ul>
<li>一个查询在发送过程中，占用的MySQL内部的内存最大就是net_buffer_length那么大。  </li>
<li>socket send buffer默认定义在/proc/sys/net/core/wmem_default。如果socket send buffer被写满，就会暂停读数据的流程。  </li>
</ul>
<h4 id="Sending-to-client"><a href="#Sending-to-client" class="headerlink" title="Sending to client"></a>Sending to client</h4><p><strong>MySQL是“边读边发的</strong>”。如果客户端接收的慢，会导致MySQL服务端由于结果发不出去，这个事务的执行时间变长。  </p>
<p>如果让客户端不去读socket receive buffer中的内容，在服务端show processlist看到State的值一致处于”<strong>Sending to client</strong>“，表示服务端的网络栈写满了。  </p>
<p>如果客户端使用-quick参数，会使用mysql_user_result方法。这个方法是读一行处理一行。假设有一个业务的逻辑比较复杂，每读一行数据以后要处理的逻辑如果很慢，就会导致客户端要过很久才会去取下一行数据，可能会出现上边服务端发送阻塞的情况。  </p>
<p>对于正常的线上业务来说，如果一个查询的返回结果不会很多的话，建议使用，mysql_store_result这个接口，直接把查询结果保存到本地内存。  </p>
<p>如果在自己负责维护的MySQL里看到很多个线程都处于“Sending to client”这个状态，就意味着需要业务开发优化查询结果，并评估这么多的返回结果是否合理。如果要快速减少处于这个状态的线程，将net_buffer_length参数设置为一个更大的值是一个可选的方案。  </p>
<h4 id="Sending-data"><a href="#Sending-data" class="headerlink" title="Sending data"></a>Sending data</h4><p>一个查询语句的状态变化：  </p>
<ul>
<li>MySQL查询语句进入执行阶段后，首先把状态设置成“Sending data”；  </li>
<li>然后，发送执行结果的列相关的信息(meta data)给客户端；  </li>
<li>再继续执行语句的流程；  </li>
<li>执行完成后，把状态设置成空字符串。  </li>
</ul>
<p>Sending data并不一定是指“正在发送数据”，而可能是出于执行器过程中的任意阶段。例如锁等待的场景。  </p>
<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
</tr>
</thead>
<tbody><tr>
<td>begin;</br>select * from t where id=1 for update;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>select * from t lock in share mode;</br>(blocked)</td>
</tr>
</tbody></table>
<p>sessionB是在等锁，但是show processlist命令中State列显示为Sending data。  </p>
<p>仅当一个线程处于“等待客户端接收结果”的状态，才会显示”Sending to client”；而如果显示成“Sending data”，它的意思只是“正在执行”。  </p>
<p>查询结果是分段发送给客户端的，扫描全表，查询返回大量的数据，不会在server端保存完整的结果集，即使客户端读结果不及时，会堵住MySQL的查询过程，但并不会把内存打爆。  </p>
<h3 id="全表扫描对InnoDB的影响"><a href="#全表扫描对InnoDB的影响" class="headerlink" title="全表扫描对InnoDB的影响"></a>全表扫描对InnoDB的影响</h3><p>内存的数据页是在Buffer Pool(BP)中管理的，在WAL中Buffer Pool起到了加速更新的作用(随机写磁盘-&gt;顺序写磁盘)。实际上，Buffer Pool还有一个更重要的作用，就是加速查询。  </p>
<p>当事务提交的时候，磁盘上的数据页是旧的，此时马上有一个查询来读这个数据页，不需要把redo log应用到数据页。这时内存数据页的结果时最新的，直接读内存页就可以了。这时候查询根本不需要读磁盘，直接从内存拿结果，速度是很快的。所以Buffer Pool还有加速查询的作用。  </p>
<p>Buffer Pool对查询的加速效果，依赖于一个重要指标：<strong>内存命中率</strong>。  </p>
<p>可以在show engine innodb status结果中，查看一个系统当前的BP命中率。一般情况下，一个稳定服务的线上系统，要保证响应时间符合要求的话，内存命中率要在99%以上。  </p>
<blockquote>
<p>Buffer pool hit rate 990/1000  </p>
</blockquote>
<p>InnoDB Buffer Pool的大小是由参数innodb_buffer_pool_size确定的，一般建议设置成可用物理内存的60%~80%。  </p>
<h4 id="LRU淘汰算法"><a href="#LRU淘汰算法" class="headerlink" title="LRU淘汰算法"></a>LRU淘汰算法</h4><p>innodb_buffer_pool_size小于磁盘的数据量是很常见的。如果一个Buffer Pool满了，而又要从磁盘读入一个数据页，那肯定是要淘汰一个旧数据页的(刷脏页)，大查询也不会导致内存暴涨。  </p>
<p>InnoDB内存管理用的是最近最少使用(Least Recently Used,LRU)算法，核心是淘汰最久未使用的数据。  </p>
<p>InnoDB管理Buffer Pool的LRU算法，是用链表来实现的。<br><a href="/数据结构与算法/链表">数据结构与算法-链表</a><br><a href="/数据结构与算法/散列表应用">数据结构与算法-散列表应用</a>  </p>
<h4 id="改进LRU算法"><a href="#改进LRU算法" class="headerlink" title="改进LRU算法"></a>改进LRU算法</h4><p>按照LRU算法，要扫描一个200G的表，而这个表是一个历史数据表，平时没有业务访问它。按照普通LRU算法扫描的话，就会把当前的Buffer Pool里的数据全部淘汰掉，存入扫描过程中访问到的数据页的内容。Buffer Pool里面主要放的是这个历史数据表的数据。  </p>
<p>对于一个正在做业务服务的库，Buffer Pool的内存命中率急剧下降，磁盘压力增加，SQL语句响应变慢。  </p>
<p>InnoDB对LRU算法做了改进：  </p>
<img src='/img/MySQL改进LRU算法.png'>

<p>InnoDB实现上，按照5:3的比例把整个LRU链表分成了young区域和old区域。图中LRU_old指向的就是old区域的第一个位置，是整个链表的5/8处。靠近链表头部的5/8是young区域，靠近链表尾部的3/8是old区域。  </p>
<p>改进后的LRU算法执行流程：  </p>
<ol>
<li>状态1，要访问数据页P3，由于P3在young区域，因此和优化前的LRU算法一样，将其移到链表头部，变成状态2。  </li>
<li>之后要访问一个新的不存在于当前链表的数据页，这时候依然是淘汰掉数据页Pm，但新插入的数据页Px，是放在LRU_old处。  </li>
<li>处于old区域的数据页，每次被访问的时候都要做下面的判断：  <ul>
<li>若这个数据页在LRU链表中存在的时间超过了1秒，就把它移动到链表头部；  </li>
<li>如果这个数据页在LRU链表中存在的时间短于1秒，位置保持不变。1秒这个时间，是由参数innodb_old_blocks_times控制的，其默认值是1000，单位毫秒。  </li>
</ul>
</li>
</ol>
<p>这个策略，就是为了处理类似全表扫描的操作量身定制的。  </p>
<ol>
<li>扫描过程中，需要新插入的数据页，都被放到old区域；  </li>
<li>一个数据页里面有多条记录，这个数据页会被多次访问到，但由于是顺序扫描，这个数据页第一次被访问和最后一次被访问的时间间隔不会超过1秒，因此还是会被保留在old区域；  </li>
<li>再继续扫描后续的数据，之前的这个数据页之后也不会再被访问到，于是始终没有机会移动到链表头部(young区域)，很快就会被淘汰出去。  </li>
</ol>
<p>这个策略最大的收益，就是在扫描大表的过程中，即使是冷数据的全表扫描，虽然也用到了Buffer Pool，但是对young区域完全没有影响，从而保证了Buffer Pool响应正常业务的查询命中率。  </p>
<blockquote>
<p>全表扫描比较耗费IO资源，业务高峰期不能直接在线上主库执行全表扫描。  </p>
</blockquote>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>join执行原理</title>
    <url>/MySQL/join%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        示例表
    </div>
    <div class='spoiler-content'>
        <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">'t2'</span> (</span><br><span class="line">    <span class="string">'id'</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="string">'a'</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="string">'b'</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line">    primary <span class="keyword">key</span> (<span class="string">'id'</span>),<span class="comment">-- 主键索引</span></span><br><span class="line">    <span class="keyword">key</span> <span class="string">'a'</span> (<span class="string">'a'</span>)<span class="comment">-- 普通索引</span></span><br><span class="line">) <span class="keyword">engine</span>=<span class="keyword">innodb</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入t2表1000行数据</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> idata;</span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span> </span><br><span class="line">    <span class="keyword">declare</span> i <span class="built_in">int</span>;</span><br><span class="line">    <span class="keyword">set</span> i=<span class="number">1</span>;</span><br><span class="line">    while(i&lt;=1000) do</span><br><span class="line">        <span class="keyword">insert</span> <span class="keyword">into</span> t2 <span class="keyword">values</span>(i,i,i);</span><br><span class="line">        <span class="keyword">set</span> i=i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> idata();</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1 <span class="keyword">like</span> t2;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 (<span class="keyword">select</span> * <span class="keyword">from</span> t2 <span class="keyword">where</span> <span class="keyword">id</span>&lt;=<span class="number">100</span>)</span><br><span class="line"><span class="comment">-- 插入t1表100行数据</span></span><br></pre></td></tr></table></figure>
    </div>
</div>  

<h3 id="Index-Nested-Loop-Join"><a href="#Index-Nested-Loop-Join" class="headerlink" title="Index Nested-Loop Join"></a>Index Nested-Loop Join</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">straight_join</span> t2 <span class="keyword">on</span>(t1.a=t2.a);</span><br></pre></td></tr></table></figure>

<p>如果直接使用join语句，MySQL优化器可能会选择表t1或t2作为驱动表，这样会影响分析SQL语句的执行过程。使用straight_join让MySQL使用固定的连接方式执行查询，优化器只会按照指定的方式去join。上述语句，t1是驱动表，t2是被驱动表。  </p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>partitions</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>filtered</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>simple</td>
<td>t1</td>
<td>null</td>
<td>all</td>
<td>a</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>100</td>
<td>100.00</td>
<td>Using where</td>
</tr>
<tr>
<td>1</td>
<td>simple</td>
<td>t2</td>
<td>null</td>
<td>ref</td>
<td>a</td>
<td>a</td>
<td>5</td>
<td>test.t1.a</td>
<td>1</td>
<td>100.00</td>
<td>null</td>
</tr>
</tbody></table>
<p>被驱动表t2的字段a上有索引，join过程用上了这个索引。  </p>
<ol>
<li>从表t1中读入一行数据R；  </li>
<li>从数据行R中，取出a字段到表t2里去查找；  </li>
<li>取出表t2中满足条件的行，跟R组成一行，作为结果集的一部分；  </li>
<li>重复执行步骤1到3，直到表t1的末尾循环结束。  </li>
</ol>
<p>这个过程是先遍历表t1，然后根据表t1中取出的每行数据中的a值，去表t2中查找满足条件的记录。在形式上，这个过程跟写程序时的嵌套查询类似，并且可以用上被驱动表的索引，称之为”Index Nested-Loop Join”，简称NLJ。  </p>
<img src='/img/MySQL Index Nested-Loop Join算法执行流程.jpg'>

<ol>
<li>对驱动表t1做了全表扫描，这个过程需要扫描100行；  </li>
<li>而对于每一行R，根据a字段去表t2查找，走的是树搜索过程。由于插入的数据都是一一对应的，因此每次的扫描过程都只扫描一行，总共扫描100行。  </li>
<li>整个执行流程，总扫描行数是200。  </li>
</ol>
<h4 id="不使用join"><a href="#不使用join" class="headerlink" title="不使用join"></a>不使用join</h4><p>假设不使用join，只能用单表查询。  </p>
<ol>
<li>执行select * from t1，查出表t1的所有数据，这里有100行。  </li>
<li>循环遍历这100行数据：  <ul>
<li>从每一行R取出字段a的值$R.a；  </li>
<li>执行select * from t2 where a=$R.a；  </li>
<li>把返回的结果和R构成结果集的一行。  </li>
</ul>
</li>
</ol>
<p>这个查询过程，扫描了200行，但是总共执行了101条语句，比直接join多了100次交互。除此之外，客户端还要自己拼接SQL语句和结果。  </p>
<h4 id="驱动表选择"><a href="#驱动表选择" class="headerlink" title="驱动表选择"></a>驱动表选择</h4><p>示例join语句执行过程中，驱动表是走全表扫描，被驱动表是走树搜索。  </p>
<p>假设被驱动表的行数是M。每次在被驱动表查一行数据，要先搜索索引a，再搜索主键索引。每次搜索一棵树近似复杂度是以2为底的M的对数，记为log<sub>2</sub>M，在被驱动表上查一行的时间复杂度是2*log<sub>2</sub>M。  </p>
<p>假设驱动表的行数是N，执行过程就要扫描驱动表N行，然后对于每一行，到被驱动表上匹配一次。整个执行过程，近似复杂度是N+N*2*log<sub>2</sub>M。显然N对扫描函数的影响更大，因此应该让小表来做驱动表。  </p>
<blockquote>
<p>N扩大1000倍，扫描行数就扩大1000倍；M扩大1000倍，扫描行数扩大不到10倍。  </p>
</blockquote>
<hr>
<ul>
<li>使用join语句，性能比强行拆成多个单表执行SQL语句的性能要好；  </li>
<li>如果使用join语句的话，需要让小表做驱动表。前提是可以使用被驱动表的索引。  </li>
</ul>
<h3 id="Simple-Nested-Loop-Join"><a href="#Simple-Nested-Loop-Join" class="headerlink" title="Simple Nested-Loop Join"></a>Simple Nested-Loop Join</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">straight_join</span> t2 <span class="keyword">on</span> (t1.a=t2.b);</span><br></pre></td></tr></table></figure>

<p>由于表t2的字段b上没有索引，每次到t2去匹配的时候，就要做一次全表扫描。这个SQL请求需要扫描表t2多达100次，总共扫描100*1000=10万行。  </p>
<h3 id="Block-Nested-Loop-Join"><a href="#Block-Nested-Loop-Join" class="headerlink" title="Block Nested-Loop Join"></a>Block Nested-Loop Join</h3><p>被驱动表上没有可用的索引，算法流程：  </p>
<ol>
<li>把表t1的数据读入线程内存join_buffer中，由于语句中写的是select *，因此是把整个表t1放入了内存；  </li>
<li>扫描表t2，把表t2中的每一行取出来，跟join_buffer中的数据做对比，满足join条件的，作为结果集的一部分返回。  </li>
</ol>
<img src='/img/MySQL Block Nested-Loop Join算法执行流程.jpg'>

<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>partitions</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>filtered</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>simple</td>
<td>t1</td>
<td>null</td>
<td>all</td>
<td>a</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>100</td>
<td>100.00</td>
<td>null</td>
</tr>
<tr>
<td>1</td>
<td>simple</td>
<td>t2</td>
<td>null</td>
<td>all</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>1000</td>
<td>10.00</td>
<td>Using where;Using join buffer(Block Nested Loop)</td>
</tr>
</tbody></table>
<p>在这个过程中，对t1和t2都做了一次全表扫描，总的扫描行数是1100。由于join_buffer是以<strong>无序数组</strong>的方式组织的，因此对表t2中的每一行，都要做100次判断，总共需要在内存中做的判断次数是:100*1000=10万次。  </p>
<p>如果使用Simple Nested-Loop Join算法进行查询，扫描行数也是10万行。从时间复杂度上说，两个算法是一样的。但是Block Nested-Loop Join算法的10万次判断是内存操作，速度上会快很多，性能也更好。  </p>
<p>假设小表的行数是N，大表的行数是M：  </p>
<ol>
<li>两个表都做一次全表扫描，所以总的扫描行数是M+N；  </li>
<li>内存中的判断次数是M*N。  </li>
</ol>
<p>调换这两个算式中的M和N没差别，此时选择大表还是小表做驱动表，执行耗时是一样的。  </p>
<h4 id="join-buffer"><a href="#join-buffer" class="headerlink" title="join_buffer"></a>join_buffer</h4><p>join_buffer的大小是由参数join_buffer_size设定的，默认值是256k。如果放不下表t1的所有数据，就分段放。(join_buffer_size设置为1200)</p>
<ol>
<li>扫描表t1，顺序读取数据行放入join_buffer中，放完第88行join_buffer满了，继续第2步；  </li>
<li>扫描表t2，把t2中的每一行取出来，跟join_buffer中的数据做对比，满足join条件的，作为结果集的一部分返回；  </li>
<li>清空join_buffer；  </li>
<li>继续扫描表t1，顺序读取最后的12行数据放入join_buffer中，继续执行第2步。  </li>
</ol>
<p>算法中的“Block”表示分块去join。由于表t1被分成了两次放入join_buffer中，导致表t2会被扫描两次。虽然分成两次放入join_buffer，但是判断等值条件的次数是不变的，依然是(88+12)*1000=10万次。  </p>
<h4 id="驱动表选择-1"><a href="#驱动表选择-1" class="headerlink" title="驱动表选择"></a>驱动表选择</h4><p>假设驱动表的数据行数是N，需要分K段(N越大K就会越大，表示为λ*N，λ取值范围0-1)才能完成算法流程，被驱动表的数据行数是M。  </p>
<ol>
<li>扫描函数是N+λ<em>N</em>M；  </li>
<li>内存判断N*M次。  </li>
</ol>
<p>内存判断次数是不受选择哪个表作为驱动表影响的。考虑到扫描行数，在M和N大小确定的情况下，N小一些，整个算式的结果会更小。应该让小表做驱动表。  </p>
<p>在N+λ*N*M这个式子中，λ是影响扫描行数的关键因素，这个值越小越好。  </p>
<p>N越大，分段数K越大。N固定的时候，λ(join_buffer_size)影响K的大小。join_buffer_size越大，一次可以放入的行越多，分成的段数也越小，对被驱动表的全表扫描次数就越少。所以，如果join语句很慢，就把join_buffer_size改大。  </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="使用join语句"><a href="#使用join语句" class="headerlink" title="使用join语句"></a>使用join语句</h4><ol>
<li>如果可以使用Index Nested-Loop Join算法，也就是说<strong>可以用上被驱动表上的索引</strong>，是没问题的；  </li>
<li>如果使用Block Nested-Loop Join算法，扫描的行数就会过多。尤其是在大表上的join操作，可能要扫描被驱动表很多次，会占用大量的系统资源。这种join尽量不要用。  </li>
</ol>
<p>在判断要不要使用join语句时，就是看explain结果里面，Extra字段里面有没有出现”Block Nested Loop”字样。  </p>
<h4 id="选择驱动表"><a href="#选择驱动表" class="headerlink" title="选择驱动表"></a>选择驱动表</h4><ol>
<li>如果是Index Nested-Loop Join算法，应该选择小表做驱动表；  </li>
<li>如果是Block Nested-Loop Join算法：  <ul>
<li>在join_buffer_size足够大的时候，是一样的；  </li>
<li>在join_buffer_size不够大的时候(需要对驱动表分块，对被驱动表做多次全表扫描)，应该选择小表做驱动表。</li>
</ul>
</li>
</ol>
<p>总体结论，应该使用小表做驱动表。  </p>
<h5 id="“小表”解析"><a href="#“小表”解析" class="headerlink" title="“小表”解析"></a>“小表”解析</h5><p>示例1：  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">straight_join</span> t2 <span class="keyword">on</span> (t1.b=t2.b) <span class="keyword">where</span> t2.id&lt;=<span class="number">50</span>;  </span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t2 <span class="keyword">straight_join</span> t1 <span class="keyword">on</span> (t1.b=t2.b) <span class="keyword">where</span> t2.id&lt;=<span class="number">50</span>;</span><br></pre></td></tr></table></figure>

<p>第二个语句，join_buffer只需要放入t2的前50行，是相对较小的表。  </p>
<p>示例2：  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> t1.b,t2.* <span class="keyword">from</span> t1 <span class="keyword">straight_join</span> t2 <span class="keyword">on</span> (t1.b=t2.b) <span class="keyword">where</span> t2.id&lt;=<span class="number">100</span>;  </span><br><span class="line"><span class="keyword">select</span> t1.b,t2.* <span class="keyword">from</span> t2 <span class="keyword">straight_join</span> t1 <span class="keyword">on</span> (t1.b=t2.b) <span class="keyword">where</span> t2.id&lt;=<span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>两个语句中，表t1和t2都是只有100行参加join，但是每次查询放入join_buffer中的数据是不一样的：  </p>
<ul>
<li>表t1只查字段b，因此如果把t1放到join_buffer中，则join_buffer中只需要放入b的值；  </li>
<li>表t2需要查所有的字段，因此如果把表t2放到join_buffer中，就需要放入三个字段id、a和b。  </li>
</ul>
<p>只需要一列参与join的表t1是相对较小的表。  </p>
<p>两个表按照各自的条件过滤，过滤完成之后，计算参与join的各个字段的总数据量，数据量小的那个表，就是小表，应该作为驱动表。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>内存表Memory</title>
    <url>/MySQL/%E5%86%85%E5%AD%98%E8%A1%A8Memory/</url>
    <content><![CDATA[<h3 id="内存表的数据组织结构"><a href="#内存表的数据组织结构" class="headerlink" title="内存表的数据组织结构"></a>内存表的数据组织结构</h3><p>InnoDB和Memory引擎的数据组织方式是不同的：  </p>
<ul>
<li>InnoDB引擎把数据放在主键索引树上，其他索引上保存的是主键id。称为索引组织表(Index Organizied Table)。  </li>
<li>Memory引擎采用的是把数据以数组的方式单独存放，索引上保存数据位置的数据组织形式。称为堆组织表(Heap Organizied Table)。  </li>
</ul>
<p>其他不同：  </p>
<ol>
<li>InnoDB表的数据总是有序存放的，而内存表的数据是按照写入顺序存放的；(内存表的主键索引是哈希索引，如果执行范围查询，是用不上主键索引的，需要走全表扫描)  </li>
<li>当数据文件有空洞的时候，InnoDB表在插入新数据的时候，为了保证数据有序性，只能在固定的位置写入新值，而内存表找到空位就可以插入新值；(内存表，每个数据行被删除以后，空出的这个位置都可以被接下来要插入的数据复用)  </li>
<li>数据位置发生变化的时候，InnoDB表只需要修改主键索引，而内存表需要修改所有索引；  </li>
<li>InnoDB表用主键索引查询时需要走一次索引查找，用普通索引查询的时候，需要走两次索引查找。而内存表没有这个区别，所有索引的“地位”都是相同的；  </li>
<li>InnoDB支持变长数据累心，不同记录的长度可能不同；内存表不支持Blob和Text字段，并且即使定义了varchar(N)，实际也当作char(N)，也就是固定长度字符串来存储，因此内存表的每行数据长度相同。  </li>
</ol>
<h3 id="hash索引和B-Tree索引"><a href="#hash索引和B-Tree索引" class="headerlink" title="hash索引和B-Tree索引"></a>hash索引和B-Tree索引</h3><p>内存表也是支持B-tree索引的。跟InnoDB的b+树索引组织形式类似。在id列上创建一个B-Tree索引：  </p>
<blockquote>
<p>alter table t1 add index a_btree_index using btree(id);  </p>
</blockquote>
<p>执行select * from t1 where id&lt;5的时候，优化器会选择B-Tree索引，返回结果是0到4。使用force index强行使用主键id索引select * from t1 force index(primary) where id&lt;5，id=0这一行就不一定在结果集的第一个了(与插入顺序有关)。  </p>
<p>内存表的优势是速度快，其中一个原因是Memory引擎支持hash索引；更重要的原因是，内存表的所有数据都保存在内存，内存的读写速度总是比磁盘块。  </p>
<p>由于1锁粒度问题；2数据持久化问题。不建议在生产环境上使用内存表。  </p>
<h3 id="内存表的锁"><a href="#内存表的锁" class="headerlink" title="内存表的锁"></a>内存表的锁</h3><p>内存表不支持行锁，只支持表锁。一张表只要有更新，就会堵住其他所有在这个表上的读写操作。这里的表锁与MDL锁不同，但都是表级的锁。  </p>
<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
<th>sessionC</th>
</tr>
</thead>
<tbody><tr>
<td>update t1 set id=sleep(50) where id=1;</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>select * from t1 where id=2;</br>(wait 50s)</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>show processlist;</td>
</tr>
</tbody></table>
<p>在这个执行序列里，sessionA的update语句要执行50秒，在这个语句执行期间sessionB的查询会进入锁等待状态。  </p>
<table>
<thead>
<tr>
<th>id</th>
<th>user</th>
<th>host</th>
<th>db</th>
<th>command</th>
<th>time</th>
<th>state</th>
<th>info</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>root</td>
<td>localhost:xxxxx</td>
<td>test</td>
<td>query</td>
<td>3</td>
<td>user sleep</td>
<td>update t1 set id=sleep(50) where id=1</td>
</tr>
<tr>
<td>2</td>
<td>root</td>
<td>localhost:yyyyy</td>
<td>test</td>
<td>query</td>
<td>1</td>
<td>waiting for table level lock</td>
<td>select * from t1 where id=2</td>
</tr>
<tr>
<td>3</td>
<td>root</td>
<td>localhost:zzzzz</td>
<td>test</td>
<td>query</td>
<td>0</td>
<td>starting</td>
<td>show processlist</td>
</tr>
</tbody></table>
<p>跟行锁比起来，表锁对并发访问的支持不够好。内存表的锁粒度问题，决定了它在处理并发事务的时候，性能也不会好。  </p>
<h3 id="数据持久性问题"><a href="#数据持久性问题" class="headerlink" title="数据持久性问题"></a>数据持久性问题</h3><p>数据库重启的时候，所有的内存表都会被清空。  </p>
<h4 id="M-S架构"><a href="#M-S架构" class="headerlink" title="M-S架构"></a>M-S架构</h4><ol>
<li>业务正常访问主库；  </li>
<li>备库硬件升级，备库重启，内存表t1内容被清空；  </li>
<li>备库重启后，客户端发送一条update语句，修改表t1的数据行，备库的应用线程报错“找不到要更新的行”。  </li>
</ol>
<p>导致主备同步停止。这时发生主备切换的话，客户端会看到，表t1的数据“丢失”了。在右proxy的架构里，默认主备切换的逻辑是由数据库系统自己维护的，对客户端来说，就是“网络断开，重连之后，发现内存表数据丢失了”。  </p>
<p>由于MySQL直到重启之后，内存表的数据会丢失。担心主库重启之后，出现主备不一致，MySQL在实现上：在数据库重启之后，往binlog里面写入一行delete from t1。  </p>
<h4 id="双M结构"><a href="#双M结构" class="headerlink" title="双M结构"></a>双M结构</h4><p>在备库重启的时候，备库binlog里的delete语句就会传到主库，然后把主库内存表的内容删除。客户端在使用的时候发现，主库的内存表数据突然被清空了。  </p>
<h3 id="Memory与InnoDB选择"><a href="#Memory与InnoDB选择" class="headerlink" title="Memory与InnoDB选择"></a>Memory与InnoDB选择</h3><p>内存表并不适合在生产环境上作为普通数据表使用。普通内存表都用InnoDB表来代替：  </p>
<ol>
<li>如果表更新量很大，那么并发度是一个很重要的参考指标，InnoDB支持行锁，并发度比内存表好；  </li>
<li>能放到内存表的数据量都不大。如果考虑的是读的性能，一个QPS很高并且数据量不大的表，即使是使用InnoDB，数据也是都会缓存在InnoDB Buffer Pool里的，使用InnoDB表的读性能也不会差。  </li>
</ol>
<p>在数据量可控，不会耗费过多内存的情况下，可以考虑使用内存临时表。<a href="/MySQL/用户临时表简析">MySQL-用户临时表简析</a>  </p>
<p>内存临时表可以无视内存表的两个不足：  </p>
<ol>
<li>临时表不会被其他线程访问，没有并发性的问题；  </li>
<li>临时表重启后也是需要删除的，清空数据这个问题不存在；  </li>
<li>备库的临时表也不会影响主库的用户线程。  </li>
</ol>
<hr>
<p>示例：<a href="/MySQL/join语句优化">MySQL-join语句优化</a>  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">temporary</span> <span class="keyword">table</span> temp_t(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>, a <span class="built_in">int</span>, b <span class="built_in">int</span>, <span class="keyword">index</span>(b))<span class="keyword">engine</span>=<span class="keyword">innodb</span>;  </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> temp_t <span class="keyword">select</span> * <span class="keyword">from</span> t2 <span class="keyword">where</span> b&gt;=<span class="number">1</span> <span class="keyword">and</span> b&lt;=<span class="number">2000</span>;  </span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">join</span> temp_t <span class="keyword">on</span> (t1.b=temp_t.b);</span><br></pre></td></tr></table></figure>

<ol>
<li>相比于InnoDB表，使用内存表不需要写磁盘，往表temp_t里写数据的速度更快；  </li>
<li>索引b使用hash索引，查找的速度比B-Tree索引快；  </li>
<li>临时表数据只有2000行，占用的内存有限。  </li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 将临时表temp_t改成内存临时表，并且在字段b上创建一个hash索引。(如果是范围查找，依然需要创建b-tree索引)  </span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">temporary</span> <span class="keyword">table</span> temp_t(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>, a <span class="built_in">int</span>, b <span class="built_in">int</span>, <span class="keyword">index</span>(b))<span class="keyword">engine</span>=<span class="keyword">memory</span>;  </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> temp_t <span class="keyword">select</span> * <span class="keyword">from</span> t2 <span class="keyword">where</span> b&gt;=<span class="number">1</span> <span class="keyword">and</span> b&lt;=<span class="number">2000</span>;  </span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">join</span> temp_t <span class="keyword">on</span> (t1.b=temp_t.b);  </span><br><span class="line"><span class="comment">-- 不论是导入数据的时间，还是执行join的时间，使用内存Memory临时表的速度都比使用InnoDB临时表要更快些。</span></span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>join语句优化</title>
    <url>/MySQL/join%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        示例表
    </div>
    <div class='spoiler-content'>
        <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>, a <span class="built_in">int</span>, b <span class="built_in">int</span>, <span class="keyword">index</span>(a));  </span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2 <span class="keyword">like</span> t1;  </span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> idata;  </span><br><span class="line">delimiter ;;  </span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> i <span class="built_in">int</span>;</span><br><span class="line">    <span class="keyword">set</span> i=<span class="number">1</span>;</span><br><span class="line">    while(i&lt;=1000) do</span><br><span class="line">        <span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>(i, <span class="number">1001</span>-i, i);</span><br><span class="line">        <span class="keyword">set</span> i=i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">while</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> i=<span class="number">1</span>;</span><br><span class="line">    while(i&lt;=1000000)do</span><br><span class="line">        <span class="keyword">insert</span> <span class="keyword">into</span> t2 <span class="keyword">values</span>(i, i, i);</span><br><span class="line">        <span class="keyword">set</span> i=i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> idata();</span><br><span class="line"><span class="comment">-- 表t1插入1000行数据，字段a是逆序的；t2中插入了100万行数据。</span></span><br></pre></td></tr></table></figure>
    </div>
</div>  

<h3 id="Multi-Range-Read-MRR-优化"><a href="#Multi-Range-Read-MRR-优化" class="headerlink" title="Multi-Range Read(MRR)优化"></a>Multi-Range Read(MRR)优化</h3><p>MRR优化的主要目的是尽量使用顺序读盘。  </p>
<p>回表是指，InnoDB在普通索引a上查到主键id的值后，再根据一个个主键id的值到主键索引上去查整行数据的过程。  </p>
<p>主键索引是一棵B+树，在这棵树上，每次只能根据一个主键id查到一行数据。因此回表是一行行搜索主键索引的。  </p>
<blockquote>
<p>select * from t1 where a&gt;=1 and a&lt;=100;  </p>
</blockquote>
<p>如果随着a的值递增顺序查询的话，id的值就变成随机的，那么就会出现随机访问，性能相对较差。虽然“按行查”这个机制不能改，但是调整查询的顺序，还是能够加速的。  </p>
<p><strong>大多数的数据都是按照主键递增顺序插入得到的，可以认为，按照主键递增顺序查询的话，对磁盘的读比较接近顺序读，能够提升性能。</strong>MRR优化的设计思路。  </p>
<ol>
<li>根据索引a，定位到满足条件的记录，将id值放入read_rnd_buffer中；  </li>
<li>将read_ran_buffer中的id进行递增排序；  </li>
<li>排序后的id数组，依次到主键id索引中查记录，并作为结果返回。  </li>
</ol>
<p>read_rnd_buffer的大小是由read_rnd_buffer_size参数控制的。如果步骤1中，read_rnd_buffer放满了，就会先执行完步骤2和3，然后清空read_rnd_buffer。之后继续找索引a的下个记录，并继续循环。  </p>
<p>如果想要稳定的使用MRR优化，需要设置set optimizer_switch=”mrr_cost_based=off”。(优化器策略，判断消耗的时候，会更倾向于不使用MRR)  </p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>partitions</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>filtered</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>simple</td>
<td>t2</td>
<td>null</td>
<td>range</td>
<td>a</td>
<td>a</td>
<td>5</td>
<td>null</td>
<td>101</td>
<td>100.00</td>
<td>Using index condition;Using MRR</td>
</tr>
</tbody></table>
<p>explain结果中，Extra字段的Using MRR，表示用上了MRR优化。而且由于在read_rnd_buffer中按照id做了排序，所以最后得到的结果集也是按照主键id递增的。  </p>
<p>MRR能够提升性能的核心在于，这条<strong>查询语句在索引a上做的是一个范围查询(多值查询)，可以得到足够多的主键id</strong>。这样<strong>通过排序以后，再去主键索引查数据</strong>，才能体现出“顺序性”的优势。(注意MRR优化是按照主键id排序，如果语句使用了索引a，结果还要对a排序，就不使用MRR优化了，否则回表完还要增加额外的排序过程，得不偿失)  </p>
<h3 id="Batched-Key-Access"><a href="#Batched-Key-Access" class="headerlink" title="Batched Key Access"></a>Batched Key Access</h3><p>MySQL在5.6版本后引入Batched Key Access(BKA)算法。BKA算法是对NLJ(Index Nested-Loop Join)算法的优化。  </p>
<p>NLJ算法执行的逻辑是：从驱动表t1，一行行的取出a的值，再到被驱动表t2去做join。对于表t2来说，每次都是匹配一个值。MRR的优势就用不上了。  </p>
<p>从表t1里 一次性的多拿些行出来，先放到一个临时内存-join_buffer中。join_buffer在BNL算法里的作用，是暂存驱动表的数据，在NLJ算法中并没有用，可以复用join_buffer到BKA算法中。  </p>
<p>如果要使用BKA优化算法，需要先设置set optimizer_switch=’mrr=on,mrr_cost_based=off,batched_key_access=on’。（BKA算法的优化依赖于MRR）  </p>
<h3 id="BNL算法的性能问题"><a href="#BNL算法的性能问题" class="headerlink" title="BNL算法的性能问题"></a>BNL算法的性能问题</h3><p>使用Block Nested-Loop Join(BNL)算法时，可能会对被驱动表做多次扫描。如果被驱动表是一个大的冷数据表，会导致IO压力大。  </p>
<p>InnoDB对Buffer Pool的LRU算法做了优化：第一次从磁盘读入内存的数据页，会先放在old区域，如果1秒之后这个数据页就不再被访问了，就不会被移动到LRU链表头部，这样对Buffer Pool的命中率影响不大。  </p>
<p>但是如果一个使用BNL算法的join语句，多次扫描一个冷表，而且这个语句执行时间超过1秒，就会在再次扫描冷表的时候，把冷表的数据页移到LRU链表头部。(冷表的数据量小于整个Buffer Pool的3/8，能够完全放入old区域)。如果冷表很大，业务正常访问的数据页，没有机会进入young区域。  </p>
<p>由于优化机制的存在，一个正常访问的数据页，要进入young区域，需要隔一秒后再次被访问到。但是，由于join语句在循环读磁盘和淘汰内存页，进入old区域的数据页，很可能在1秒之内就被淘汰了。这样会导致这个MySQL实例的Buffer Pool在这段时间内，young区域的数据页没有被合理的淘汰掉。  </p>
<p>以上两种情况都会影响Buffer Pool的正常运作。  </p>
<p><strong>大表join操作虽然对IO有影响，但是在语句执行结束后，对IO的影响也就结束了。但是，对Buffer Pool的影响就是持续性的，需要依靠后续的查询请求慢慢恢复内存命中率。</strong>  </p>
<p>解决方案：增大join_buffer_size的值，减少对被驱动表的扫描次数。  </p>
<p>BNL算法对系统的影响包括三个方面：  </p>
<ol>
<li>可能会多次扫描被驱动表，占用磁盘IO资源；  </li>
<li>判断join条件需要执行M*N次对别(M、N分别是两张表的行数)，如果是大表就会占用非常多的CPU资源；  </li>
<li>可能会导致Buffer Pool的热数据被淘汰，影响内存命中率。  </li>
</ol>
<p>执行语句之前，需要通过理论分析和查看explain结果的方式，确认是否要使用BNL算法。如果确认优化器会使用BNL算法，就需要做优化。优化的常见做法：给被驱动表的join字段加上索引，把BNL算法转成BKA算法。  </p>
<h4 id="BNL转BKA"><a href="#BNL转BKA" class="headerlink" title="BNL转BKA"></a>BNL转BKA</h4><p>一些情况下，可以直接在被驱动表上建索引，这时就可以直接转成BKA算法了。  </p>
<blockquote>
<p>select * from t1 join t2 on(t1.b=t2.b) where t2.b&gt;=1 and t2.b&lt;=2000;  </p>
</blockquote>
<p>t2表中插入了100万行数据，但是经过where条件过滤后，需要参与join的只有2000行数据。这条语句同时是一个低频的SQL语句，为这个语句在表t2的字段b上创建一个索引很浪费。  </p>
<p>使用BNL算法来join的执行流程：  </p>
<ol>
<li>把表t1的所有字段取出来，存入join_buffer中。这个表只有1000行，join_buffer_size默认值是256k，可以完全存入。  </li>
<li>扫描表t2，取出每一行数据跟join_buffer中的数据进行对比，  <ul>
<li>如果不满足t1.b=t2.b，则跳过；  </li>
<li>如果满足t1.b=t2.b，再判断其他条件，是否满足t2.b处于[1,2000]的条件，如果是，就作为结果集的一部分返回，否则跳过。  </li>
</ul>
</li>
</ol>
<p>对于表t2的每一行，判断join是否满足的时候，都需要遍历join_buffer中的所有行。因此判断等值条件的次数是1000*100万=10亿次，这个判断的工作量很大。  </p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>partitions</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>filtered</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>simple</td>
<td>t1</td>
<td>null</td>
<td>all</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>1000</td>
<td>100.00</td>
<td>Using where</td>
</tr>
<tr>
<td>1</td>
<td>simple</td>
<td>t2</td>
<td>null</td>
<td>all</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>998222</td>
<td>1.11</td>
<td>Using where;Using join buffer(Block Nested Loop)</td>
</tr>
</tbody></table>
<p>explain结果中Extra字段显示使用了BNL算法。但是执行时间超过一分钟。  </p>
<p>在表t2的字段b上创建索引会浪费资源，但是不创建索引的话语句等值条件要判断10亿次。  </p>
<p>解决方案-临时表：  </p>
<ol>
<li>把表t2中满足条件的数据放在临时表tmp_t中；  </li>
<li>为了让join使用BKA算法，给临时表tmp_t的字段b加上索引；  </li>
<li>让表t1和tmp_t做join操作。  </li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">temporary</span> <span class="keyword">table</span> temp_t(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>, a <span class="built_in">int</span>, b <span class="built_in">int</span>, <span class="keyword">index</span>(b)) <span class="keyword">engine</span>=<span class="keyword">innodb</span>;  </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> temp_t <span class="keyword">select</span> * <span class="keyword">from</span> t2 <span class="keyword">where</span> b&gt;=<span class="number">1</span> <span class="keyword">and</span> b&lt;=<span class="number">2000</span>;  </span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">join</span> temp_t <span class="keyword">on</span> (t1.b=temp_t.b);</span><br></pre></td></tr></table></figure>

<p>执行时间大幅下降到不到1秒。  </p>
<ol>
<li>执行insert语句构造temp_t表并插入数据的过程中，对表t2做了全表扫描，这里扫描的行数是100万。  </li>
<li>之后的join语句，扫描表t1，这里的扫描行数是1000；join比较过程中，做了1000次带索引的查询。(优化前需要做10亿次条件判断)</li>
</ol>
<p>总体来看，不论是在原表上加索引，还是用有索引的临时表，思路都是让join语句能够用上被驱动表上的索引，来触发BKA算法，提升查询性能。  </p>
<h3 id="扩展-hash-join"><a href="#扩展-hash-join" class="headerlink" title="扩展-hash join"></a>扩展-hash join</h3><p>如果join_buffer里面维护的不是一个无序数组，而是一个哈希表的话，就不用10亿次判断，而是100万次hash查找(表t2中100w条数据)。  </p>
<ol>
<li>select * from t1;取得表t1的全部1000行数据，在业务端存入一个hash结构。  </li>
<li>select * from t2 where b&gt;=1 and b&lt;=2000;获取表t2满足条件的2000行数据。  </li>
<li>把这2000行数据，一行一行的取到业务端，到hash结构的数据表中寻找匹配的数据。满足匹配的条件的整行数据，就作为结果集的一行。  </li>
</ol>
<p>理论上，这个过程会比临时表方案的执行速度还要快一些。  </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>BKA优化是MySQL已经内置支持的，建议默认使用。  </li>
<li>BNL算法效率低，建议尽量转成BKA算法。优化的方向就是给被驱动表的关联字段加上索引。  </li>
<li>基于临时表的改进方案，对于能够提前过滤出小数据的join语句来说，效果还是很好的。  </li>
<li>MySQL目前的版本还不支持hash join，但是可以配合应用端模拟出来，理论上效果好于临时表的方案。  </li>
</ol>
<h3 id="扩展-三表join"><a href="#扩展-三表join" class="headerlink" title="扩展-三表join"></a>扩展-三表join</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t1`</span> (</span><br><span class="line"> <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"> <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line"> <span class="string">`b`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line"> <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2 <span class="keyword">like</span> t1;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t3 <span class="keyword">like</span> t2;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> ... //初始化三张表的数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">join</span> t2 <span class="keyword">on</span>(t1.a=t2.a) <span class="keyword">join</span> t3 <span class="keyword">on</span> (t2.b=t3.b) <span class="keyword">where</span> t1.c&gt;=X <span class="keyword">and</span> t2.c&gt;=Y <span class="keyword">and</span> t3.c&gt;=Z;</span><br></pre></td></tr></table></figure>

<p>第一原则是要尽量使用BKA算法。使用BKA算法的时候，并不是“先计算两个表join的结果，再跟第三个表join”，而是直接嵌套查询。  </p>
<p>具体实现是：在t1.c&gt;=X、t2.c&gt;=Y、t3.c&gt;=Z这三个条件里，选择一个经过过滤以后，数据最少的那个表，作为第一个驱动表。有两种情况。  </p>
<p>第一种情况，如果选出来是表t1或者t3，那剩下的部分就固定了。  </p>
<ol>
<li>如果驱动表是t1，则连接顺序是t1-&gt;t2-&gt;t3，要在被驱动表字段创建上索引，也就是t2.a和t3.b上创建索引；  </li>
<li>如果驱动表是t3，则连接顺序是t3-&gt;t2-&gt;t1，需要在t2.b和t1.a上创建索引。  </li>
</ol>
<p>同时需要再第一个驱动表的字段c上创建索引。  </p>
<p>第二种情况，如果选出来的第一个驱动表是表t2，则需要评估另外两个条件的过滤效果。  </p>
<p>整体的思路就是，尽量让每一次参与join的驱动表的数据集，越小越好，这样驱动表就会越小。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>用户临时表简析</title>
    <url>/MySQL/%E7%94%A8%E6%88%B7%E4%B8%B4%E6%97%B6%E8%A1%A8%E7%AE%80%E6%9E%90/</url>
    <content><![CDATA[<p>内存表与临时表：  </p>
<ul>
<li>内存表，指的是使用Memory引擎的表，建表语法是create table…engine=memory。这种表的数据都保存在内存里，系统启动的时候会被清空，但是表结构还在。  </li>
<li>临时表，可以使用各种引擎类型。如果是使用InnoDB引擎或者MyISAM引擎的临时表，写数据的时候是写在磁盘上的。使用Memory引擎数据保存在内存上。  </li>
</ul>
<h3 id="临时表的特性"><a href="#临时表的特性" class="headerlink" title="临时表的特性"></a>临时表的特性</h3><table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
</tr>
</thead>
<tbody><tr>
<td>create temporary table t(c int) engine=myisam;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>show create table t;</br>(Table ‘t’ doesn’t exist)</td>
</tr>
<tr>
<td>create table t(id int primary key) engine=innodb;</br>show create table;</br>//create temporary table t(c int) engine=myisam;</br>show tables;</br>//只显示普通表t</td>
<td></td>
</tr>
<tr>
<td></td>
<td>insert into t values(1);</br>select * from t;</br>//返回1</td>
</tr>
<tr>
<td>select * from t;</br>Empty set</td>
<td></td>
</tr>
</tbody></table>
<ol>
<li>建表语法是create temporary table…。  </li>
<li>一个临时表只能被创建它的session访问，对其他线程不可见。所以sessionA创建的临时表t，对于sessionB就是不可见的。  </li>
<li>临时表可以与普通表同名。  </li>
<li>sessionA内有同名的临时表和普通表的时候，show create语句，以及增删改查语句访问的是临时表。  </li>
<li>show tables命令不显示临时表。  </li>
</ol>
<p>临时表只能被创建它的session访问，所以在这个session结束的时候，会自动删除临时表。这个特性适合join优化的场景。  </p>
<ol>
<li>不同session的临时表是可以重名的，如果有多个session同时执行join优化，不需要担心表名重复导致建表失败的问题。  </li>
<li>不需要担心数据删除问题。如果使用普通表，在流程执行过程中客户端发生了异常断开，或者数据库发生异常重启，还需要专门来清理中间过程中生成的数据表。而临时表由于会自动回收，所以不需要这个额外的操作。  </li>
</ol>
<h3 id="临时表的应用"><a href="#临时表的应用" class="headerlink" title="临时表的应用"></a>临时表的应用</h3><p>由于不用担心线程之间的重名冲突，临时表经常会被用在复杂查询的优化过程中。分库分表系统的跨库查询  </p>
<p>一般分库分表的场景，要把一个逻辑上的大表分散到不同的数据库实例上。将一个大表ht，按照字段f，拆分成1024个分表，然后分布到32个数据库实例上。一般情况下，这种分库分表系统都有一个中间层proxy。(也有一些方案会让客户端直接连接数据库，也就是没有proxy这一层)  </p>
<p>在这个架构中，分区key的选择是以“减少跨库和跨表查询”为依据的。如果大部分的语句都会包含f的等值条件，那么就要用f做分区键。这样，在proxy这一层解析完SQL语句以后，就能确定将这条语句路由到哪个分表做查询。  </p>
<blockquote>
<p>select v from ht where f=N;<br>这时可以通过分表规则(N%1024)来确认需要的数据被放在了哪个分表上。这种语句只需要访问一个分表。  </p>
</blockquote>
<blockquote>
<p>select v from ht where k&gt;=M order by t_modified desc limit 100;– k为索引字段<br>由于查询条件里面没有用到分区字段f，只能到所有的分区中去查找满足条件的所有行，然后统一做order by的操作。  </p>
</blockquote>
<p>第一种思路，在proxy层的进程代码中实现排序。<br>优势：处理速度快，拿到分库的数据以后，直接在内存中参与计算。<br>缺点：  </p>
<ol>
<li>需要的开发工作量比较大。如果涉及到复杂的操作，比如group by，甚至join这样的操作，对中间层的开发能力要求比较高；  </li>
<li>对proxy端的压力比较大，尤其是很容易出现内存不够用和CPU瓶颈的问题。  </li>
</ol>
<p>另一种思想，把各个分库拿到的数据，汇总到一个MySQL实例的一个表中，然后再这个汇总实例上做逻辑操作。  </p>
<ul>
<li>在汇总库上创建一个临时表temp_ht，表里包含三个字段v、k、t_modified；  </li>
<li>在各个分库上执行select v,k,t_modified from ht_x where k&gt;=M order by t_modified desc limit 100;  </li>
<li>把分库执行的结果插入到temp_ht表中；  </li>
<li>执行select v from temp_ht order by t_modified desc limit 100;  </li>
<li>得到结果。</li>
</ul>
<p>实践中，每个分库的计算量都不饱和，会直接把临时表temp_ht放到32个分库中的某一个上。  </p>
<h3 id="临时表可以重名"><a href="#临时表可以重名" class="headerlink" title="临时表可以重名"></a>临时表可以重名</h3><p>create temporary table temp_t(id int primary key) engine=innodb;  </p>
<p>执行这个语句的时候，MySQL要给这个InnoDB表创建一个frm文件保存表结构定义，还要有地方保存表数据。  </p>
<p>这个frm文件放在临时文件目录下，文件名的后缀是.frm，前缀是”#sql{进程id}_{线程id}_序列号”。可以使用select@@tmpdir命令，来显示实例的临时文件目录。关于表中数据的存放方式，不同的MySQL版本有不同的处理方式：  </p>
<ul>
<li>在5.6以及以前的版本，MySQL会在临时文件目录下创建一个相同前缀、以.ibd为后缀的文件，用来存放数据文件；  </li>
<li>从5.7版本开始，MySQL引入了一个临时文件表空间，专门用来存放临时文件的数据。不需要再创建idb文件了。  </li>
</ul>
<p>从文件名的前缀规则，可以看到，其实创建一个叫做t1的InnoDB临时表，MySQL在存储上认为创建的表名跟普通的表t1是不同的，因此同一个库下面已经有普通表t1的情况下，还是可以再创建一个临时表t1的。  </p>
<hr>
<h4 id="临时表重命名"><a href="#临时表重命名" class="headerlink" title="临时表重命名"></a>临时表重命名</h4><p>执行rename table语句的时候，要求按照“库名/表名.frm”的规则去磁盘找文件，但是临时表在磁盘上的frm文件是放在tmpdir目录下的，并且文件名的规则是”#sql{进程id}_{线程id}_序列号.frm”，会报”找不到文件名”的错误。  </p>
<p>只能用alter table语法修改临时表的表名，而不能使用rename语法。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">temporary</span> <span class="keyword">table</span> temp_t(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>)<span class="keyword">engine</span>=<span class="keyword">innodb</span>;  </span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> temp_t <span class="keyword">rename</span> <span class="keyword">to</span> temp_t2;  </span><br><span class="line"><span class="keyword">rename</span> <span class="keyword">table</span> temp_t2 <span class="keyword">to</span> temp_t3;</span><br></pre></td></tr></table></figure>
<hr>
<p>MySQL维护数据表，除了物理上要有文件外，内存里面也有一套机制区别不同的表，每个表都对应一个table_def_key。  </p>
<ul>
<li>一个普通的table_def_key的值是有“库名+表名”得到的，如果要在同一个库下创建两个同名的普通表，创建第二个表的过程中就会发现table_def_key已经存在了。  </li>
<li>对于临时表，table_def_key在“库名+表名”的基础上，又加入了“server_id+thread_id”。  </li>
</ul>
<p>不同session创建的两个同名的临时表t1，它们的table_def_key不同，磁盘文件名也不同，因此可以并存。  </p>
<p>在实现上，每个线程都维护了自己的临时表链表。这样每次session内操作表的时候，先遍历链表，检查是否有这个名字的临时表，如果有就优先操作临时表，如果没有再操作普通表；在session结束的时候，对链表里的每个临时表，执行”DROP TEMPORARY TABLE + 表名”操作。(如果数据库掉电，重启以后MySQL会扫描临时目录，把表都删掉。)  </p>
<p>binlog也记录了DROP TEMPORARY TABLE这条命令。</p>
<h3 id="临时表和主备复制"><a href="#临时表和主备复制" class="headerlink" title="临时表和主备复制"></a>临时表和主备复制</h3><p>既然写binlog，就意味着备库需要。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_normal(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>, c <span class="built_in">int</span>) <span class="keyword">engine</span>=<span class="keyword">innodb</span>;<span class="comment">/*Q1*/</span>  </span><br><span class="line"><span class="keyword">create</span> <span class="keyword">temporary</span> <span class="keyword">table</span> temp_t <span class="keyword">like</span> t_normal;<span class="comment">/*Q2*/</span>  </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> temp_t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>);<span class="comment">/*Q3*/</span>  </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_normal <span class="keyword">select</span> * <span class="keyword">from</span> temp_t;<span class="comment">/*Q4*/</span></span><br></pre></td></tr></table></figure>

<p>如果临时表的操作都不记录，那么在备库就只有create table t_normal表和insert into t_normal select * from temp_t这两个语句的binlog日志，备库在执行到insert into t_normal的时候，就会报错“表temp_t不存在”。  </p>
<p>如果当前的binlog_format=row，那么跟临时表有关的语句，就不会记录到binlog里(insert into t_normal的binlog记录的是这个操作的数据，write_row event里记录的逻辑是“插入一行数据(1,1)”)。  </p>
<p><strong>只在binlog_format=statment/mixed的时候，binlog中才记录临时表的操作。</strong>创建临时表的语句会传到备库执行，备库的同步线程会创建这个临时表。在主库线程退出的时候，就会删除临时表，但是备库同步线程是持续在运行的。需要在主库上再写一个DROP TEMPORARY TABLE传给备库执行。  </p>
<h4 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h4><p>MySQL在记录binlog的时候，不论是create table还是alter table语句，都是原样记录，甚至于连空格都不会变。drop table语句记录问题。  </p>
<p>设置binlog_format=row，如果主库上执行”drop table t_normal,temp_t”命令，binlog改成了标准的格式只能记录：DROP TABLE ‘t_normal’/<em>generated by server</em>/  </p>
<p>备库上并没有表temp_t，将这个命令重写后再传到备库执行，才不会导致备库同步线程停止。drop table命令记录到binlog的时候，/<em>generated by server</em>/说明了这是一个被服务端改写过的命令。  </p>
<h4 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h4><p>主库上不同的线程创建同名的临时表是没关系的，传到备库执行问题。  </p>
<table>
<thead>
<tr>
<th></th>
<th>M上sessionA</th>
<th>M上sessionB</th>
<th>S上的应用日志线程</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>create temporary table t1…;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td></td>
<td></td>
<td>create temporary table t1…;</td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td>create temporary table t1…;</td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td></td>
<td>create temporary table t1…;</td>
</tr>
</tbody></table>
<p>主库M上的两个session创建了同名的临时表t1，这两个create temporary table t1语句都会被传到备库S上。但是备库的应用日志线程是共用的，在应用线程里面执行这个create语句两次。(即使开了多线程复制，也可能被分配到从库的同一个worker中执行)。备库线程在执行的时候，要把这两个t1表当做两个不同的临时表来处理，才能避免出错。  </p>
<p>MySQL在记录binlog的时候，会把主库执行这个语句的线程id写到binlog中。这样，在备库的应用线程就能够知道每个语句的主库线程id，并利用这个线程id来构造临时表的table_def_key:  </p>
<ol>
<li>sessionA的临时表t1，在备库的table_def_key就是：库名+t1+”M的serverid”+”sessionA的thread_id”；  </li>
<li>sessionB的临时表t1，在备库的table_def_key就是：库名+t1+”M的serverid”+”sessionB的thread_id”；  </li>
</ol>
<p>由于table_def_key不同，这两个表在备库的应用线程里面不会冲突。  </p>
<h4 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h4><p>如果创建临时表在主库，查询的时候打到从库上，查询就有问题了，查询主库的线程id跟从库不一致。  </p>
<p>一般一个事务创建来临时表以后，读写分离就会默认接下来的请求都路由到主库。  </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>临时表一般用于比较复杂的计算逻辑。临时表是每个线程自己乐见的，不需要考虑多个线程执行同一个处理逻辑时，临时表的重名问题。在线程退出的时候，临时表也能自动删除，省去了收尾和异常处理的工作。  </p>
<p>以上临时表，是用户自己创建的，称为用户临时表，与其对应的是内部临时表(内存临时表&amp;磁盘临时表)。<a href="/MySQL/随机排序">MySQL-随机排序</a>  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>快速复制一张表</title>
    <url>/MySQL/%E5%BF%AB%E9%80%9F%E5%A4%8D%E5%88%B6%E4%B8%80%E5%BC%A0%E8%A1%A8/</url>
    <content><![CDATA[<p>在两表中拷贝数据。如果可以控制对源表的扫描函数和加锁范围很小的话，简单的使用insert…select语句即可实现。  </p>
<p>为了避免对源表加读锁，更稳妥的方案是先将数据写到外部文本文件，然后再写回目标表。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> db1;  </span><br><span class="line"><span class="keyword">use</span> db1;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>, a <span class="built_in">int</span>, b <span class="built_in">int</span>, <span class="keyword">index</span>(a))<span class="keyword">engine</span>=<span class="keyword">innodb</span>;  </span><br><span class="line">delimiter ;;  </span><br><span class="line">    <span class="keyword">create</span> <span class="keyword">procedure</span> idata()  </span><br><span class="line">    <span class="keyword">begin</span>  </span><br><span class="line">        <span class="keyword">declare</span> i <span class="built_in">int</span>;  </span><br><span class="line">        <span class="keyword">set</span> i=<span class="number">1</span>;  </span><br><span class="line">        while(i&lt;=1000)do  </span><br><span class="line">            <span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(i,i,i);  </span><br><span class="line">            <span class="keyword">set</span> i=i+<span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">while</span>;  </span><br><span class="line">    <span class="keyword">end</span>;;  </span><br><span class="line">delimiter ;  </span><br><span class="line"><span class="keyword">call</span> idata();  </span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> db2;  </span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> db2.t <span class="keyword">like</span> db1.t  </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 把db1.t里面a&gt;900的数据行导出来，插入到db2.t中。</span></span><br></pre></td></tr></table></figure>

<h3 id="mysqldump方法"><a href="#mysqldump方法" class="headerlink" title="mysqldump方法"></a>mysqldump方法</h3><p>使用mysqldump命令将数据导出成一组insert语句。把结果输出到临时文件。  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump -h$host -P$port -u$user --add-locks=0 --no-create-info --single-transaction --set-gtid-purged=OFF db1 t --where="a&gt;900" --result-file=/client_tmp/t.sql</span><br></pre></td></tr></table></figure>

<ol>
<li>-single-transaction的作用是，在导出数据的时候不需要对表db1.t加表锁，而是使用start transaction with consistent snapshot的方法；  </li>
<li>-add-locks设置为0，表示在输出文件结果里，不增加”lock tables t write;”；(等效于–skip-add-locks)  </li>
<li>-no-create-info的意思是，不需要导出表结构；  </li>
<li>-set-gtid-purged=off表示的是，不输出跟gtid相关的信息；  </li>
<li>-result-file指定了输出文件的路径，其中client表示生成的文件是在客户端机器上的。  </li>
</ol>
<p>通过这条mysqldump命令生成的t.sql文件中就包含了insert语句。一条insert语句里面包含多个value对，后续用这个文件来写入数据的时候，执行所读可以更快。  </p>
<blockquote>
<p>单条sql里的value值不会超过参数net_buffer_length，通过–net_buffer_length传给mysqldump工具</p>
</blockquote>
<p>执行mysqldump命令时，加上参数-skip-extended-insert，生成的文件中一条insert语句只插入一行数据。  </p>
<h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -h127.0.0.1 -P13000 -uroot db2 -e "source /client_tmp/t.sql"  </span><br><span class="line">// 将insert语句放到db2库里执行</span><br></pre></td></tr></table></figure>

<p>source并不是一条sql语句，而是一个客户端命令。mysql客户端执行这个命令的流程：  </p>
<ol>
<li>打开文件，默认以分号为结尾读取一条条的SQL语句；  </li>
<li>将SQL语句发送到服务端执行。  </li>
</ol>
<p>服务端执行的并不是这个”source t.sql”语句，而是insert语句。不论是在慢查询日志(slow log)，还是在binlog，记录的都是这些要被真正执行的insert语句。  </p>
<h3 id="导出CSV文件"><a href="#导出CSV文件" class="headerlink" title="导出CSV文件"></a>导出CSV文件</h3><p>将结果导出成.csv文件。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> db1.t <span class="keyword">where</span> a&gt;<span class="number">900</span> <span class="keyword">into</span> <span class="keyword">outfile</span> <span class="string">'/server_tmp/t.csv'</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>这条语句会将结果保存在服务端。如果执行命令的客户端和MySQL服务端不在同一个机器上，客户端机器的临时目录下是不会生成t.csv文件的。  </li>
<li>into outfile指定了文件的生成位置(/server_tmp)，这个位置必须受参数secure_file_priv的限制。参数secure_file_priv的可选值和作用分别是：  <ul>
<li>如果设置为empty，表示不限制文件生成的位置，这是不安全的设置；  </li>
<li>如果设置为一个表示路径的字符串，就要求生成的文件只能放在这个指定的目录，或者它的子目录；  </li>
<li>如果设置为null，就表示禁止在这个MySQL实例上执行select…into outfile操作。  </li>
</ul>
</li>
<li>这条命令不会覆盖文件，需要确保/server_tmp/t.csv这个文件不存在，否则执行语句时会因为有同名文件的存在而报错。  </li>
<li>这条命令生成的文本文件中，原则上一个数据行对应文本文件的一行。但是，如果字段中包含换行符，在生成的文本中也会有换行符。不过类似换行符、制表符这类符号，前面都会跟上”&quot;这个转义符，可以跟字段之间、数据行之间的分隔符区分开。  </li>
</ol>
<h4 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">infile</span> <span class="string">'/server_tmp/t.csv'</span> <span class="keyword">into</span> <span class="keyword">table</span> db2.t;  </span><br><span class="line">// 用<span class="keyword">load</span> <span class="keyword">data</span>命令将csv文件中的数据导入到目标表db2.t中。</span><br></pre></td></tr></table></figure>

<p>执行流程：  </p>
<ol>
<li>打开文件/server_tmp/t.csv，以制表符(\t)作为字段间的分隔符，以换行符(\n)作为记录之间的分隔符，进行数据读取；  </li>
<li>启动事务。  </li>
<li>判断每一行的字段数与表db2.t是否相同；  <ul>
<li>若不相同，则直接报错，事务回滚；  </li>
<li>若相同，则构造成一行，调用InnoDB引擎接口，写入到表中。  </li>
</ul>
</li>
<li>重复步骤3，直到/server_tmp/t.csv整个文件读入完成，提交事务。  </li>
</ol>
<h4 id="备库重放"><a href="#备库重放" class="headerlink" title="备库重放"></a>备库重放</h4><p>binlog_format=statement<br>由于/server_tmp/t.csv文件只保存在主库所在的主机上，如果只是把这条语句原文写到binlog中，在备库执行的时候，备库的本地机器上没有这个文件，就会导致主备同步停止。  </p>
<p>完整流程：  </p>
<ol>
<li>主库执行完成后，将/server_tmp/t.csv文件的内容直接写到binlog文件中。  </li>
<li>往binlog文件中写入语句load data local infile ‘/tmp/SQL_LOAD_MB-1-0’ into table ‘db2’.’t’。  <blockquote>
<p>备库执行的load data语句里面，多了一个”local”。它的意思是”将执行这条命令的客户端所在机器的本地文件/tmp/SQL_LOAD_MB-1-0的内容，加载到目标表db2.t中”。  </p>
</blockquote>
</li>
<li>把这个binlog日志传到备库。  </li>
<li>备库的apply线程在执行这个事务日志时；  <ul>
<li>先将binlog中t.csv文件的内容读出来，写入到本地临时目录/tmp/SQL_LOAD_MB-1-0中；  </li>
<li>再执行load data语句，往备库的db2.t表中插入跟主库相同的数据。  </li>
</ul>
</li>
</ol>
<p>load data命令两种用法：  </p>
<ol>
<li>不加“local”，是读取服务端的文件，这个文件必须在secure_file_priv指定的目录或子目录下；  </li>
<li>加上“local”，读取的时候客户端的文件，只要mysql客户端有访问这个文件的权限即可。这时，MySQL客户端会先把本地文件传给服务端，然后执行上述的load data流程。  </li>
</ol>
<h4 id="导出表结构定义"><a href="#导出表结构定义" class="headerlink" title="导出表结构定义"></a>导出表结构定义</h4><p>select…into outfile方法不会生成表结构文件，导数据时还需要单独的命令得到表结构定义。-tab参数，可以同时导出表结构定义文件和csv数据文。  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump -h$host -P$port -u$user ---single-transaction --set-gtid-purged=OFF db1 t --where="a&gt;900" --tab=$secure_filr_priv;  </span><br><span class="line">// 这条命令会在$secure_file_priv定义的目录下，创建一个t.sql文件保存建表语句，同时创建一个t.txt文件保存csv数据。</span><br></pre></td></tr></table></figure>

<h3 id="物理拷贝方法"><a href="#物理拷贝方法" class="headerlink" title="物理拷贝方法"></a>物理拷贝方法</h3><p>mysqldump和csv都是逻辑导数据的方法，将数据从表db1.t中读出来，生成文本，然后再写入目标表db2.t中。  </p>
<p>物理导数据，直接把db1.t表的.frm文件和.ibd文件拷贝到db2目录下不可行。<br>一个InnoDB表，除了包含这两个物理文件外，还需要再数据字典中注册。直接拷贝这两个文件的话，因为数据字典中没有db2.t这个表，系统不会识别和接受它们。  </p>
<p>MySQL5.6版本引入了<strong>可传输表空间</strong>(transportable tablespace)的方法，可以通过导出+导入表空间的方式，实现物理拷贝表的功能。  </p>
<p>在db1库下，复制一个跟表t相同的表r，执行步骤：  </p>
<ol>
<li>执行create table r like t，创建一个相同表结构的空表；  </li>
<li>执行alter table r discard tablespace，这时候r.ibd文件会被删除；  </li>
<li>执行flush table t for export，这是db1目录下会生成一个t.cfg文件；  </li>
<li>在db1目录下执行cp t.cfg r.cfg; cp t.ibd r.ibd;这两个命令(拷得到的两个文件，MySQL进程要有读写权限:root账号下命令行复制的文件，mysql用户启动的进程没有读写权限)；  </li>
<li>执行unlock tables，这是t.cfg文件会被删除；  </li>
<li>执行alter table r import tablespcace，将这个r.ibd文件作为表r的新的表空间，由于这个文件的数据内容和t.ibd是相同的所以表r中就有了和表t相同的数据。  </li>
</ol>
<img src="/img/MySQL物理拷贝表.jpg">

<p>注意：  </p>
<ol>
<li>在第3步执行完flush table命令之后，db1.t整个表处于只读状态，直到执行unlock tables命令后才释放读锁；  </li>
<li>在执行import tablespace的时候，为了让文件里的表空间id和数据字典中的一致，会修改r.ibd的表空间id。而这个表空间id存在于每一个数据页中。因此，如果是一个很大的文件(TB级别)，每个数据页都需要修改，所以会看到这个import语句的执行是需要一些时间的。但相比于逻辑导入的方法，import语句的耗时是非常短的。  </li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>物理拷贝的方式速度最快，尤其对于大表拷贝来说是最快的方法。如果出现误删表的情况，用备份恢复出误删之前的临时库，然后再把临时库中的表拷贝到生产库上，是恢复数据最快的方法。局限性：  <ul>
<li>必须是全表拷贝，不能只拷贝部分数据；  </li>
<li>需要到服务器上拷贝数据，在用户无法登陆数据库主机的场景下无法使用；  </li>
<li>由于是通过拷贝物理文件实现的，源表和目标表都是使用InnoDB引擎时才能使用。  </li>
</ul>
</li>
<li>用mysqldump生成包含insert语句文件的方法，可以在where参数增加过滤条件，来实现只导出部分数据。不足之一：不能使用join这种比较复杂的where条件写法。(mysqldump本身会保留一些环境信息、字符集等)  </li>
<li>用select…into outfile的方法是最灵活的，支持所有的SQL写法。缺点之一：每次只能导出一张表的数据，而且表结构也需要另外的语句单独备份。  </li>
</ol>
<p>后两种方式都是逻辑备份方式，可以跨引擎使用。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>分区表</title>
    <url>/MySQL/%E5%88%86%E5%8C%BA%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="分区表定义"><a href="#分区表定义" class="headerlink" title="分区表定义"></a>分区表定义</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">'t'</span> (</span><br><span class="line">    <span class="string">'ftime'</span> datetime <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="string">'c'</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">key</span> (<span class="string">'ftime'</span>)</span><br><span class="line">) <span class="keyword">engine</span>=<span class="keyword">innodb</span> <span class="keyword">default</span> <span class="keyword">charset</span>=latin1  </span><br><span class="line"><span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">range</span> (<span class="keyword">year</span>(ftime))</span><br><span class="line">(pratition p_2017 <span class="keyword">values</span> <span class="keyword">less</span> <span class="keyword">than</span> (<span class="number">2017</span>) <span class="keyword">engine</span>=<span class="keyword">innodb</span>,</span><br><span class="line"><span class="keyword">partition</span> p_2018 <span class="keyword">values</span> <span class="keyword">less</span> <span class="keyword">than</span> (<span class="number">2018</span>) <span class="keyword">engine</span>=<span class="keyword">innodb</span>,</span><br><span class="line"><span class="keyword">partition</span> p_2019 <span class="keyword">values</span> <span class="keyword">less</span> <span class="keyword">than</span> (<span class="number">2019</span>) <span class="keyword">engine</span>=<span class="keyword">innodb</span>,</span><br><span class="line"><span class="keyword">partition</span> p_others <span class="keyword">values</span> <span class="keyword">less</span> <span class="keyword">than</span> maxvalue <span class="keyword">engine</span>=<span class="keyword">innodb</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="string">'2017-4-1'</span>,(<span class="string">'2018-4-1'</span>,<span class="number">1</span>);  </span><br><span class="line"><span class="comment">-- 按照定义的分区规则，这两行记录分别落在p_2018和p_2019这两个分区上。  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 表t的磁盘文件：</span></span><br><span class="line"><span class="comment">-- t.frm t#P#p_2017.ibd t#P#p_2018.ibd t#P#p_2019.ibd t#P#p_others.ibd</span></span><br></pre></td></tr></table></figure>

<p>这个表包含了1个.frm文件和4个.ibd文件，每个分区对应一个.ibd文件。  </p>
<ul>
<li>对于引擎层来说，这是4个表；  </li>
<li>对于server层来说，这是1个表。  </li>
</ul>
<h3 id="分区表的引擎层行为"><a href="#分区表的引擎层行为" class="headerlink" title="分区表的引擎层行为"></a>分区表的引擎层行为</h3><h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><table>
<thead>
<tr>
<th></th>
<th>sessionA</th>
<th>sessionB</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>begin;</br>select * from t where ftime=’2017-5-1’ for update;</td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td></td>
<td>insert into t values(‘2018-2-1’,1);</br>(Query OK)</br>insert into t values(‘2017-12-1’,1);</br>(blocked)</td>
</tr>
</tbody></table>
<p>初始化表t的时候，只插入了两行数据，ftime的值分别是’2017-4-1’和’2018-4-1’。sessionA的select语句对索引ftime上这两个记录之间的间隙加了锁。如果是普通表的话，T1时刻，在表t的ftime索引上,’2017-4-1’和’2018-4-1’这两个记录之间的间隙是会被锁住的。sessionB的两条插入语句应该都要进入锁等待状态。  </p>
<center class="half">
    <img src='/img/MySQL加锁范围-普通表.jpg' width='300'/><img src='/img/MySQL加锁范围-分区表.jpg' width='300'/>
</center>


<p>而分区表，对于引擎来说，p_2018和p_2019是两个不同的表，2017-4-1的下一个记录并不是2018-4-1，而是p_2018分区的supremum。表t的ftime索引上的间隙锁范围是’2017-4-1’和’supremum’之间的间隙。所以sessionB要写一行ftime是2018-2-1的时候是可以成功的，而要写入2017-12-1这个记录，就要等sessionA的间隙锁。  </p>
<p>show engine innodb status的部分结果：  </p>
<blockquote>
<p>——- TRX HAS BEEN WAITING 5 SEC FOR THIS LOCK TO BE GRANTED:<br>RECORD LOCKS space id 24 page no 4 n bits 72 index ftime of table ‘test’.’t’ /* Partition ‘p_2018’ */ trx id 1304 lock_mode X insert intentin waiting<br>Record lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0<br>0: len 8; hex 73757072656d756d; asc supremum;;  </p>
</blockquote>
<h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4><p>alter table t engine=myisam;把表t改成MyISAM表。  </p>
<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
</tr>
</thead>
<tbody><tr>
<td>alter table t engine=myisam;</br>update t set c=sleep(100) where ftime=’2017-4-1’;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>select * from t where ftime=’2018-4-1’;</br>(Query OK)</br>select * from t where ftime=’2017-5-1’;</br>(blocked)</td>
</tr>
</tbody></table>
<p>MyISAM引擎只支持表锁，sessionA中的update语句会锁住整个表t上的读。sessionB的第一条查询语句可以正常执行，第二条语句才进入锁等待状态。  </p>
<p>MyISAM的表锁是在引擎层实现的，sessionA加的表锁，其实是锁在分区p_2018上，只会堵住在这个分区上执行的查询，落到其他分区的查询是不受影响的。  </p>
<h4 id="手动分表"><a href="#手动分表" class="headerlink" title="手动分表"></a>手动分表</h4><p>不使用分区表的话，需要使用手动分表的方式，避免单表过大。  </p>
<p>按照年份来划分，分别创建普通表t_2017、t_2018、t_2019。手工分表的逻辑，也是找到需要更新的所有分表，然后依次执行更新。在性能上，这和分区表没有实质的差别。  </p>
<p>分区表和手工分表，一个是由server层来决定使用哪个分区，一个是由应用程代码来决定使用哪个分表。从引擎层看，这两种方式是没有差别的。  </p>
<p>这两个方案的区别，主要是在server层上。分区表的问题：打开表的行为。  </p>
<h3 id="分区策略"><a href="#分区策略" class="headerlink" title="分区策略"></a>分区策略</h3><p>每当第一次访问一个分区表的时候，MySQL需要把所有的分区都访问一遍。一个典型的报错情况是：如果分区表的分区很多，超过了1000个，而MySQL启动的时候，open_files_limit参数使用的是默认值1024，那么就会在访问这个表的时候，由于需要打开所有的文件，导致打开表文件的个数超过了上限而报错。<br>例：insert into t_myisam values(‘2017-4-1’,1);  </p>
<blockquote>
<p>ERROP 1016 (HY000): Can’t open file:’./test/t_myisam.frm’ (errno: 24 - Too many open files)  </p>
</blockquote>
<p>这条insert语句，明显只需要访问一个分区，但语句却无法执行。  </p>
<blockquote>
<p>使用InnoDB引擎的话，并不会出现这个问题。在InnoDB引擎打开文件超过innodb_open_files这个值的时候，就会关掉一些之前打开的文件。即使分区个数大于open_files_limit，打开InnoDB分区表也不会报“打开文件过多”这个错误，就是innodb_open_files这个参数发挥的作用。本地分区策略的优化。  </p>
</blockquote>
<p>MyISAM分区表使用的分区策略，称为<strong>通用分区策略</strong>(generic partitioning)，每次访问分区都由server层控制。  </p>
<p>MySQL5.7.9，InnoDB引擎引入了<strong>本地分区策略</strong>(native partitioning)。这个策略是在InnoDB内部自己管理打开分区的行为。优化：如果文件数过多，就会淘汰之前打开的文件句柄（暂时关掉）。  </p>
<p>MySQL5.7.17，将MyISAM分区表标记为即将弃用(deprecated)。  </p>
<p>MySQL8.0，不允许创建MyISAM分区表，只允许创建已经实现了本地分区策略的引擎。只有InnoDB和NDB这两个引擎支持了本地分区策略。  </p>
<h3 id="分区表的server层行为"><a href="#分区表的server层行为" class="headerlink" title="分区表的server层行为"></a>分区表的server层行为</h3><p>从server层看，一个分区表只是一个表。  </p>
<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
</tr>
</thead>
<tbody><tr>
<td>begin;</br>select * from t where ftime=’2018-4-1’;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>alter table t truncate partition p_2017;</br>(blocked)</td>
</tr>
</tbody></table>
<p>show processlist;  </p>
<table>
<thead>
<tr>
<th>id</th>
<th>user</th>
<th>host</th>
<th>db</th>
<th>command</th>
<th>time</th>
<th>state</th>
<th>info</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>root</td>
<td>localhost:xxxxx</td>
<td>test</td>
<td>Sleep</td>
<td>219</td>
<td></td>
<td>null</td>
</tr>
<tr>
<td>2</td>
<td>root</td>
<td>localhost:yyyyy</td>
<td>test</td>
<td>Query</td>
<td>221</td>
<td>waiting for table metadata lock</td>
<td>alter table t truncate partition p_2017</td>
</tr>
<tr>
<td>3</td>
<td>root</td>
<td>localhost:zzzzz</td>
<td>test</td>
<td>Query</td>
<td>0</td>
<td>starting</td>
<td>show processlist</td>
</tr>
</tbody></table>
<p>虽然sessionB只需要操作p_2017这个分区，但是由于sessionA持有整个表t的MDL锁，就导致了sessionB的alter语句被堵住了。分区表，在做DDL的时候，影响会更大。如果使用的是普通分表，在truncate一个分表的时候，肯定不会跟另外一个分表上的查询语句出现MDL锁冲突。  </p>
<h3 id="分区表的应用场景"><a href="#分区表的应用场景" class="headerlink" title="分区表的应用场景"></a>分区表的应用场景</h3><p>分区表的优势是对业务透明，相对于用户分表来说，使用分区表的业务代码更简洁。分区表可以很方便的清理历史数据。  </p>
<p>如果一项业务跑的时间足够长，往往就会有根据时间删除历史数据的需求，这是按照时间分区的分区表，可以直接通过alter table t drop partition…这个语法删掉分区，从而删掉过期的历史数据。  </p>
<blockquote>
<p>alter table t drop partition…操作是直接删除分区文件，效果跟drop普通表类似。与使用delete语句删除数据相比，优势是速度快、对系统影响小。  </p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>MySQL支持范围range分区、hash分区、list分区等分区方法。  </p>
<ol>
<li>MySQL在第一次打开分区表的时候，需要访问所有的分区；  </li>
<li>在server层，认为这是同一张表，因此所有分区共用同一个MDL锁；  </li>
<li>在引擎层，认为这是不同的表，因此MDL锁之后的执行过程，会根据分区表规则，只访问必要的分区。  <blockquote>
<p>必要的分区，根据SQL语句中的where条件，结合分区规则来实现。where ftime=’2018-4-1’，只访问p_2019这个分区。where ftime&gt;=’2018-4-1’，则访问p_2019和p_others这两个分区。<br>如果查询语句的where条件中没有分区key，那就只能访问所有分区。当然业务分表的方式，同样如此。  </p>
</blockquote>
</li>
</ol>
<p>如果使用分区表，不要创建太多的分区。  </p>
<ol>
<li>分区并不是越细越好。实际上，单表或者单分区的数据一千万行，只要没有特别大的索引，对于现在的硬件能力来说都是小表。  </li>
<li>分区不要提前预留太多，在使用之前预先创建即可。如果按月分区，每年年底时再把下一年度的12个新分区创建上即可。对于没有数据的历史分区，要及时的drop掉。  <blockquote>
<p>查询需要跨多个分区取数据，查询性能比较慢，不是分区表本身的问题,属于数据量的问题或使用方式的问题。  </p>
</blockquote>
</li>
</ol>
<h3 id="分区表创建自增主键"><a href="#分区表创建自增主键" class="headerlink" title="分区表创建自增主键"></a>分区表创建自增主键</h3><p>由于MySQL要求主键包含所有的分区字段，所以肯定是要创建联合主键的。  </p>
<p>(ftime,id)还是(id,ftime):<br>从利用率上来看，应该使用(ftime,id)这种模式。因为用ftime做分区key，说明大多数语句都是包含ftime的，使用这种模式，可以利用前缀索引的规则，减少一个索引。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`ftime`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`ftime`</span>,<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=MyISAM <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=latin1</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (<span class="keyword">YEAR</span>(ftime))</span><br><span class="line">(<span class="keyword">PARTITION</span> p_2017 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2017</span>) <span class="keyword">ENGINE</span> = MyISAM,</span><br><span class="line"> <span class="keyword">PARTITION</span> p_2018 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2018</span>) <span class="keyword">ENGINE</span> = MyISAM,</span><br><span class="line"> <span class="keyword">PARTITION</span> p_2019 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2019</span>) <span class="keyword">ENGINE</span> = MyISAM,</span><br><span class="line"> <span class="keyword">PARTITION</span> p_others <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> MAXVALUE <span class="keyword">ENGINE</span> = MyISAM);</span><br></pre></td></tr></table></figure>

<p>InnoDB引擎，要求至少有一个索引，以自增字段作为第一个字段，需要加一个id的单独索引。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`ftime`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`ftime`</span>,<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`id`</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=latin1</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (<span class="keyword">YEAR</span>(ftime))</span><br><span class="line">(<span class="keyword">PARTITION</span> p_2017 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2017</span>) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>,</span><br><span class="line"> <span class="keyword">PARTITION</span> p_2018 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2018</span>) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>,</span><br><span class="line"> <span class="keyword">PARTITION</span> p_2019 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2019</span>) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>,</span><br><span class="line"> <span class="keyword">PARTITION</span> p_others <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> MAXVALUE <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>);</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>内部临时表应用-union与group by</title>
    <url>/MySQL/%E5%86%85%E9%83%A8%E4%B8%B4%E6%97%B6%E8%A1%A8%E5%BA%94%E7%94%A8-union%E4%B8%8Egroup%20by/</url>
    <content><![CDATA[<p>[MySQL-order&nbsp;by工作原理](/MySQL/order by工作原理)<br><a href="/MySQL/join执行原理">MySQL-join执行原理</a>  </p>
<p>sort buffer、join buffer、内部临时表都是用来存放语句执行过程中的中间数据，以辅助SQL语句的执行。  </p>
<h3 id="union执行流程"><a href="#union执行流程" class="headerlink" title="union执行流程"></a>union执行流程</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>, a <span class="built_in">int</span>, b <span class="built_in">int</span>, <span class="keyword">index</span>(a));  </span><br><span class="line">delimiter ;;  </span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()  </span><br><span class="line"><span class="keyword">begin</span>  </span><br><span class="line">    <span class="keyword">declare</span> i <span class="built_in">int</span>;  </span><br><span class="line">    <span class="keyword">set</span> i=<span class="number">1</span>;  </span><br><span class="line">    while(i&lt;=1000) do  </span><br><span class="line">        <span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>(i,i,i);  </span><br><span class="line">        <span class="keyword">set</span> i=i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">where</span>;  </span><br><span class="line"><span class="keyword">end</span>;;  </span><br><span class="line">delimiter ;  </span><br><span class="line"><span class="keyword">call</span> idata();</span><br><span class="line"></span><br><span class="line">(<span class="keyword">select</span> <span class="number">1000</span> <span class="keyword">as</span> f) <span class="keyword">union</span> (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t1 <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>partitions</th>
<th>tyoe</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>filtered</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>primary</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>No tables used</td>
</tr>
<tr>
<td>2</td>
<td>union</td>
<td>t1</td>
<td>null</td>
<td>index</td>
<td>null</td>
<td>primary</td>
<td>4</td>
<td>null</td>
<td>2</td>
<td>100.00</td>
<td>Using index</td>
</tr>
<tr>
<td>null</td>
<td>union result</td>
<td>&lt;uoion1,2&gt;</td>
<td>null</td>
<td>all</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>Using temporary</td>
</tr>
</tbody></table>
<ul>
<li>第二行的key=primary，说明第二个子句用到了索引id。  </li>
<li>第三行的Extra字段，表示在对子查询的结果集做union的时候，使用了临时表(Using temporary)。  </li>
</ul>
<p>执行流程：  </p>
<ol>
<li>创建一个内存临时表，这个临时表只有一个整型字段f，并且f是主键字段。  </li>
<li>执行第一个子查询，得到1000这个值，并存入临时表中。  </li>
<li>执行第二个子查询：  <ul>
<li>拿到第一行id=1000，视图插入临时表中。但由于1000这个值已经存在于临时表了，违反了唯一性约束，所以插入失败，然后继续执行；  </li>
<li>取到第二行id=999，插入临时表成功。  </li>
</ul>
</li>
<li>从临时表中按行取出数据，返回结果，并删除了临时表，结果中包含两行数据分别是1000和999。  </li>
</ol>
<p>这里的内存临时表起到了暂存数据的作用，而且计算过程还用上了临时表主键id的唯一性约束，实现了union的语义。  </p>
<p>如果把语句中的union改成union all的话，就没有了“去重”的语义。这样执行的时候，就依次执行子查询，得到的结果直接作为结果集的一部分，发给客户端，就不需要临时表。  </p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>partition</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>filtered</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>primary</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>No tables used</td>
</tr>
<tr>
<td>2</td>
<td>union</td>
<td>t1</td>
<td>null</td>
<td>index</td>
<td>null</td>
<td>primary</td>
<td>4</td>
<td>null</td>
<td>2</td>
<td>100.00</td>
<td>Using index</td>
</tr>
</tbody></table>
<ul>
<li>第二行的Extra字段显示的是Using index，表示只使用了覆盖索引。没有用临时表的记录。  </li>
</ul>
<h3 id="group-by执行流程"><a href="#group-by执行流程" class="headerlink" title="group by执行流程"></a>group by执行流程</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>%<span class="number">10</span> <span class="keyword">as</span> m, <span class="keyword">count</span>(*) <span class="keyword">as</span> c <span class="keyword">from</span> t1 <span class="keyword">group</span> <span class="keyword">by</span> m;  </span><br><span class="line"><span class="comment">-- 把表t1里的数据，按照id%10进行分组统计，并按照m的结果排序后输出。</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>partitions</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>filtered</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>simple</td>
<td>t1</td>
<td>null</td>
<td>index</td>
<td>primary,a</td>
<td>a</td>
<td>5</td>
<td>null</td>
<td>1000</td>
<td>100.00</td>
<td>Using index; Using temporary;</td>
</tr>
</tbody></table>
<ul>
<li>Using index，表示这个语句使用了覆盖索引，选择了索引a，不需要回表；  </li>
<li>Using temporary，表示使用了临时表；  </li>
<li>Using filesort，表示需要排序。  </li>
</ul>
<p>执行流程：  </p>
<ol>
<li>创建内存临时表，表里有两个字段m和c，主键是m；  </li>
<li>扫描表t1的索引a，依次取出叶子节点上的id值，计算id%10的结果，记为x；  <ul>
<li>如果临时表中没有主键为x的行，就插入一个记录(x,1)；  </li>
<li>如果表中有主键为x的行，就将x这一行的c值加1；  </li>
</ul>
</li>
<li>遍历完成后，<strong>再根据字段m做排序(8.0版本不再排序)</strong>，得到结果集返回给客户端。  <blockquote>
<p>内存临时表+(sort buffer)进行排序<a href="/MySQL/随机排序">MySQL-随机排序</a>  </p>
</blockquote>
</li>
</ol>
<p><strong>如果不需要对结果进行排序，可以在SQL语句末尾增加order by null。</strong>  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>%<span class="number">10</span> <span class="keyword">as</span> m, <span class="keyword">count</span>(*) <span class="keyword">as</span> c <span class="keyword">from</span> t1 <span class="keyword">group</span> <span class="keyword">by</span> m <span class="keyword">order</span> <span class="keyword">by</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>表t1中的id值是从1开始的，返回的结果集中第一行是id=1；扫描到id=10的时候才插入m=0这一行，结果集里最后一行才是m=0。  </p>
<p>示例中临时表只有10行，内存可以放得下，全程只使用了内存临时表。内存临时表的大小是有限制的，参数tmp_table_size控制其内存大小，默认16M。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> tmp_table_size=<span class="number">1024</span>;  </span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>%<span class="number">100</span> <span class="keyword">as</span> m, <span class="keyword">count</span>(*) <span class="keyword">as</span> c <span class="keyword">from</span> t1 <span class="keyword">group</span> <span class="keyword">by</span> m <span class="keyword">order</span> <span class="keyword">by</span> <span class="literal">null</span> <span class="keyword">limit</span> <span class="number">10</span>;  </span><br><span class="line"><span class="comment">-- 把内存临时表的大小限制为最大1024字节，并把语句改成id%100，这样返回结果里有100行数据。</span></span><br></pre></td></tr></table></figure>

<p>内存临时表大小不够存下100行数据，执行过程中发现内存临时表大小到达了上限，这时会把内存临时表转成磁盘临时表，磁盘临时表默认使用的引擎是InnoDB。如果这个表t1的数据量很大，很可能这个查询需要的磁盘临时表就会占用大量的磁盘空间。  </p>
<h3 id="group-by优化方法–索引"><a href="#group-by优化方法–索引" class="headerlink" title="group by优化方法–索引"></a>group by优化方法–索引</h3><p>不论是使用内存临时表还是磁盘临时表，group by逻辑都需要构造一个带唯一索引的表，执行代价都是比较高的。  </p>
<p>group by的语句逻辑，是统计不同的值出现的个数。但是由于每一行的id%100的结果是无序的，所以需要有一个临时表，来记录并统计结果。  </p>
<p>如果可以确保输入的数据是有序的，那么计算group by的时候，就只需要从左到右顺序扫描，依次累加。  </p>
<ul>
<li>当碰到第一个1的时候，已经知道累积了X个0，结果集里的第一行就是(0,X)；  </li>
<li>当碰到第一个2的时候，已经知道累积了Y个1，结果集里的第二行就是(1,Y)；  </li>
</ul>
<p>按照这个逻辑执行，扫描到整个输入的数据结束，就可以拿到group by的结果，不需要临时表，也不需要再额外排序。  </p>
<p>InnoDB的索引，可以满足这个输入有序的条件。<br>在MySQL5.7版本支持了generated column机制，用来实现列数据的关联更新。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">add</span> <span class="keyword">column</span> z <span class="built_in">int</span> <span class="keyword">generated</span> <span class="keyword">always</span> <span class="keyword">as</span>(<span class="keyword">id</span>%<span class="number">100</span>), <span class="keyword">add</span> <span class="keyword">index</span>(z);  </span><br><span class="line"><span class="comment">-- 创建一个列z，然后在z列上创建一个索引。这样索引z上的数据就是有序的了。  </span></span><br><span class="line"><span class="comment">-- MySQL5.6及之前的版本，可以创建普通列和索引来解决这个问题。</span></span><br></pre></td></tr></table></figure>

<p>原始group by语句优化：  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> z, <span class="keyword">count</span>(*) <span class="keyword">as</span> c <span class="keyword">from</span> t1 <span class="keyword">group</span> <span class="keyword">by</span> z;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>partitions</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>filtered</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>simple</td>
<td>t1</td>
<td>null</td>
<td>index</td>
<td>z</td>
<td>z</td>
<td>5</td>
<td>null</td>
<td>1000</td>
<td>100.00</td>
<td>Using index</td>
</tr>
</tbody></table>
<p>从Extra字段可以看到，语句的执行不再需要临时表，也不需要排序。  </p>
<h3 id="group-by优化方法–直接排序"><a href="#group-by优化方法–直接排序" class="headerlink" title="group by优化方法–直接排序"></a>group by优化方法–直接排序</h3><p>不适合创建索引的场景，老老实实做排序。  </p>
<p>针对语句要放到临时表上的数据量特别大，超过内存临时表，需要磁盘临时表的group by语句。在语句中加入SQL_BIG_RESULT这个提示(hint)，告诉优化器：这个语句涉及的数据量很大，请直接用磁盘临时表。  </p>
<p>磁盘临时表是B+树存储，存储效率不如数组来的搞。优化器从磁盘空间考虑，直接用数组来存。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">SQL_BIG_RESULT</span> <span class="keyword">id</span>%<span class="number">100</span> <span class="keyword">as</span> m, <span class="keyword">count</span>(*) <span class="keyword">as</span> c <span class="keyword">from</span> t1 <span class="keyword">group</span> <span class="keyword">by</span> m;</span><br></pre></td></tr></table></figure>

<p>执行流程：  </p>
<ol>
<li>初始化sort_buffer，确定放入一个整型字段，记为m；  </li>
<li>扫描表t1的索引a，依次取出里面的id值，将id%100的值存入sort_buffer中；  </li>
<li>扫描完成后，对sort_buffer的字段m做排序(如果sort_buffer内存不够用，就会利用磁盘临时文件辅助排序)；  </li>
<li>排序完成后，就得到了一个有序数组。  </li>
</ol>
<p>根据有序数组，得到数组 里面的不同值，以及每个值的出现次数。  </p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>partitions</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>filtered</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>simple</td>
<td>t1</td>
<td>null</td>
<td>index</td>
<td>primary,a</td>
<td>a</td>
<td>5</td>
<td>null</td>
<td>1000</td>
<td>100.00</td>
<td>Using index; Using filesort</td>
</tr>
</tbody></table>
<p>Extra字段分析，语句的执行没有使用临时表，而是直接使用了排序算法。  </p>
<hr>
<ol>
<li>如果语句执行过程可以一边读数据，一边直接得到结果，是不需要额外内存的，否则就需要额外的内存，来保存中间结果；  </li>
<li>join_buffer是无序数组，sort_buffer是有序数组，临时表是二维表结构；  </li>
<li>如果执行逻辑需要用到二维表特性，就会优先考虑使用临时表。union需要用到唯一索引约束，group by还需要用到另外一个字段来存累积计数。  </li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>如果对group by语句的结果没有排序要求，要在语句后面加order by null(跳过最后排序的阶段不需要sort buffer，直接从临时表中取数据返回)；  </li>
<li>尽量让group by过程用上表的索引，确认方法是explain结果里没有Using temporary和Using filesort；(Using index表示使用了覆盖索引，如果覆盖索引的顺序扫描不能满足需求，只能排序，排序过程中用到临时表，就会三个Using都有)  </li>
<li>如果group by需要统计的数据量不大，尽量只适用内存临时表；也可以通过适当调大tmp_table_size参数，来避免用到磁盘临时表；  </li>
<li>如果数据量实在太大，使用SQL_BIG_RESULT这个提示，来告诉优化器直接使用排序算法得到group by的结果。  </li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>自增主键</title>
    <url>/MySQL/%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE/</url>
    <content><![CDATA[<p>自增主键可以让主键索引尽量的保持递增顺序插入，避免了页分裂，索引更紧凑。但自增主键不能保证连续递增，业务设计不能依赖自增主键的连续性。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">'t'</span> (</span><br><span class="line">    <span class="string">'id'</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="literal">null</span> auto_increment,</span><br><span class="line">    <span class="string">'c'</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="string">'d'</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line">    primary <span class="keyword">key</span> (<span class="string">'id'</span>),</span><br><span class="line">    <span class="keyword">unique</span> <span class="keyword">key</span> <span class="string">'c'</span> (<span class="string">'c'</span>)</span><br><span class="line">) <span class="keyword">engine</span>=<span class="keyword">innodb</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在空表t中插入一行数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">value</span>(<span class="literal">null</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h3 id="自增值保存位置"><a href="#自增值保存位置" class="headerlink" title="自增值保存位置"></a>自增值保存位置</h3><p>show create table t;  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">table: t</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span>: <span class="keyword">create</span> <span class="keyword">table</span> <span class="string">'t'</span> (</span><br><span class="line">    ...</span><br><span class="line">) <span class="keyword">engine</span>=<span class="keyword">innodb</span> auto_increment=<span class="number">2</span> <span class="keyword">default</span> <span class="keyword">charset</span>=latin1  </span><br><span class="line"></span><br><span class="line"><span class="comment">-- auto_increment=2，表示下一次插入数据时，如果需要自动生成自增值，会生成id=2。</span></span><br></pre></td></tr></table></figure>

<p>表的结构定义存放在后缀名为.frm的文件中，但是并不会保存自增值。不同引擎对于自增值的保存策略：  </p>
<ul>
<li>MyISAM引擎的自增值保存在数据文件中。  </li>
<li>InnoDB引擎的自增值，其实是保存在内存里，MySQL8.0版本后，才有了“自增值持久化”的能力，实现了“如果发生重启，表的自增值可以恢复为MySQL重启前的值”：  <ul>
<li>MySQL5.7以前，自增值保存在内存里，并没有持久化。每次重启后，第一次打开表的时候，都会去找自增值的最大值max(id)，然后将max(id)+1作为这个表当前的自增值。MySQL重启可能会修改一个表的auto_increment的值。(如果一个表当前数据行的最大的id是10，auto_increment=11。删除id=10的行，auto_increment还是11。马上重启实例，重启后这个表的auto_increment就会变成10。)  </li>
<li>MySQL8.0版本，将自增值的变更记录在了redo log中，重启的时候依靠redo log恢复重启之前的值。  </li>
</ul>
</li>
</ul>
<h3 id="自增值修改机制"><a href="#自增值修改机制" class="headerlink" title="自增值修改机制"></a>自增值修改机制</h3><p>在MySQL里面，如果字段id被定义为auto_increment，在插入一行数据的时候，自增值的行为如下：  </p>
<ol>
<li>如果插入数据时id字段指定为0、null或者未指定值，那么就把这个表当前的auto_increment值填到自增字段；  </li>
<li>如果插入数据时id字段指定了具体的值，就直接使用语句里指定的值。  </li>
</ol>
<p>根据要插入的值和当前自增值的大小关系，自增值的变更结果也会有所不同。假设某次要插入的值是X，当前的自增值是Y。  </p>
<ol>
<li>如果X&lt;Y，那么这个表的自增值不变；  </li>
<li>如果X&gt;=Y，就需要把当前自增值修改为新的自增值。  </li>
</ol>
<p>新的自增值生成算法是：从auto_increment_offset开始，以auto_increment_increment为步长，持续叠加，直到找到第一个大于X的值，作为新的自增值。两个系统参数，分别用来表示自增的初始值和步长，默认值都是1。  </p>
<blockquote>
<p>在一些场景下，使用的不全是默认值。双M的主备结构里要求双写的时候，会设置成auto_increment_increment=2，让一个库的自增id都是奇数，另一个库的自增id都是偶数，避免两个库生成的主键发生冲突。  </p>
</blockquote>
<p>当auto_increment_offset和auto_increment_increment都是1的时候，新的自增值生成逻辑：  </p>
<ol>
<li>如果准备插入的值&gt;=当前自增值，新的自增值就是“准备插入的值+1”；  </li>
<li>否则，自增值不变。  </li>
</ol>
<h3 id="自增值修改时机"><a href="#自增值修改时机" class="headerlink" title="自增值修改时机"></a>自增值修改时机</h3><h4 id="唯一键冲突-自增主键id不连续原因1"><a href="#唯一键冲突-自增主键id不连续原因1" class="headerlink" title="唯一键冲突-自增主键id不连续原因1"></a>唯一键冲突-自增主键id不连续原因1</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--假设表t里面已经有了(1,1,1)这条记录，这时执行一条插入数据命令：  </span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>执行流程：  </p>
<ol>
<li>执行器调用InnoDB引擎接口写入一行，传入的这一行的值是(0,1,1)；  </li>
<li>InnoDB发现用户没有指定自增id的值，获取表t当前的自增值2；  </li>
<li>将传入的行的值改成(2,1,1)；  </li>
<li>将表的自增值改成3；  </li>
<li>继续执行插入数据操作，由于已经存在c=1的记录，所以报Duplicate key error，语句返回。  </li>
</ol>
<p>这个表的自增值改成3，是在真正执行插入数据的操作之前。这个语句真正执行的时候，因为碰到唯一键c冲突，所以id=2这一行并没有插入成功，但是也没有将自增值再改回去。在这之后，再插入新的数据行时，拿到的自增id就是3。出现了自增主键不连续的情况。  </p>
<h4 id="事务回滚-自增主键id不连续原因2"><a href="#事务回滚-自增主键id不连续原因2" class="headerlink" title="事务回滚-自增主键id不连续原因2"></a>事务回滚-自增主键id不连续原因2</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>,<span class="number">1</span>,<span class="number">1</span>);  </span><br><span class="line"><span class="keyword">begin</span>;  </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>,<span class="number">1</span>,<span class="number">1</span>);  </span><br><span class="line"><span class="keyword">rollback</span>;  </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>,<span class="number">2</span>,<span class="number">2</span>);  </span><br><span class="line">//插入的行是(3,2,2)</span><br></pre></td></tr></table></figure>

<p>出现唯一键冲突或者回滚的时候，MySQL都没有把表t的自增值改回去。这么设计是为了提升性能。  </p>
<h3 id="自增值不能回退原因"><a href="#自增值不能回退原因" class="headerlink" title="自增值不能回退原因"></a>自增值不能回退原因</h3><p>假设有两个并行执行的事务，在申请自增值的时候，为了避免两个事务申请到相同的自增id，肯定要加锁，然后顺序申请。  </p>
<ol>
<li>假设事务A申请到了id=2，事务B申请到id=3，那么这时候表t的自增值是4，之后继续执行。  </li>
<li>事务B正确提交了，但事务A出现了唯一键冲突。  </li>
<li>如果允许事务A把自增id回退，把表t的当前自增值改回2，那么就会出现：表里面已经有id=3的行，而当前的自增id值是2。  </li>
<li>接下来，继续执行的其他事务就会申请到id=2，然后再申请到id=3。就会出现插入语句报错“主键冲突”。  </li>
</ol>
<p>解决主键冲突：  </p>
<ol>
<li>每次申请id之前，先判断表里面是否已经存在这个id。如果存在，就跳过这个id。但是这个方法的成本很高。  </li>
<li>把自增id的锁范围扩大，必须等到一个事务执行完成并提交，下一个事务才能再申请自增id。锁的粒度太大，系统并发能力大大下降。  </li>
</ol>
<p>InnoDB放弃了“允许自增id回退”的设计，只保证了自增id是递增的，但不保证是连续的。  </p>
<h3 id="自增锁的优化"><a href="#自增锁的优化" class="headerlink" title="自增锁的优化"></a>自增锁的优化</h3><p>自增id锁并不是一个事务锁，而是每次申请完就马上释放，以便允许别的事务再申请。  </p>
<p>MySQL5.0版本，自增锁的范围是语句级别的。如果一个语句申请了一个表自增锁，这个锁会等语句执行结束以后才释放，影响并发度。  </p>
<p>MySQL5.1.22版本，引入参数innodb_autoinc_lock_mode，默认值是1。  </p>
<ol>
<li>这个参数的值被设置为0时，表示采用之前5.0版本的策略，即语句执行结束后才释放锁；  </li>
<li>这个参数的值被设置为1时：  <ul>
<li>普通insert语句，自增锁在申请之后马上释放；  </li>
<li>类似insert…select这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放；  </li>
</ul>
</li>
<li>这个参数的值被设置为2时，所有的申请自增主键的动作都是申请后就释放锁。  </li>
</ol>
<h4 id="普通批量insert批量申请后释放"><a href="#普通批量insert批量申请后释放" class="headerlink" title="普通批量insert批量申请后释放"></a>普通批量insert批量申请后释放</h4><p>在普通的insert语句里面包含多个value值的情况下，即使innodb_autoinc_lock_mode设置为1，也不会等语句执行完成才释放锁。因为这类语句在申请自增id的时候，是可以精确计算出需要多少给id的，然后一次性申请，申请完成后锁就可以释放了。  </p>
<h4 id="insert…select、replace…select、load-data语句级锁执行完释放"><a href="#insert…select、replace…select、load-data语句级锁执行完释放" class="headerlink" title="insert…select、replace…select、load data语句级锁执行完释放"></a>insert…select、replace…select、load data语句级锁执行完释放</h4><table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
</tr>
</thead>
<tbody><tr>
<td>insert into t values(null, 1, 1);</br>insert into t values(null, 2, 2);</br>insert into t values(null, 3, 3);</br>insert into t values(null, 4, 4);</td>
<td></td>
</tr>
<tr>
<td></td>
<td>create table t2 like t;</td>
</tr>
<tr>
<td>insert into t2 values(null, 5, 5);</td>
<td>insert into t2(c,d) select c,d from t;</td>
</tr>
</tbody></table>
<p>示例中，往表t1中插入了4行数据，然后创建了一个相同结构的表t2，然后两个session同时执行向表t2中插入数据的操作。  </p>
<p>如果sessionB申请了自增值以后马上就释放自增锁，那么可能出现情况：  </p>
<ul>
<li>sessionB先插入了两个记录，(1,1,1)、(2,2,2)；  </li>
<li>然后，sessionA来申请自增id得到id=3，插入了(3,5,5)；  </li>
<li>之后，sessionB继续执行，插入两条记录(4,3,3)、(5,4,4)。  </li>
</ul>
<p>如果binlog_format=statement，由于两个session是同时执行插入数据命令的，所以binlog里面对表t2的更新日志只有两种情况：要么先记sessionA的，要么先记sessionB的。但是不论是哪一种，这个binlog拿去从库执行，或者用来恢复临时实例，备库和临时实例里面，sessionB这个语句执行出来，生成的结果里面，id都是连续的。这个库就发生了数据不一致。  </p>
<p>因为原库sessionB的insert语句，生成的id不连续。这个不连续的id，用statement格式的binlog来串行执行，是执行不出来的。解决的两种思路：  </p>
<ol>
<li>一种思路是，让原库的批量插入数据语句，固定生成连续的id值。所以，自增锁直到语句执行结束才释放，就是为了达到这个目的。  </li>
<li>另一种思路是，在binlog里面把插入数据的操作都如实记录进来，到备库执行的时候，不再依赖于自增主键去生成。这种情况，其实就是innodb_autoinc_lock_mode设置为2，同时binlog_format设置为row。  </li>
</ol>
<p><strong>在生产上，尤其是有insert…select、replace…select、load data这种批量插入数据的场景时，从并发插入数据性能的角度考虑，设置：innodb_autoinc_lock_mode=2，并且binlog_format=row。技能提升并发性，又不会出现数据一致性问题</strong>。  </p>
<h4 id="批量申请id策略-自增主键id不连续原因3"><a href="#批量申请id策略-自增主键id不连续原因3" class="headerlink" title="批量申请id策略-自增主键id不连续原因3"></a>批量申请id策略-自增主键id不连续原因3</h4><p>批量插入数据的语句，若不知道要预先申请多少个id(普通批量insert知道要申请多少个id)，需要一个时申请一个，但是在大批量插入数据的情况下，不但速度慢，还会影响并发插入的性能。批量申请自增id策略：  </p>
<ol>
<li>语句执行过程中，第一次申请自增id，会分配1个；  </li>
<li>1个用完以后，这个语句第二次申请自增id，会分配2个；  </li>
<li>2个用完以后，还是这个语句，第三次申请自增id，会分配4个；  </li>
<li>依此类推，同一个语句去申请自增id，每次申请到的自增id个数都是上一次的两倍。(但不一定会被用完，未使用的会被浪费掉)  </li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>grant权限</title>
    <url>/MySQL/grant%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<p>在MySQL中，grant语句是用来给用户赋权的。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">'ua'</span>@<span class="string">'%'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'pa'</span>;  </span><br><span class="line"><span class="comment">-- 创建一个用户'us'@'%'，密码是pa。  </span></span><br><span class="line"><span class="comment">-- MySQL中，用户名(user)+地址(host)才表示一个用户，us@ip1和ua@ip2代表的是两个不同的用户。</span></span><br></pre></td></tr></table></figure>

<p>这条命令做了两个动作：  </p>
<ol>
<li>磁盘上，往mysql.user表里插入一行，由于没有指定权限，所以这行数据上所有表示权限的字段的值都是N；  </li>
<li>内存里，往数组acl_users里插入一个acl_user对象，这个对象的access字段值为0。  </li>
</ol>
<p>MySQL中，用户权限是有不同的范围的。  </p>
<h3 id="全局权限"><a href="#全局权限" class="headerlink" title="全局权限"></a>全局权限</h3><p>全局权限，作用于整个MySQL实例，这些权限信息保存在mysql库的user表里。内存里则保存在数组acl_users中。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">privileges</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="string">'ua'</span>@<span class="string">'%'</span> <span class="keyword">with</span> <span class="keyword">grant</span> <span class="keyword">option</span>;  </span><br><span class="line"><span class="comment">-- 给用户ua赋一个最高权限。</span></span><br></pre></td></tr></table></figure>

<p>这个grant命令做了两个动作：  </p>
<ol>
<li>磁盘上，将mysql.user表里，用户‘ua’@’%’这一行的所有表示权限的字段的值都修改为’Y’；  </li>
<li>内存里，从数组acl_users中找到这个用户对应的对象，将access值(权限位)修改为二进制的”全1”。  </li>
</ol>
<p>在这个grant命令执行完成后，如果有新的客户端使用用户名ua登录成功，MySQL会为新连接维护一个线程对象，然后从acl_users数组里查到这个用户的权限，并<strong>将权限值拷贝到这个线程对象中</strong>。之后在这个连接中执行的语句，所有关于全局权限的判断，都直接使用线程对象内部保存的权限位。  </p>
<ul>
<li>grant命令对于全局权限，同时更新了磁盘和内存。命令完成后即时生效，接下来新创建的链接会使用新的权限。  </li>
<li>对于一个已经存在的连接，它的全局权限不受grant命令的影响。  <blockquote>
<p>一般在生产环境上要合理控制用户权限的范围。如果一个用户有所有权限，一般就不应该设置为所有ip地址都可以访问。  </p>
</blockquote>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">revoke</span> <span class="keyword">all</span> <span class="keyword">privileges</span> <span class="keyword">on</span> *.* <span class="keyword">from</span> <span class="string">'ua'</span>@<span class="string">'%'</span>;  </span><br><span class="line"><span class="comment">-- 收回grant语句赋予ua的权限。</span></span><br></pre></td></tr></table></figure>

<p>这个revoke命令做了两个动作：  </p>
<ol>
<li>磁盘上，将mysql.user表里，用户‘ua’@’%’这一行的所有表示权限的字段的值都修改为’N’；  </li>
<li>内存上，从数组acl_users中找到这个用户对应的对象，将access的值修改为0。  </li>
</ol>
<h3 id="db权限"><a href="#db权限" class="headerlink" title="db权限"></a>db权限</h3><p>MySQL支持库级别的权限定义。基于库的权限记录保存在mysql.db表中，在内存里则保存在数组acl_dbs中。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">privileges</span> <span class="keyword">on</span> db1.* <span class="keyword">to</span> <span class="string">'ua'</span>@<span class="string">'%'</span> <span class="keyword">with</span> <span class="keyword">grant</span> <span class="keyword">option</span>;  </span><br><span class="line"><span class="comment">-- 让用户ua拥有库db1的所有权限。</span></span><br></pre></td></tr></table></figure>

<p>这条grant命令做了两个动作：  </p>
<ol>
<li>磁盘上，往mysql.db表中插入了一行记录，所有权限位字段设置为’Y’；  </li>
<li>内存里，增加一个对象到数组acl_dbs中，这个对象的权限位为”全1”。  </li>
</ol>
<p>每次需要判断一个用户对一个数据库读写权限的时候，都需要遍历一次acl_dbs数组，根据user、host和db三个字段找到匹配的对象，然后根据对象的权限位来判断。  </p>
<ul>
<li>grant修改db权限的时候，是同时对磁盘和内存生效的。  </li>
</ul>
<h3 id="全局权限与db权限对比"><a href="#全局权限与db权限对比" class="headerlink" title="全局权限与db权限对比"></a>全局权限与db权限对比</h3><p>grant操作对于已经存在的连接的影响，在全局权限和基于db的权限效果是不同的。  </p>
<table>
<thead>
<tr>
<th></th>
<th>sessionA</th>
<th>sessionB</th>
<th>sessionC</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>connect(root,root)</br>create database db1;</br>create user ‘ua’@’%’ identified by ‘pa’;</br>grant super on *.* to ‘ua’@’%’;</br>grant all privileges on db1.* to ‘ua’@’%’;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td></td>
<td>connect(ua,pa)</br>set global sync_binlog=1;</br>(Query OK)</br>create table db1.t(c int);</br>(Query OK)</td>
<td>connect(ua,pa)</br>use db1;</td>
</tr>
<tr>
<td>T3</td>
<td>revoke super on *.* from ‘ua’@’%’;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td>set global sync_binlog=1;</br>(Query OK)</br>alter table db1.t engine=innodb;</br>(Query OK)</td>
<td></br></br>alter table t engine=innodb;</br>(Query OK)</td>
</tr>
<tr>
<td>T5</td>
<td>revoke all privileges on db1.* from ‘ua’@’%’;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td>set global sync_binlog=1;</br>(Query OK)</br>alter table db1.t engine=innodb;</br>(alter command denied)</td>
<td></br></br>alter table t engine=innodb;</br>(Query OK)</td>
</tr>
</tbody></table>
<p>set global sync_binlog这个操作需要super权限。  </p>
<p>用户ua的super权限在T3时刻已经通过revoke语句回收了，但是在T4时刻执行set global的时候，权限验证还是通过了。这是因为super是全局权限，这个权限信息在线程对象中，而revoke操作影响不到这个线程对象。  </p>
<p>在T5时刻去掉ua对db1库的所有权限后，在T6时刻sessionB再操作db1库的表，就会报错“权限不足”。这是因为acl_dbs是一个全局数组，所有线程判断db权限都用这个数组，这样revoke操作马上就会影响到sessionB。  </p>
<p>特别的逻辑，<strong>如果当前会话已经处于某一个db里面，之前use这个库的时候拿到的库权限会保存在会话变量中。</strong>在T6时刻，sessionC和sessionB对表t的操作逻辑是一样的。但是sessionB报错，而sessionC可以执行成功。这是因为sessionC在T2时刻执行的use db1，拿到了这个库的权限，在切换出db1库之前，sessionC对这个库就一直有权限。  </p>
<h3 id="表权限和列权限"><a href="#表权限和列权限" class="headerlink" title="表权限和列权限"></a>表权限和列权限</h3><p>MySQL支持更细粒度的表权限和列权限。其中，表权限定义存放在表mysql.tables_priv中，列权限定义存放在表mysql.columns_priv中。这两类权限，组合起来存放在<strong>内存</strong>的hash结构column_priv_hash中。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> db1.t1(<span class="keyword">id</span> <span class="built_in">int</span>, a <span class="built_in">int</span>);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">privileges</span> <span class="keyword">on</span> db1.t1 <span class="keyword">to</span> <span class="string">'ua'</span>@<span class="string">'%'</span> <span class="keyword">with</span> <span class="keyword">grant</span> <span class="keyword">option</span>;  </span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span>(<span class="keyword">id</span>), <span class="keyword">insert</span>(<span class="keyword">id</span>,a) <span class="keyword">on</span> mtdb,mytbl <span class="keyword">to</span> <span class="string">'ua'</span>@<span class="string">'%'</span> <span class="keyword">with</span> <span class="keyword">grant</span> <span class="keyword">option</span>;</span><br></pre></td></tr></table></figure>

<p>跟db权限类似，这两个权限每次grant的时候都会修改数据表，也会同步修改内存中的hash结构。因此，对这两类权限的操作，也会马上影响到已经存在的连接。  </p>
<hr>
<p>grant语句都是即时生效的，会同时修改数据表和内存，判断权限的时候使用的是内存数据。规范的使用grant和revoke语句，不需要随后执行flush privileges语句。  </p>
<p>flush privileges命令会清空acl_users数组，然后从mysql.user表中读取数据重新加载，重新构造一个acl_users数组。以数据表中的数据为准，会将全局权限内存数组重新加载一遍。  </p>
<p>同样的，对于db权限、表权限、列权限，MySQL也做了这样的处理。  </p>
<p>如果内存的权限数据和磁盘数据表相同的话，不需要执行flush privileges。而如果都是用grant/revoke语句来执行的话，内存和数据表本来就是保持同步更新的。  </p>
<p><strong>正常情况下，grant命令之后，没有必要紧跟着执行flush privileges命令。</strong>  </p>
<table>
<thead>
<tr>
<th>权限</th>
<th>磁盘存储</th>
<th>内存存储</th>
<th>修改策略</th>
<th>作用范围</th>
</tr>
</thead>
<tbody><tr>
<td>全局权限</td>
<td>表mysql.user</td>
<td>数组acl_users</td>
<td>已存在的连接不生效，新建连接立即生效</td>
<td>当前线程</td>
</tr>
<tr>
<td>db权限</td>
<td>表mysql.db</td>
<td>数组acl_dbs</td>
<td>所有连接立即生效</td>
<td>全局</td>
</tr>
<tr>
<td>表权限</td>
<td>表mysql.tables_priv</td>
<td>和列权限组合的hash结构column_priv_hash</td>
<td>所有连接立即生效</td>
<td>全局</td>
</tr>
<tr>
<td>列权限</td>
<td>表mysql.columns_priv</td>
<td>和表权限组合的hash结构column_priv_hash</td>
<td>所有连接立即生效</td>
<td>全局</td>
</tr>
</tbody></table>
<h3 id="flush-privileges使用场景"><a href="#flush-privileges使用场景" class="headerlink" title="flush privileges使用场景"></a>flush privileges使用场景</h3><p>当数据表中的权限数据跟内存中的权限数据不一致的时候，flush privileges语句可以用来重建内存数据，达到一致状态。(这种不一致往往是由不规范的操作导致的，比如直接用DML语句操作系统权限表)  </p>
<blockquote>
<p>drop语句同时操作磁盘和内存，能保证全选数据一致。delete语句只删除磁盘数据。  </p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th>clientA</th>
<th>clientB</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>connect(root,root)</br>create user ‘ua’@’%’ identified by ‘pa’;</td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td></td>
<td>connect(ua,pa)</br>(connect ok)</br>disconnect</td>
</tr>
<tr>
<td>T3</td>
<td>delete from mysql.user where user=’ua’;</td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td>connect(ua,ua)</br>(connect ok)</br>disconnect</td>
</tr>
<tr>
<td>T5</td>
<td>flush privileges;</td>
<td></td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td>connect(ua,pa)</br>(Access Denied)</td>
</tr>
</tbody></table>
<p>T3时刻虽然已经用delete语句删除了用户ua，但是在T4时刻，仍然可以用ua连接成功。原因就是，这时内存中acl_users数组中还有这个用户，因此系统判断时认为用户还正常存在。  </p>
<p>在T5时刻执行过flush命令后，内存更新，T6时刻再要用ua来登录的话，就会报错“无法访问”了。  </p>
<p>直接操作系统表是不规范的操作，这个不一致状态也会导致一些更“诡异”的现象发生。  </p>
<table>
<thead>
<tr>
<th></th>
<th>clientA</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>connect(root,root)</br>create user ‘ua’@’%’ identified by ‘pa’;</td>
</tr>
<tr>
<td>T2</td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td>delete from mysql.user where user=’ua’;</td>
</tr>
<tr>
<td>T4</td>
<td>grant super on *.* to ‘ua’@’%’ with grant option;</br>error 1133(42000):Can’t find any matching row in the user table</td>
</tr>
<tr>
<td>T5</td>
<td>create user ‘ua’@’%’ identified by ‘pa’;</br>error 1396(HY000):Operation create user failed for ‘ua’@’%’</td>
</tr>
</tbody></table>
<p>由于在T3时刻直接删除了数据表的记录，而内存的数据还在，导致：  </p>
<ol>
<li>T4时刻给用户ua赋权限失败，因为mysql.user表中找不到这行记录；  </li>
<li>T5时刻重新创建这个用户也不行，因为在做内存判断的时候，会认为这个用户还存在。  </li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>insert语句加的锁</title>
    <url>/MySQL/insert%E8%AF%AD%E5%8F%A5%E5%8A%A0%E7%9A%84%E9%94%81/</url>
    <content><![CDATA[<p>普通的insert语句是一个很轻量的操作；有些特殊情况的insert语句，在执行过程中需要给其他资源加锁，无法在申请到自增id以后立马释放自增锁。  </p>
<h3 id="insert…select语句"><a href="#insert…select语句" class="headerlink" title="insert…select语句"></a>insert…select语句</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`d`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`c`</span> (<span class="string">`c`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>, <span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>, <span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>, <span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>, <span class="number">4</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2 <span class="keyword">like</span> t</span><br></pre></td></tr></table></figure>

<p>可重复读隔离级别，binlog_format为statement，执行insert into t2(c,d) select c,d from t;时，需要对表t的所有行和间隙加锁。  </p>
<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
</tr>
</thead>
<tbody><tr>
<td>insert into values(-1,-1,-1);</td>
<td>insert into t2(c,d) select c,d from t;</td>
</tr>
</tbody></table>
<p>如果sessionB先执行，由于语句对表t主键索引加了(-∞,1]这个next-key lock，会在语句执行完成后，才允许sessionA的insert语句执行。  </p>
<p>如果没有锁的话，可能出现sessionB的insert语句先执行，但是后写入binlog的情况(日志和数据不一致)。到备库执行，就会把id=-1这一行也写到表t2中，出现主备不一致。  </p>
<h3 id="insert循环写入"><a href="#insert循环写入" class="headerlink" title="insert循环写入"></a>insert循环写入</h3><p>执行insert…select的时候，对目标表不是锁全表，而是只锁住需要访问的资源。  </p>
<h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h4><p>往表t2中插入一行数据，这一行的c值是表t中c值的最大值加1。</p>
<blockquote>
<p>insert into t2(c,d) (select c+1,d from t force index(c) order by c desc limit 1);  </p>
</blockquote>
<p>这个语句的加锁范围，是表t索引c上的(3,4]和(4,supremum]这两个next-key lock，以及主键索引上id=4这一行。  </p>
<p>执行流程：从表t中按照索引c倒叙，扫描第一行，拿到结果写入到表t2中。整条语句的扫描行数是1。  </p>
<p>慢查询日志slow log：{Query_time:0.000732 Lock_time:0.000356 Rows_sent:0 Rows_examined:1}  </p>
<h4 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h4><p>将数据插入表t。(同一个表，可能造成循环写入，引入用户临时表做优化)  </p>
<blockquote>
<p>insert into t(c,d) (select c+1, d from t force index(c) order by c desc limit 1);  </p>
</blockquote>
<p>慢查询日志slow log：{Query_time:0.000478 Lock_time:0.000128 Rows_sent:0 Rows_examined:5}。扫描行数5。  </p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>partitions</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>filtered</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>insert</td>
<td>t</td>
<td>null</td>
<td>all</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>1</td>
<td>simple</td>
<td>t</td>
<td>null</td>
<td>index</td>
<td>null</td>
<td>c</td>
<td>5</td>
<td>null</td>
<td>1</td>
<td>100.00</td>
<td>Using temporary</td>
</tr>
</tbody></table>
<p>Extra字段中Using temporary，表示这个语句用到了临时表。表示执行过程中，需要把表t的内容读出来，写入临时表。rows=1是受到了limit 1的影响。  </p>
<p>执行语句前后查看innode_rows_read的结果：show status like ‘%Innodb_rows_read%’;增加了4。临时表默认使用Memory引擎，这4行查的都是表t，表示对表t租了全表扫描。  </p>
<p>执行过程：  </p>
<ol>
<li>创建临时表，表里有两个字段c和d。  </li>
<li>按照索引c扫描表t，依次取c=4、3、2、1，然后回表，读到c和d的值写入临时表。这时Rows_examined=4。  </li>
<li>由于语句里面有limit 1，所以只取了临时表的第一行，再插入到表t中。这时Rows_examined的值加1，变成了5。  </li>
</ol>
<p>这个语句会导致在表t上做全表扫描，并且会给索引c上的所有间隙都加上共享的next-key lock。所以这个语句执行期间，其他事务不能在这个表上插入数据。  </p>
<p>这类一边遍历数据，一边更新数据的情况，如果读出来的数据直接写回原表，就可能在遍历过程中，读到刚刚插入的记录，新插入的记录如果参与计算逻辑，就跟语义不符。（可能造成循环写入，所以需要临时表Using temporary）  </p>
<p>由于在实现上，这个语句没有在子查询中就直接使用limit 1，导致了这个语句的执行需要遍历整个表t（？？？）。优化方法，先insert into到临时表temp_t(数据量小可以使用内存临时表)，这样就只需要扫描一行；然后再从表temp_t里面取出这行数据插入表t1。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">temporary</span> <span class="keyword">table</span> temp_t(c <span class="built_in">int</span>, d <span class="built_in">int</span>) <span class="keyword">engine</span>=<span class="keyword">memory</span>;  </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> temp_t (<span class="keyword">select</span> c+<span class="number">1</span>, d <span class="keyword">from</span> t <span class="keyword">force</span> <span class="keyword">index</span>(c) <span class="keyword">order</span> <span class="keyword">by</span> c <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">1</span>);  </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">select</span> * <span class="keyword">from</span> temp_t;  </span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> temp_t;</span><br></pre></td></tr></table></figure>

<h3 id="insert唯一键冲突-会在冲突的唯一值上加共享的next-key-lock-S锁"><a href="#insert唯一键冲突-会在冲突的唯一值上加共享的next-key-lock-S锁" class="headerlink" title="insert唯一键冲突-会在冲突的唯一值上加共享的next-key lock(S锁)"></a>insert唯一键冲突-会在冲突的唯一值上加共享的next-key lock(S锁)</h3><table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
</tr>
</thead>
<tbody><tr>
<td>insert into values(10,10,10);</td>
<td></td>
</tr>
<tr>
<td>begin;</br>insert into values(11,10,10);<br>(Duplicate entry ‘10’ for key ‘c’)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>insert into t values(12,9,9);</blocked></td>
</tr>
</tbody></table>
<p>可重复读隔离级别下，sessionB要执行的insert语句进入了锁等待状态。  </p>
<p>sessionA执行insert语句，发生唯一键冲突的时候，并不是简单的报错返回，还在冲突的索引上加了锁(在要写入的时候，发现有冲突，才会加上next-key lock的锁)。  </p>
<p>一个next-key lock是由它右边界的值定义的，这时sessionA持有索引c上的(5,10]共享next-key lock(读锁)（从作用上来看，可以避免这一行被别的事务删掉）。因此碰到由于唯一键约束导致报错后，要尽快提交或回滚事务，避免加锁时间过长，导致后续出现死锁。  </p>
<blockquote>
<p>gap lock无所谓S还是X的，主要解决幻读问题，不管属于读锁还是写锁，都会阻塞其他事务的写请求。gap lock+排他的record就称作排他的next-key lock。  </p>
</blockquote>
<ul>
<li>select…lock in share mode是共享锁；  </li>
<li>select…for update和IUD语句是排它锁。  <blockquote>
<p>复习：next-key lock由间隙锁gap lock和记录锁record lock组成。加锁单位是next-key lock。  </p>
</blockquote>
</li>
</ul>
<p>主键索引和唯一索引冲突，加的都是next-key lock(间隙锁+记录锁)。(官方文档主键索引加记录锁，唯一索引加next-key lock)  </p>
<h4 id="死锁场景"><a href="#死锁场景" class="headerlink" title="死锁场景"></a>死锁场景</h4><table>
<thead>
<tr>
<th></th>
<th>sessionA</th>
<th>sessionB</th>
<th>sessionC</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>begin;</br>insert into t values(null,5,5);</td>
<td></td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td></td>
<td>insert into t values(null,5,5);</td>
<td>insert into t values(null,5,5);</td>
</tr>
<tr>
<td>T3</td>
<td>rollback;</td>
<td></td>
<td>(DeadLock found)</td>
</tr>
</tbody></table>
<p>sessionA执行rollback语句回滚的时候，sessionC几乎同时发现死锁并返回。  </p>
<ol>
<li>在T1时刻，启动sessionA，并执行insert语句，此时在索引c的c=5上加了记录锁。这个索引是唯一索引，因此退化为记录锁。  </li>
<li>在T2时刻，sessionB要执行相同的insert语句，发现了唯一键冲突，才加上读锁；同样sessionC也在索引c上，c=5这一记录上，加了读锁。  </li>
<li>T3时刻，sessionA回滚。这时，sessionB和sessionC都试图继续执行插入操作，都要加上写锁。两个session都要等待对方的行锁，所以就出现了死锁。  <blockquote>
<p>插入意向锁Lock_insert_intention会被间隙锁gap lock阻塞，造成相互等待。  </p>
</blockquote>
</li>
</ol>
<h3 id="insert-into…on-duplicate-key-update"><a href="#insert-into…on-duplicate-key-update" class="headerlink" title="insert into…on duplicate key update"></a>insert into…on duplicate key update</h3><blockquote>
<p>insert into t values(11,10,10) on duplicate key update d=100;  </p>
</blockquote>
<p>insert唯一键冲突示例中主键冲突后直接报错，而该例子主键冲突后会给索引c上(5,10]加一个排他的next-key lock(写锁)。  </p>
<p>insert into…on duplicate key update这个语义的逻辑是，插入一行数据，如果碰到唯一键约束，就执行后面的更新语句。  </p>
<p>如果有多个列违反了唯一键约束，就会按照索引的顺序，修改跟第一个索引冲突的行。  </p>
<p>执行这条语句的affected rows返回的是2，实际上，真正更新的只有一行，只是在代码实现上，insert和update都认为自己成功了，update计数加了1，insert计数也加了1。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>Java代码是怎么运行的</title>
    <url>/JVM/1Java%E4%BB%A3%E7%A0%81%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%90%E8%A1%8C%E7%9A%84/</url>
    <content><![CDATA[<p>Java代码有多种不同的运行方式：在开发工具中运行，双击执行jar文件运行，在命令行中(java -jar xxx.jar)运行，在网页中(Applet)运行。这些执行方式都离不开JRE-Java运行时环境。  </p>
<ul>
<li>JVM，Java虚拟机  </li>
<li>JRE，Java运行时环境，包括JVM和Java核心类库  </li>
<li>JDK，Java开发工具表，包括JRE和一系列开发、诊断工具  </li>
</ul>
<h3 id="Java要在虚拟机里运行"><a href="#Java要在虚拟机里运行" class="headerlink" title="Java要在虚拟机里运行"></a>Java要在虚拟机里运行</h3><p>Java是一门高级程序语言，不能直接在硬件上运行，需要进行转换。通过编译器将Java程序转换成虚拟接所能识别的指令序列-Java字节码(Java字节码指令的操作码opcode被固定为一个字节)。  </p>
<blockquote>
<p>C++的策略是直接编译成目标架构的机器码，Java的策略是编译成一个虚拟架构的机器码(将虚拟机当做一个机器，所接收的代码格式-“机器码”。Java虚拟机的机器码-Java字节码)。  </p>
</blockquote>
<h4 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h4><p>Java虚拟机可以由硬件实现(Java processor)，也可在各个现有平台上(Windows_x64、Linux_aarch64)提供软件实现(JRE)。一旦一个程序被转换成Java字节码，便可以在不同平台上的虚拟机实现里运行-一次编写，到处运行。  </p>
<h4 id="代码托管环境"><a href="#代码托管环境" class="headerlink" title="代码托管环境"></a>代码托管环境</h4><p>虚拟机带来了一个托管环境-Managed Runtime。这个托管环境能够处理一些代码中冗长而且容易出错的部分，如自动内存管理、垃圾回收以及数组越界、动态类型、安全权限等动态监测。  </p>
<h3 id="Java虚拟机运行Java字节码"><a href="#Java虚拟机运行Java字节码" class="headerlink" title="Java虚拟机运行Java字节码"></a>Java虚拟机运行Java字节码</h3><p>HotSpot虚拟机为例。  </p>
<blockquote>
<p>HotSpot是JVM中的引擎，JDK中用C++写的部分。  </p>
</blockquote>
<h4 id="从虚拟机视角"><a href="#从虚拟机视角" class="headerlink" title="从虚拟机视角"></a>从虚拟机视角</h4><p>从虚拟机视角，执行Java代码首先需要将它编译而成的class文件加载到Java虚拟机中。加载后的Java类会被放于方法区-Method Area中，实际运行时，虚拟机会执行方法区内的代码。(与X86的段式内存管理中的代码段类似)  </p>
<p>Java虚拟机在内存中划分出堆(存放Java对象)和栈来存储运行时数据。并且会将栈细分为面向Java方法的Java方法栈、面向本地方法(用C++写的native方法)的本地方法栈、存放各个线程执行位置的PC寄存器。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        JVM虚拟机
    </div>
    <div class='spoiler-content'>
        <img src='/img/JVM虚拟机.png'>
    </div>
</div>  

<p>在运行过程中，每当调用进入一个Java方法，Java虚拟机会在当前线程的Java方法栈中生成一个栈帧，用以存放局部变量以及字节码的操作数。栈帧的大小是提前计算好的，并且JVM不要求栈帧在内存空间里连续分布。  </p>
<p>当退出当前执行的方法时，不管是正常返回还是异常返回，Java虚拟机均会弹出当前线程的当前栈帧，并将之舍弃。  </p>
<h4 id="从硬件视角"><a href="#从硬件视角" class="headerlink" title="从硬件视角"></a>从硬件视角</h4><p>从硬件视角，Java字节码无法直接执行。Java虚拟机需要将字节码翻译成机器码。  </p>
<p>在HotSpot里，有两种翻译形式：  </p>
<ul>
<li>解释执行，逐条将字节码翻译成机器码并执行；  </li>
<li>即时编译(Just-In-Time compilation,JIT)，将一个方法中包含的所有字节码编译成机器码后再执行(重启后需要重做)。  <blockquote>
<p>AOT(ahead of time compilation)线下编译</p>
</blockquote>
</li>
</ul>
<p>解释执行无需等待编译，即时编译实际运行速度更快。HotSpot默认采用混合模式，综合两者优点。先解释执行字节码，而后将其中反复执行的热点代码，<strong>以方法为单位</strong>进行即时编译。  </p>
<blockquote>
<p>JVM两种编译方式：</p>
<ul>
<li>整个方法进行编译</li>
<li>热循环进行编译-on stack replacement</li>
</ul>
</blockquote>
<h3 id="Java虚拟机的运行效率"><a href="#Java虚拟机的运行效率" class="headerlink" title="Java虚拟机的运行效率"></a>Java虚拟机的运行效率</h3><p>HotSpot采用多种技术提升启动性能以及峰值性能。  </p>
<p>即时编译建立在程序符合二八定律的假设上，百分之二十的代码占据了百分之八十的计算资源。对于占据大部分的不常用的代码，才去解释执行的方式运行(多次调用多次解释执行)；对于仅占据小部分的热点代码，将其编译成机器码，以达到理想的运行速度。  </p>
<p>即时编译拥有程序的运行时信息，能够根据这个信息作出相应优化(多态-虚方法调用开销，多个目标方法只调用其中一个)，执行效率可能超过静态编译。峰值性能更好。  </p>
<p>HotSpot内置即时编译器：C1、C2、Graal(Java 10)。  </p>
<ul>
<li>C1，Client编译器。面向的是对启动性能有要求的客户端GUI程序，采用的优化手段相对简单，编译时间较短。  </li>
<li>C2，Server编译器。面向的是对峰值性能有要求的服务端程序，采用的优化手段相对复杂，便是时间较长，但生成代码的执行效率较高。  </li>
</ul>
<p>HotSpot默认采用分层编译的方式(Java 7)：热点方法首先会被C1编译，而后热点方法中的热点会进一步被C2编译(默认的分层编译，达到两千调C1，达到一万五调C2)。即时编译是放在额外的编译线程中进行的，不干扰应用的正常运行。根据CPU的数量设置编译线程的数目，按1:2的比例配置给C1及C2编译器。  </p>
<blockquote>
<p>热点代码：  </p>
<ul>
<li>基于采样的热点探测  </li>
<li>基于计数器的热点探测  <ul>
<li>方法调用计数器(JVM采用)  </li>
<li>回边计数器  </li>
</ul>
</li>
</ul>
</blockquote>
<p>字节码的解释执行和即时编译可同时执行。编译完成后的机器码会在下次调用该方法时启用，替换原本的解释执行。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>Java的基本类型</title>
    <url>/JVM/2Java%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>Java引进了八个基本类型，在执行效率以及内存使用两方面提升软件性能。  </p>
<h3 id="Java虚拟机的boolean类型"><a href="#Java虚拟机的boolean类型" class="headerlink" title="Java虚拟机的boolean类型"></a>Java虚拟机的boolean类型</h3><p>在Java语言规范中，boolean类型的值只有两种可能，分别用符号”true”和”false”来表示。这两个符号是不能被虚拟机直接使用的。  </p>
<p>在Java虚拟机规范中，boolean类型则被映射成int类型。”true”被映射为整数1，”false”被映射为整数0。这个编码规则约束了Java字节码的具体实现：如对于存储boolean数组的字节码，Java虚拟机需要保证实际存入的值是整数1或者0。  </p>
<p>Java虚拟机规范同时要求Java编译器遵守这个编码规则，并且用整数相关的字节码来实现逻辑运算，以及基于boolean类型的条件跳转。在编译而成的class文件中，除了字段和传入参数外，基本看不出boolean类型的痕迹。  </p>
<p>对于Java虚拟机来说，它看到的boolean类型，早已被映射为整数类型。将原本声明为boolean类型的局部变量，赋值为除了0、1之外的整数值，在Java虚拟机看来是合法的。  </p>
<h3 id="Java的基本类型"><a href="#Java的基本类型" class="headerlink" title="Java的基本类型"></a>Java的基本类型</h3><p>Java的基本类型还包括整数类型byte、short、char、int和long，以及浮点类型float和double。  </p>
<table>
<thead>
<tr>
<th>类型</th>
<th>字节</th>
<th>位</th>
<th>值域</th>
<th>默认值</th>
<th>虚拟机内部符号</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td></td>
<td></td>
<td>{false,true}</td>
<td>false</td>
<td>Z</td>
</tr>
<tr>
<td>byte</td>
<td>1byte</td>
<td>8bit</td>
<td>[-128,127]</td>
<td>0</td>
<td>B</td>
</tr>
<tr>
<td>short</td>
<td>2byte</td>
<td>16bit</td>
<td>[-32768,32767]</td>
<td>0</td>
<td>S</td>
</tr>
<tr>
<td>char</td>
<td>2byte</td>
<td>16bit</td>
<td>[0,65525]</td>
<td>‘\u0000’</td>
<td>C</td>
</tr>
<tr>
<td>int</td>
<td>4byte</td>
<td>32bit</td>
<td>[-2^31,2^31-1]</td>
<td>0</td>
<td>I</td>
</tr>
<tr>
<td>long</td>
<td>8byte</td>
<td>64bit</td>
<td>[-2^63,2^63-1]</td>
<td>0L</td>
<td>J</td>
</tr>
<tr>
<td>float</td>
<td>4byte</td>
<td>32bit</td>
<td>~[-3.4E38,3.4E38]</td>
<td>+0.0F</td>
<td>F</td>
</tr>
<tr>
<td>double</td>
<td>8byte</td>
<td>64bit</td>
<td>~[-1.8E308,1.8E308]</td>
<td>+0.0D</td>
<td>D</td>
</tr>
</tbody></table>
<p>基本类型从上到下的值域依次扩大，而且前面的值域被后面的值域所包含。从前面的基本类型转换至后面的基本类型，无需强制转换。尽管默认值看起来不一样，但在内存中都是0。  </p>
<p>boolean和char是唯二的无符号类型。在不考虑违反规范的情况下，boolean类型的取值范围是0或者1。char类型的取值范围则是[0,65535]。通常可以认定char类型的值为非负数。这种特性可以用作数组索引。  </p>
<p>声明为boolean、byte、char、short的局部变量，能够存储超出它们取值范围的数值。  </p>
<p>Java浮点类型采用IEEE754浮点数格式。以float为例，浮点类型通常有两个0，+0.0F以及-0.0F。前者在Java里是0，后者是符号为1、其他位均为0的浮点数，在内存中等同于十六进制整数0x8000000(即-0.0F可通过Float.intBitsToFloat(0x8000000)求得)。它们的内存数值不同，但是在Java中+0.0F==-0.0F会返回真。  </p>
<p>正无穷是任意正浮点数(不包括+0.0F)除以+0.0F得到的值；负无穷是任意正浮点数除以-0.0F得到的值。在Java中，正无穷和负无穷是有确切的值，在内存中分别等同于十六进制整数0x7F800000和0xFF800000。  </p>
<p>[0x7F800001,0x7FFFFFFF]和[0xFF800001,0xFFFFFFFF]对应的都是NaN(Not-a-Number)。一般计算得出的NaN，如+0.0F/+0.0F=0x7FC00000。称之为标准的NaN，其他的称之为不标准的NaN。NaN：除了”!=”始终返回true之外，所有其他比较结果都会返回false。  </p>
<blockquote>
<p>NaN&lt;1.0F返回false，NaN&gt;=1.0F返回false。对于任意浮点数f(包括0，NaN)，f!=NaN始终返回true，f==NaN始终返回false。  </p>
</blockquote>
<h3 id="Java基本类型的大小"><a href="#Java基本类型的大小" class="headerlink" title="Java基本类型的大小"></a>Java基本类型的大小</h3><p>Java虚拟机每调用一个Java方法，便会创建一个栈帧。以解释器使用的解释栈帧(interpreted frame)为例。  </p>
<p>这种栈帧有两个主要的组成部分，分别是局部变量区、字节码的操作数栈。局部变量是广义的，除了普遍意义下的局部变量之外，还包含实例方法的”this指针”以及方法所接受的参数。  </p>
<h4 id="存储-掩码操作"><a href="#存储-掩码操作" class="headerlink" title="存储-掩码操作"></a>存储-掩码操作</h4><p>在Java虚拟机规范中，局部变量区等价于一个数组，并且可以用正整数来索引。除了long、double值需要用两个数组单元来存储之外，其他基本类型以及引用类型的值均占用一个数组单元。boolean、byte、char、short这四种类型，在<strong>栈上</strong>占用的空间和int是一样的，和引用类型也是一样的。在32为的HotSpot中，这些类型在栈上将占用4个字节(一个数组单位4字节)；在64位的HotSpot中，将占8个字节(一个数组单位8字节)。  </p>
<blockquote>
<p>变长数组不好控制，浪费一些空间转换成定长，以便访问时直接通过下标来计算地址。  </p>
</blockquote>
<p>存储于<strong>堆中</strong>的字段或者数组元素上，对于byte、char、short这三种类型的字段或者数组单元，他们在堆上占用的空间分别为一字节、两字节、两字节，跟这些类型的值域相吻合(在栈上跟值域不吻合)。  </p>
<p>将一个int类型的值，存储到这些类型的字段或者数组时，相当于做了一次隐式的掩码操作。如，把0xFFFFFFFF(-1)存储到一个声明为char类型的字段里时，由于该字段仅占两字节，所以高位的字节便会被截取掉，最终存入”\uFFFF”。(32位)  </p>
<p>在HotSpot中，boolean字段占用一字节(存储到堆中)，而boolean数组则直接用byte数组实现。为了保证堆中的boolean值是合法的，HotSpot在存储时显式的进行掩码操作，只取最后一位的值存入boolean字段或者数组中。  </p>
<h4 id="加载-扩展操作"><a href="#加载-扩展操作" class="headerlink" title="加载-扩展操作"></a>加载-扩展操作</h4><p>Java虚拟机的算术运算几乎全部依赖于操作数栈。需要将堆中的boolean、byte、char、short加载到操作数栈上，而后将栈上的值当成int类型来运算。  </p>
<blockquote>
<p>其他long、double、float加载至操作数栈上，当成各自类型来计算，不用转换。  </p>
</blockquote>
<p>对于boolean、char这两个无符号类型，加载伴随着零扩展。char的大小为两个字节，在加载char的值会被复制到int类型的低二字节，高二字节则会用0来填充。  </p>
<p>对于byte、short这两个类型来说，加载伴随着符号扩展。short的大小为两个字节。在加载时short的值同样会被复制到int类型的低二字节。如果该short值为非负数，即最高位为0，那么该int类型的值的高二字节会用0来填充，否则用1来填充。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>自增id</title>
    <url>/MySQL/%E8%87%AA%E5%A2%9Eid/</url>
    <content><![CDATA[<p>MySQL里有很多自增的id，每个自增id都定义了初始值，然后不停的往上加步长。虽然自然数是没有上限的，但是在计算机里，只要定义了表示这个数的字节长度，那它就有上限。无符号整型(unsigned int)是4个字节，上限是2<sup>32</sup>-1。  </p>
<h3 id="表定义自增值id"><a href="#表定义自增值id" class="headerlink" title="表定义自增值id"></a>表定义自增值id</h3><p>表结构定义中的自增字段。<br><a href="/MySQL/自增主键">MySQL-自增主键</a></p>
<p>表定义的自增值达到上限后的逻辑是：再申请下一个id时，得到的值保持不变。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t(<span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">unsigned</span> auto_increment primary <span class="keyword">key</span>) auto_increment=<span class="number">4294967295</span>;  </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>);  </span><br><span class="line">//成功插入一行 4294967295  </span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> t;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span> auto_increment,  </span><br><span class="line">    primary <span class="keyword">key</span> (<span class="keyword">id</span>)  </span><br><span class="line">) <span class="keyword">engine</span>=<span class="keyword">innodb</span> auto_increment=<span class="number">4294967295</span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>);  </span><br><span class="line">// Duplicate entry '4294967295' for key 'primary'</span><br></pre></td></tr></table></figure>

<p>第一个insert语句插入数据成功后，这个表的auto_increment没有改变，就导致第二个insert语句又拿到相同的自增id值，再试图执行插入语句，报主键冲突错误。  </p>
<p>在建表的时候需要考虑表是否有可能达到2<sup>32</sup>-1这个上限，如果有可能，就应该创建成8个字节的bigint unsigned。  </p>
<h3 id="InnoDB系统自增row-id"><a href="#InnoDB系统自增row-id" class="headerlink" title="InnoDB系统自增row_id"></a>InnoDB系统自增row_id</h3><p>如果创建的InnoDB表没有指定主键，那么InnoDB会创建一个不可见的，长度为6个字节的row_id。InnoDB维护了一个全局的dict_sys.row_id值，所有无主键的InnoDB表，每插入一行数据，都将当前的dict_sys.row_id值作为要插入数据的row_id，然后把dict_sys.row_id的值加1。  </p>
<p>在代码实现时row_id是一个长度为8字节的无符号长整型(bigint unsigned)。InnoDB在设计时，给row_id留的只是6个字节的长度，这样写到数据表中时只放了最后6个字节，row_id能写到数据表中的值的特征：  </p>
<ol>
<li>row_id写入表中的值范围，是从0到2<sup>48</sup>-1；  </li>
<li>当dict_sys.row_id=2<sup>48</sup>时，如果再有插入数据的行为要来申请row_id，拿到以后再取最后6个字节的话就是0。  </li>
</ol>
<p>写入表的row_id是从0开始到2<sup>48</sup>-1。达到上限后，下一个值就是0，然后继续循环。在InnoDB逻辑里，申请到row_id=N后，就将这行数据写入表中；如果表中已经存在row_id=N的行，新写入的行就会覆盖原有的行。  </p>
<p>通过gdb修改系统自增row_id。  </p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">mysql&gt;<span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">table</span> t(a <span class="type">int</span>) engine=innodb;  </span><br><span class="line">gdb -p &lt;pid <span class="keyword">of</span> mysqld&gt; -ex <span class="string">'p dict_sys.row_id=1'</span> <span class="comment">--batch  </span></span><br><span class="line">mysql&gt;<span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>);  </span><br><span class="line">gdb -p &lt;pid.mysqld&gt; -ex <span class="string">'p dict_sys.row_id=281474976710656'</span> <span class="comment">--batch  </span></span><br><span class="line">mysql&gt;<span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">2</span>);  </span><br><span class="line">mysql&gt;<span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">3</span>);  </span><br><span class="line">mysql&gt;<span class="keyword">select</span> * <span class="keyword">from</span> t;</span><br></pre></td></tr></table></figure>

<p>用gdb将dict_sys.row_id设置为2<sup>48</sup>之后，再插入的a=2的行会出现在表t的第一行，因为这个值的row_id=0。之后在插入的a=3的行，由于row_id=1，就覆盖了之前a=1的行，因为a=1这一行的row_id也是1。  </p>
<p>在InnoDB表中主动创建自增主键，表自增id到达上限后，再插入数据时报主键冲突错误，更能被接受。覆盖数据，则意味着数据丢失，影响的是数据可靠性；报主键冲突，是插入失败，影响的是可用性。一般情况下，可靠性优先于可用性。  </p>
<h3 id="Xid"><a href="#Xid" class="headerlink" title="Xid"></a>Xid</h3><p>redo log和binlog相配合的时候，它们有一个共同的字段叫做Xid，它在MySQL中是用来对应事务的。<br><a href="/MySQL/日志与索引">MySQL-日志与索引</a></p>
<p>MySQL内部维护了一个全局变量global_query_id，每次执行语句的时候将它赋值给Query_id，然后给这个变量加1。如果当前语句是这个事务执行的第一条语句，那么MySQL还会同时把Query_id赋值给这个事务的XID。  </p>
<p>而global_query_id是一个纯内存变量，重启之后就清零了。在同一个数据库实例中，不同事务的Xid是有可能相同的。  </p>
<p>但是MySQL重启之后会重新生成新的binlog文件，这就保证了，同一个binlog文件里，Xid一定是唯一的。  </p>
<p>虽然MySQL重启不会导致同一个binlog里面出现两个相同的Xid，但是如果global_query_id达到上限后，就会继续从0开始计数。从理论上讲，还是回出现同一个binlog里面出现相同Xid的场景。  </p>
<p>global_query_id定义的长度是8个字节，这个自增值的上限是2<sup>64</sup>-1。重复的可能性质存在于理论上。  </p>
<ol>
<li>执行一个事务，假设Xid是A；  </li>
<li>接下来执行2<sup>64</sup>次查询语句，让global_query_id回到A；  </li>
<li>再启动一个事务，这个事务的Xid也是A。  </li>
</ol>
<h3 id="Innodb-trx-id"><a href="#Innodb-trx-id" class="headerlink" title="Innodb trx_id"></a>Innodb trx_id</h3><p>Xid和InnoDB的trx_id是两个容易混淆的概念。  </p>
<p><strong>Xid是由server层维护的。InnoDB内部使用Xid，是为了能够在InnoDB事务和server之间做关联。InnoDB自己的trx_id是另外维护的。</strong>事务可见性用到的事务id(transaction id)。<br><a href="/MySQL/隔离事务">MySQL-隔离事务</a></p>
<p>InnoDB内部维护了一个max_trx_id全局变量，每次需要申请一个新的trx_id时，就获得max_trx_id的当前值，然后将max_trx_id加1。  </p>
<p>InnoDB数据可见性的核心思想是：每一行数据都记录了更新它的trx_id，当一个事务读到一行数据的时候，判断这个数据是否可见的方法，就是通过事务的一致性视图与这行数据的trx_id做对比。  </p>
<p>对于正在执行的事务，可以从information_schema.innodb_trx表中看到事务的trx_id。  </p>
<table>
<thead>
<tr>
<th></th>
<th>sessionA</th>
<th>sessionB</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>begin;</br>select * from t limit 1;</td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td></td>
<td>use information_schema;</br>select trx_id, trx_mysql_thread_id from innodb_trx;</br>trx_id=421578461423440</br>trx_mysql_thread_id=5</td>
</tr>
<tr>
<td>T3</td>
<td>insert into t values(null);</td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td>select trx_id, trx_mysql_thread_id from innodb_trx;</br>trx_id=1289</br>trx_mysql_thread_id=5</td>
</tr>
</tbody></table>
<p>sessionB中，从innodb_trx表里查出两个字段，trx_mysql_thread_id表示线程id，说明这两次查询看到的事务对应的线程id都是5，就是sessionA所在的线程。  </p>
<p>在T1时刻，sessionA还没有涉及到更新，是一个只读事务(select…for update不是只读事务)。对于只读事务，InnoDB并不会分配trx_id。  </p>
<ol>
<li>在T1时刻，trx_id的值其实就是0。T2中这个很大的数，只是显示用的。  </li>
<li>直到sessionA在T3时刻执行insert语句的时候，InnoDB才真正分配了trx_id。T4时刻，sessionB查到的这个trx_id的值就是1289。  </li>
</ol>
<h4 id="显示的事务id不止加1"><a href="#显示的事务id不止加1" class="headerlink" title="显示的事务id不止加1"></a>显示的事务id不止加1</h4><ol>
<li>update和delete语句除了事务本省，还涉及到标记删除旧数据，也就是要把数据放到purge队列里等待后续物理伤处，这个操作也会把max_trx_id+1，因此在一个事务中至少加2；  </li>
<li>InnoDB的后台操作，如表的索引信息统计这类操作，也会启动内部事务。综合导致看到的trx_id值并不是按照加1递增的。</li>
</ol>
<h4 id="只读事务超大事务id"><a href="#只读事务超大事务id" class="headerlink" title="只读事务超大事务id"></a>只读事务超大事务id</h4><p>这个数字是每次查询的时候有系统临时计算出来的。算法是：把当前事务的trx变量的指针地址转成整数，再加上2<sup>48</sup>。  </p>
<ol>
<li>因为同一个只读事务在执行期间，它的指针地址是不会变的，所以不论是在innodb_trx还是在innodb_locks表里，同一个只读事务查出来的trx_id就会是一样的。  </li>
<li>如果有并行的多个只读事务，每个事务的trx变量的指针地址肯定不同。这样，不同的并发只读事务，查出来的trx_id就是不同的。  </li>
</ol>
<p>在显示值里面加上2<sup>48</sup>，目的是要保证只读事务显示的trx_id值比较大，正常情况下就会区别于读写事务的id。  </p>
<blockquote>
<p>trx_id跟row_id的逻辑类似，定义长度也是8个字节，在理论上还是可能出现一个读写事务与一个只读事务显示的trx_id相同的情况。概率低，危害小，可忽略。  </p>
</blockquote>
<h4 id="只读事务不分配trx-id好处"><a href="#只读事务不分配trx-id好处" class="headerlink" title="只读事务不分配trx_id好处"></a>只读事务不分配trx_id好处</h4><ol>
<li>这样做可以减小事务视图里面活跃事务数组的大小。因为当前正在运行的只读事务，是不影响数据的可见性判断的。所以在创建事务的一致性视图时，InnoDB就只需要拷贝读写事务的trx_id。  </li>
<li>可以减少trx_id的申请次数。在InnoDB里，即使只是执行一个普通的select语句，在执行过程中，也是要对应一个只读事务的。只读事务优化后，普通的查询语句不需要申请trx_id，大大减少了并发事务申请trx_id的锁冲突。  </li>
</ol>
<p>由于只读事务不分配trx_id，trx_id的增加速度变慢了。  </p>
<h4 id="脏读bug"><a href="#脏读bug" class="headerlink" title="脏读bug"></a>脏读bug</h4><p>max_trx_id会持久化存储，重启也不会重置为0，从理论上讲，只要一个MySQL服务跑的足够久，就可能出现max_trx_id达到2<sup>48</sup>-1的上限，然后从0开始的情况。  </p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">mysql&gt;<span class="keyword">create</span> <span class="keyword">table</span> t(id <span class="type">int</span> <span class="keyword">primary key</span>, c <span class="type">int</span>)engine=innodb;  </span><br><span class="line">mysql&gt;<span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>);  </span><br><span class="line">gdb -p &lt;pid.mysqld&gt; -ex <span class="string">'p trx_sys-&gt;max_trx_id=281474976710655'</span> <span class="comment">--batch  </span></span><br><span class="line">// 将max_trx_id的值修改为<span class="number">2</span>&lt;sup&gt;<span class="number">48</span>&lt;/sup&gt;<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th>sessionA</th>
<th>sessionB</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>begin;</br>select * from t;//TA</br>id=1;c=1;</td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td></td>
<td>update t set c=1 where id=1;</br>begin;</br>update t set c=3 where id=1;</td>
</tr>
<tr>
<td>T3</td>
<td>select * from t;</br>id=1;c=3;//脏读</td>
<td></td>
</tr>
</tbody></table>
<p>在T1时刻，由于已经把系统的max_trx_id设置成了2<sup>48</sup>-1，所以在sessionA启动的事务TA的低水位就是2<sup>48</sup>-1。  </p>
<p>在T2时刻，sessionB执行第一条update语句的事务id就是2<sup>48</sup>-1，而第二条update语句的事务id就是0了，这条update语句执行后生成的数据版本上的trx_id就是0。  </p>
<p>在T3时刻，sessionA执行select语句的时候，判断可见性发现，c=3这个数据版本的trx_id，小于事务TA的低水位，因此认为这个数据可见。但这个是脏读。  </p>
<p>由于低水位值会持续增加，而事务id从0开始计数，就导致了系统在这个时刻之后，所有的查询斗湖出现脏读。并且MySQL重启时max_trx_id也不会清0，重启MySQL，这个bug仍然存在。这个bug只要MySQL实例服务时间够长，就会必然出现。  </p>
<h3 id="thread-id"><a href="#thread-id" class="headerlink" title="thread_id"></a>thread_id</h3><p>线程id是MySQL中最常见的一种自增id。平时在查各种现场的时候，show processlist里面的第一列，就是thread_id。  </p>
<p>thread_id的逻辑：系统保存了一个全局变量thread_id_counter，每新建一个连接，就将thread_id_counter赋值给这个新连接的线程变量。  </p>
<p>thread_id_counter定义的大小是4个字节，达到2<sup>32</sup>-1后，就会重置为0，然后继续增加。但是在show processlist中不会看到两个相同的thread_id。  </p>
<p>MySQL设计了一个唯一数据的逻辑，给新线程分配thread_id的时候，逻辑代码如下：  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    new_id = thread_id_counter++;  </span><br><span class="line">&#125; where (!thread_ids.insert_unique(new_id).second);</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>表的自增id达到上限后，再申请时它的值就不会改变，进而导致继续插入数据时报主键冲突的错误。  </li>
<li>row_id达到上限后，则会归0再重新递增，如果出现相同的row_id，后写的数据会覆盖之前的数据。  </li>
<li>Xid只需要不在同一个binlog文件中出现重复值即可。理论上会出现重复值的概率极小，可忽略不计。  </li>
<li>InnoDB的，max_trx_id递增值每次MySQL重启都会被保存起来，脏读的是一个必先的bug。  </li>
<li>thread_id是使用中最常见的，也是处理的最好的一个自增id逻辑。  </li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>部分问题扩展</title>
    <url>/MySQL/%E9%83%A8%E5%88%86%E9%97%AE%E9%A2%98%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<h3 id="join写法"><a href="#join写法" class="headerlink" title="join写法"></a>join写法</h3><p>问题：  </p>
<ol>
<li>如果用left join的话，左边的表一定是驱动表吗？(与straight_join对比)  </li>
<li>如果两个表的join包含多个条件的等值匹配，是都要写到on里面，还是只把一个条件写到on里面，其他条件写到where部分？  </li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> a(f1 <span class="built_in">int</span>, f2 <span class="built_in">int</span>, <span class="keyword">index</span>(f1))<span class="keyword">engine</span>=<span class="keyword">innodb</span>;  </span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> b(f1 <span class="built_in">int</span>, f2 <span class="built_in">int</span>)<span class="keyword">engine</span>=<span class="keyword">innodb</span>;  </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> a <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">5</span>),(<span class="number">6</span>,<span class="number">6</span>);  </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> b <span class="keyword">values</span>(<span class="number">3</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">5</span>),(<span class="number">6</span>,<span class="number">6</span>),(<span class="number">7</span>,<span class="number">7</span>),(<span class="number">8</span>,<span class="number">8</span>);  </span><br><span class="line"><span class="comment">-- 表a和b都有两个字段f1和f2，不同的是表a的字段f1上有索引。  </span></span><br><span class="line"><span class="comment">-- 分别往两个表中插入6条记录，在表a和b中同时存在的数据有4行。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> a <span class="keyword">left</span> <span class="keyword">join</span> b <span class="keyword">on</span>(a.f1=b.f1) <span class="keyword">and</span> (a.f2=b.f2);<span class="comment">/*Q1*/</span>  </span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> a <span class="keyword">left</span> <span class="keyword">join</span> b <span class="keyword">on</span>(a.f1=b.f1) <span class="keyword">where</span> (a.f2=b.f2);<span class="comment">/*Q2*/</span>  </span><br><span class="line"><span class="comment">-- 这两个left join语句的语义逻辑并不相同  </span></span><br><span class="line"><span class="comment">-- 下方表格分别是Q1和Q2的结果</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>f1</th>
<th>f2</th>
<th>f1</th>
<th>f2</th>
<th></th>
<th>f1</th>
<th>f2</th>
<th>f1</th>
<th>f2</th>
</tr>
</thead>
<tbody><tr>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td></td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td></td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>5</td>
<td>5</td>
<td>5</td>
<td>5</td>
<td></td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>5</td>
</tr>
<tr>
<td>6</td>
<td>6</td>
<td>6</td>
<td>6</td>
<td></td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>6</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>null</td>
<td>null</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>null</td>
<td>null</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>语句Q1返回的结果集是6行，表a中即使没有满足匹配条件的记录，查询结果中也会返回一行，并将表b的各个字段值填成NULL。  </li>
<li>语句Q2返回的是4行。从逻辑上理解，最后的两行，由于表b中没有匹配的字段，结果集里面b.f2的值是空，不满足where部分的条件判断，因此不能作为结果集的一部分。  </li>
</ul>
<h4 id="Q1语句分析"><a href="#Q1语句分析" class="headerlink" title="Q1语句分析"></a>Q1语句分析</h4><p>Q1的explain结果：  </p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>partitions</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>filtered</th>
<th>extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>simple</td>
<td>a</td>
<td>null</td>
<td>all</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>6</td>
<td>100.00</td>
<td>null</td>
</tr>
<tr>
<td>1</td>
<td>simple</td>
<td>b</td>
<td>null</td>
<td>all</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>6</td>
<td>100.00</td>
<td>Using where; Using join buffer (Block Nested Loop)</td>
</tr>
</tbody></table>
<ul>
<li>驱动表是表a，被驱动表是表b；  </li>
<li>由于表b的f1字段上没有索引，所以使用的是Block Nested Loop Join(BNL)算法。  </li>
</ul>
<p>Q1语句执行流程：  </p>
<ol>
<li>把表a的内容读入join_buffer中。因为是select *，所以字段f1和f2都被放入join_buffer了。  </li>
<li>顺序扫描表b，对于每一行数据，判断join条件((a.f1=b.f1)and(a.f1=1))是否满足，满足条件的记录，作为结果集的一行返回。如果语句中有where子句，需要先判断where部分满足条件后，再返回。  </li>
<li>表b扫描完成后，对于没有被匹配的表a的行(在这个例子中就是(1,1)、(2,2)这两行)，把剩余字段不上null，再放入结果集中。  </li>
</ol>
<p>Q1语句是以表a为驱动表，执行效果与使用straight_join一样。  </p>
<h4 id="Q2语句分析"><a href="#Q2语句分析" class="headerlink" title="Q2语句分析"></a>Q2语句分析</h4><p>Q2explain结果:  </p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>partitions</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>filtered</th>
<th>extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>simple</td>
<td>b</td>
<td>null</td>
<td>all</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>6</td>
<td>100.00</td>
<td>Using where</td>
</tr>
<tr>
<td>1</td>
<td>simple</td>
<td>a</td>
<td>null</td>
<td>ref</td>
<td>f1</td>
<td>f1</td>
<td>5</td>
<td>test.b.f1</td>
<td>1</td>
<td>16.67</td>
<td>Using where</td>
</tr>
</tbody></table>
<p>Q2语句是以表b为驱动表的：如果一条join语句的Extra字段什么都没写，表示使用的是Index Nested-Loop Join(NLJ)算法，使用了被驱动表的索引a.f1。  </p>
<p>Q2语句执行流程：<br>顺序扫描表b，每一行用b.f1到表a中去查，匹配到记录后判断a.f2=b.f2是否满足，满足条件的话就作为结果集的一部分返回。  </p>
<p><strong>在MySQL里，NULL跟任何值执行等值判断和不等值判断的结果，都是NULL。(select NULL = NULL的结果也是返回NULL)。</strong>  </p>
<p>因此语句Q2里面where a.f2=b.f2就表示，查询结果里面不包含b.f2是NULL的行(不匹配)，这样这个left join的语义就是”找到这两个表里面，f1、f2对应相同的行。对于表a中存在，而表b中匹配不到的行，就放弃”。  </p>
<p>这条语句虽然用的是left join，但语义跟join是一致的。因此优化器就把这条语句的left join改写成join，然后因为表a的f1上有索引，就把表b作为驱动表，这样就可以用上NLJ算法。  </p>
<p>执行explain之后，再执行show warnings查看改写的结果：  </p>
<table>
<thead>
<tr>
<th>Level</th>
<th>Code</th>
<th>Message</th>
</tr>
</thead>
<tbody><tr>
<td>Note</td>
<td>1003</td>
<td>/*select#1*/ select test.a.f1 AS ‘f1’, test.a.f2 AS f2, test.b.f1 AS f1, test.b.f2 AS f2 from test.a join test.b where ((test.a.f1=test.b.f1)and(test.a.f2=test.b.f2))</td>
</tr>
</tbody></table>
<hr>
<p><strong>即使在SQL语句中写成left join，执行过程还是有可能不是从左到右连接的。使用left join时，左边的表不一定是驱动表。</strong>  </p>
<p><strong>如果需要left join语义，就不能把被驱动表的字段放在where条件里面做等值判断或不等值判断，必须都写在on里面。</strong>  </p>
<hr>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> a <span class="keyword">join</span> b <span class="keyword">on</span>(a.f1=b.f1) <span class="keyword">and</span> (a.f2=b.f2);<span class="comment">/*Q3*/</span>  </span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> a <span class="keyword">join</span> b <span class="keyword">on</span>(a.f1=b.f1) <span class="keyword">where</span> (a.f2=b.f2);<span class="comment">/*Q4*/</span></span><br></pre></td></tr></table></figure>

<p>根据explain和show warnings发现这两条语句都被改写成:<br>select * from a join b where (a.f1=b.f1) and (a.f2=b.f2);  </p>
<blockquote>
<p>跟Q2相同</p>
</blockquote>
<p>执行计划一样，join语句是否将判断条件全部放在on部分是没有区别的。  </p>
<h3 id="Simple-Nested-Loop-Join的性能问题"><a href="#Simple-Nested-Loop-Join的性能问题" class="headerlink" title="Simple Nested Loop Join的性能问题"></a>Simple Nested Loop Join的性能问题</h3><p>join语句使用不同的算法，对语句的性能影响会很大。  </p>
<p><a href="/MySQL/join执行原理">MySQL-join执行原理</a></p>
<p>虽然BNL算法和Simple Nested Loop Join算法都是要判断M*N次(M和N分别是join的两个表的行数)，但是Simple Nested Loop Join算法的每轮判断都要走全表扫描，因此性能上BNL算法执行起来会快很多。  </p>
<p>BNL算法的执行逻辑：  </p>
<ol>
<li>首先，将驱动表的数据全部读入内存join_buffer中，这里join_buffer是无序数组；  </li>
<li>然后，顺序遍历被驱动表的所有行，每一行数据都跟join_buffer中的数据进行匹配，匹配成功则作为结果集的一部分返回。  </li>
</ol>
<p>Simple Nested Loop Join算法的执行逻辑：<br>顺序取出驱动表中的每一行数据，到被驱动表去做全表扫描匹配，匹配成功则作为结果集的一部分返回。  </p>
<blockquote>
<p>其实也是把数据读到内存里，然后按照匹配条件进行判断，但性能比BNL差距依然很大。</p>
</blockquote>
<p>BNL算法性能比SNL好的原因：  </p>
<ol>
<li>在对被驱动表做全表扫描的时候，如果数据没有在Buffer Pool中，就需要等待着部分数据从磁盘读入；从磁盘读入数据到内存，会影响到正常业务的Buffer Pool命中率，而且这个算法天然会对被驱动表的数据做多次访问，更容易将这些数据页放到Buffer Pool的头部。  <blockquote>
<p><a href="/MySQL/join语句优化">MySQL-join语句优化</a>  </p>
</blockquote>
</li>
<li>即使被驱动表数据都在内存中，每次查找”下一个记录的操作”，都是类似指针操作。而join_buffer中是数组，遍历的成本更低。  </li>
</ol>
<h3 id="distinct和group-by的性能"><a href="#distinct和group-by的性能" class="headerlink" title="distinct和group by的性能"></a>distinct和group by的性能</h3><p>[MySQL-内部临时表应用-union与group&nbsp;by](/MySQL/内部临时表应用-union与group by)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a <span class="keyword">from</span> t <span class="keyword">group</span> <span class="keyword">by</span> a <span class="keyword">order</span> <span class="keyword">by</span> <span class="literal">null</span>;  </span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> a <span class="keyword">from</span> t;  </span><br><span class="line"><span class="comment">-- 表t的字段a上没有索引</span></span><br></pre></td></tr></table></figure>
<p>标准的group by语句，需要再select部分加一个聚合函数:  </p>
<blockquote>
<p>select a,count(*) from t group by a order by null;<br>按照字段a分组，计算每组的a出现的次数。在结果里，由于做的是聚合计算，相同的a只出现一次。  </p>
</blockquote>
<p>没有count(*)时，不再需要执行“计算总数”的逻辑，第一条语句的逻辑就变成：按照字段a做分组，相同的a的值只返回一行。这是distinct的语义，所以不需要执行聚合函数时，distinct和group by这两条语句的语义和执行流程是相同的，执行性能也相同。  </p>
<ol>
<li>创建一个临时表，临时表有一个字段a，并且在这个字段a上创建一个唯一索引；  </li>
<li>遍历表t，依次取数据插入临时表中：  <ul>
<li>如果发现唯一键冲突，就跳过；  </li>
<li>否则插入成功；  </li>
</ul>
</li>
<li>遍历完成后，将临时表作为结果集返回给客户端 。  </li>
</ol>
<h3 id="备库自增主键问题"><a href="#备库自增主键问题" class="headerlink" title="备库自增主键问题"></a>备库自增主键问题</h3><p>在binlog_format=statement时，语句a先获取id=1，语句b获取id=2；语句b提交，写binlog，然后语句a再提交写binlog。备库重放不会不一致。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t(<span class="keyword">id</span> <span class="built_in">int</span> auto_increment primary <span class="keyword">key</span>);  </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">begin</span><br><span class="line"><span class="comment">/*!*/</span>;</span><br><span class="line"># at <span class="number">486</span></span><br><span class="line"># at <span class="number">518</span></span><br><span class="line">#<span class="number">190219</span> hh:mm:ss server id <span class="number">1</span> end_log_pos <span class="number">518</span> CRC32 <span class="number">0x6364946b</span> <span class="built_in">int</span>var</span><br><span class="line"><span class="keyword">set</span> insert_id=<span class="number">1</span><span class="comment">/*!*/</span>;</span><br><span class="line">#<span class="number">190219</span> hh:mm:ss server id <span class="number">1</span> end_log_pos <span class="number">618</span> CRC32 <span class="number">0xb6277773</span> query thread_id=<span class="number">4</span> exec_time=<span class="number">0</span> error_code=<span class="number">0</span></span><br><span class="line"><span class="keyword">set</span> timestamp=<span class="number">1550572969</span><span class="comment">/*!*/</span>;</span><br><span class="line">insert <span class="built_in">int</span>o t values(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure>

<p>insert语句的binlog，在insert语句之前，还有一句set insert_id=1。这条命令的意思是，这个线程里下一次需要用到自增值的时候，不论当前表的自增值是多少，固定用1这个值。  </p>
<p>这个set insert_id语句是固定跟在insert语句之前的。在备库上语句b用到的insert_id依然是2，跟主库相同。即使两个insert语句在主备库的执行顺序不同，自增主键字段的值也不会不一致。  </p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">set</span> <span class="attribute">insert_id</span>=2;  </span><br><span class="line">语句b;  </span><br><span class="line"><span class="builtin-name">set</span> <span class="attribute">insert_id</span>=1;  </span><br><span class="line">语句a;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>JVM是如何执行方法调用的</title>
    <url>/JVM/4JVM%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E7%9A%84/</url>
    <content><![CDATA[<h3 id="重载与重写"><a href="#重载与重写" class="headerlink" title="重载与重写"></a>重载与重写</h3><p>在Java程序里，如果同一个类出现多个名字相同、参数类型相同的方法，那么它无法通过编译。正常情况下，想要在同一个类中定义名字相同的方法，那么它们的参数类型必须不同。这些方法之间的关系，称之为重载。  </p>
<p>重载的方法在编译过程中即可完成识别。<br>每一个方法调用，Java编译器会根据所传入参数的声明类型(与实际类型区分)来选取重载方法。选取过程：  </p>
<ol>
<li>在不考虑对基本类型自动装拆箱(auto-boxing, auto-unboxing)，以及可变长参数的情况下选取重载方法；  </li>
<li>如果在第1个阶段中没有找到适配的方法，那么在允许自动装拆箱，但不允许可变长参数的情况下选取重载方法；  </li>
<li>如果在第2个阶段中没有找到适配的方法，那么在允许自动装拆箱以及可变长参数的情况下选取重载方法。  </li>
</ol>
<p>如果Java编译器在同一个阶段中找到了多个适配的方法，那么它会在其中选择一个最为贴切的，而决定贴切程度的一个关键就是形式参数类型的继承关系。  </p>
<p>除了同一个类中的方法，重载也可以作用于这个类所继承而来的方法。如果子类定义了与父类中非私有方法同名的方法，而且这两个方法的参数类型不同，那么在子类中，这两个方法同样构成了<strong>重载</strong>。<br>如果这两个方法的参数类型相同：如果这两个方法都是静态的，那么子类中的方法<strong>隐藏</strong>了父类中的方法；如果这两个方法都不是静态的，且都不是私有的，那么子类的方法<strong>重写</strong>了父类中的方法。  </p>
<p>方法重写，是多态最重要的一种体现方式：它允许子类在继承父类部分功能的同时，拥有自己独特的行为。重写的调用：它会根据调用者的动态类型，来选取实际的目标方法。  </p>
<blockquote>
<ul>
<li>方法重载是一个类中(或子类中)定义了多个方法名相同，而参数的数量不同或者数量相同而类型和次序不同。  </li>
<li>方法重写是在子类存在方法与父类方法的名字相同，而参数的个数与类型一样，返回值也一样的方法。  </li>
<li>重载是一个类(或子类与父类)的多态性表现，重写是子类与父类的一种多态性表现。  </li>
</ul>
</blockquote>
<h3 id="JVM的静态绑定和动态绑定"><a href="#JVM的静态绑定和动态绑定" class="headerlink" title="JVM的静态绑定和动态绑定"></a>JVM的静态绑定和动态绑定</h3><p>JVM识别方法的关键在于类名、方法名以及方法描述符(method descriptor)。方法描述符，是由方法的参数类型以及返回类型所构成。在同一个类中，如果同时出现多个名字相同且描述符也相同的方法，那么JVM会在类的验证阶段报错。  </p>
<p>JVM与Java语言不同，它并不限制名字与参数类型相同，但返回类型不同的方法出现在同一个类中，对于调用这些方法的字节码来说，由于字节码所附带的方法描述符包含了返回类型，因此JVM能够准确的识别目标方法。  </p>
<p>JVM中关于方法重写的判定同样基于方法描述符。如果子类定义了与父类中非私有、非静态方法同名的方法，那么只有当这两个方法的参数类型以及返回类型一致，JVM才会判定为重写。对于Java语言中重写而JVM中非重写的情况，编译器会通过生成桥接方法来实现Java中的重写语义。  </p>
<table>
<thead>
<tr>
<th></th>
<th>重载</th>
<th>重写</th>
</tr>
</thead>
<tbody><tr>
<td>参数列表</td>
<td>必须修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>返回类型</td>
<td>可以修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>异常</td>
<td>可以修改</td>
<td>可以减少或删除，一定不能抛出新的或者更广的异常</td>
</tr>
<tr>
<td>访问</td>
<td>可以修改</td>
<td>一定不能做更严格的限制，可以降低限制</td>
</tr>
</tbody></table>
<p>对重载方法的区分在编译阶段已经完成，可认为JVM不存在重载这一概念。重载也被称为静态绑定(static binding)，或者编译时多态(compile-time polymorphism)；重写则被称为动态绑定(dynamic binding)。但在JVM中，某个类中的重载方法可能被它的子类所重写，因此Java编译器会将所有对非私有实例方法的调用编译为需要动态绑定的类型。  </p>
<p><strong>JVM中的静态绑定指的是在解析时便能够直接识别目标方法的情况，而动态绑定则指的是需要在运行过程中根据调用者的动态类型来识别目标方法的情况。</strong>  </p>
<blockquote>
<p>静态方法都是静态绑定。HotSpot虚拟机针对final方法做了优化，也会静态绑定。  </p>
</blockquote>
<p>Java字节码中与调用相关的指令共有五种：  </p>
<ol>
<li>invokestatic:用于调用静态方法。  </li>
<li>invokespecial:用于调用私有实例方法、构造器；以及使用super关键字调用父类的实例方法或构造器，和所实现接口的默认方法(注意使用super关键字调用的默认方法)。  </li>
<li>invokevirtual:用于调用非私有实例方法(可以也可能被子类重写)。  </li>
<li>invokeinterface:用于调用接口方法(包括普通调用接口的默认方法，不使用super关键字调用)。  </li>
<li>invokedynamic:用于调用动态方法。  </li>
</ol>
<p>对于invokestatic和invokespecial而言，JVM能够直接识别具体的目标方法。  </p>
<p>对于invokevirtual和invokeinterface而言，在绝大部分情况下，虚拟机需要在执行过程中，根据调用者的动态类型，来确定具体的目标方法。如果虚拟机能够确定目标方法有且仅有一个，那么它可以不通过动态类型，直接确定目标方法(如目标方法被标记为final)。  </p>
<h3 id="调用指令的符号引用"><a href="#调用指令的符号引用" class="headerlink" title="调用指令的符号引用"></a>调用指令的符号引用</h3><p>在编译过程中，并不知道目标方法的具体内存地址。Java编译器会暂时用符号引用来表示该目标方法。这一符号引用包括目标方法所在的类或接口的名字，以及目标方法的方法名和方法描述符。  </p>
<p>符号引用存储在class文件的常量池中。根据目标方法是否为接口方法，这些引用可分为接口符号引用和非接口符号引用。在执行使用了符号引用的字节码前，JVM需要解析这些符号引用，并替换为实际引用。  </p>
<p>对于非接口符号引用，假定该符号引用所指向的类为C，则JVM查找步骤：  </p>
<ol>
<li>在C中查找符合名字及描述符的方法。  </li>
<li>如果没有找到，在C的父类中继续搜索，直至Object类。  </li>
<li>如果没有找到，在C所直接实现或间接实现的接口中搜索，这一步搜索得到的目标方法必须是非私有、非静态的。并且，如果目标方法在间接实现的接口中，则需要满足C与该接口之间没有其他符合条件的目标方法。如果有多个符合条件的目标方法，则任意返回其中一个。  <blockquote>
<p>静态方法也可以通过子类来调用。另外子类的静态方法会隐藏(与重写区分)父类中的同名、同描述符的静态方法(子类调不到父类的同名静态方法了)。  </p>
</blockquote>
</li>
</ol>
<p>对于接口符号引用，假定该符号引用所指向的接口为I，则JVM查找步骤：  </p>
<ol>
<li>在I中查找符合名字及描述符的方法。  </li>
<li>如果没有找到，在Object类中的公有实例方法中搜索。  </li>
<li>如果没有找到，则在I的超接口中搜索。这一步的搜索结果的要求与非接口符号引用步骤3的要求一致。  </li>
</ol>
<p>经过上述的解析步骤之后，符号引用会被解析成实际引用。对于可以静态绑定的方法调用而言，实际引用是一个指向方法的指针。对于需要动态绑定的方法调用而言，实际引用是一个方法表的索引。  </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Java中，方法存在重载以及重写的概念，重载指的是方法名相同而参数类型不相同的方法之间的关系，重写指的是方法名相同并且参数类型也相同的方法之间的关系。  </p>
<p>JVM中，识别方法除了方法名和参数类型之外，还会考虑返回类型。  </p>
<p>JVM中，静态绑定指的是在解析时便能够直接识别目标方法的情况，而动态绑定则指的是需要在运行过程中根据调用者的动态类型来识别目标方法的情况。由于Java编译器已经区分了重载的方法，可以认为JVM中不存在重载。  </p>
<p>在Class文件中，Java编译器会用符号引用指代目标方法。在执行调用指令前，它所附带的符号引用需要被解析成实际引用。对于可以静态绑定的方法调用而言，实际引用为目标方法的指针。对于需要动态绑定的方法调用而言，实际引用为辅助动态绑定的信息。  </p>
<p>Java的重写与JVM中的重写并不一致，但是编译器会通过桥接方法来弥补。不一致原因：  </p>
<blockquote>
<ul>
<li>重写方法的返回类型不一致(Java中重写的返回值类型可以是子类)；  </li>
<li>泛型参数类型造成的方法参数类型不一致。  </li>
</ul>
</blockquote>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>JVM是如何处理异常的</title>
    <url>/JVM/6JVM%E6%98%AF%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%E7%9A%84/</url>
    <content><![CDATA[<h3 id="异常处理的组成要素"><a href="#异常处理的组成要素" class="headerlink" title="异常处理的组成要素"></a>异常处理的组成要素</h3><p>异常处理的两大组成要素是抛出异常和捕获异常。这两大要素共同实现程序控制流的非正常转移。  </p>
<h4 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h4><p>抛出异常可分为显示和隐式两种。  </p>
<ul>
<li>显示抛异常的主体是应用程序，指的是在程序中使用”throw”关键字，手动将异常实例抛出。  </li>
<li>隐式抛异常的主体则是JVM，指的是JVM在执行过程中，碰到无法继续执行的异常状态，自动抛出异常。  </li>
</ul>
<h4 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h4><p>捕获异常涉及三种代码块。  </p>
<ol>
<li>try代码块：用来标记需要进行异常监控的代码。  </li>
<li>catch代码块：跟在try代码块之后，用来捕获在try代码块中触发的某种指定类型的异常。除了声明所捕获异常的类型之外，catch代码块还定义了针对该异常类型的异常处理器。在Java中，try代码块后面可以跟着多个catch代码块，来捕获不同类型的异常。JVM会从上至下匹配异常处理器。前面的catch代码块所捕获的异常类型不能覆盖后边的，否则编译器会报错。  </li>
<li>finally代码块：跟在try代码块和catch代码块之后，用来声明一段必定运行的代码。它的设计初衷是为了避免跳过某些关键的清理代码，例如关闭已打开的系统资源。  </li>
</ol>
<p>在程序正常执行的情况下，这段代码会在try代码块之后运行。否则try代码块触发异常的情况下，如果该异常没有被捕获，finally代码块会直接运行，并且在运行之后重新抛出该异常。<br>如果该异常被catch代码块捕获，finally代码块则在catch代码块之后运行。在某些不幸的情况下，catch代码块也触发了异常，那么finally代码块同样会运行，并会抛出catch代码块触发的异常。咋某些极端不幸的情况下，finally代码块也触发了异常，那么只好终端当前finally代码块的执行，并往外抛异常。  </p>
<h3 id="异常的基本概念"><a href="#异常的基本概念" class="headerlink" title="异常的基本概念"></a>异常的基本概念</h3><p>在Java语言规范中，所有异常都是Throwable类或者其子类的实例。Throwable有两大直接子类。  </p>
<ul>
<li>第一个是Error，涵盖程序不应捕获的异常。当程序触发Error时，它的执行状态已经无法恢复，需要中止线程甚至是中止虚拟机。  </li>
<li>第二子类是Exception，涵盖程序可能需要捕获并且处理的异常。  </li>
</ul>
<p>Exception有一个特殊的子类RuntimeException，用来 表示”程序虽然无法继续执行，但是还能抢救一下”的情况。  </p>
<p>RuntimeException和Error属于Java里的非检查异常(unchecked exception)。在Java语法中，所有的检查异常都需要程序显式的捕获，或者在方法声明中用throws关键字标注。通常情况下，程序中自定义的异常应为检查异常，以便最大化利用Java编译器的编译时检查。  </p>
<p>异常实例的构造十分昂贵。这是由于在构造异常实例时，JVM需要生成该异常的栈轨迹(stack trace)。该操作会逐一访问当前线程的Java栈帧，并记录下各种调试信息，包括栈帧所指向方法的名字，方法所在的类名、文件名，以及在代码中的第几行触发该异常。  </p>
<blockquote>
<p>实践中，抛出新建异常实例。而不是缓存异常实例，因为栈轨迹不一致。  </p>
</blockquote>
<p>在生成栈轨迹时，JVM会忽略掉异常构造器以及填充栈帧的Java方法(Throwable.fillnStackTrace)，直接从新建异常位置开始算起。持外，JVM虚拟机还会忽略标记为不可见的Java方法栈帧。  </p>
<h3 id="Java虚拟机是如何捕获异常的"><a href="#Java虚拟机是如何捕获异常的" class="headerlink" title="Java虚拟机是如何捕获异常的"></a>Java虚拟机是如何捕获异常的</h3><p>在编译生成的字节码中，每个方法都附带一个异常表。异常表中的每一个条目代表一个异常处理器，并且由from指针、to指针、target指针以及所捕获的异常类型构成。这些指针的值是字节码索引(bytecode index, bci)，用以定位字节码。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        javap -c Foo
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tryBlock;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> catchBlock;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> finallyBlock;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> methodExit;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            tryBlock = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            catchBlock = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            finallyBlock = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        methodExit = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ javap -c Foo</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: iconst_0</span><br><span class="line">       2: putfield      #20      // Field tryBlock:I</span><br><span class="line">       <span class="number">5</span>: goto          <span class="number">30</span></span><br><span class="line">       <span class="number">8</span>: astore_1</span><br><span class="line">       <span class="number">9</span>: aload_0</span><br><span class="line">      <span class="number">10</span>: iconst_1</span><br><span class="line">      11: putfield      #22      // Field catchBlock:I</span><br><span class="line">      <span class="number">14</span>: aload_0</span><br><span class="line">      <span class="number">15</span>: iconst_2</span><br><span class="line">      16: putfield      #24      // Field finallyBlock:I</span><br><span class="line">      <span class="number">19</span>: goto          <span class="number">35</span></span><br><span class="line">      <span class="number">22</span>: astore_2</span><br><span class="line">      <span class="number">23</span>: aload_0</span><br><span class="line">      <span class="number">24</span>: iconst_2</span><br><span class="line">      25: putfield      #24      // Field finallyBlock:I</span><br><span class="line">      <span class="number">28</span>: aload_2</span><br><span class="line">      <span class="number">29</span>: athrow</span><br><span class="line">      <span class="number">30</span>: aload_0</span><br><span class="line">      <span class="number">31</span>: iconst_2</span><br><span class="line">      32: putfield      #24      // Field finallyBlock:I</span><br><span class="line">      <span class="number">35</span>: aload_0</span><br><span class="line">      <span class="number">36</span>: iconst_3</span><br><span class="line">      37: putfield      #26      // Field methodExit:I</span><br><span class="line">      <span class="number">40</span>: <span class="keyword">return</span></span><br><span class="line">    Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">           <span class="number">0</span>     <span class="number">5</span>     <span class="number">8</span>   Class java/lang/Exception</span><br><span class="line">           <span class="number">0</span>    <span class="number">14</span>    <span class="number">22</span>   any</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p>其中from指针和to指针标识了该异常处理器所监控的范围，try代码块索覆盖的范围。target指针则指向异常处理器的起始位置，catch代码块的起始位置。  </p>
<p>当程序触发异常时，JVM会从上到下遍历异常表中的所有条目。当触发异常的字节码的索引值在某个异常表条目的监控范围内，JVM会判断所抛出的异常和该条目想要捕获的异常是否匹配。如果匹配，JVM会将控制流转移至该条目target指针指向的字节码。  </p>
<p>如果遍历完所有异常条目，JVM仍未匹配到异常处理器，那么它会弹出当前方法对应的Java栈帧，并且在调用者(caller)中重复上述操作。在最坏情况下，JVM需要遍历当前线程Java栈上所有方法的异常表。  </p>
<p>finally代码块的编译比较复杂。当前版本Java编译器的做法，是复制finally代码块的内容，分别放在try-catch代码块所有正常执行路径以及异常执行路径的出口中。  </p>
<p>针对异常执行路径，Java编译器会生成一个或多个异常表条目，监控整个try-catch代码块，并且捕获所有种类的异常(在javap中以any指代)。<strong>这些异常表条目的target指针将各自指向另一份复制的finally代码块。并且，在这个finally代码块的最后，若触发新异常，Java编译器会重新抛出所捕获的异常。</strong>  </p>
<p>最后一份finally代码块作为异常处理器，监控try代码块以及catch代码块。它将捕获try代码块触发的、未被catch代码块捕获的异常，以及catch代码块触发的异常。(如果catch代码块捕获了异常，并且触发了另一个异常，那么finally捕获并且重抛的异常是最后的异常，原本的异常便会被忽略掉！)  </p>
<h3 id="Java7的Suppressed异常以及语法糖-try-with-resources、多异常捕获"><a href="#Java7的Suppressed异常以及语法糖-try-with-resources、多异常捕获" class="headerlink" title="Java7的Suppressed异常以及语法糖(try-with-resources、多异常捕获)"></a>Java7的Suppressed异常以及语法糖(try-with-resources、多异常捕获)</h3><p>Java7引入Suppressded异常允许开发人员将一个异常附于另一个异常之上。抛出的异常可以附带多个异常的信息(Java层面的finally代码块缺少指向所捕获异常的引用，使用Suppressed的特性较繁琐)。  </p>
<p>Java7构造了名为try-with-resources的语法糖，在字节码层面自动使用Suppressed异常。精简资源打开关闭的用法。  </p>
<p>Java7之前，对于打开的资源，需要定义一个finally代码块，来确保资源在正常或者异常执行状况下都能关闭。资源的关闭操作本身容易触发异常。如果同时打开多个资源，那么每一个资源都要对应一个独立的try-finally代码块，以保证每个资源都能够关闭。代码将会变得十分繁琐。  </p>
<p>try-with-resources语法糖，简化了上述操作。程序可以在try关键字后声明并实例化实现了AutoCloseable接口的类，编译器将自动添加对应的close()操作。与手工代码相比，try-with-resources还会使用Suppressed异常的功能，来避免原异常”被消失”。  </p>
<p>除了try-with-resources语法糖之外，Java7还支持在同一catch代码块中捕获多种异常。生成多个异常表条目，多异常捕获语法糖。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>JVM是如何实现反射的</title>
    <url>/JVM/7JVM%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%8D%E5%B0%84%E7%9A%84/</url>
    <content><![CDATA[<p>Java里的反射，允许正在运行的Java程序观测，甚至是修改程序的动态行为。可以通过Class对象枚举该类中的所有方法，还可以通过Method.setAccessible(java.lang.reflect包，继承自AccessibleObject)绕过Java语言的访问权限，在私有方法所在类之外的地方调用该方法。  </p>
<p>应用：  </p>
<ul>
<li>Java集成开发环境(IDE)，根据敲入点号时，点号前的内容，动态展示可以访问的字段或者方法。（通过语法树实现）  </li>
<li>Java调试器，在调试过程中枚举某一对象所有字段的值。  </li>
<li>Web开发中可配置的通用框架。保证框架的可扩展性，借助Java的反射机制，根据配置文件来加载不同的类。(Spring框架的依赖反转IOC)。  </li>
</ul>
<h3 id="反射API-reflect包的javadoc"><a href="#反射API-reflect包的javadoc" class="headerlink" title="反射API(reflect包的javadoc)"></a>反射API(reflect包的javadoc)</h3><p>通常来说，使用反射API的第一步便是获取Class对象。在Java中常见的有三种：  </p>
<ol>
<li>使用静态方法Class.forName来获取。  </li>
<li>调用对象的getClass()方法。  </li>
<li>直接用类名+”.class”访问。对于基本类型来说，它们的包装类型(wrapper classer)拥有一个名为”TYPE”的final静态字段，指向该基本类型对应的Class对象。  <blockquote>
<p>Integer.Type指向int.class、对于数组类型来说，可以使用类名+”[].class”来访问，int[].class。  </p>
</blockquote>
</li>
</ol>
<p>除此之外，Class类和java.lang.reflect包中还提供了许多返回Class对象的方法。对于数组类的Class对象，调用Class.getComponentType()方法可以获得数组元素的类型。  </p>
<p>一旦得到了Class对象，便可以正式的使用反射功能了。较为常用的几项：  </p>
<ol>
<li>使用newInstance()来生成一个该类的实例。它要求该类中拥有一个无参数的构造器。  </li>
<li>使用isInstance(Object)来判断一个对象是否该类的实例，语法上等同于instanceof关键字(JIT优化时会有差别)。  </li>
<li>使用Array.newInstance(Class,int)来构造该类型的数组。  </li>
<li>使用getFields()/getConstructors()/getMethods()来访问该类的成员。除了这三个之外，Class类还提供了许多其他方法。方法名中带Declared的不会返回父类的成员，但是会返回私有成员；而不带Declared的则相反。  </li>
</ol>
<p>获得了类成员之后，可以进一步做如下操作：  </p>
<ul>
<li>使用Constructor/Field/Method.setAccessible(true)来绕开Java语言的访问限制。  </li>
<li>使用Constructor.newInstance(Object[])来生成该类的实例。  </li>
<li>使用Field.get/set(Object)来访问字段的值。  </li>
<li>使用Method.invoke(Object, Object[])来调用方法。  </li>
</ul>
<h3 id="反射调用的实现"><a href="#反射调用的实现" class="headerlink" title="反射调用的实现"></a>反射调用的实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Method</span> <span class="keyword">extends</span> <span class="title">Executable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span> <span class="keyword">throws</span> ... </span>&#123;</span><br><span class="line">        ...<span class="comment">//权限检查</span></span><br><span class="line">        MethodAccessor ma = methodAccessor;</span><br><span class="line">        <span class="keyword">if</span>(ma == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ma = acquireMethodAccessor();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ma.invoke(obj, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法的反射调用-Method.invoke实际上委派给MethodAccessor来处理。MethodAccessor是一个接口，有两个具体实现：  </p>
<ul>
<li>通过本地方法来实现反射调用  </li>
<li>使用委派模式  </li>
</ul>
<p>每个Method实例的第一次反射调用都会生成一个委派实现，它所委派的具体实现便是一个本地实现：当进入了JVM内部之后，便拥有了Method实例所指向方法的具体地址。此时，反射调用将传入的参数准备好，然后调用进入目标方法。  </p>
<blockquote>
<p>反射调用先是调用了Method.invoke，然后进入委派实现(DelegatingMethodAccessorImpl)中间层，再然后进入本地实现(NativeMethodAccessorImpl)，最后到达目标方法。  </p>
</blockquote>
<p>Java的反射调用机制还设立了另一种动态生成字节码的实现。直接使用invoke指令来调用目标方法。之所以采用委派实现，是为了能够在本地实现以及动态实现中切换。  </p>
<p>动态实现和本地实现相比，运行效率要快上20倍。因为动态实现无需经过Java到C++再到Java的切换(JNI,Java Native Interface)，但生成字节码十分耗时，仅调用一次的话，本地实现反而要快上3到4倍。  </p>
<p>许多反射调用仅会执行一次，JVM设置了一个阈值15(Dsun.reflect.inflationThreshold=15)，当某个反射调用的调用次数在15之下时，采用本地实现(C++)；当达到15时，开始动态生成字节码(动态生成一个Java类来做直接调用，加速反射调用)，并将委派实现的委派对象切换至动态实现，这个过程称为inflation。  </p>
<p>反射调用的Inflation机制是可以通过参数(-Dsun.reflect.noInflation=true)来关闭。在反射调用一开始便直接生成动态实现，而不会使用委派实现或者本地实现。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        JVM虚拟机
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sun.reflect.ReflectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> noInflation=<span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> inflationThreshold=<span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MethodAccessor <span class="title">newMethodAccessor</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        checkInitted();</span><br><span class="line">        <span class="keyword">if</span>(noInflation) &#123;<span class="comment">//动态实现Java</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MethodAccessorGenetor().</span><br><span class="line">                generateMethod(method.getDeclaringClass(),</span><br><span class="line">                                method.getName(),</span><br><span class="line">                                method.getParameterTypes(),</span><br><span class="line">                                method.getReturnType(),</span><br><span class="line">                                method.getExceptionTypes(),</span><br><span class="line">                                method.getModifiers());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            NativeMethodAccessorImpl acc = <span class="keyword">new</span> NativeMethodAccessorImpl(method);<span class="comment">//本地实现</span></span><br><span class="line">            DelegatingMethodAccessorImpl res = <span class="keyword">new</span> DelegatingMethodAccessorImpl(acc);<span class="comment">//委派实现</span></span><br><span class="line">            acc.setParent(res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<h3 id="反射调用的开销"><a href="#反射调用的开销" class="headerlink" title="反射调用的开销"></a>反射调用的开销</h3><p>反射调用过程中先后进行了Class.forName,Class.getMethod以及Method.invoke三个操作。其中Class.forName会调用本地方法，Class.getMethod则会遍历该类的公有方法。如果没有匹配到，它还将遍历父类的公有方法，这两个操作都非常费时。  </p>
<p>以getMethod为代表的查找方法操作，会返回查找结果的一份拷贝。应当避免在热点代码中使用返回Method数组的getMethods或者getDeclaredMethods方法，以减少不必要的堆空间消耗。在实践中，会在应用程序中缓存Class.forName和Class.getMethod的结果。  </p>
<p>Method.invoke是一个变长参数方法，在字节码层面它的最后一个参数会是Object数组。Java编译器会在方法调用处生成一个长度为传入参数数量的Object数组，并将传入参数一一存储进该数组中。<br>Object数组不能存储基本类型，Java编译器会对传入的基本类型参数进行自动装箱(Java缓存了[-128, 127]中所有整数所对应的Integer对象。当需要自动装箱的整数在这个范围之内，便返回缓存的Integer，否则需要新建一个Integer对象(参数-DJava.lang.Integr.IntegerCache.high=128,扩大缓存范围，避免新建Integer对象))。  </p>
<p>上述两个Object数组的操作除了带来性能开销外，还可能占用堆内存，使得GC更加频繁(虚拟机参数-XX:+PrintGC)。  </p>
<p>Method.setAccessible(true);关闭权限检查(每次反射调用都会检查目标方法的权限)。  </p>
<p>即时编译器中的方法内联(编译器在编译一个方法时，将某个方法调用的目标方法也纳入编译范围内，并用其返回值替代原方法)。<br><strong>在关闭了Inflation的情况下，内联的瓶颈在于Method.invoke方法中对MethodAccessor.invoke方法的调用。</strong>  </p>
<img src='/img/JVM反射内联瓶颈.png'>

<p>在生产环境中，往往拥有多个不同的反射调用，对应多个多态实现GeneratedMethodAccessor+num。由于JVM关于上述调用点的类型profile(对于invokevirtual或者involeinterface，JVM会记录下调用者的具体类型，称为类型profile)无法同时记录这么多个类(虚拟机参数-XX:TypeProfileWidth,默认值是2。提高JVM关于每个调用能够记录的类型数目)，因此可能造成反射调用没有被内联的情况。  </p>
<blockquote>
<p>Method.invoke就像是个独木桥一样，各处的反射调用都要挤过去，在调用点上收集到的类型信息就会很乱，影响内联程序的判断，使得Method.invoke自身难以被内联到调用方。  </p>
</blockquote>
<blockquote>
<p>Java&amp;中的MethodHandle，在使用MethodHandle来做反射调用时，MethodHandle.invoke()的形式参数与返回值类型都是准确的，所以只需要在链接方法的时候才需要检查类型的匹配性，而不必在每次调用时都检查。而且MethodHandle是不可变值，在创建后其内部状态就不会再改变了；JVM可以利用这个知识而放心的对它做激进优化，例如将实际的调用目标内联到做反射调用的一侧。<br><a href="https://www.iteye.com/blog/rednaxelafx-548536" target="_blank" rel="noopener">关于反射调用方法的一个log</a>  </p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在默认情况下，方法的反射调用为委派实现，委派给本地实现来进行方法调用。在调用超过15次之后，委派实现便会将委派对象切换至动态实现。这个动态实现的字节码是自动生成的，它将直接使用invoke指令来调用目标方法。  </p>
<p>方法的反射调用会带来不少性能开销，主要有三个原因：变长参数方法导致的Object数组，基本类型的自动装箱、拆箱，方法内联。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>JVM是怎么实现invokedynamic的</title>
    <url>/JVM/9JVM%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0invokedynamic%E7%9A%84/</url>
    <content><![CDATA[<h3 id="invokedynamic指令"><a href="#invokedynamic指令" class="headerlink" title="invokedynamic指令"></a>invokedynamic指令</h3><p>invokedynamic是Java7引入的一条新指令，用以支持动态语言的方法调用。它将调用点(CallSite)抽象成一个Java类，并且将原本由JVM控制的方法调用以及方法链接暴露给了应用程序。在运行过程中，每一条invokedynamic指令将捆绑一个调用点，并且会调用该调用点所链接的方法句柄。  </p>
<p>在第一次执行invokedynamic指令时，JVM会调用该指令所对应的启动方法(BootStrap Method)，来生成前面提到的调用点，并且将之绑定至该invokedynamic指令中。在之后的运行过程中，JVM则会直接调用绑定的调用点所链接的方法句柄。  </p>
<p>在字节码中，启动方法是用方法句柄来指定的。这个方法句柄指向一个返回类型为调用点的静态方法。该方法必须接收三个固定的参数，分别为Lookup类实例(MethodHandles.Lookup)、一个用来指代目标方法名字的字符串(String)、以及该调用点能够链接的方法句柄的类型(MethodType)。  </p>
<blockquote>
<p>除了这三个必须参数之外，启动方法还可以接受若干个其他的参数，用来辅助生成调用点，或者定位所要链接的目标方法。  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CallSite <span class="title">bootstrap</span><span class="params">(MethodHandles.Lookup l, String name, MethodType callSiteType)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    MethodHandle mh = l.findVirtual(Xyz<span class="class">.<span class="keyword">class</span>, <span class="title">name</span>, <span class="title">MethodType</span>.<span class="title">methodType</span>(<span class="title">void</span>.<span class="title">class</span>, <span class="title">Object</span>.<span class="title">class</span>))</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConstantCallSite(mh.asType(callSiteType));<span class="comment">//连接到Xyz中某个方法的ConstantCallSite调用点</span></span><br><span class="line">    <span class="comment">//asType改操作、bindTo增操作、dropArguments删操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConstantCallSite是一种不可以更改链接对象的调用点。除此之外，Java核心类库还提供多种可以更改链接对象的调用点，比如MutableCallSite和VolatileCallSite。(应用程序还可以自定义调用点类，来满足特定的重链接需求)  </p>
<p>invokedynamic指令最终调用的是方法句柄，而方法句柄会将调用者当成第一个参数。<br>调用点仅要求方法句柄的类型能够匹配，对方法名不做要求。将调用点与目标方法的链接交由应用程序来做，并且依赖于应用程序对目标方法进行验证。如果应用程序将“赛跑方法链接至睡觉方法，那只能怪应用程序自己”。  </p>
<h3 id="Java8的Lambda表达式"><a href="#Java8的Lambda表达式" class="headerlink" title="Java8的Lambda表达式"></a>Java8的Lambda表达式</h3><p>在Java8中，Lambda表达式也是借助invokedynamic来实现的。  </p>
<p>Java编译器利用invokedynamic指令来生成实现了函数式接口(仅包括一个非default接口方法的接口，一般通过@FunctionalInterface注解)的适配器。  </p>
<p>在编译过程中，Java编译器会对Lambda表达式进行解语法糖(desugar)，生成一个方法来保存Lambda表达式的内容(方法引用，则不会生成额外的方法。Horse::race)。该方法的参数列表不仅包含原本Lambda表达式的参数，还包含它所捕获的变量。所捕获的变量同样也会作为参数传入生成的方法之中。  </p>
<p>第一次执行invokedynamic指令时，它所对应的启动方法会通过ASM来生成一个适配器类。这个适配器类实现了对应的函数式接口。启动方法的返回值是一个ContantCallSite，其连接对象为一个返回适配器类实例的方法句柄。  </p>
<p>根据Lambda表达式是否捕获其他变量，启动方法生成的适配器类以及所链接的方法句柄皆不同。  </p>
<ul>
<li>如果该Lambda表达式没有捕获其他变量，那么可以认为它是上下文无关的。启动方法将新建一个适配器类的实例，并且生成一个特殊的方法句柄，始终返回该实例。  </li>
<li>如果该Lambda表达式捕获了其他变量，那么每次执行该invokedynamic指令，都要更新这些捕获了的变量，以防止它们发生了变化。  <blockquote>
<p>另外为了保证Lambda表达式的线程安全，无法共享同一个适配器类的实例。在每次执行invokedynamic指令时，所调用的方法句柄都需要新建一个适配器类实例。在这种个情况下，启动方法生成的适配器类将包含一个额外的静态方法，来构造适配器类的实例。该方法将接收这些捕获的参数，并且将它们保存为适配器类实例的实例字段。  </p>
</blockquote>
</li>
</ul>
<p>虚拟机参数-Djdk.internal.lambda.dumpProxyClasses=/DUMP/PATH导出具体的适配器类。  </p>
<p>捕获了局部变量的Lambda表达式多出了一个get$Lambda的方法。启动方法便会将所返回的调用点链接指向该方法的方法句柄。也就是说，每次执行invokedynamic指令时，都会调用至这个方法中，并构造一个新的适配器类实例。  </p>
<h3 id="Lambda以及方法句柄的性能分析"><a href="#Lambda以及方法句柄的性能分析" class="headerlink" title="Lambda以及方法句柄的性能分析"></a>Lambda以及方法句柄的性能分析</h3><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Lambda表达式与直接调用
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.IntConsumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">target</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">1</span>;<span class="comment">//变量</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> current = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2_000_000_000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">100_000_000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> temp = System.currentTimeMillis();</span><br><span class="line">                System.out.println(temp - current);</span><br><span class="line">                current = temp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ((IntConsumer) Test::target.accept(128);</span></span><br><span class="line">            ((IntConsumer) j -&gt; Test.target(j)).accept(<span class="number">128</span>);</span><br><span class="line">            ((IntConsumer) j -&gt; Test.target(x + j)).accept(<span class="number">128</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<h4 id="未捕获变量"><a href="#未捕获变量" class="headerlink" title="未捕获变量"></a>未捕获变量</h4><p>((IntConsumer) j -&gt; Test.target(j)).accept(128)  </p>
<p>lambda表达式所使用的invokedynamic将绑定一个ConstantCallSite，其链接的目标方法无法改变。因此，即时编译器会将该目标方法直接内联进来。对于这类没有捕获变量的Lambda表达式而言，目标方法只完成了一个动作，便是加载缓存的适配器类常量。  </p>
<blockquote>
<p>即时编译器能够将转换Lambda表达式所使用的invokedynamic，以及对IntConsumer.accept方法的调用统统内联进来，最终优化为空操作。与直接调用的性能并无太大区别。  </p>
</blockquote>
<p>对IntConsumer.accept方法的调用实则是对适配器类的accept方法的调用。从字节码看是调用了Java编译器在解Lambda语法糖时生成的方法。该方法内容便是Lambda表达式的内容，也就是直接调用目标方法Test.target。将这个方法调用内联进来之后，原本对accept方法的调用则会被优化为空操作。  </p>
<h4 id="捕获变量"><a href="#捕获变量" class="headerlink" title="捕获变量"></a>捕获变量</h4><p>((IntConsumer) j -&gt; Test.target(x + j)).accept(128);  </p>
<p>针对带捕获变量的版本，理论上每次调用invokedynamic指令，JVM都会新建一个适配器类的实例。该例中实际运行结果还是与直接调用的性能一致。  </p>
<p>即使编译器的逃逸分析就将该新建实例给优化掉了。  </p>
<blockquote>
<p>虚拟机参数-XX:-DoEscapeAnalysis关闭逃逸分析。  </p>
</blockquote>
<p>逃逸分析能够去除这些额外的新建实例开销，但是不是时时奏效的。需要同时满足两件事：  </p>
<ul>
<li>invokedynamic指令所执行的方法句柄能够内联  </li>
<li>接下来的对accept方法的调用也能内联。  </li>
</ul>
<p>这样逃逸分析才能判定该适配器实例不逃逸。否则会在运行过程中不停地生成适配器类实例。应当尽量使用非捕获的Lambda表达式。  </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>invokedynamic指令抽象出调用点的概念，并且将调用该调用点所链接的方法句柄。在第一次执行invokedynamic指令时，JVM将执行它所对应的启动方法，生成并且绑定一个调用点。之后如果再次执行该指令，JVM则直接调用已经绑定了的调用点所链接的方法。  </p>
<p>Lambda表达式到函数式接口的转换是通过invokedynamic指令来实现的。该invokedynamic指令对应的启动方法将通过ASM生成一个适配器类。  </p>
<p>对于没有捕获其他变量的Lambda表达式，该invokedynamic指令始终返回同一个适配器类的实例。对于捕获了其他变量的Lambda表达式，每次执行invokedynamic指令将新建一个适配器类实例。  </p>
<p>不管是捕获型的还是未捕获型的Lambda表达式，它们在性能上皆可达到直接调用的性能。其中，捕获型Lambda表达式借助了即时编译器中的逃逸分析，来边实际的新建适配器类实例的操作。  </p>
<p><a href="https://zhuanlan.zhihu.com/p/26389041" target="_blank" rel="noopener">Invokedynamic 和 MethodHandle的缘由</a><br><a href="https://zhuanlan.zhihu.com/p/30936412" target="_blank" rel="noopener">JSR292: InvokeDynamic和MethodHandle的优化</a>  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>JVM是如何执行方法调用的</title>
    <url>/JVM/5JVM%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E7%9A%84/</url>
    <content><![CDATA[<p>设计模式大量使用了虚方法来实现多态，但是虚方法的性能效率并不高。  </p>
<h3 id="虚方法调用"><a href="#虚方法调用" class="headerlink" title="虚方法调用"></a>虚方法调用</h3><p>Java里所有非私有实例方法调用都会被编译成invokevirtual指令，接口方法调用都会被编译成invokeinterface指令。这两种指令，均属于JVM中的虚方法调用。  </p>
<blockquote>
<p>虚方法，可以被子类覆盖的方法。  </p>
</blockquote>
<p>绝大多数情况下，JVM需要根据调用者的动态类型，来确定虚方法调用的目标方法。这个过程称之为动态绑定。相对于静态绑定的非虚方法调用来说，虚方法调用更加耗时。  </p>
<p>在JVM中，静态绑定包括用于静态方法的invokestatic指令，和用于调用构造器、私有实例方法以及超类非私有实例方法的invokespecial指令。如果虚方法调用指向一个标记为final的方法，那么JVM也可以静态绑定该虚方法调用的目标方法。  </p>
<p>JVM中采取了一种用空间换取时间的策略来实现动态绑定。它为每个类生成一张方法表，用以快速定位目标方法。  </p>
<h3 id="方法表"><a href="#方法表" class="headerlink" title="方法表"></a>方法表</h3><p>类加载的连接-准备阶段，除了为静态字段分配内存之外，还会构造与该类相关联的方法表。方法表这个数据结构，是JVM实现动态绑定的关键所在。以invokevirtual所使用的虚方法表(virtual method table, vtable)为例。(invokeinterface所使用的接口方法表(interface method table, itable)稍微复杂，但原理类似)  </p>
<p>方法表本质上是一个数组，每个数组元素指向一个当前类及其祖先类中非私有的实例方法。这些方法可能是具体的、可执行的方法，也可能是没有相应字节码的抽象方法。  </p>
<p>方法表满足两个特质：  </p>
<ul>
<li>子类方法表中包含父类方法表中的所有方法；  </li>
<li>子类方法在方法表中的索引值，与它所重写的父类方法的索引值相同。  </li>
</ul>
<p>方法调用指令中的符号引用会在执行之前解析成实际引用。对于静态绑定的方法调用而言，实际引用将指向具体的目标方法。对于动态绑定的方法调用而言，实际引用则是方法表的索引值(并不仅仅是索引值)。  </p>
<p>在执行过程中，JVM将获取调用者的实际类型，并在该实际类型的虚方法表中，根据索引值获得目标方法。这个过程便是动态绑定。  </p>
<p>实际上，使用了方法表的动态绑定与静态绑定相比，仅仅多出几个内存解引用操作：访问栈上的调用者，读取调用者的动态类型，读取该类型的方法表，读取方法表中某个索引值所对应的目标方法。相对于创建并初始化Java栈帧来说，这几个内存解引用操作的开销可以忽略不计。  </p>
<p>在解释执行或者即时编译代码的最坏情况中，上述优化的效果很好。但即时编译还有另外两种性能更好的优化手段：内联缓存(inlining cache)和方法内联(method inlining)。  </p>
<h3 id="内联缓存"><a href="#内联缓存" class="headerlink" title="内联缓存"></a>内联缓存</h3><p>内联缓存是一种加快动态绑定的优化技术。它能够缓存虚方法调用中调用者的动态类型，以及该类型所对应的目标方法。在之后的执行过程中，如果碰到已缓存的类型，内联缓存便会直接调用该类型所对应的目标方法。如果没有碰到已缓存的类型，内联缓存则会退化至使用基于方法表的动态绑定。  </p>
<p>针对多态的优化手段中的术语(内联缓存也有类似定义)：  </p>
<ol>
<li>单态(monomorphic)指的是仅有一种状态的情况。  </li>
<li>多态(polymorphic)指的是有限数量种状态的情况。二态(bimorphic)是多态的其中一种。(HotSpot不存在多态内联缓存)  </li>
<li>超多态(megamorphic)指的是更多种状态的情况。通常用一个具体数值来区分多态和超多态。  </li>
</ol>
<p>单态内联缓存：只缓存了一种动态类型以及它所对应的目标方法。比较所缓存的动态类型，如果命中，则直接调用对应的目标方法。  </p>
<p>多态内联缓存：缓存了多个动态类型及其目标方法。需要逐个将缓存的动态类型与当前动态类型进行比较，如果命中，则调用对应的目标方法。  </p>
<p>一般来说，会将更加热门的动态类型放在前面。在实践中，大部分的虚方法调用均是单态的，也就是只有一种动态类型。为了节省内存空间，JVM只采用单态内联缓存。  </p>
<p>当内联缓存没有命中的情况下，JVM需要重新使用方法表进行动态绑定。对于内联缓存中的内容，有两种选择：  </p>
<ul>
<li>替换单态内联缓存中的记录。  <blockquote>
<p>在替换内联缓存之后的一段时间内，方法调用的调用者的动态类型应当保持一致，从而能够有效的利用内联缓存。最坏情况下，不同类型的调用者，轮流执行该方法调用，每次进行方法调用都将替换内存缓存(只有写缓存的额外开销，没有用缓存的性能提升)。  </p>
</blockquote>
</li>
<li>劣化为超多态状态。(JVM的具体实现方式)  <blockquote>
<p>处于这种状态下的内联缓存，放弃了优化的机会。它将直接访问方法表，来动态绑定目标方法(牺牲了优化的击昏，节省了写缓存的额外开销)。  </p>
</blockquote>
</li>
</ul>
<p>内联缓存附带内联二字，但是它并没有内联目标方法。任何方法调用除非被内联，否则都会有固定开销。这些开销来源于保存程序在该方法中的执行位置，以及新建、压入和弹出新方法所使用的栈帧。  </p>
<p>对于极其简单的方法，如getter/setter，这部分固定开销占据的CPU时间甚至超过了方法本身。此外，在即时编译中，方法内联不仅仅能够消除方法调用的固定开销，而且还增加了进一步优化的可能性。  </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>虚方法调用包括invokevirtual指令和incokeinterface指令。如果这两种指令所声明的目标方法被标记为final，那么JVM会采用静态绑定。否则将会采用动态绑定，在运行过程中根据调用者的动态类型，来决定具体的目标方法。  </p>
<p>JVM的动态绑定是通过方法表这一数据结构来实现的。方法表中每一个重写方法的索引值，与父类方发表中被重写的方法的索引值一致。在解析虚方法调用时，JVM会记录下所声明的目标方法的索引值，并且在运行过程中根据这个索引值查找具体的目标方法。  </p>
<p>JVM中的即时编译器会使用内联缓存来加速动态绑定。JVM所采用的单态内联缓存将记录调用者的动态类型，以及它所对应的目标方法。当碰到新的调用者时，如果其动态类型与缓存中的类型匹配，则直接调用缓存的目标方法。否则JVM将该内联缓存劣化为超多态内联缓存，在今后的执行过程中直接使用方法表进行动态绑定。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>垃圾回收</title>
    <url>/JVM/11%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<h3 id="引用计数法与可达性分析"><a href="#引用计数法与可达性分析" class="headerlink" title="引用计数法与可达性分析"></a>引用计数法与可达性分析</h3><p>垃圾回收，将已经分配出去的，但却不再使用的内存回收回来，以便能够再次分配。在JVM的语境下，垃圾指的是死亡的对象所占据的堆空间。辨别一个对象是存是亡的方法：1.引用计数法(reference counting)。2.可达性分析。  </p>
<h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>为每个对象添加一个引用计数器，用来统计指向该对象的引用个数。一旦某个对象的引用计数器为0，则说明该对象已经死亡，便可以被回收了。  </p>
<p>具体实现：如果有一个引用，被赋值为某一对象，那么将该对象的引用计数器+1。如果一个指向某一对象的引用，被赋值为其他值，那么该对象的引用计数器-1。需要截获所有的引用更新操作，并且相应的增减目标对象的引用计数器。  </p>
<p>除了需要额外的空间来存储计数器，以及繁琐的更新操作，引用计数法还有一个重大的漏洞，那便是无法处理循环引用对象。假设对象a与b湘湖引用，除此之外没有其他引用指向a和b。这种情况下，a和b实际上已经死了，但是由于它们的引用计数器皆不为0，在引用计数法的心中，这两个对象还活着，循环引用对象所占据的空间将不可回收，造成内存泄漏。  </p>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>目前JVM的主流垃圾回收期采用的算法。实质在于将一系列GC Roots作为初始存活对象合集(live set)，然后从该合集触发，探索所有能够被该集合引用到的对象，并将其加入到该集合中，这个过程称之为标记(mark)。最终，未被探索到的对象便是死亡的，是可以回收的。  </p>
<blockquote>
<p>整个堆空间减去存活对象集占用的空间就是空闲堆空间，不用具体去追究死亡对象的地址空间。  </p>
</blockquote>
<p>GC Roots，可以暂时理解为<strong>由堆外指向堆内的引用</strong>，一般而言包括但不限于以下几种：  </p>
<ul>
<li>Java方法栈帧中的局部变量；  </li>
<li>已加载类的静态变量；  </li>
<li>JNI(Java Native Interface) handles;  </li>
<li>已启动且未停止的Java线程。  </li>
</ul>
<p>可达性分析可以解决引用计数法所不能解决的循环引用问题。即便对象a和b相互引用，只要从GC Roots出发无法到达a或者b，那么可达性分析便不会将它们加入存活对象合集之中。  </p>
<p>多线程环境下，(没有STW时，没有做好同步的前提下)其他线程可能会更新已经访问过的对象中的引用，从而造成误报(将引用设置为null，可达性分析误认为某个死亡对象是可达的，认为可达本次不回收)或者漏报(将引用设置为未被访问过的对象，可达性分析没有发现某个存活对象可达，认为不可达给回收掉了)。误报没什么伤害，JVM至多损失了部分垃圾回收的机会。漏报比较麻烦，垃圾回收器可能回收事实上扔被引用的对象内存，一旦从原引用访问已经被回收了的对象，则很有可能会直接导致JVM崩溃。  </p>
<blockquote>
<p>可达性分析会找出非垃圾，而其他对象通通被认为是垃圾。  </p>
</blockquote>
<h3 id="Stop-the-world-以及安全点"><a href="#Stop-the-world-以及安全点" class="headerlink" title="Stop-the-world 以及安全点"></a>Stop-the-world 以及安全点</h3><p>针对漏报问题，在JVM里，传统的垃圾回收算法采用的是一种简单粗暴的方式：Stop-the-world，停止其他非垃圾回收线程的工作(禁止工作线程继续更新引用)，直到完成垃圾回收。这也就造成了垃圾回收所谓的暂停时间(GC pause)。  </p>
<blockquote>
<p>采用并行GC可以减少需要STW的时间。它们会在即时编译器生成的代码中加入写屏障或者读屏障。  </p>
</blockquote>
<p>JVM中的Stop-the-world是通过安全点(safepoint)机制来实现的。当JVM收到Stop-the-world请求，它便会等待所有的线程都到达安全点，才允许请求Stop-the-world的线程进行独占的工作。  </p>
<blockquote>
<p>安全词。一旦垃圾回收线程喊出了安全词，其他非垃圾回收线程便会一一停下。  </p>
</blockquote>
<p>安全点的初始目的并不是让其他线程停下，而是找到一个稳定的执行状态。在这个执行状态下，JVM的堆栈不会发生变化。这样，垃圾回收器便能够“安全”的执行可达性分析。  </p>
<h4 id="执行JNI本地代码"><a href="#执行JNI本地代码" class="headerlink" title="执行JNI本地代码"></a>执行JNI本地代码</h4><p>当Java程序通过JNI执行本地代码时，如果这段代码不访问Java对象、调用Java方法或者返回至原Java方法，那么JVM的堆栈不会发生改变，也就代表着这段本地代码可以作为同一个安全点。只要不离开这个安全点，JVM便能够在垃圾回收的同时，继续运行这段本地代码。  </p>
<p>由于本地代码需要通过JNI的API来完成上述三个操作，因此JVM仅需要在API的入口处进行安全点检测(safepoint poll)，测试是有其他线程请求停留在安全点里，便可以在必要的时候挂起当前线程。  </p>
<h4 id="Java线程其他状态"><a href="#Java线程其他状态" class="headerlink" title="Java线程其他状态"></a>Java线程其他状态</h4><p><strong>解释执行字节码</strong>、<strong>执行即时编译器生成的机器码</strong>或<strong>线程阻塞</strong>。  </p>
<p><strong>阻塞的线程</strong>由于处于JVM线程调度器的掌控之下，因此属于安全点。其他几种状态则是运行状态，需要虚拟机保证在可预见的时间内进入安全点。否则，垃圾回收线程可能长期处于等待所有线程进入安全点的状态，从而变相的提高了垃圾回收的暂停时间。  </p>
<p>对<strong>解释执行来</strong>说，字节码与字节码之间皆可作为安全点。JVM采取的做法是，当有安全点请求时，执行一条字节码便进行一次安全点检测。  </p>
<p><strong>执行即时编译器生成的机器码</strong>则比较复杂。由于这些代码直接运行在底层硬件之上，不受JVM掌控，因此在生成机器码时，即时编译器需要插入安全点检测，以避免机器码长时间没有安全点检测的情况。HotSpot虚拟机的做法便是在生成代码的方法出口以及非计数循环的循环回边(back-edge)处插入安全点检测。  </p>
<p>不在每一条机器码或者每一个机器码基本块处插入安全点检测的原因：  </p>
<ul>
<li>安全点检测本身也有一定的开销。不过HotSpot虚拟机已经将机器码中安全点检测简化为<strong>一个内存访问操作</strong>。在有安全点请求的情况下，JVM会将安全点检测访问的内存所在的页设置为不可读，并且定义一个segfault处理器，来截获因访问该不可读内存而触发segfault的线程，并将它们挂起。  </li>
<li>即时编译器生成的机器码打乱了原本栈帧上的对象分布状况。在进入安全点时，机器码还需要提供一些额外的信息，来表明哪些寄存器，或者当前栈帧上的哪些内存空间存放着指向对象的引用，以便垃圾回收器能够枚举GC Roots。  </li>
</ul>
<p>由于这些信息需要不少空间来存储，因此即时编译器会尽量避免过多的安全点检测。  </p>
<p>不过，不同的即时编译器插入安全点检测的位置也可能不同。以Graal为例，除了上述位置外，它还会在计数循环的循环回边处插入安全点检测。其他的虚拟机也可能选取方法入口而非方法出口来插入安全点检测。  </p>
<p>不管如何，其目的都是在可接受的性能开销以及内存开销之内，避免机器码长时间不进入安全点的情况，间接的减少垃圾回收的暂停时间。  </p>
<p>除了垃圾回收之外，JVM其他一些对堆栈内容的一致性有要求的操作也会用到安全点这一机制。  </p>
<h3 id="垃圾回收的三种方式"><a href="#垃圾回收的三种方式" class="headerlink" title="垃圾回收的三种方式"></a>垃圾回收的三种方式</h3><p>当标记完所有的存活对象时，便可以进行死亡对象的回收工作了。主流的基础回收方式可分为三种。  </p>
<h4 id="清除"><a href="#清除" class="headerlink" title="清除"></a>清除</h4><p>第一种是<strong>清除</strong>(sweep)，即把死亡对象所占据的内存标记为空闲内存，并记录在一个空闲列表(free list)之中。当需要新建对象时，内存管理模块便会从该空闲列表中寻找空闲内存，并划分给新建的对象。  </p>
<p>清除这种回收方式的原理极其简单，但是有两个缺点。<br>一是会造成内存碎片。由于JVM的堆中对象必须是连续分布的，因此可能出现总空闲内存足够，但是无法分配的极端情况。  </p>
<p>另一个是分配效率较低。如果是一块连续的内存空间，那么可以通过指针加法(pointer bumping)来做分配。而对于空闲列表，JVM则需要逐个访问列表中的项，来查找能够放入新建对象的空闲内存。  </p>
<h4 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h4><p>第二种是<strong>压缩</strong>(compact)，即把存活的对象聚集到内存区域的起始位置，从而留下一段连续的内存空间。  </p>
<p>这种做法能够解决内存碎片化的问题，但代价是压缩算法的性能开销。  </p>
<h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p>第三种是<strong>复制</strong>(copy)，即把内存区域分为两等分，分别用两个指针from和to来维护，并且只是用from指针指向的内存区域来分配内存。当发生垃圾回收时，便把存活的对象复制到to指针指向的内存区域中，并且交换from指针和to指针的内容。  </p>
<p>复制这种回收方式同样能够解决内存碎片化的问题，但是它的缺点也极其明显，即堆空间的使用效率极其低下。  </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>JVM中的垃圾回收器采用可达性分析来探索所有存活的对象。它从一些列GC Roots出发，边标记边探索所有被引用的对象。  </p>
<p>为了防止在标记过程中堆栈的状态发生改变，JVM采取安全点机制来实现Stop-the-world操作，暂停其他非垃圾回收线程。  </p>
<p>回收死亡对象的内存共有三种方式，分别为:会造成内存碎片的清除、性能开销较大的压缩、以及堆使用效率较低的复制。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>Java虚拟机是如何加载Java类的</title>
    <url>/JVM/3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%98%AF%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BDJava%E7%B1%BB%E7%9A%84/</url>
    <content><![CDATA[<p>从class文件到内存中的类，按先后顺序需要经过加载、链接、初始化三大步骤。  </p>
<p>Java语言的类型可以分为两大类：基本类型(primitive types)和引用类型(reference types)。引用类型细分为四种：类、接口、数组类和泛型参数。泛型参数会在编译过程中被擦除；数组类是由Java虚拟接直接生成的，其他两种则有对应的字节流。  </p>
<p>字节流形式：1Java编译器生成的class文件；2在程序内部直接生成；3从网络中获取(网页中内嵌的小程序Java applet)。这些不同形式的字节流，都会被加载到Java虚拟机中，成为类或接口-统称为’类’。  </p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>加载，是指<strong>查找字节流，并且据此创建类的过程</strong>。对于数组类来说，并没有对应的字节流，是由Java虚拟机直接生成的。对于其他的类来说，Java虚拟机则需要借助类加载器来完成查找字节流的过程。  </p>
<blockquote>
<p>用到的类才会被加载。大部分情况下，不同类的加载阶段是不同的。  </p>
</blockquote>
<p>类加载器：  </p>
<ul>
<li>启动类加载器(bootstrap class loader)，由C++实现，没有对应的Java对象，用null来指代。  </li>
<li>其他类加载器，都是java.lang.ClassLoader的子类，有对应的Java对象。这些类加载器需要先由另一个类加载器如启动类加载器，加载至Java虚拟机中，才能执行类加载。  <blockquote>
<p>除了启动类加载器之外，另外两个重要的类加载器是扩展类加载器(extension class loader)和应用类加载器(application class loader)，均由Java核心类库提供。</p>
</blockquote>
</li>
</ul>
<p>双亲委派模型：每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。  </p>
<p><strong>启动类加载器</strong>负责加载最为基础、最为重要的类，如存放在JRE的lib目录下jar包中的类(以及由虚拟机参数-Xbootclasspath指定的类)。  </p>
<p><strong>扩展类加载器</strong>的父类加载器是启动类加载器。它负责加载相对次要、但又通用的类，如存放在JRE的lib/ext目录下jar包中的类(以及由系统变量java.ext.dirs指定的类)。  </p>
<p><strong>应用类加载器</strong>的父类加载器则是扩展类加载器。它负责加载应用程序路径下的类。(虚拟机参数-cp/-classpath、系统变量java.class.path或环境变量CLASSPATH所指定的路径)默认情况下，应用程序中包含的类便是由应用类加载器加载的。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Java9 类加载器
    </div>
    <div class='spoiler-content'>
        <p>Java9引入了模块系统，更改了上述的类加载器。扩展类加载器被改名为平台类加载器(platform class loader)。JavaSE中除了少数几个关键模块-java.base由启动类加载器加载之外，其他的模块均由平台类加载器加载。  </p>

    </div>
</div>  

<p><strong>自定义类加载器</strong>，实现特殊的加载方式。如可以对class文件进行加密，加载时再利用自定义的类加载器对其解密。  </p>
<p>除了加载功能，类加载器还提供了命名空间的作用。在Java虚拟机中，类的唯一性是由类加载器实例以及类的全名一同确定的。即便是同一串字节流，经由不同的类加载器加载，也会得到两个不同的类。在大型应用中，借助这一特性，运行同一个类的不同版本。  </p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>链接是指<strong>将创建成的类合并至Java虚拟机中，使之能够执行的过程</strong>。可分为验证、准备、解析三个阶段。(解析阶段为非必须的)  </p>
<p><strong>验证</strong>，确保被加载类能够满足Java虚拟机的约束条件。  </p>
<p><strong>准备</strong>，为被加载类的静态字段分配内存。部分Java虚拟机还会在此阶段构造其他跟类层次相关的数据结构，如用来实现虚方法的动态绑定的方法表。  </p>
<blockquote>
<p>在class文件被加载至Java虚拟机之前，这个类无法知道其他类及其方法、字段所对应的具体地址，甚至不知道自己方法、字段的地址。每当需要引用这些成员时，Java编译器会生成一个符号引用(类名、方法名、参数类型、返回类型等的符号引用)。在运行阶段，这个符号引用一般都能够无歧义的定位到具体目标上。  </p>
</blockquote>
<p><strong>解析</strong>，将上述符号引用解析成为实际引用。如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载(但未必触发这个类的链接以及初始化)  </p>
<p>Java虚拟机规范并没有要求在连接过程中完成解析。仅规定：如果某些字节码使用了符号引用，那么在执行这些字节码之前，需要完成对这些符号引用的解析。  </p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>在Java代码中，如果要初始化一个静态字段，可以在声明时直接赋值，也可以在静态代码块中对其赋值。  </p>
<p>如果直接赋值的静态字段被final所修饰，并且它的类型是<strong>基本类型或者字符串</strong>时，那么该字段会被Java编译器标记成常量值(ConstantValue)，其初始化直接由Java虚拟机完成。除此之外的直接赋值操作，以及所有静态代码块中的代码，则会被Java编译器置于同一方法中，并把它命名为<clinit>。  </p>
<p>类加载的最后一步是初始化，便是<strong>为标记为常量值的字段赋值，以及执行<clinit>方法的过程</strong>。Java虚拟机会通过加锁来确保类的<clinit>方法仅被执行一次。  </p>
<p>只有当初始化完成之后，类才正式成为可执行状态。  </p>
<p>类初始化触发情况：  </p>
<ol>
<li>当虚拟机启动时，初始化用户指定的主类；  </li>
<li>当遇到用以新建目标类实例的new指令时，初始化new指令的目标类；  </li>
<li>当遇到调用静态方法的指令时，初始化该静态方法所在的类；  </li>
<li>当遇到访问静态字段的指令时，初始化该静态字段所在的类；  </li>
<li>子类的初始化会触发父类的初始化；  </li>
<li>如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化；  </li>
<li>使用反射API对某个类进行反射调用时，初始化这个类；  </li>
<li>当初次调用MethodHandle实例时，初始化该MethodHandle指向的方法所在的类。  <blockquote>
<p>Java8引入，相当于方法指针</p>
</blockquote>
</li>
</ol>
<p>被动引用不会触发类的初始化：  </p>
<ul>
<li>引用类的静态常量  </li>
<li>引用父类的静态字段不会初始化子类  </li>
<li>数组定义来引用类不会导致被引用的类的初始化(新建数组只有加载，甚至没有链接，更不会初始化引用的类)  </li>
</ul>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        静态内部类 单例延迟初始化
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有当调用Singleton.getInstance时，程序才会访问LazyHolder.INSTANCE，才会触发对LazyHolder的初始化，继而新建一个Singleton的实例。  </p>
<p>类初始化是线程安全的，并且仅被执行一次，因此程序可以确保多线程环境下有且仅有一个Singleton实例。  </p>

    </div>
</div>  <link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>Java对象的内存布局</title>
    <url>/JVM/10Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h3 id="新建对象方式"><a href="#新建对象方式" class="headerlink" title="新建对象方式"></a>新建对象方式</h3><ul>
<li>new语句  </li>
<li>反射机制  </li>
<li>Object.clone方法  </li>
<li>反序列化  </li>
<li>Unsafe.allocateInstance方法  </li>
</ul>
<p>new语句和反射机制，通过调用构造器来初始化实例字段。<br>Object.clone方法和反序列化，通过直接复制已有的数据来初始化新建对象的实例字段。<br>Unsafe.allocateInstance方法没有初始化实例字段。  </p>
<hr>
<p>以new语句为例，它编译而成的字节码将包含用来请求内存的new指令，以及用来调用构造器的invokespecial指令。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Foo foo = new Foo();//编译而成的字节码</span></span><br><span class="line">    <span class="number">0</span> <span class="keyword">new</span> Foo</span><br><span class="line">    <span class="number">3</span> dup</span><br><span class="line">    <span class="number">4</span> <span class="function">invokespecial <span class="title">Foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    7 astore_1</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//Foo类构造器会调用父类Object的构造器</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">()</span></span>;</span><br><span class="line">    o aload_0 [<span class="keyword">this</span>]</span><br><span class="line">    <span class="number">1</span> invokespecial java.lang.Object() [<span class="number">8</span>]</span><br><span class="line">    <span class="number">4</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>Java对构造器的约束  </p>
<ul>
<li>如果一个类没有定义任何构造器的话，Java编译器会自动添加一个无参数的构造器。  </li>
<li>子类的构造器需要调用父类的构造器。如果父类存在无参数构造器的话，该调用可以是隐式的，Java编译器会自动添加对父类构造器的调用。但是，如果父类没有无参数构造器，那么子类的构造器则需要显式地调用父类带参数的构造器。  <ul>
<li>直接使用”super”关键字调用父类构造器。  </li>
<li>使用”this”关键字调用同一个类中的其他构造器。  <blockquote>
<p>无论是直接的显式调用，还是间接的显式调用，都需要作为构造器的第一条语句，以便优先初始化集成而来的父类字段。(但是可以通过调用其他生成参数的方法，或者字节码注入来绕开)  </p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><strong>当调用一个构造器时，它将优先调用父类的构造器，直至Object类。</strong>这些构造器的调用者皆为同一对象，也就是通过new指令新建而来的对象。<br>它的内存涵盖了所有父类中的实例字段。虽然子类无法访问父类的私有实例字段，或者子类的实例字段隐藏了父类的同名实例字段，但是<strong>子类的实例还是会为这些父类实例字段分配内存的</strong>。  </p>
<h3 id="压缩指针"><a href="#压缩指针" class="headerlink" title="压缩指针"></a>压缩指针</h3><p>在JVM中，每个Java对象都有一个对象头(object header)，这个由<strong>标记字段和类型指针</strong>所构成。其中，标记字段(mark word)用以存储JVM有关该对象的运行数据，如哈希码、GC信息以及锁薪资，而类型指针则指向该对象的类。  </p>
<p>在64位的JVM中，对象头的标记字段占64位，而类型指针又占了64位。每一个Java对象在内存中的额外开销就是16字节。以Integer类为例，它仅有一个int类型的私有字段，占4个字节。因此，每一个Integer对象的额外内存开销至少是400%。这是Java引入基本类型的原因之一。  </p>
<p>为了尽量减少对象的内存使用量，64位JVM引入了压缩指针的概念(虚拟机选项-XX:+UseCompressedOops,默认开启)，将堆中原本64位(8字节)的Java对象指针压缩成32位(4字节)的。这样，对象头中的类型指针也会被压缩成32位，使得对象头的大小从16字节降至12字节(标记字段8字节+类型指针4字节)。压缩指针不仅可以作用于对象头的类型指针，还可以作用于引用类型的字段，以及引用类型数组。   </p>
<h4 id="压缩指针原理"><a href="#压缩指针原理" class="headerlink" title="压缩指针原理"></a>压缩指针原理</h4><p>内存对齐，虚拟机选项-XX:ObjectAlignmentInBytes,默认值为8(2的3次方)。java对象的内存对齐大小。默认是8字节，JVM实际计算堆内存上限的方法是 4GB * ObjectAlignmentInBytes。  </p>
<blockquote>
<p>默认 8 字节对齐，那么最低 3 位是零，所以移动 3 位，那么就有 2<sup>32+3</sup>字节 = 32 GB 压缩引用空间。如果 16 字节对齐，那么就有 2<sup>32+4</sup>字节 = 64 GB 压缩引用堆空间<br><a href="https://shipilev.net/jvm/anatomy-quarks/24-object-alignment/" target="_blank" rel="noopener">JVM Anatomy Quark #24: 对象对齐</a></p>
</blockquote>
<p>默认情况下，JVM堆中对象的起始地址需要对齐至8的倍数。如果一个对象用不到8N个字节，那么空白的那部分空间就浪费掉了。这些浪费掉的空间称之为对象间的填充(padding)。  </p>
<p>在默认情况下，JVM中的32位压缩指针可以寻址到2的35次方个字节，也就是32GB的地址空间(超过32GB则会关闭压缩指针)。<strong>在压缩指针解引用时，需要将其左移3位，再加上一个固定偏移量，便可以得到能够寻址32GB地址空间的伪64位指针了。</strong>  </p>
<blockquote>
<p>并没有通过压缩指针让两个寻址范围一致，而是通过压缩指针放大了32位的寻址空间使它够用了。<br>此外可以通过内存对齐选项-XX:ObjectAlignmentInBytes来进一步提升寻址范围。但是同时也可能增加对象间填充，导致压缩指针没有达到原本节省空间的效果。  </p>
</blockquote>
<p>关闭了压缩指针，JVM还是会进行内存对齐。此外，<strong>内存对齐不仅存在于对象与对象之间，也存在于对象中的字段之间</strong>。如JVM要求long字段、double字段，以及非压缩指针状态下的引用字段地址为8的倍数。  </p>
<p>字段内存对齐的原因之一，让字段只出现在同一CPU地缓存行中。如果字段不是对齐的，那么就有可能出现跨缓存行的字段。该字段的读取可能需要替换两个缓存行，而该字段的存储也会同时污染两个缓存行。这两种情况对程序的执行效率而言都是不利的。  </p>
<h3 id="字段重排列"><a href="#字段重排列" class="headerlink" title="字段重排列"></a>字段重排列</h3><p>字段重排列，是指<strong>JVM重新分配字段的先后顺序</strong>，以达到内存对齐的目的。JVM中有三种排列方法(对应JVM选项-XX:FieldsAllocationStyle,默认值是1)。遵循两个规则：  </p>
<ul>
<li>如果一个字段占据C个字节，那么该字段的偏移量需要对齐至NC。这里偏移量指的是字段地址与对象的起始地址差值。  <blockquote>
<p>以long类为例，它仅有一个long类型(8字节)的实例字段。在使用了压缩指针的64位虚拟机中，尽管对象头的大小为12个字节，该long类型字段的偏移量也只能是16，而中间空着的4个字节便会被浪费掉。  </p>
</blockquote>
</li>
<li>子类所继承字段的偏移量，需要与父类对应字段的偏移量保持一致。  <blockquote>
<p>在具体实现中，JVM还会对齐子类字段的起始位置。对于使用了压缩指针的64位虚拟机，子类第一个字段需要对齐至4N；而对于关闭了压缩指针的64位虚拟机，子类第一个字段则需要对齐至8N。  </p>
</blockquote>
</li>
</ul>
<h4 id="虚共享"><a href="#虚共享" class="headerlink" title="虚共享"></a>虚共享</h4><p>Java8引入了一个新的注释@Contended，用来解决对象字段之间的虚共享(false sharing)问题。这个注释也会影响到字段的排列。  </p>
<p>假设两个线程分别访问同一对象中不同的volatile字段，逻辑上它们并没有共享内容，因此不需要同步。然而，如果这两个字段恰好在同一个缓存行中，那么对这些字段的写操作会导致缓存行的写回，也就造成了实质上的共享。  </p>
<p>JVM会让不同的@Contended字段处于独立的缓存行中，会导致大量的空间被浪费掉。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 虚拟机选项-XX:-RestrictContended。</span></span><br><span class="line"><span class="comment">* Java9以上版本，使用javac编译时需要添加--add-exports java.base/jdk.internal.vm.annotation=ALL-UNNAME。  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//JOL工具，打印工程中的类的字段分布情况</span></span><br><span class="line">curl -L -O http:<span class="comment">//central.maven.org/maven2/org/openjdk/jol/jol-cli/0.9/jol-cli-0.9-full.jar</span></span><br><span class="line">java -cp jol-cli-<span class="number">0.9</span>-full.jar org.openjdk.jol.Main internals java.lang.String</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>常见的new语句会被编译为new指令，以及对构造器的调用。每个类的构造器皆会直接或间接调用父类的构造器，并且在同一个实例中初始化相应的字段。  </p>
<p>JVM引入了压缩指针的概念，将原本的64位指针压缩成32位。压缩指针要求JVM堆中对象的起始地址要对齐至8的倍数。JVM还会对每个类的字段进行重排列，使得字段也能够内存对齐。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>JVM是怎么实现invokedynamic的</title>
    <url>/JVM/8JVM%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0invokedynamic%E7%9A%84/</url>
    <content><![CDATA[<p>Java中，方法调用会被编译为invokestatic、invokespecial、invokevirtual、invokeinterfaces四种指令。这些指令与包含目标方法类名、方法名以及方法描述符的符号引用捆绑。在实际运行之前，JVM将根据这个符号引用链接到具体的目标方法。  </p>
<blockquote>
<p>这四种调用指令中，JVM明确要求方法调用需要提供目标方法的类名：  </p>
<ul>
<li>调用其中一种类型的目标方法。不符合的类型，套一层马甲后再调用。  </li>
<li>通过反射机制，来查找并且调用各个类型中的目标方法，以此来模拟真正的目标方法。  </li>
</ul>
</blockquote>
<p>Java7引入了一条新的指令invokedynamic，该指令的调用机制抽象出调用点这一个概念，并允许应用程序将调用点链接至任意符合条件的方法上(加载一个任意对象，invokedynamic调用目标方法)。  </p>
<blockquote>
<p>作为invokedynamic的准备工作，Java7引入了更加底层、更加灵活的方法抽象：方法句柄(MethodHandle)。  </p>
</blockquote>
<h3 id="方法句柄的概念"><a href="#方法句柄的概念" class="headerlink" title="方法句柄的概念"></a>方法句柄的概念</h3><p>方法句柄是一个强类型的，能够被直接执行的引用。该引用可以指向常规的静态方法或者实例方法，也可以指向构造器或者字段。当指向字段时，方法句柄实则指向包含字段访问字节码的虚构方法，语义上等价于目标字段的getter或者setter方法(但并不会直接指向目标字段所在类中的getter/setter，因为已有的getter/setter方法不一定就是在访问目标字段)。  </p>
<p>方法句柄的类型(MethodType)是由所指向方法的参数类型以及返回类型组成的。它是用来确认方法句柄是否适配的唯一关键。当使用方法句柄时，并不关心方法句柄所指向方法的类名或者方法名。  </p>
<p>方法句柄的创建是通过MethodHandles.Lookup类来完成的。它提供了多个API，既可以使用反射API中的Method来查找，也可以根据类、方法名以及方法句柄类型来查找(需区分具体的调用类型)。  </p>
<blockquote>
<ul>
<li>Lookup.findStatic方法-invokestatic调用的静态方法。  </li>
<li>Lookup.findVirtual方法-invokevirtual调用的实例方法&amp;invokeinterface调用的接口方法。  </li>
<li>Lookup.findSpecial方法-invokespecial调用的实例方法。  </li>
</ul>
</blockquote>
<p>调用方法句柄，和原本对应的调用指令时一致的。对于原本用invokevirtual调用的方法句柄，它也会采用动态绑定；而对于原本用invokespecial调用的方法句柄，它会采用静态绑定。  </p>
<p>方法句柄同样也有权限问题。但它与反射API不同，其权限检查是在句柄的创建阶段完成的。在实际调用过程中，JVM并不会检查方法句柄的权限。如果该句柄被多次调用，与反射调用相比，它将省下重复权限检查的开销。  </p>
<blockquote>
<p>由于方法句柄没有运行时权限检查，应用程序需要负责方法句柄的管理。一旦它发布了某些指向私有方法的方法句柄，那么这些私有方法便被暴露出去了。  </p>
</blockquote>
<p>方法句柄的访问权限不取决于方法句柄的创建位置，而是取决于Lookup对象的创建位置。  </p>
<blockquote>
<p>对于一个私有字段，如果Lookup对象是在私有字段所在类中获取的，那么这个Lookup对象便拥有对该私有字段的访问权限，即使是在所在类的外边，也能够通过该Lookup对象创建该私有字段的getter或者setter。  </p>
</blockquote>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        方法句柄的不同获取和调用方式
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.invoke.*;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Exception().printStackTrace();<span class="comment">//通过新建异常实例来查看栈轨迹</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Lookup <span class="title">lookup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> MethodHandles.lookup();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取方法句柄的不同方式  </span></span><br><span class="line">        <span class="comment">//MethodHandles.Lookup l = Foo.lookup();//具备Foo类的访问权限</span></span><br><span class="line">        <span class="comment">//Method m = Foo.class.getDeclaredMethod("bar", Object.class);</span></span><br><span class="line">        <span class="comment">//MethodHandle mh0 = l.unreflect(m);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        MethodHandles.Lookup l = MethodHandles.lookup();</span><br><span class="line">        MethodType t = MethodType.methodType(<span class="keyword">void</span><span class="class">.<span class="keyword">class</span>, <span class="title">Object</span>.<span class="title">class</span>)</span>;<span class="comment">//返回值和参数</span></span><br><span class="line">        MethodHandle mh1 = l.findStatic(Foo.class, "bar", t);//引用的方法</span><br><span class="line">        mh1.invokeExact(<span class="keyword">new</span> Object());<span class="comment">//调用执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<h3 id="方法句柄的操作"><a href="#方法句柄的操作" class="headerlink" title="方法句柄的操作"></a>方法句柄的操作</h3><p>方法句柄的调用可分为两种，一是需要严格匹配参数类型的invokeExact。而是自动适配参数类型的invoke。  </p>
<h4 id="invokeExact"><a href="#invokeExact" class="headerlink" title="invokeExact"></a>invokeExact</h4><p>假设一个方法句柄将接收一个Object类型的参数，如果直接传入String作为实际参数，那么方法句柄的调用会在运行时抛出方法类型不匹配的异常。正确的调用方式是将该String显示转化为Object类型。  </p>
<p>在普通Java方法调用中，只有在选择重载方法时，才会用到显式转化。经过显式转化后，参数的声明类型发生了改变，因此有可能匹配到不同的方法描述符，从而选取不同的目标方法。  </p>
<p>方法句柄API有一个特殊的注解类@PolymorphicSignature(签名多态性，signature polymorphism)。在碰到被它注解的方法调用时，Java编译器会根据所传入参数的声明类型来生成方法描述符，而不是采用目标方法所声明的描述符。  </p>
<blockquote>
<p>public final native @PolymorphicSignature Object invokeExact(Object… args) throws Throwable;</p>
</blockquote>
<p>invokeExact会确认invokevirtual(以及其他三种)指令对应的方法描述符，和该方法句柄的类型是否严格匹配。在不匹配的情况下，便会在运行时抛出异常。  </p>
<h4 id="invoke"><a href="#invoke" class="headerlink" title="invoke"></a>invoke</h4><p>invoke同样是一个签名多态性的方法。invoke会调用MethodHandle.asType方法，生成一个适配器方法句柄，对传入的参数进行适配，再调用原方法句柄。调用原方法句柄的返回值同样也会先进行适配，然后再返回给调用者。  </p>
<p>方法句柄还支持增删改参数的操作，这些操作都是通过生成另一个方法句柄来实现的。  </p>
<ul>
<li>改操作，通过MethodHandle.asType方法实现。  </li>
<li>删操作，通过MethodHandles.dropArguments方法，将传入的部分参数就地抛弃，再调用另一个方法句柄。  </li>
<li>增操作，通过MethodHandle.bindTo方法，往传入的参数中插入额外的参数，再调用另外一个方法句柄。  <blockquote>
<p>Java8 中捕获类型的Lambda表达式便是使用这种操作来实现的。<br>增操作还可以用来实现方法的柯里化。  </p>
</blockquote>
</li>
</ul>
<h3 id="方法句柄的实现"><a href="#方法句柄的实现" class="headerlink" title="方法句柄的实现"></a>方法句柄的实现</h3><p>HotSpot虚拟机中方法句柄的具体实现(DirectMethodHandle为例)。  </p>
<p>通过查看栈轨迹，invokeExact的目标方法就是方法句柄指向的方法。<br>启用-XX:+ShowHiddenFrames参数打印被JVM隐藏的栈信息。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        invokeExact栈轨迹
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ java -XX:+UnlockDiagnosticVMOptions -XX:+ShowHiddenFrames Foo</span><br><span class="line">java.lang.Exception</span><br><span class="line">        at Foo.bar(Foo.java:<span class="number">5</span>)</span><br><span class="line">        at java.base/java.lang.invoke.DirectMethodHandle$Holder. invokeStatic(DirectMethodHandle$Holder:<span class="number">1000010</span>)</span><br><span class="line">        at java.base/java.lang.invoke.LambdaForm$MH000/<span class="number">766572210</span>. invokeExact_MT000_LLL_V(LambdaForm$MH000:<span class="number">1000019</span>)</span><br><span class="line">        at Foo.main(Foo.java:<span class="number">12</span>)</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p><strong>JVM会对invokeExact调用做特殊处理</strong>，调用至一个共享的、与方法句柄类型相关的特殊适配器中。这个适配器是一个LambdaForm，可以通过添加虚拟机参数将之导出成class文件(-DJava.lang.invoke.MethodHandle.DUMP_CLASS_FILES=true)。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        invokeExact-LambdaForm
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">invoke</span>.<span class="title">LambdaForm</span>$<span class="title">MH000</span> </span>&#123;  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeExact_MT000_LLLLV</span><span class="params">(jeava.lang.bject, jjava.lang.bject, jjava.lang.bject)</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">        : aload_0</span><br><span class="line">      1 : checkcast      #14                 //class java/lang/invoke/MethodHandle</span><br><span class="line">        : dup</span><br><span class="line">      <span class="number">5</span> : astore_0</span><br><span class="line">        : aload_32        :</span><br><span class="line">         checkcast      #16                 //class java/lang/invoke/MethodType</span><br><span class="line">      10: invokestatic  #22                 // Method java/lang/invoke/Invokers.checkExactType:(Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType);V</span><br><span class="line">      <span class="number">13</span>: aload_0</span><br><span class="line">      14: invokestatic   #26                // Method java/lang/invoke/Invokers.checkCustomized:(Ljava/lang/invoke/MethodHandle);V</span><br><span class="line">      <span class="number">17</span>: aload_0</span><br><span class="line">      <span class="number">18</span>: aload_1</span><br><span class="line">      19: invokevirtual #30                // Method.java/lang/invoke/MethodHandle.invokeBasic:(Ljava/lang/object);V</span><br><span class="line">       <span class="number">23</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p>在这个适配器中，它会调用Invokers.checkExactType方法来检查参数类型，然后调用Invokers.checkCustomized方法，在方法句柄的执行次数超过一个阈值时进行优化(Djava.lang.invoke.MethodHandle.CUSTOMIZE_THRESHOLD=127)，最后调用方法句柄的invokeBase方法。  </p>
<p><strong>JVM同样会对invokeBasic调用做特殊处理</strong>，将调用至方法句柄本身所持有的适配器中，这个适配器同样是一个LambdaForm，通过反射机制将其打印出来。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        invokeBasic-LambdaForm
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该方法句柄持有的LambdaForm实例的toString()结果</span></span><br><span class="line">DMH.invokeStatic_L_V=Lambda(a0:L,a1:L)=&gt;&#123;</span><br><span class="line">  t2:L=DirectMethodHandle.internalMemberName(a0:L);</span><br><span class="line">  t3:V=MethodHandle.linkToStatic(a1:L,t2:L);<span class="keyword">void</span>&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p>这个适配器将获取方法句柄中的MemberName类型的字段，并且以它为参数调用linkToStatic方法。  </p>
<p><strong>JVM也会对linkToStatic调用做特殊处理</strong>，它将根据传入的MemberName参数所存储的方法地址或者方法表索引，直接跳转至目标方法。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        linkToStatic
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberName</span> <span class="keyword">implements</span> <span class="title">Member</span>, <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//@Injected JVM_Method* vmtarget;</span></span><br><span class="line">    <span class="comment">//@Injected int         vmindex;</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<hr>
<p>方法句柄一开始持有的适配器是共享的。当它被多次调用之后，Invokers.checkCustomized方法会为该方法句柄生成一个特有的适配器。这个特有的适配器会将方法句柄作为常量，直接获取其MemberName类型的字段，并继续后面的linkToStatic调用。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        checkCustomized优化
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">invoke</span>.<span class="title">LambdaForm</span>$<span class="title">DMH000</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeStatic000_LL_V</span><span class="params">(java.lang.Object, java.lang.Object)</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: ldc           #14                 // String CONSTANT_PLACEHOLDER_1 &lt;&lt;Foo.bar(Object)void/invokeStatic&gt;&gt;</span><br><span class="line">       2: checkcast     #16                 // class java/lang/invoke/MethodHandle</span><br><span class="line">       <span class="number">5</span>: astore_0     <span class="comment">// 上面的优化代码覆盖了传入的方法句柄</span></span><br><span class="line">       <span class="number">6</span>: aload_0      <span class="comment">// 从这里开始跟初始版本一致</span></span><br><span class="line">       7: invokestatic  #22                 // Method java/lang/invoke/DirectMethodHandle.internalMemberName:(Ljava/lang/Object;)Ljava/lang/Object;</span><br><span class="line">      <span class="number">10</span>: astore_2</span><br><span class="line">      <span class="number">11</span>: aload_1</span><br><span class="line">      <span class="number">12</span>: aload_2</span><br><span class="line">      13: checkcast     #24                 // class java/lang/invoke/MemberName</span><br><span class="line">      16: invokestatic  #28                 // Method java/lang/invoke/MethodHandle.linkToStatic:(Ljava/lang/Object;Ljava/lang/invoke/MemberName;)V</span><br><span class="line">      <span class="number">19</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p>方法句柄的调用和反射调用一样，都是间接调用。因此它也面临无法内联的问题。与反射不同的是，方法句柄的内联瓶颈在于即时编译器能否将该方法句柄识别为常量。  </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>方法句柄是invokedynamic底层机制的基石。  </p>
<p>方法句柄是一个强类型、能够被直接执行的引用。它仅关心所指向方法的参数类型以及返回类型，而不关心方法所在的类以及方法名。方法句柄的权限检查发生在创建过程中，相较于反射调用节省了调用时反复权限检查的开销。  </p>
<p>方法句柄可以通过invokeExact以及invoke来调用。其中invokeExact要求传入的参数和所指向方法的描述符严格匹配。方法句柄还支持增删改参数的操作，这些操作是通过生成另一个充当适配器的方法句柄来实现的。  </p>
<p>方法句柄和反射调用一样，都是间接调用，同样会面临无法内联的问题。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>Java语法糖和Java编译器</title>
    <url>/JVM/15Java%E8%AF%AD%E6%B3%95%E7%B3%96%E5%92%8CJava%E7%BC%96%E8%AF%91%E5%99%A8/</url>
    <content><![CDATA[<p>Java语法和Java字节码之间的差异，都是通过Java编译器来协调的。  </p>
<h3 id="自动装箱与自动拆箱"><a href="#自动装箱与自动拆箱" class="headerlink" title="自动装箱与自动拆箱"></a>自动装箱与自动拆箱</h3><p>自动装箱(auto-boxing)与自动拆箱(auto-unboxing)。  </p>
<p>Java语言拥有8个基本类型，每个基本类型都有对应的包装(wrapper)类型。之所以需要包装类型，是因为许多Java核心类库的API都是面向对象的。如Java核心类库中的容器类，就只支持引用类型。  </p>
<p>当需要一个能够存储数值的容器类时，往往定义一个存储包装类对象的容器。对于基本类型的数值来说，需要先将其转换为对应的包装类，再存图容器之中。在Java程序中，这个转换可以是显式，也可以是隐式的，后者正是Java中的自动装箱。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        自动装拆箱示例
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> result = list.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述Java代码中，构造了一个Integer类型的ArrayList，并且向其中添加一个int值0。然后获取该ArrayList的第0个元素，并作为int值返回给调用者。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">  Code:</span><br><span class="line">     <span class="number">0</span>: <span class="keyword">new</span> java/util/ArrayList</span><br><span class="line">     <span class="number">3</span>: dup</span><br><span class="line">     <span class="number">4</span>: invokespecial java/util/ArrayList.<span class="string">"&lt;init&gt;"</span>:()V</span><br><span class="line">     <span class="number">7</span>: astore_1</span><br><span class="line">     <span class="number">8</span>: aload_1</span><br><span class="line">     <span class="number">9</span>: iconst_0</span><br><span class="line">    <span class="number">10</span>: invokestatic java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span><br><span class="line">    <span class="number">13</span>: invokevirtual java/util/ArrayList.add:(Ljava/lang/Object;)Z</span><br><span class="line">    <span class="number">16</span>: pop</span><br><span class="line">    <span class="number">17</span>: aload_1</span><br><span class="line">    <span class="number">18</span>: iconst_0</span><br><span class="line">    <span class="number">19</span>: invokevirtual java/util/ArrayList.get:(I)Ljava/lang/Object;</span><br><span class="line">    <span class="number">22</span>: checkcast java/lang/Integer</span><br><span class="line">    <span class="number">25</span>: invokevirtual java/lang/Integer.intValue:()I</span><br><span class="line">    <span class="number">28</span>: istore_2</span><br><span class="line">    <span class="number">29</span>: iload_2</span><br><span class="line">    <span class="number">30</span>: ireturn</span><br></pre></td></tr></table></figure>

<p>当向泛型参数为Integer的ArrayList添加int值时，便需要用到自动装箱了。在上述字节码偏移量为10的指令中，调用了Integer.valueOf方法，将int类型的值转换为Integer类型，再存储至容器类中。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Integer.valueOf源代码，当请求的int值再某个范围内时，会返回缓存了的Integer对象；而当所请求的int值再范围之外时，则会新建一个Integer对象。  </p>
<p>配置参数java.lang.Integer.IntegerCache.high，扩大Integer缓存的范围。JVM参数-XX:+AggressiveOpts也会将IntegerCache.high调整至20000。  </p>
<p>但是Java并不支持对IntegerCache.low的更改，对于小于-128的整数，无法直接使用由Java核心类库所缓存的Integer对象。  </p>
<p>当从泛型参数为Integer的ArrayList取出元素时，得到的实际上也是Integer对象。如果应用程序期待的是一个int值，那么就会发生自动拆箱。  </p>
<p>自动拆箱对应的是字节码偏移量为25的指令。该指令将调用Integer.intValue方法。这是一个实例方法，直接返回Integer对象所存储的int值。  </p>

    </div>
</div>  

<h3 id="泛型与类型擦除"><a href="#泛型与类型擦除" class="headerlink" title="泛型与类型擦除"></a>泛型与类型擦除</h3><p>示例中生成的字节码，往ArrayList中添加元素的add方法，所接受的参数类型是Object；而从ArrayList中获取元素的get方法，其返回类型也是Object。  </p>
<p>后者返回类型，在字节码中需要进行向下转换，将所返回的Object强制转换为Integer，方能进行接下来的自动拆箱。  </p>
<p>之所以出现这种情况，是因为Java泛型的类型擦除：Java程序里的泛型信息，在JVM里全部都丢失了，这么做是为了兼容引入泛型之前的代码。  </p>
<p>但并不是每一个泛型参数被擦除类型后都会变成Object类。对于限定了继承类的泛型参数，经过类型擦除后，所有的泛型类型都将变成所限定的继承类。Java编译器将选取该泛型所能指代的所有类中层次最高的那个，作为替换泛型的类。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        泛型与类型擦除示例
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义了一个T extends Number的泛型参数。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">T <span class="title">foo</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">T <span class="title">foo</span><span class="params">(T)</span></span>;</span><br><span class="line">  descriptor: (Ljava/lang/Number;)Ljava/lang/Number;</span><br><span class="line">  flags: (<span class="number">0x0000</span>)</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">1</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">       <span class="number">0</span>: aload_1</span><br><span class="line">       <span class="number">1</span>: areturn</span><br><span class="line">  Signature: (TT;)TT;</span><br></pre></td></tr></table></figure>

<p>foo方法的方法描述符所接收参数的类型以及返回类型都为Number。方法描述符是JVM识别方法调用的目标方法的关键。  </p>
<p>字节码中仍存在泛型参数的信息，方法声明里的T foo(T)，以及方法签名(Signature)中的”(TT;)TT;”。这类信息主要<strong>由Java编译器在编译他类时使用</strong>。  </p>

    </div>
</div>  

<p>泛型会被类型擦除，但依然必要。Java编译器可以根据泛型参数判断程序中的语法是否正确。尽管经过类型擦除后，ArrayList.add方法所接收的参数是Object类型，但是往泛型参数为Integer类型的ArrayList中添加字符串对象，Java编译器是会报错的。  </p>
<h3 id="桥接方法"><a href="#桥接方法" class="headerlink" title="桥接方法"></a>桥接方法</h3><h4 id="参数类型不同"><a href="#参数类型不同" class="headerlink" title="参数类型不同"></a>参数类型不同</h4><p>泛型的类型擦除带来了不少问题。其中一个是方法重写。但通过桥接方法可以解决参数类型不匹配问题。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        桥接不同参数类型
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Merchant</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Customer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">actionPrice</span><span class="params">(T customer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VIPOnlyMerchant</span> <span class="keyword">extends</span> <span class="title">Merchant</span>&lt;<span class="title">VIP</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">actionPrice</span><span class="params">(VIP customer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VIPOnlyMerchant</span> <span class="keyword">extends</span> <span class="title">Merchant</span>&lt;<span class="title">VIP</span>&gt;</span></span><br><span class="line"><span class="class">...</span></span><br><span class="line"><span class="class">  <span class="title">public</span> <span class="title">double</span> <span class="title">actionPrice</span>(<span class="title">VIP</span>)</span>;</span><br><span class="line">    descriptor: (LVIP;)D</span><br><span class="line">    flags: (<span class="number">0x0001</span>) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">         <span class="number">0</span>: dconst_0</span><br><span class="line">         <span class="number">1</span>: dreturn</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">actionPrice</span><span class="params">(Customer)</span></span>;</span><br><span class="line">    descriptor: (LCustomer;)D</span><br><span class="line">    flags: (<span class="number">0x1041</span>) ACC_PUBLIC, ACC_BRIDGE, ACC_SYNTHETIC</span><br><span class="line">    Code:</span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: aload_1</span><br><span class="line">         <span class="number">2</span>: checkcast <span class="class"><span class="keyword">class</span> <span class="title">VIP</span></span></span><br><span class="line">         5: invokevirtual actionPrice:(LVIP;)D</span><br><span class="line">         <span class="number">8</span>: dreturn</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个桥接方法等同于</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">actionPrice</span><span class="params">(Customer customer)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> actionPrice((VIP) customer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>VIPOnlyMerchant中的actionPrice方法经过类型擦除后，父类的方法描述符为(LCustomer;)D，而子类的方法描述符为(LVIP;)D。这显然不符合JVM关于方法重写的定义。  </p>
<p><strong>为了保证编译而成的Java字节码能够保留重写的语义，Java编译器额外添加了一个桥接方法。该桥接方法在字节码层面重写了父类的方法，并将调用子类的方法。</strong>  </p>
<p>VIPOnlyMerchant类包含一个桥接方法actionPrice(Customer)，它重写了父类的同名同方法描述符的方法。该桥接方法将传入的Customer参数强制转换为VIP类型，再调用原本的actionPrice(VIP)方法。  </p>
<blockquote>
<p>当一个声明类型为Merchant，实际类型为VIPOnlyMerchant的对象，调用actionPrice方法时，字节码里的符号引用指向的是Merchant.actionPrice(Customer)方法。JVM将动态绑定至VIPOnlyMerchant类的桥接方法之中，并且调用其actionPrice(VIP)方法。  </p>
</blockquote>
<p>在Javap的输出中，该桥接方法的访问标识符除了代表桥接方法的ACC_BRIDGE之外，还有ACC_SYNTHETIC。它表示该方法对于Java源代码来说是不可见的。当尝试通过传入一个声明类型为Customer的对象作为参数，调用VIPOnlyMerchant类的actionPrice方法时，Java编译器会报错，并且提示参数类型不匹配。  </p>
<blockquote>
<p>Customer customer = new VIP();<br>new VIPOnlyMerchant().actionPrice(customer); // 编译出错    </p>
</blockquote>

    </div>
</div>  

<h4 id="返回类型不同"><a href="#返回类型不同" class="headerlink" title="返回类型不同"></a>返回类型不同</h4><p>如果子类定义了一个与父类参数类型相同的方法，其返回类型为父类方法返回类型的子类，那么Java编译器也会为其生成桥接方法。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        桥接不同返回类型
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Merchant</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Number <span class="title">actionPrice</span><span class="params">(Customer customer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NativeMerchant</span> <span class="keyword">extends</span> <span class="title">Merchant</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">actionPrice</span><span class="params">(Customer customer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>D;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NaiveMerchant</span> <span class="keyword">extends</span> <span class="title">Merchant</span></span></span><br><span class="line"><span class="class">  <span class="title">public</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Double</span> <span class="title">actionPrice</span>(<span class="title">Customer</span>)</span>;</span><br><span class="line">    descriptor: (LCustomer;)Ljava/lang/Double;</span><br><span class="line">    flags: (<span class="number">0x0001</span>) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: dconst_0</span><br><span class="line">         <span class="number">1</span>: invokestatic Double.valueOf:(D)Ljava/lang/Double;</span><br><span class="line">         <span class="number">4</span>: areturn</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> java.lang.<span class="function">Number <span class="title">actionPrice</span><span class="params">(Customer)</span></span>;</span><br><span class="line">    descriptor: (LCustomer;)Ljava/lang/Number;</span><br><span class="line">    flags: (<span class="number">0x1041</span>) ACC_PUBLIC, ACC_BRIDGE, ACC_SYNTHETIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: aload_1</span><br><span class="line">         <span class="number">2</span>: invokevirtual actionPrice:(LCustomer;)Ljava/lang/Double;</span><br><span class="line">         <span class="number">5</span>: areturn</span><br></pre></td></tr></table></figure>

<p>该桥接方法标注了ACC_SYNTHETIC不可见，当在Java程序中调用NativeMerchant.actionPrice时，只会调用到原方法。  </p>

    </div>
</div>  

<p>class文件里允许出现两个同名、同参数类型但是不同返回类型的方法。原方法与桥接方法便是例子。  </p>
<h3 id="其他语法糖"><a href="#其他语法糖" class="headerlink" title="其他语法糖"></a>其他语法糖</h3><p>变长参数<br>try-with-resources以及在同一catch代码块中捕获多种异常等语法糖。  </p>
<p>foreach循环允许Java程序在for循环里遍历数组或者Iterable对象。  </p>
<h4 id="foreach循环数组"><a href="#foreach循环数组" class="headerlink" title="foreach循环数组"></a>foreach循环数组</h4><p>对于数组来说，foreach循环将从0开始逐一访问数组中的元素，直至数组的末尾。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> item : array) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] myArray = array;</span><br><span class="line">    <span class="keyword">int</span> length = myArray.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> item = myArray[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="foreach循环Iterator"><a href="#foreach循环Iterator" class="headerlink" title="foreach循环Iterator"></a>foreach循环Iterator</h4><p>对于Iterable对象来说，foreach循环将调用其iterator方法，并且用它的hasNext以及next方法来遍历该Iterable对象中的元素。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(ArrayList&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Integer item : list) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(ArrayList&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">    Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        Integer item = iterator.next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字符串switch"><a href="#字符串switch" class="headerlink" title="字符串switch"></a>字符串switch</h4><p>字符串switch编译而成的字节码看起来非常复杂，但实际上就是一个哈希桶。由于每个case所截获的字符串都是常量值，因此，Java编译器会将原来的字符串switch转换为int值switch，比较所输入的字符串的哈希值。  </p>
<p>由于字符串哈希值很容易发生碰撞，因此，还需要用String.equals逐个比较相同哈希值的字符串。  </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>基本类型和其包装类型之间的自动转换，也就是自动装箱、自动拆箱，是通过加入[Wrapper].valueOf(如Integer.valueOf)以及[Wrapper].[primitive]Value(如Integer.intValue)方法调用来实现的。  </p>
<p>Java程序中的泛型信息会被擦除。Java编译器将选取该泛型所能指代的所有类中层次最高的那个，作为替换泛型的具体类。  </p>
<p>由于Java语义与Java字节码中关于重写的定义并不一致，因此Java编译器会生成桥接方法作为适配器。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>Java虚拟机是怎么实现synchronized的</title>
    <url>/JVM/14Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0synchronized%E7%9A%84/</url>
    <content><![CDATA[<p>在Java程序中，可以利用synchronized关键字来对程序进行加锁。它既可以用来声明一个synchronized代码块，也可以直接标记静态方法或者实例方法。  </p>
<p>当声明synchronized代码块时，<strong>编译而成的字节码将包含monitorenter和monitorexit指令</strong>。这两种指令均会消耗操作数栈上的一个引用类型的元素(synchronized关键字括号里的引用)，作为所要加锁解锁的锁对象。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        synchronized 代码块字节码
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Object lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">      lock.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 上面的Java代码将编译为下面的字节码</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(java.lang.Object)</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_1</span><br><span class="line">       <span class="number">1</span>: dup</span><br><span class="line">       <span class="number">2</span>: astore_2</span><br><span class="line">       <span class="number">3</span>: monitorenter</span><br><span class="line">       <span class="number">4</span>: aload_1</span><br><span class="line">       <span class="number">5</span>: invokevirtual java/lang/Object.hashCode:()I</span><br><span class="line">       <span class="number">8</span>: pop</span><br><span class="line">       <span class="number">9</span>: aload_2</span><br><span class="line">      <span class="number">10</span>: monitorexit</span><br><span class="line">      <span class="number">11</span>: goto          <span class="number">19</span></span><br><span class="line">      <span class="number">14</span>: astore_3</span><br><span class="line">      <span class="number">15</span>: aload_2</span><br><span class="line">      <span class="number">16</span>: monitorexit</span><br><span class="line">      <span class="number">17</span>: aload_3</span><br><span class="line">      <span class="number">18</span>: athrow</span><br><span class="line">      <span class="number">19</span>: <span class="keyword">return</span></span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           <span class="number">4</span>    <span class="number">11</span>    <span class="number">14</span>   any</span><br><span class="line">          <span class="number">14</span>    <span class="number">17</span>    <span class="number">14</span>   any</span><br><span class="line"></span><br><span class="line"><span class="comment">//字节码中包含一个monitorenter指令以及多个monitorexit指令。  </span></span><br><span class="line"><span class="comment">//JVM需要确保所获得的锁在正常执行路径，以及异常执行路径上都能够被解锁。</span></span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p>当用synchronized标记方法时，<strong>字节码中方法的访问标记包括ACC_SYNCHRONIZED</strong>。该标记表示在进入该方法时，JVM需要进行monitorenter操作；而在退出该方法时，不管是正常返回，还是向调用者抛异常，JVM均需要进行monitorexit操作。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        synchronized 方法字节码
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Object lock)</span> </span>&#123;</span><br><span class="line">    lock.hashCode();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 上面的Java代码将编译为下面的字节码</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(java.lang.Object)</span></span>;</span><br><span class="line">    descriptor: (Ljava/lang/Object;)V</span><br><span class="line">    flags: (<span class="number">0x0021</span>) ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: aload_1</span><br><span class="line">         <span class="number">1</span>: invokevirtual java/lang/Object.hashCode:()I</span><br><span class="line">         <span class="number">4</span>: pop</span><br><span class="line">         <span class="number">5</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//monitorenter和monitorexit操作所对应的锁对象是隐式的。  </span></span><br><span class="line"><span class="comment">//对于实例方法来说，这两个操作对应的锁对象是this；  </span></span><br><span class="line"><span class="comment">//对于静态方法来说，这两个操作对应的锁对象则是所在类的Class实例。</span></span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p>关于monitorenter和monitorexit的作用，可以抽象的理解为每个锁对象拥有一个锁计数器和一个指向持有该锁的线程的指针。  </p>
<p>当执行monitorenter时，如果目标锁对象的计数器为0，那么说明它没有被其他线程所持有。在这个情况下，JVM会将该锁对象的持有线程设置为当前线程，并且将其计数器加1。  </p>
<p>在目标锁对象的计数器不为0的情况下，如果锁对象的持有线程是当前线程，那么JVM可以将其计数器加1，否则需要等待，直到持有线程释放该锁。  </p>
<p>当执行monitorexit时，JVM则需将锁对象的计数器减1，当计数器减为0时，那便代表该锁已经被释放掉了。  </p>
<p>采用这种计数器的方式，是为了允许同一个线程重复获取同一把锁。如果一个Java类中拥有多个synchronized方法，那么这些方法之间的相互调用，不管是直接的还是间接的，都会涉及对同一把锁的重复加锁操作。需要设计这么一个可冲入的特性，来避免编程里的隐式约束。  </p>
<h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>重量级锁是JVM中最为基础的锁实现。在这种状态下，JVM会阻塞加锁失败的线程，并且在目标锁被释放的时候，唤醒这些线程。  </p>
<p>Java线程的阻塞以及唤醒，都是依靠操作系统来完成的。对于符合posix接口的操作系统(macOS和大部分Linux)，上述操作是通过pthread的互斥锁(mutex)来实现的。此外，这些操作将涉及系统调用，需要从操作系统的用户态切换至内核态，其开销非常之大。  </p>
<p>为了避免昂贵的线程阻塞、唤醒操作，JVM会在线程进入阻塞状态之前，以及被唤醒后竞争不到锁的情况下，进入自旋状态，在处理器上空跑并且轮询锁是否被释放。如果此时锁恰好被释放了，那么当前线程便无须进入阻塞状态，而是直接获得这把锁。  </p>
<p>与线程阻塞相比，<strong>自旋状态可能会浪费大量的处理器资源</strong>。这是因为当前线程仍处于运行状况，只不过跑的是无用指令。它期望在运行无用指令的过程中，锁能够被释放出来。  </p>
<p>JVM么有办法根据等待时间的长短来选择自旋还是阻塞。JVM啊啊给出的是自适应自旋，根据以往自旋等待时是否能够获得锁，来动态调整自旋的时间(循环数目)。  </p>
<p><strong>自旋状态带来另外一个副作用-不公平的锁机制</strong>。处于阻塞状态的线程，并没有办法立刻竞争被释放的锁。然而，处于自旋状态的线程，则很有可能优先获得这把锁。  </p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>多个线程在不同的时间段请求同一把锁，没有锁竞争。针对这种情形，JVM采用了轻量级锁，来避免重量级锁的阻塞以及唤醒。  </p>
<p>在对象内存布局中，对象头中的标记字段(mark word)。它的最后两位被用来表示该对象的锁状态。其中00代表轻量级锁，01代表无锁(或偏向锁)，10代表重量级锁，11则跟垃圾回收算法的标记有关。  </p>
<img src='/img/JVM锁.gif'>
<img src='/img/JVM锁.jpg'>

<p><a href="https://my.oschina.net/lscherish/blog/3117851" target="_blank" rel="noopener">synchronized原理和锁优化策略(偏向/轻量级/重量级)</a>  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        synchronized原理和锁优化策略-轻量级锁
    </div>
    <div class='spoiler-content'>
        <p>JVM的开发者发现在很多情况下，在Java程序运行时，同步块中的代码都是不存在竞争的，不同的线程交替的执行同步块中的代码。这种情况下，用重量级锁是没必要的。因此JVM引入了轻量级锁的概念。  </p>
<p>轻量级锁是由偏向所升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁。  </p>
<h4 id="加锁过程"><a href="#加锁过程" class="headerlink" title="加锁过程"></a>加锁过程</h4><ol>
<li><p>在代码进入同步块的时候，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁记录目前的Mark Word的拷贝（称为Displaced Mark Word）以及记录锁对象的指针（即obj（即下图的Object reference）字段指向锁对象）。下图右边的部分就是一个Lock Record。左边部分是锁对象。  </p>
 <img src='/img/JVM锁对象与Lock Record.jpg'>
</li>
<li><p>当一个线程来获取这个锁，虚拟机将使用CAS操作尝试将锁对象的Mark Word更新为指向Lock Record的指针。  </p>
</li>
</ol>
<ul>
<li>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位（Mark Word的最后2bit）将转变为“00”，即表示此对象处于轻量级锁定状态。  </li>
<li>如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否已经指向当前线程的栈帧。  <ul>
<li>如果已经指向当前线程的栈帧，说明当前线程已经拥有了这个对象的锁，现在是重入状态，那么：  <ul>
<li>设置Lock Record第一部分（Displaced Mark Word）为null，起到了一个重入计数器的作用。  </li>
<li>下图为重入三次时的lock record示意图，左边为锁对象，右边为当前线程的栈帧。    <img src='/img/JVM重入锁对象与Lock Record.jpg'></li>
<li>然后结束。就可以直接进入同步块继续执行。  <blockquote>
<p>为什么JVM选择在线程栈中添加Displaced Mark word为null的Lock Record来表示重入计数呢？首先锁重入次数是一定要记录下来的，因为每次解锁都需要对应一次加锁，解锁次数等于加锁次数时，该锁才真正的被释放，也就是在解锁时需要用到说锁重入次数的。一个简单的方案是将锁重入次数记录在对象头的mark word中，但mark word的大小是有限的，已经存放不下该信息了。另一个方案是只创建一个Lock Record并在其中记录重入次数，Hotspot没有这样做的原因我猜是考虑到效率有影响：每次重入获得锁都需要遍历该线程的栈找到对应的Lock Record，然后修改它的值。所以最终Hotspot选择每次获得锁都添加一个Lock Record来表示锁的重入。  </p>
</blockquote>
</li>
</ul>
</li>
<li>如果已经指向别的线程的栈帧，说明这个锁对象已经被其他线程抢占了。那么：  <ul>
<li>它就会自旋等待锁，一定次数后仍未获得锁对象，说明发生了竞争，需要膨胀为重量级锁。  </li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="解锁过程"><a href="#解锁过程" class="headerlink" title="解锁过程"></a>解锁过程</h4><ol>
<li>遍历当前线程栈,找到所有obj字段等于当前锁对象的Lock Record。  </li>
<li>如果Lock Record的Displaced Mark Word为null，代表这是一次重入，将obj设置为null后continue（即一次解锁结束）。  </li>
<li>如果Lock Record的Displaced Mark Word不为null，则利用CAS指令将对象头的mark word恢复成为Displaced Mark Word。如果成功，则continue（即一次解锁结束），否则膨胀为重量级锁。  </li>
</ol>

    </div>
</div>  

<h4 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h4><p>当进行加锁操作时，JVM会判断是否已经是重量级锁。如果不是，它会在当前线程的当前栈帧中划出一块空间，作为该锁的锁记录，并且将锁对象的标记字段复制到该锁记录中。然后，JVM会尝试用CAS(compare-and-swap)操作替换锁对象的标记字段。  </p>
<blockquote>
<p>CAS是一个原子操作，它会比较目标地址的值是否和期望值相等，如果相等，则替换为一个新的值。  </p>
</blockquote>
<p>假设当前锁对象的标记字段为X…XYZ，JVM会比较该字段是否为X…X01。</p>
<ul>
<li>如果是，则替换为刚才分配的锁记录的地址（当前线程当前栈帧中的一块空间）。由于内存对齐的缘故，它的最后两位为00。此时，该线程已成功获得这把锁，可以继续执行了。</li>
<li>如果不是X…X01，那么有两种可能：第一，该线程重复获取同一把锁。此时，JVM会将锁记录清零，以代表该锁被重复获取。第二，其他线程持有该锁。此时，JVM会将这把锁膨胀为重量级锁，并且阻塞当前线程。  <blockquote>
<p>通过标记字段所指向的轻量级锁锁记录是否在自己栈上判断。</p>
</blockquote>
</li>
</ul>
<h4 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h4><p>当进行解锁操作时，如果当前锁记录(可以将一个线程的所有锁记录想象成一个栈结构，每次加锁压入一条锁记录，解锁弹出一条锁记录，当前锁记录指的便是栈顶的锁记录)的值为0，则代表重复进入同一把锁，直接返回即可。  </p>
<p>否则，JVM会尝试用CAS操作，比较锁对象的标记字段的值是否为当前锁记录的地址。如果是，则替换为锁记录中的值，也就是锁对象原本的标记字段。此时，该线程已经成功释放这把锁。如果不是，则意味着这把锁已经被膨胀为重量级锁。此时，JVM会进入重量级锁的释放过程，唤醒因竞争该锁而被阻塞了的线程。  </p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁针对的情况更加乐观：从始至终只有一个线程请求一把锁。  </p>
<p>在线程进行加锁时，如果该锁对象支持偏向锁，那么JVM会通过CAS操作，将当前线程的地址记录在锁对象的标记字段之中，并且将标记字段的最后三位设置为101。  </p>
<p>在接下来的运行过程中，每当有线程请求这把锁，JVM只需要判断锁对象标记字段中：最后三位是否为101，是否包含当前线程的地址，以及epoch值是否和所对象的类的epoch值相同。如果都满足，那么当前线程持有该偏向锁，可以直接返回。  </p>
<p>当请求加锁的线程和锁对象标记字段保持的线程地址不匹配时(而且epoch值相等，如若不等，那么当前线程可以将该锁重偏向至自己)，JVM需要撤销该偏向锁。这个撤销过程非常麻烦，它要求持有偏向锁的线程到达安全点，再将偏向锁替换成轻量级锁。  </p>
<hr>
<p>如果某一类锁对象的总撤销数超过了一个阈值(JVM参数-XX:BiasedLockingBulkRebiasThreshold，默认为20)，那么JVM会宣布这个类的偏向锁失效。进行批量重偏向。  </p>
<p>具体的做法便是在每个类中维护一个epoch值，可以理解为第几代偏向锁。当设置偏向锁时，JVM需要将该epoch值复制到锁对象的标记字段中。  </p>
<p>在宣布某个类的偏向锁失效时，JVM实则将该类的epoch值加1，表示之前那一代的偏向锁已经失效。而新设置的偏向锁则需要复制新的epoch值。  </p>
<p>为了保证当前持有偏向锁并且已加锁的线程不至于因此丢所，JVM需要遍历所有线程的Java栈，找出该类已加锁的实例，并且将它们标记字段中的epoch值加1。该操作需要所有线程处于安全点状态。  </p>
<p>如果总撤销数超过另一个阈值(JVM参数-XX:BiasedLockingBulkRevokeThreshold，默认值为40)，那么JVM会认为这个类已经不再适合偏向锁。此时，JVM会撤销该类实例的偏向锁，并且在之后的加锁过程中直接为该类实例设置轻量级锁。  </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>JVM中synchronized关键字的实现，按照代价由高到低可分为重量级锁、轻量级锁和偏向锁三种。  </p>
<p>重量级锁会阻塞、唤醒请求加锁的线程。它针对的是多个线程同时竞争同一把锁的情况。JVM采取了自适应自旋，来避免线程在面对非常小的synchronized代码块时，仍会被阻塞、唤醒的情况。  </p>
<p>轻量级锁采用CAS操作，将锁对象的标记字段替换为一个指针，指向当前线程上的一块空间，存储着锁对象原本的标记字段。它针对的是多个线程在不同时间段申请同一把锁的情况。  </p>
<p>偏向锁只会在第一次请求时采用CAS操作，在锁对象的标记字段中记录下当前线程的地址。在之后的运行过程中，持有该偏向锁的线程的加锁操作将直接返回。它针对的是锁仅会被同一线程持有的情况。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>垃圾回收</title>
    <url>/JVM/12%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<p>大部分的Java对象只存活一小段时间，而存活下来的小部分Java对象则会存活很长一段时间。  </p>
<p>JVM的分代回收思想：将堆空间划分为两代，分别叫做新生代和老年代。新生代用来存储新建的对象。当对象存活时间够长时，则将其移动到老年代。  </p>
<p>JVM可以给不同代使用不同的回收算法。  </p>
<ul>
<li><strong>对于新生代</strong>，大部分的Java对象只存活一小段时间，可以频繁地采用耗时较短的垃圾回收算法，让大部分的垃圾都能够在新生代被回收掉。  </li>
<li><strong>对于老年代</strong>，大部分的垃圾已经在新生代中被回收了，而在老年代中的对象有大概率会继续存活。当真正触发针对老年代的回收时，说明堆空间已经耗尽了。JVM需要做一次全盘扫描，耗时也将不计成本。(现代垃圾回收器采用并发收集，避免这种全堆扫描的情况)  </li>
</ul>
<h3 id="JVM的堆划分"><a href="#JVM的堆划分" class="headerlink" title="JVM的堆划分"></a>JVM的堆划分</h3><p>JVM将堆划分为新生代和老年代。其中新生代又被划分为Eden区，以及两个大小相同的Survivor区。  </p>
<p>默认情况下，JVM采取的是一种动态分配的策略(对应JVM参数-XX:+UserPSAdaptiveSurvivorSizePolicy)，根据生成对象的速率，以及Survivor区的使用情况动态调整Eden区和Survivor区的比例。  </p>
<p>也可以通过参数-XX:SurvivorRatio来固定这个比例。其中一个Survivor区会一直为空，因此比例越低，浪费的堆空间将越高。  </p>
<p>通常来说，当调用new指令时，它会在Eden区中划出一块作为存储对象的内存。由于堆空间是线程共享的，因此直接在这里边划空间是需要进行同步的。否则，将有可能出现两个对象共用一段内存的事故。  </p>
<h4 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h4><p>TLAB(Thread Local Allocation Buffer,对应虚拟机参数-XX:+UseTLAB,默认开启)。<strong>每个线程可以一次性向JVM申请一段连续的内存</strong>，比如2048字节，作为线程私有的TLAB。  </p>
<blockquote>
<p>MySQL，批量生成自增id，一次性生成多个。<br>数据结构与算法，令牌桶算法优化，一次性放入多个令牌</p>
</blockquote>
<p>这个操作需要加锁，线程需要维护两个指针(实际上可能更多，最重要的有两个)，一个指向TLAB中空余内存的起始位置，一个则指向TLAB末尾。  </p>
<p>接下来的new指令，便可以直接通过指针加法(bump the pointer)来实现，即把指向空余内存位置的指针加上所请求的字节数。如果加法后空余内存指针的值仍小于或等于指向末尾的指针，则代表分配成功。否则，TLAB已经没有足够的空间来满足本次新建操作。这个时候，便需要当前线程重新申请新的TLAB。  </p>
<h4 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h4><p>当Eden区的空间耗尽了，JVM便会触发一次Minor GC，来收集新生代的垃圾。存活下来的对象，则会被送到Survivor区。  </p>
<p>新生代共有两个Survivor区，分别用from和to代替，其中to指向的Survivor区是空的。  </p>
<p>当发生Minor GC时，Eden区和from指向的Survivor区中的存活对象会被复制到to指向的Survivor区中，然后交换from和to指针，以保证下一次Minor GC时，to指向的Survivor区还是空的。  </p>
<p>JVM会记录Survivor区中的对象一共被来回复制了几次。如果一个对象被复制的次数为15(对应虚拟机参数-XX:+MaxTenuringThreshold)(对象头中标记字段记录年龄，分配的空间只有4位，最大值15)，那么该对象将被晋升(promote)至老年代。另外，如果单个Survivor区已经被占用了50%(对应虚拟机参数-XX:TargetSurvivorRatio)，那么较高复制次数的对象也会被晋升至老年代。  </p>
<p>总之，当发生Minor GC时，应用了标记-复制算法，将Survivor区中的老存活对象晋升到老年代，然后将剩下的存活对象和Eden区的存活对象复制到另外一个Survivor区中。理想情况下，Eden区中的对象基本都死亡了，那么需要复制的数据将非常少，因此采用这种标记-复制算法的效果极好。  </p>
<p>Minor GC的另外一个好处是不用对整个堆进行垃圾回收。但是它有一个问题，老年代的对象可能引用新生代的对象。也就是说，在标记存活对象的时候，需要扫描老年代中的对象，如果该对象拥有对新生代对象的引用，那么这个引用也会被作为GC Roots。  </p>
<blockquote>
<p>又做了一次全堆扫描</p>
</blockquote>
<h3 id="卡表"><a href="#卡表" class="headerlink" title="卡表"></a>卡表</h3><p>HotSpot采用卡表(Card Table)技术解决上述问题。卡表将整个堆划分为一个个大小为512字节的卡，并且维护一个卡表，用来存储每张卡的一个标识位。这个标识位代表对应的卡是否可能存有指向新生代对象的引用。如果可能存在，就认为这张卡是脏的。  </p>
<p>在进行Minor GC的时候，便可以不用扫描整个老年代，而是在卡表中寻找脏卡，并将脏卡中的对象加入到Minor GC的GC Roots里。当完成所有脏卡的扫描之后，JVM便会将所有脏卡的标识位清零。  </p>
<p>由于Minor GC伴随着存活对象的复制，而复制需要更新指向该对象的引用。因此，在更新引用的同时，又会设置引用所在的卡的标识位。这个时候，可以确保脏卡中必定包含指向新生代对象的引用。  </p>
<p>在Minor GC之前，并不能确保脏卡中包含指向新生代对象的引用。其原因和如何设置卡的标识位有关。  </p>
<h4 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h4><p>如果要保证每个可能有指向新生代对象引用的卡都被标记为脏卡，那么JVM需要截获每个引用型实例变量的写操作，并作出对应的写标识位操作。  </p>
<p>这个操作在解释执行器中比较容易实现。但是在即时编译器生成的机器码中，则需要插入额外的逻辑。写屏障(write barrier；不同于volatile字段的写屏障)  </p>
<p>写屏障需要尽可能的保持简洁。并不希望在每条引用型实例变量的写指令后跟着一大串注入的指令。写屏障并不会判断更新后的引用是否指向新生代中的对象，而是宁可错杀，不可放过，一律当成可能指向新生代对象的引用。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CARD_TABLE [<span class="keyword">this</span> address &gt;&gt; <span class="number">9</span>] = DIRIY;<span class="comment">//写屏障伪代码</span></span><br></pre></td></tr></table></figure>

<p>右移9位相当于除以512，JVM便是通过这种方式来从地址映射到卡表中的索引的。最终这段代码会被编译成一条移位指令和一条存储指令。  </p>
<h4 id="虚共享"><a href="#虚共享" class="headerlink" title="虚共享"></a>虚共享</h4><p>写屏障不可避免的带来一些开销，但是它能够加大Minor GC的吞吐率(应用运行时间/(应用运行时间+垃圾回收时间))。总的来说是值得的。但在高并发环境下，写屏障又带来了虚共享问题。  </p>
<p>对象内存布局中虚共享问题，几个volatile字段出现在同一缓存行里造成的虚共享。这里的虚共享是指卡表中不同卡的标识位之间的虚共享问题。  </p>
<p>在HotSpot中，卡表是通过byte数组来实现的。对于一个64字节的缓存行来说，如果用它来加载部分卡表，那么它将对应64张卡(&gt;&gt;9后一个字节可以表示512字节)，也就是32KB的内存。  </p>
<p>如果同时有两个Java线程，在这32KB内存中进行引用更新操作，那么也将造成存储卡表的同一部分的缓存行的写回、无效化或者同步操作，因而间接影响程序性能。  </p>
<p>为此，HotSpot引入了一个新的参数-XX:+UseCondCardMark，来尽量减少写卡表的操作。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(CARD_TABLE [<span class="keyword">this</span> address &gt;&gt; <span class="number">9</span>] != DIRIY) </span><br><span class="line">    CARD_TABLE [<span class="keyword">this</span> address &gt;&gt; <span class="number">9</span>] = DIRIY;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>JVM将堆分为新生代和老年代，并且对不同代采用不同的垃圾回收算法。其中，新生代分为Eden区和两个大小一致的Survivor区，并且其中一个Survivor 区是空的。  </p>
<p>在只针对新生代的Mintor GC中，Eden区和非空Survivor区的存活对象会被复制到空的Survivor区中，当Survivor区中的存活对象复制次数超过一定数值时，它将被晋升至老年代。  </p>
<p>因为Mintor GC只针对新生代进行垃圾回收，所以在枚举GC Roots的时候，它需要考虑从老年代到新生代的引用。为了避免扫描整个老年代，JVM引入了名为卡表的技术，大致地标出可能存在老年代到新生代引用的内存区域。  </p>
<h3 id="JVM中的垃圾回收器"><a href="#JVM中的垃圾回收器" class="headerlink" title="JVM中的垃圾回收器"></a>JVM中的垃圾回收器</h3><p>针对新生代的垃圾回收器：Serial、Parallel New、Parallel Scavenge。这三个采用的都是标记-复制算法。其中Serial是一个单线程的，Parallel New可以看成Serial的多线程版本。Parallel Scavenge和Parallel New类似，但更加注重吞吐率，Parallel Scavenge不能与CMS一起使用。  </p>
<p>针对老年代的垃圾回收器：Serial Old、Parallel Old、CMS。Serial Old和Parallel Old都是标记-压缩算法。前者是单线程的，后者可以看成前者的多线程版本。<br>CMS采用的是标记-清除算法，并且是并发的。除了少数几个操作需要Stop-the-world之外，它可以在应用程序运行过程中进行垃圾回收。在并发收集失败的情况下，JVM会使用其他两个压缩型垃圾回收器进行一次垃圾回收。有G1的出现，CMS在Java 9中已经被废弃。  </p>
<p>G1(Garbage First)是一个横跨新生代和老年代的垃圾回收器。实际上它已经打乱了堆结构，直接将堆分成极其多个区域。每个区域都可以充当Eden区、Survivor区或者老年代中的一个。它采用的是标记-压缩算法，而且和CMS一样都能够在应用程序运行过程中并发的进行垃圾回收。<br>G1能够针对每个细分的区域来进行垃圾回收。在选择进行垃圾回收的区域时，它会优先回收死亡对象较多的区域。名字的由来。  </p>
<p>Java11引入了ZGC。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>即时编译</title>
    <url>/JVM/17%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h3 id="profiling"><a href="#profiling" class="headerlink" title="profiling"></a>profiling</h3><p>分层编译中的1层、3层、4层都会进行profiling，收集能够反映程序执行状态的数据。其中最为基础的便是方法的调用次数以及循环回边的执行次数，它们被用于触发即时编译。  </p>
<p>1层和4层还会收集用于5层C2编译的数据，如分支跳转字节码的分支profile(branch profile)，包括跳转次数和不跳转次数，以及非私有实例方法调用指令、强制类型转换checkcast指令、类型测试instanceof指令、引用类型的数组存储aastore指令的类型profile(receiver type profile)。  </p>
<p>分支profile和类型profile的收集将给应用程序带来不少的性能开销。正是因为这部分额外的profiling，是的4层C1代码的性能比3层C1代码的性能低30%。  </p>
<p>通常情况下，不会在解释执行过程中收集分支profile以及类型profile。只有在方法触发C1编译后，JVM认为该方法有可能被C2编译，方才在该方法的C1代码中收集这些profile。  </p>
<p>只有在比较极端的情况下，如等待C1编译的方法数目太多时，JVM才会开始在解释执行过程中收集这些profile。  </p>
<p>C2可以根据收集得到的数据进行猜测，假设接下来的执行同样会按照所收集的profile进行，从而作出比较激进的优化。  </p>
<h3 id="基于分支profile的优化"><a href="#基于分支profile的优化" class="headerlink" title="基于分支profile的优化"></a>基于分支profile的优化</h3><p>根据条件跳转指令的分支profile，即时编译器可以将从未执行过的分支剪掉，以避免编译这些很有可能不会用到的代码，从而节省编译时间以及部署代码所要消耗的内存空间。此外，“剪枝”将精简程序的数据流，从而触发更多的优化。  </p>
<p>在现实中，分支profile出现仅跳转或者仅不跳转的情况并不多见。即时编译器对分支profile的利用也不仅限于“剪枝”。它还会根据分支profile，计算每一条程序执行路径的概率，以便某些编译器优化优先处理概率较高的路径。  </p>
<h3 id="基于类型profile的优化"><a href="#基于类型profile的优化" class="headerlink" title="基于类型profile的优化"></a>基于类型profile的优化</h3><p>关于instanceof以及方法调用的类型profile。  </p>
<p>如果instanceof的目标类型是final类型，那么JVM仅需要比较测试对象的动态类型是否为该final类型。对象头存有该对象的动态类型。获取对象的动态类型仅为单一的内存读指令。  </p>
<p>如果目标类型不是final类型，那么JVM需要从测试对象的动态类型开始，一次测试该类、该类的父类、祖先类，该类所直接实现或者间接实现的接口是否与目标类型一致。  </p>
<p>和基于分支profile的优化一样，基于类型profile的优化同样也是作出假设，从而精简控制流以及数据流。这两者的核心都是假设。  </p>
<p>对于分支profile，即时编译器假设的是仅执行某一分支；对于类型profile，即时编译器假设的是对象的动态类型仅为类型profile中的那几个。  </p>
<h3 id="去优化"><a href="#去优化" class="headerlink" title="去优化"></a>去优化</h3><h4 id="假设失败就去优化"><a href="#假设失败就去优化" class="headerlink" title="假设失败就去优化"></a>假设失败就去优化</h4><p>当假设失败的情况下，JVM给出的解决方案是去优化，即从执行即时编译生成的机器码切换回解释执行。  </p>
<p>在生成的机器码中，即时编译器将在假设失败的位置上插入一个陷阱(trap)。该陷阱实际上是一条call指令，调用至JVM里专门负责去优化的方法。与普通的call指令不一样的是，去优化方法将更改栈上的返回地址，并不再返回即时编译器生成的机器码中。  </p>
<p>去优化的过程相当复杂。由于即时编译器采用了许多优化方式，其生成的代码和原本的字节码的差异非常之大。在去优化的过程中，需要将当前机器码的执行状态转换至某一字节码之前的执行状态，并从该字节码开始执行。这便要求即时编译器在编译过程中记录好这两种执行状态的映射。  </p>
<p>例：经过逃逸分析之后，机器码可能并没有实际分配对象，而是在各个寄存器中存储该对象的各个字段(标量替换)。在去优化过程中，JVM需要还原出这个对象，以便解释执行时能够使用该对象。  </p>
<blockquote>
<p>对于标量替换的新建对象，机器码会在去优化时重建对象。  </p>
</blockquote>
<p>当根据映射关系创建好对应的解释执行栈帧后，JVM便会采用OSR技术，动态替换栈上的内容，并在目标字节码处开始解释执行。  </p>
<h4 id="去优化是否保留机器码"><a href="#去优化是否保留机器码" class="headerlink" title="去优化是否保留机器码"></a>去优化是否保留机器码</h4><p>在调用JVM的去优化方法时，即时编译器生成的机器码可以根据产生去优化的原因来决定是否保留这一份机器码，以及何时重新编译对应的Java方法。  </p>
<p>如果去优化的原因与优化无关，即使重新编译也不会改变生成的机器码，那么生成的机器码可以在调用去优化方法时传入Action_None，表示保留这一份机器码，在下一次调用该方法时重新进入这一份机器码。  </p>
<p>如果去优化的原因与静态分析的结果有关，例如类层次分析，那么生成的机器码可以在调用去优化方法时传入Action_Recompile，表示不保留这一份机器码，但是可以不经过重新profile，直接重新编译。  </p>
<p>如果去优化的原因与基于profile的激进优化有关，那么生成的机器码需要在调用去优化方法时传入Action_Reinterpret，表示不保留这一份机器码，而且需要重新收集程序的profile。  </p>
<p>这是因为基于profile的优化失败的时候，往往代表着程序的执行状态发生改变，因此需要更正已收集的profile，以便更好的反映新的程序执行状态。  </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通常情况下，解释执行过程中仅收集方法的调用次数以及循环回边的执行次数。  </p>
<p>当方法被4层C1所编译时，生成的C1代码将收集条件跳转指令的分支profile，以及类型相关指令的类型profile。在部分极端情况下，JVM也会在解释执行过程中收集这些profile。  </p>
<p>基于分支profile的优化以及基于类型profile的优化都将对程序今后的执行作出假设。这些假设将精简所要编译的代码的控制流以及数据流。在假设失败的情况下，JVM将采取去优化，退回至解释执行并重新收集相关的profile。  </p>
<p>使用参数-XX:CompileCommand=’print,*ClassName.methodName’可以打印程序运行过程中即时编译器生成的机器码。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>Java字节码</title>
    <url>/JVM/19Java%E5%AD%97%E8%8A%82%E7%A0%81/</url>
    <content><![CDATA[<h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>Java字节码是JVM所使用的指令集。它与JVM<strong>基于栈的计算模型</strong>是密不可分的。  </p>
<p>在<strong>解释执行</strong>过程中，每当为Java方法分配栈帧时，JVM往往需要开辟一块额外的空间作为操作数栈，来存放计算的操作数以及返回结果。  </p>
<blockquote>
<p>在JVM中，只有解释器完整的模拟出该计算模型。即时编译器在解析字节码时会使用一个虚拟的栈计算模型，但是在接下来的编译优化，以及生成的机器码就不用了。  </p>
</blockquote>
<p>执行每一条指令之前，JVM要求该指令的操作数已被压入操作数栈中。在执行指令时，JVM会将该指令所需的操作数弹出，并且将指令的结果重新压入栈中。  </p>
<p>以加法指令iadd为例。iadd指令只消耗栈顶的两个元素，因此，对于离栈顶距离为2的元素，iadd指令并不关心它是否存在，更加不会对其进行修改。  </p>
<p>Java字节码中有好几条指令时直接作用在操作数栈上的。最为常见的便是dup：复制栈顶元素；以及pop：舍弃栈顶元素。  </p>
<p>dup与pop指令只能处理非long或者非double类型的值，long类型或者double类型的值，需要占据两个栈单元。当遇到这些值时，需要同时复制栈顶两个单元的dup2指令，以及弹出栈顶两个单元的pop2指令。  </p>
<h4 id="dup指令"><a href="#dup指令" class="headerlink" title="dup指令"></a>dup指令</h4><p>dup指令常用语复制new指令所生成的未经初始化的引用。当执行new指令时，JVM将指向一块已分配的、未初始化的内存的引用压入操作数栈中。  </p>
<p>接着，需要以这个引用为调用者，调用其构造器(invokespecial指令)，该指令将消耗操作数栈上的元素，作为它的调用者以及参数(Object的构造器不需要参数)。  </p>
<p>需要利用dup指令复制一份new指令的结果，并用来调用构造器。当调用返回之后，操作数栈上仍有原本由new指令生成的引用，可用于接下来的操作。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        dup指令
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Object o = <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对应的字节码如下：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="number">0</span>  <span class="keyword">new</span> java.lang.Object [<span class="number">3</span>]</span><br><span class="line">  <span class="number">3</span>  dup</span><br><span class="line">  <span class="number">4</span>  invokespecial java.lang.Object() [<span class="number">8</span>]</span><br><span class="line">  <span class="number">7</span>  astore_1 [o]</span><br><span class="line">  <span class="number">8</span>  <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
    </div>
</div>  

<h4 id="pop指令"><a href="#pop指令" class="headerlink" title="pop指令"></a>pop指令</h4><p>pop指令常用于舍弃调用指令的返回结果。例如调用静态方法，但不用其返回值。  </p>
<p>对应的invokestatic指令仍旧会将返回值压入调用方法的操作数栈中，因此JVM需要额外执行pop指令，将返回值舍弃。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        pop指令
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo方法对应的字节码如下：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="number">0</span>  invokestatic FooTest.bar() : <span class="keyword">boolean</span> [<span class="number">24</span>]</span><br><span class="line">  <span class="number">3</span>  pop</span><br><span class="line">  <span class="number">4</span>  <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
    </div>
</div>  

<h4 id="swap指令"><a href="#swap指令" class="headerlink" title="swap指令"></a>swap指令</h4><p>直接作用于操作数栈顶的指令，它将交换栈顶两个元素的值。  </p>
<h4 id="加载常量指令"><a href="#加载常量指令" class="headerlink" title="加载常量指令"></a>加载常量指令</h4><p>直接将常量加载到操作数栈上。以int类型为例，JVM既可以通过iconst指令加载-1至5之间的int值，也可以通过bipush、sipush加载一个字节、两个字节所能代表的int值。  </p>
<p>通过ldc加载常量池中的常量值。如ldc#18将加载常量池中的第18项。  </p>
<p>这些常量包括int类型、long类型、float类型、double类型、String类型以及Class类型的常量。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        常数加载指令表
    </div>
    <div class='spoiler-content'>
        <table>
<thead>
<tr>
<th>类型</th>
<th>常数指令</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>int(boolean,byte,char,short)</td>
<td>iconst</td>
<td>[-1,5]</td>
</tr>
<tr>
<td></td>
<td>bipush</td>
<td>[-128,127]</td>
</tr>
<tr>
<td></td>
<td>sipush</td>
<td>[-32768,32767]</td>
</tr>
<tr>
<td></td>
<td>ldc</td>
<td>any int value</td>
</tr>
<tr>
<td>long</td>
<td>lconst</td>
<td>0,1</td>
</tr>
<tr>
<td></td>
<td>ldc</td>
<td>any long value</td>
</tr>
<tr>
<td>float</td>
<td>fconst</td>
<td>0,1,2</td>
</tr>
<tr>
<td></td>
<td>ldc</td>
<td>any float value</td>
</tr>
<tr>
<td>double</td>
<td>dconst</td>
<td>0,1</td>
</tr>
<tr>
<td></td>
<td>ldc</td>
<td>any double value</td>
</tr>
<tr>
<td>reference</td>
<td>aconst</td>
<td>null</td>
</tr>
<tr>
<td></td>
<td>ldc</td>
<td>String literal,Class literal</td>
</tr>
</tbody></table>

    </div>
</div>  

<p><strong>正常情况下，操作数栈的压入弹出都是一条条指令完成的。唯一的例外情况是在抛异常时，JVM会清除操作数栈上的所有内容，然后将异常实例压入操作数栈上。</strong>  </p>
<h3 id="局部变量区"><a href="#局部变量区" class="headerlink" title="局部变量区"></a>局部变量区</h3><p>Java方法栈帧的另外一个重要组成部分则是局部变量区，字节码程序可以将计算的结果缓存在局部变量区之中。  </p>
<p>JVM将局部变量区当成一个数组，依次存放this指针(仅非静态方法)，所传入的参数，以及字节码中的局部变量。  </p>
<blockquote>
<p>局部变量必须初始化。  </p>
</blockquote>
<p>和操作数栈一样，long类型以及double类型的值将占据两个单元，其余类型仅占据一个单元。  </p>
<p>存储在局部变量区的值，通常需要加载至操作数栈中，方能进行计算，得到计算结果后再存储至局部变量数组中。这些加载、存储指令时区分类型的。如，int类型的加载指令为iload，存储指令为istore。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        局部变量区访问指令表
    </div>
    <div class='spoiler-content'>
        <table>
<thead>
<tr>
<th>类型</th>
<th>加载指令</th>
<th>存储指令</th>
</tr>
</thead>
<tbody><tr>
<td>int(boolean,byte,char,short)</td>
<td>iload</td>
<td>istore</td>
</tr>
<tr>
<td>long</td>
<td>lload</td>
<td>lstore</td>
</tr>
<tr>
<td>float</td>
<td>fload</td>
<td>fstore</td>
</tr>
<tr>
<td>double</td>
<td>dload</td>
<td>dstore</td>
</tr>
<tr>
<td>reference</td>
<td>aload</td>
<td>astore</td>
</tr>
</tbody></table>

    </div>
</div>  

<p>局部变量数组的加载、存储指令都需要指明所加载单元的下标。例，aload 0指的是加载第0个单元所存储的引用(this指针)。  </p>
<p>Java字节码中唯一能够直接作用于局部变量区的指令时iinc M N(M为非负整数，N为整数)。该指令指的是将局部变量数组的第M个单元中的int值增加N，常用于for循环中的自增量的更新。  </p>
<h3 id="综合示例"><a href="#综合示例" class="headerlink" title="综合示例"></a>综合示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//bar方法，接收一个int类型的参数，进行一系列计算之后再返回</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bar</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ((i + <span class="number">1</span>) - <span class="number">2</span>) * <span class="number">3</span> / <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对应的字节码如下：</span></span><br><span class="line">Code:</span><br><span class="line">  stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">     <span class="number">0</span>: iload_0</span><br><span class="line">     <span class="number">1</span>: iconst_1</span><br><span class="line">     <span class="number">2</span>: iadd</span><br><span class="line">     <span class="number">3</span>: iconst_2</span><br><span class="line">     <span class="number">4</span>: isub</span><br><span class="line">     <span class="number">5</span>: iconst_3</span><br><span class="line">     <span class="number">6</span>: imul</span><br><span class="line">     <span class="number">7</span>: iconst_4</span><br><span class="line">     <span class="number">8</span>: idiv</span><br><span class="line">     <span class="number">9</span>: ireturn</span><br></pre></td></tr></table></figure>

<p>对应的字节码中的stack=2，locals=1代表该方法需要的操作数栈空间为2，局部变量数组空间为1。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        综合示例
    </div>
    <div class='spoiler-content'>
        <p>当调用bar(5)时，每条指令执行前后局部变量数组空间以及操作数栈的分布如下：  </p>
<img src='/img/JVM局部变量与操作数栈分布示例.png' width='200' height='500'>

    </div>
</div>  

<h3 id="Java字节码简介"><a href="#Java字节码简介" class="headerlink" title="Java字节码简介"></a>Java字节码简介</h3><p>其他类别的指令。  </p>
<p><strong>Java相关指令</strong>，包括各类具备高层语义的字节码，new(后跟目标类，生成该类的未初始化的对象)，instanceof(后跟目标类，判断栈顶元素是否为目标类/接口的实例。是则压入1，否则压入0)，checkcast(后跟目标类，判断栈顶元素是否为目标类/接口的实例。如果不是便抛出异常)，athrow(将栈顶异常抛出)，monitorenter(为栈顶对象加锁)和monitorexit(为栈顶对象解锁)。<br>该类型的指令还包括<em>字段访问指令</em>：静态字段访问指令getstatic、putstatic，和实例字段访问指令getfield、putfield。这四条指令均附带用以定位目标字段的信息，但所消耗的操作数栈元素皆不同。  </p>
<p><strong>方法调用指令</strong>，包括invokestatic，invokespecial，invokevirtual，invokeinterface以及invokedynamic。除invokedynamic外，其他的方法调用指令所消耗的操作数栈元素是根据调用类型以及目标方法描述符来确定的。在方法调用之前，程序需要依次压入调用者(invokestatic不需要)，以及各个参数。  </p>
<p><strong>数组相关指令</strong>，包括新建基本类型数组的newarray，新建引用类型数组的anewarray，生成多维数组的multianewarray，以及求数组长度的arraylength。另外，还包括数组的加载指令以及存储指令。这些指令时区分类型的，如int数组的加载指令为iaload，存储指令为iastore。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        数组加载指令以及存储指令
    </div>
    <div class='spoiler-content'>
        <table>
<thead>
<tr>
<th>数组类型</th>
<th>加载指令</th>
<th>存储指令</th>
</tr>
</thead>
<tbody><tr>
<td>byte(boolean)</td>
<td>baload</td>
<td>bastore</td>
</tr>
<tr>
<td>char</td>
<td>caload</td>
<td>castore</td>
</tr>
<tr>
<td>short</td>
<td>saload</td>
<td>sastore</td>
</tr>
<tr>
<td>int</td>
<td>iaload</td>
<td>iastore</td>
</tr>
<tr>
<td>long</td>
<td>laload</td>
<td>lastore</td>
</tr>
<tr>
<td>float</td>
<td>faload</td>
<td>fastore</td>
</tr>
<tr>
<td>double</td>
<td>daload</td>
<td>dastore</td>
</tr>
<tr>
<td>reference</td>
<td>aaload</td>
<td>aastore</td>
</tr>
</tbody></table>

    </div>
</div>  

<p><strong>控制流指令</strong>，包括无条件跳转指令goto，条件跳转指令tableswitch和Lookupswitch(前者针对密集的cases，后者针对稀疏的cases)，返回指令，以及被废弃的jsr、ret指令。其中返回指令时区分类型的。如返回int值的指令为ireturn(正常执行路径return，异常执行路径athrow)。<br>除返回指令外，其他的控制流指令均附带一个或者多个字节码偏移量，代表需要跳转到的位置。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        返回指令表
    </div>
    <div class='spoiler-content'>
        <table>
<thead>
<tr>
<th>返回类型</th>
<th>返回指令</th>
</tr>
</thead>
<tbody><tr>
<td>void</td>
<td>return</td>
</tr>
<tr>
<td>int(boolean,byte,char,short)</td>
<td>ireturn</td>
</tr>
<tr>
<td>long</td>
<td>lreturn</td>
</tr>
<tr>
<td>float</td>
<td>freturn</td>
</tr>
<tr>
<td>double</td>
<td>dreturn</td>
</tr>
<tr>
<td>reference</td>
<td>areturn</td>
</tr>
</tbody></table>

    </div>
</div>  

<p><strong>其他</strong>，剩余的Java字节码几乎都和计算相关。  </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Java方法的栈帧分为局部变量区和操作数栈。通常来说，程序需要将变量从局部变量区加载至操作数栈中，进行一番运算之后再存储回局部变量区中。  </p>
<p>Java字节码可以划分为很多种类型，如加载常量指令，操作数栈专用指令，局部变量区访问指令，Java相关指令，方法调用指令，数组相关指令，控制流指令，以及计算相关指令。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>即时编译器的中间表达形式</title>
    <url>/JVM/18%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E8%A1%A8%E8%BE%BE%E5%BD%A2%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="中间表达形式-IR"><a href="#中间表达形式-IR" class="headerlink" title="中间表达形式(IR)"></a>中间表达形式(IR)</h3><p>通常将编译器分为前端和后端。其中，前端会对所输入的程序进行词法分析、语法分析、语义分析，然后生成中间表达形式，也就是IR(Intermediate Representation)。后端会对IR进行优化，然后生成目标代码。  </p>
<p>如果不考虑解释执行的话，从Java源代码到最终的机器码实际上经过了两轮编译：Java编译器将Java源代码编译成Java字节码，而即时编译器则将Java字节码编译成机器码。  </p>
<p>对于即时编译器来说，所输入的Java字节码剥离了很多高级的Java语法，而且其采用的基于栈的计算模型非常容易建模。因此，即时编译器并不需要重新进行词法分析、语法分析以及语义分析，而是直接将Java字节码作为一种IR。  </p>
<h4 id="静态单赋值-SSA-IR"><a href="#静态单赋值-SSA-IR" class="headerlink" title="静态单赋值(SSA) IR"></a>静态单赋值(SSA) IR</h4><p>不过，Java字节码本身并不适合直接作为可供优化的IR。这是因为现代编译器一般采用静态单赋值(Static Single assignment，SSA)IR。这种IR的特点是每个变量只能被赋值一次，而且只有当变量被赋值之后才能使用。  </p>
<p>在源代码中，对变量的赋值可能是冗余的，传统编译器需要借助数据流分析(reaching definition)，从后至前依次确认哪些变量的值被覆盖kill掉。不过如果借助了SSA IR，编译器则可以通过查找赋值了但是没有使用的变量，来识别冗余赋值。  </p>
<p>除此之外，SSA IR对其他优化方式也有很大的帮助，例如常量折叠(constant folding)、常量传播(constant propagation)、强度削减(strength reduction)、死代码删除(dead code elimination)等。  </p>
<p>SSR IR会带来一个问题，那便是不同执行路径可能会对同一变量设置不同的值，根据不同的执行路径，所读取到的值也很有可能不同。  </p>
<p>为了解决这个问题，需要引入一个Phi函数的概念，能够根据不同的执行路径选择不同的值。  </p>
<p>即时编译器会将Java字节码转换成SSA IR。更确切的说，是一张包含控制流和数据流的IR图，每个字节码对应其中的若干个结点(有些字节码并没有对应的IR节点)。然后，即时编译器在IR图上进行优化。  </p>
<p>可以将每一种优化看成一个独立的图算法，它接收一个IR图，并输出经过转换后的IR图，整个编译器优化过程便是一个个优化串联起来的。  </p>
<h3 id="Sea-of-Nodes"><a href="#Sea-of-Nodes" class="headerlink" title="Sea-of-Nodes"></a>Sea-of-Nodes</h3><p>HotSpot里的C2采用的是一种名为Sea-of-Nodes的SSA IR。它的最大特点，便是去除了变量的改变，直接采用变量所指向的值，来进行运算。Phi函数本身也是一个值，被其他IR节点所依赖。常量传播在Sea-of—Nodes中变成了一个no-op。  </p>
<p>Graal的IR同样也是Sea-of-Nodes类型的，并且可以认为是C2 IR的精简版本。  </p>
<p>IR图中，包含控制流、数据流等，被控制流所连接的是固定节点，其他的皆属于浮动节点。若干顺序执行的结点将被包含在同一个基本块之中。(图中没有变量名，取而代之的是一个个的值。)  </p>
<p>基本块是仅有一个入口和一个出口的指令序列(IR节点序列)。一个基本块的出口可以和若干个基本块的入口相连，反之亦然。  </p>
<h4 id="节点调度"><a href="#节点调度" class="headerlink" title="节点调度"></a>节点调度</h4><p>浮动节点的位置并不固定。在编译过程中，编译器需要多次计算浮动节点具体的排布位置。这个过程称之为节点调度(node scheduling)。节点调度是根据节点之间的依赖关系来进行的。  </p>
<p>C2没有固定节点这一概念，所有的IR节点都是浮动节点。它将根据各个基本块头尾之间的<strong>控制依赖</strong>，以及<strong>数据依赖</strong>和<strong>内存依赖</strong>，来进行节点调度。  </p>
<p>内存依赖：假设一段程序往内存中存储了一个值，而后又读取同一内存，那么显然程序希望读取到的是所存储的值。即时编译器不能任意调度对同一内存地址的读写，因为他们之间存在依赖关系。  </p>
<p>C2的做法便是将这种时序上的先后记录为内存依赖，并让节点调度算法在进行调度时考虑这些内存依赖关系。Graal则将内存读写转换成固定节点。由于固定节点存在先后关系，因此无需额外记录内存依赖。  </p>
<h3 id="Global-Value-Numbering"><a href="#Global-Value-Numbering" class="headerlink" title="Global Value Numbering"></a>Global Value Numbering</h3><p>GVN是一种发现并消除等价计算的优化技术。例如，如果一段程序中出现了多次操作数相同的乘法，那么即时编译器可以将这些乘法并为一个，从而降低输出机器码的大小。如果这些乘法出现在同一执行路径上，那么GVN还将省下冗余的乘法操作。  </p>
<p>在Sea-of-Nodes中，由于只存在值的概念，因此GVN算法将非常简单：如果一个浮动节点本身不存在内存副作用(由于GVN可能影响节点调度，如果有内存副作用的话，那么将引发一些源代码中不可能出现的情况)，那么即时编译器只需要判断该浮动节点是否与已存在的浮动节点的类型相同，所输入的IR节点是否一致，便可以将这两个浮动节点归并成一个。  </p>
<p>可以将GVN理解为在IR图上的公共子表达式消除(Common Subexpression Elimination, CSE)。这两者的区别在于，GVN直接比较直的相同与否，而SCE则是借助词法分析器来判断两个表达式相同与否。因此，在不少情况下，CSE还需要借助常量传播来达到消除的效果。  </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>即时编译器将所输入的Java字节码转换成SSA IR，以便更好的进行优化。  </p>
<p>具体来说C2和Graal采用的是一种名为Sea-of-Nodes的IR，其特点用IR节点来代表程序中的值，并且将原程序中基于变量的计算转换为基于值的计算。  </p>
<p>基于IR的优化GVN。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>方法内联</title>
    <url>/JVM/21%E6%96%B9%E6%B3%95%E5%86%85%E8%81%94/</url>
    <content><![CDATA[<p>静态方法调用，即时编译器可以轻易的确定唯一的目标方法。  </p>
<p>对于需要动态绑定的虚方法调用，即时编译器则需要先对虚方法调用进行去虚化(devirtualize)，即转换为一个或多个直接调用，然后才能进行方法内联。  </p>
<p>即时编译器的去虚化方式可分为完全去虚化以及条件去虚化(guarded devirtualization)。  </p>
<p><strong>完全去虚化</strong>是通过类型推导或者类层次分析(class hierarchy analysis)，识别虚方法调用的唯一目标方法，从而将其转换为直接调用的一种优化手段。它的关键在于证明虚方法调用的目标方法是唯一的。  </p>
<p><strong>条件去虚化</strong>则是将虚方法调用转换为若干个类型测试以及直接调用的一种优化手段。它的关键在于找出需要进行比较的类型。  </p>
<h3 id="基于类型推导的完全去虚化"><a href="#基于类型推导的完全去虚化" class="headerlink" title="基于类型推导的完全去虚化"></a>基于类型推导的完全去虚化</h3><p>基于类型推导的完全去虚化将通过数据流分析推导出调用者的动态类型，从而确定具体的目标方法。  </p>
<p>在Sea-of-Nodes的IR系统中，变量不复存在，取而代之的是具体值，这些具体值的类型往往要比变量的声明类型精确。<br>通过将字节码转换为Sea-of-Nodes IR之后，即时编译器便可以直接去虚化，并将唯一的目标方法进一步内联进来。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        完全去虚化-类型推导示例
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象类BinaryOp，抽象方法apply;  </span></span><br><span class="line"><span class="comment">//BinaryOp的两个子类Add&amp;Sub.  </span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryOp</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">apply</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Add</span> <span class="keyword">extends</span> <span class="title">BinaryOp</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">apply</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">BinaryOp</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">apply</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//foo方法和bar方法均会调用apply方法，  </span></span><br><span class="line"><span class="comment">//调用者的声明类型皆为BinaryOp.  </span></span><br><span class="line"><span class="comment">//Java编译器会将其编译为invokevirtual指令，调用BinaryOp.apply  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  BinaryOp op = <span class="keyword">new</span> Add();</span><br><span class="line">  <span class="keyword">return</span> op.apply(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bar</span><span class="params">(BinaryOp op)</span> </span>&#123;</span><br><span class="line">  op = (Add) op;</span><br><span class="line">  <span class="keyword">return</span> op.apply(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//理论上即时编译器能够推导出调用者的动态类型为Add，但是C2和Graal都没有这么做。  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">notInlined</span><span class="params">(BinaryOp op)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (op <span class="keyword">instanceof</span> Add) &#123;</span><br><span class="line">    <span class="keyword">return</span> op.apply(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p>类型推导属于全局优化，本身比较浪费时间；另一方面，就算不进行基于类型推导的完全去虚化，也有基于类层次分析的去虚化，以及条件去虚化兜底，覆盖大部分的代码情况。  </p>
<p>因此，<strong>C2和Graal决定，如果生成Sea-of-Nodes IR后，调用者的动态类型已能够直接确定，那么就进行这项去虚化。如果需要额外的数据流分析方能确定，那么干脆不做，以节省编译时间，并依赖接下来的去虚化手段进行优化。</strong>  </p>
<h3 id="基于类层次分析的完全去虚化"><a href="#基于类层次分析的完全去虚化" class="headerlink" title="基于类层次分析的完全去虚化"></a>基于类层次分析的完全去虚化</h3><p>基于类层次分析的完全去虚化通过分析JVM中所有已被加载的类，判断某个抽象方法或者接口方法是否仅有一个实现。如果是，那么对这些方法的调用将只能调用至该具体实现中。  </p>
<p>在类型推导的例子中，假设在编译foo、bar或者notInlined方法时，JVM仅加载了Add。那么，BinaryOp.apply方法只有Add.apply这么一个具体实现。因此，当即时编译器碰到对BinaryOp.apply的调用时，便可以直接内联Add.apply的内容。  </p>
<p>即时编译器无法保证在今后的执行过程中，BinaryOp.apply方法还是只有Add.apply这么一个具体实现。JVM有可能在上述编译完成之后加载Sub类，从而引入另一个BinaryOp.apply方法的具体实现Sub.apply。  </p>
<p>JVM的做法是为当前编译结果注册若干个假设(assumption)，假定某抽象类只有一个子类，或者某抽象方法只有一个具体实现，又或者某类没有子类等。之后，每当新的类被加载，JVM便会重新验证这些假设。如果某个假设不再成立，那么JVM便会对其所属的编译结果进行去优化。  </p>
<p>事实上，即便调用者的声明类型为Add，即时编译器仍需为之添加假设，因为JVM不能保证没有重写了apply方法的Add类的子类。  </p>
<p>为了保证这里apply方法的语义，即时编译器需要假设Add类没有子类。  </p>
<blockquote>
<p>通过将Add类标注为final，可以避开这个问题。即时编译器并不要求目标方法使用final修饰符。只要目标方法事实上是final(effective final)，便可以进行相应的去虚化以及内联。不过，如果使用了final修饰符，即时编译器便可以不用生成对应的假设。这将使编译结果更加精简，并减少类加载时所需验证的内容。  </p>
</blockquote>
<p>子类生成的代码无序检测调用者的动态类型是否为Add，便直接执行内联之后的Add.apply方法中的内容。这是因为动态类型检测已被移至假设之中了。  </p>
<p>然而对于接口方法调用，该去虚化手段不能移除动态类型检测。这是因为在执行invokeinterface指令时，JVM必须对调用者的动态类型进行测试，看它是否实现了目标接口方法所在的接口。  </p>
<blockquote>
<p>Java类验证器将皆苦类型直接看成Object类型，所以有可能出现声明类型为接口，实际类型没有继承该接口的情况。  </p>
</blockquote>
<p>既然这一类型测试无法避免，<strong>C2干脆就不对接口方法调用进行基于类层次分析的完全去虚化，而是依赖于接下来的条件去虚化。</strong>  </p>
<h3 id="条件去虚化"><a href="#条件去虚化" class="headerlink" title="条件去虚化"></a>条件去虚化</h3><p>条件去虚化通过向代码中添加若干个类型比较，将虚方法调用转换为若干个直接调用。  </p>
<p>具体的原理非常简单，是将调用者的动态类型，依次与JVM所收集的类型Profile中记录的类型相比较。如果匹配，则直接调用该记录类型所对应的目标方法。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        条件去虚化示例
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">(BinaryOp op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> op.apply(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//假设编译时类型Profile记录了调用者的两个类型Sub和Add,</span></span><br><span class="line"><span class="comment">//那么即时编译器可以据此进行条件去虚化，</span></span><br><span class="line"><span class="comment">//依次比较调用者的动态类型是否为Sub或者Add,并内联相应的方法。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">(BinaryOp op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(op.getClass() == Sub<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>-<span class="number">1</span>;<span class="comment">//inlined Sub.apply</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(op.getClass() == Add<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>+<span class="number">1</span>;<span class="comment">//inlined Add.apply</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//当匹配不到类型Profile中的类型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p>如果遍历完类型Profile中的所有记录，仍旧匹配不到调用者的动态类型，那么即时编译器有两种选择。  </p>
<ul>
<li>第一，如果类型Profile是完整的，也就是说，所有出现过的动态类型都被记录至类型Profile之中，那么即时编译器可以让程序进行去优化，重新收集类型Profile。  </li>
<li>第二，如果类型Profile是不完整的，也就是说，某些出现过的动态类型并没有记录至类型Profile之中，那么重新收集并没有多大作用。此时，即时编译器可以让程序进行原本的虚调用，通过内联缓存进行调用，或者通过方发表进行动态绑定。(仅在Graal中使用)  </li>
</ul>
<p>在C2中，如果类型Profile是不完整的，即时编译器压根不会进行条件去虚化，而是直接使用内联缓存或者方法表。  </p>
<blockquote>
<p>每个字节码的type profile有数量限制，默认情况下只能存两个不同的动态类型。如果收集profile过程中来了三个不同的动态类型，那么JVM不能全部记下来，因此即时编译器看到的type profile是不完整的。  </p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>完全去虚化通过类型推导或者类层次分析，将虚方法调用转换为直接调用。它的关键在于证明虚方法调用的目标方法是唯一的。  </p>
<p>条件去虚化通过向代码中增添类型比较，将虚方法调用转换为一个个的类型测试以及对应该类型的直接调用。它将借助JVM所收集的类型Profile(分层编译时收集的数据)。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>Java内存模型</title>
    <url>/JVM/13Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>即时编译器的重排序、处理器的乱序执行、内存系统的重排序，在多线程环境下，导致共享变量值的不确定性。  </p>
<p>即时编译器(和处理器)需要保证程序能够遵守as-if-serial属性。在单线程情况下，要给程序一个顺序执行的假象。即经过重排序的执行结果要与顺序执行的结果保持一致。如果两个操作之间存在数据依赖，那么及时编译器(和处理器)不能调整他们的顺序，否则将会造成程序语义的改变。  </p>
<h3 id="Java内存模型与happens-before关系"><a href="#Java内存模型与happens-before关系" class="headerlink" title="Java内存模型与happens-before关系"></a>Java内存模型与happens-before关系</h3><p>为了让应用程序能够免于数据竞争(data race)的干扰，Java5引入了明确定义的Java内存模型。其中最为重要的一个概念便是happens-before关系。happens-before关系是用来描述两个操作的内存可见性。如果操作X happens-before 操作Y，那么X的结果对于Y可见。  </p>
<blockquote>
<p>内存模型：1.运行时数据区；2.内存可见性(访问)规则。<br>JMM中的工作内存，实际上映射到的是CPU缓存。工作线程会将用到的内存加载至CPU缓存中；但不会另外再开一片内存来存储这部分用到的堆内存。</p>
</blockquote>
<h4 id="线程内的happens-before关系"><a href="#线程内的happens-before关系" class="headerlink" title="线程内的happens-before关系"></a>线程内的happens-before关系</h4><p>在同一个线程中，字节码的先后顺序(program order)也暗含了happens-before关系：在程序控制流路径中靠前的字节码happens-before靠后的字节码。然而，这并不意味着前者一定在后者之前执行。实际上，如果后者没有观测前者的运行结果，即后者没有数据依赖于前者，那么它们可能会被重排序。  </p>
<h4 id="线程间的happens-before关系"><a href="#线程间的happens-before关系" class="headerlink" title="线程间的happens-before关系"></a>线程间的happens-before关系</h4><ol>
<li>解锁操作happens-before之后(时钟顺序先后)对同一把锁的加锁操作。  </li>
<li>volatile字段的写操作happens-before之后(时钟顺序先后)对同一字段的读操作。  </li>
<li>线程的启动操作(Thread.starts())happens-before该线程的第一个操作。  </li>
<li>线程的最后一个操作happens-before它的终止事件(其他线程通过Thread.isAlive()或Thread.join()判断该线程是否中止)。  </li>
<li>线程对其他线程的中断操作happens-before被中断线程所收到的中断事件(被中断线程的InterruptedException异常，或者第三个线程针对被中断线程的Thread.interrupted或者Thread.isInterrupted调用)。  </li>
<li>构造器中的最后一个操作happens-before析构器的第一个操作。  </li>
</ol>
<p>happens-before关系还具备传递性。如果操作X happens-before 操作Y，而操作Y happens-before 操作Z，那么操作X happens-before 操作Z。  </p>
<p>解决数据竞争问题的关键在于构造一个跨线程的happens-before关系:操作X happens-before 操作Y，使得操作X之前的字节码的结果对操作Y之后的字节码可见。  </p>
<h3 id="Java内存模型的底层实现"><a href="#Java内存模型的底层实现" class="headerlink" title="Java内存模型的底层实现"></a>Java内存模型的底层实现</h3><h4 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h4><p>Java内存模型是通过<strong>内存屏障</strong>(memory barrier)来禁止重排序的。  </p>
<p>对于即时编译器来说，它会针对前面提到的每一个happens-before关系，向正在编译的目标方法中插入相应的读读、读写、写读、写写内存屏障(一个特殊的编译器中间表达形式节点)。  </p>
<blockquote>
<p>在解释执行时，字节码之间也有内存屏障</p>
</blockquote>
<p>这些内存屏障会限制即时编译器的重排序操作。以volatile字段访问为例，所插入的内存屏障将不允许volatile字段写操作之前的内存访问被重排序至其之后；也不允许volatile字段读操作之后的内存访问被重排序至其之前。  </p>
<p>即时编译器将根据具体的底层体系架构，将这些内存屏障替换成具体的CPU指令。以X86_64架构来说，读读、读写、写写内存屏障是空操作(no-op)，只有写读内存屏障会被替换成具体指令。  </p>
<blockquote>
<p>X86_64架构的处理器并不能将读操作重排序至写操作之后，重排序必然是即时编译器造成的。  </p>
</blockquote>
<h4 id="写缓存"><a href="#写缓存" class="headerlink" title="写缓存"></a>写缓存</h4><p>对于volatile字段，即时编译器将在volatile字段的读写操作前后各插入一些内存屏障。然而在X86_64架构上，只要volatile字段写操作之后的写读内存屏障需要用具体指令来替代。(HotSpot所选取的具体指令是lock add DWORD PTR[rep],0x0，而非mfence)。该指令的具体效果可以简单理解为<strong>强制刷新处理器的写缓存</strong>。写缓存是处理器用来加速内存存储效率的一项技术。  </p>
<p>在碰到内存写操作时，处理器并不会等待该指令结束，而是直接开始下一指令，并且依赖于写缓存将更改的数据同步至主内存(main memory)之中。强制刷新写缓存，将使得当前线程写入volatile字段的值(以及写缓存中已有的其他内存修改)，同步至主内存之中。  </p>
<p>由于内存写操作同时会无效化其他处理器所持有的、指向同一内存地址的缓存行，因此可以认为其他处理器能够立即见到该volatile字段的最新值。  </p>
<h3 id="锁、volatile字段、final字段及安全发布"><a href="#锁、volatile字段、final字段及安全发布" class="headerlink" title="锁、volatile字段、final字段及安全发布"></a>锁、volatile字段、final字段及安全发布</h3><h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p>锁操作同样具备happens-before关系。<br>具体来说，解锁操作happens-before之后对同一把锁的加锁操作。<br>实际上，在解锁时，JVM同样需要强制刷新缓存，使得当前线程所修改的内存对其他线程可见。  </p>
<p>锁操作的happens-before规则的关键字是同一把锁。意味着，如果编译器能够(通过逃逸分析)证明某把锁仅被同一线程持有，那么它可以移除相应的加锁解锁操作。因此也就不再强制刷新缓存。如，即时编译后的synchronized(new Object()) {}，可能等同于空操作，而不会强制刷新缓存。  </p>
<h4 id="volatile字段"><a href="#volatile字段" class="headerlink" title="volatile字段"></a>volatile字段</h4><p>volatile字段可以看成一种轻量级的、不保证原子性的同步，其性能旺旺优于(至少不亚于)锁操作。但频繁的访问volatile字段也会因为不断的强制刷新缓存而严重影响程序的性能。  </p>
<p>在X86_64平台上，只有volatile字段的写操作会强制刷新缓存。因此理想情况下对volatile字段的使用应当多读少写，并且应当只有一个线程进行写操作。  </p>
<p>volatile字段的另一个特性是即时编译器无法将其分配到寄存器里(缓存)。volatile字段的每次访问均需要直接从内存中读写。  </p>
<h4 id="final字段"><a href="#final字段" class="headerlink" title="final字段"></a>final字段</h4><p>final实例字段则涉及新建对象的发布问题。当一个对象包含final实例字段时，希望其他线程只能看到已经初始化的final实例字段。  </p>
<p>即时编译器会在final字段的写操作后插入一个写写屏障，以防某些优化将新建对象的发布(即将实例对象写入一个共享引用中)重排序至final字段的写操作之前。在X86_64平台上，写写屏障是空操作。  </p>
<p>新建对象的安全发布(safe publication)问题不仅仅包括final实例字段的可见性，还包括其他实例字段的可见性。  </p>
<p>当发布一个已初始化的对象时，希望所有已初始化的实例字段对其他线程可见。否则，其他线程可能见到一个仅部分初始化的新建对象，从而造成程序错误。  </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Java内存模型通过定义了一系列的happens-before操作，让应用程序开发者能够轻易的表达不同线程的操作之间的内存可见性。  </p>
<p>在遵守Java内存模型的前提下，即时编译器以及底层体系架构能够调整内存访问操作，以达到性能优化的效果。如果开发者没有正确的利用happens-before规则，那么将可能导致数据竞争。  </p>
<p>Java内存模型是通过内存屏障来禁止重排序的。对于即时编译器来说，内存屏障将限制它所能做的重排序优化。对于处理器来说，内存屏障会导致缓存的刷新操作。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>逃逸分析</title>
    <url>/JVM/23%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>Java中Iterable对象的foreach循环遍历时一个语法糖，Java编译器会将该语法糖编译为调用Iterable对象的iterator方法，并用所返回的Iterator对象的hasNext以及next方法，来完成遍历。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        foreach
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(ArrayList&lt;Object&gt; list, Consumer&lt;Object&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Object obj : list) &#123;</span><br><span class="line">        f.accept(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(ArrayList&lt;Object&gt; list, Consumer&lt;Object&gt; f)</span> </span>&#123;</span><br><span class="line">    Iterator&lt;Object&gt; iter = list.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">        Object obj = iter.next();</span><br><span class="line">        f.accept(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Arraylist
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span> ... </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      checkForComodification();</span><br><span class="line">      <span class="keyword">int</span> i = cursor;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">      Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">      cursor = i + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p>ArrayList.iterator方法将创建一个ArrayList$Itr实例。(不能错误的认为，应当避免在热点代码中使用foreach循环，并且直接使用基于ArrayList.size以及ArrayList.get的循环方式，以减少对Java堆的压力)  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        for循环
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(ArrayList&lt;Object&gt; list, Consumer&lt;Object&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lsit.size(); i++) &#123;</span><br><span class="line">        f.accept(list.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p>实际上，JVM中的即时编译器可以将ArrayList.iterator方法中的实例创建操作给优化掉。但是需要方法内联以及逃逸分析的协作。  </p>
<h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>逃逸分析：一种确定指针动态范围的静态分析，它可以分析在程序的哪些地方可以访问到指针。  </p>
<p>在JVM的即时编译语境下，逃逸分析将判断新建的对象是否逃逸。即时编译器判断对象是否逃逸的依据，一是对象是否被存入堆中(静态字段或者堆中对象的实例字段)，二是对象是否被传入未知代码中。  </p>
<p>前者：一旦对象被存入堆中，其他线程便能获得该对象的引用。即时编译器也因此无法追踪所有使用该对象的代码位置。  </p>
<p>后者：由于JVM的即时编译器是以方法为单位的，对于方法中未被内联的方法调用，即时编译器会将其当成未知代码，毕竟它无法确认该方法调用会不会将调用者或所传入的参数存储至堆中。因此可以认为方法调用的调用者以及参数是逃逸的。  </p>
<p>通常来说，即时编译器里的逃逸分析是放在方法内联之后的，以便消除这些“未知代码”入口。  </p>
<hr>
<p>理想情况下，即时编译器能够内联对ArrayList$Itr构造器的调用，对hasNext以及next方法的调用，以及当内联了Itr.next方法后，对checkForComodification方法的调用。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        ArrayList中方法内联后伪代码
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(ArrayList&lt;Object&gt; list, Consumer&lt;Object&gt; f)</span> </span>&#123;</span><br><span class="line">    Itr iter = <span class="keyword">new</span> Itr;<span class="comment">//这里是new指令</span></span><br><span class="line">    iter.cursor = <span class="number">0</span>;</span><br><span class="line">    iter.lastRet = -<span class="number">1</span>;</span><br><span class="line">    iter.expectedModCount = list.modCount;</span><br><span class="line">    <span class="keyword">while</span>(iter.cursor &lt; list.size) &#123;</span><br><span class="line">        <span class="keyword">if</span>(list.modCount != iter.expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        <span class="keyword">int</span> i = iter.cursor;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= list.size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        Object[] elementData = list.elementData;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= elementData.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        iter.cursor = i+<span class="number">1</span>;</span><br><span class="line">        iter.lastRet = i;</span><br><span class="line">        Object obj = elementData[i];</span><br><span class="line">        f.accept(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码所新建的ArrayList$Ite实例既没有被存入任何字段之中，也没有作为任何方法调用的调用者或者参数。因此，逃逸分析将断定该实例不逃逸</p>

    </div>
</div>  

<h3 id="基于逃逸分析的优化"><a href="#基于逃逸分析的优化" class="headerlink" title="基于逃逸分析的优化"></a>基于逃逸分析的优化</h3><p>即时编译器可以根据逃逸分析的结果进行诸如锁消除、栈上分配以及标量替换的优化。  </p>
<h4 id="锁消除-同步消除"><a href="#锁消除-同步消除" class="headerlink" title="锁消除(同步消除)"></a>锁消除(同步消除)</h4><p>如果即时编译器能够证明锁对象不逃逸，那么对该锁对象的加锁、解锁操作没有意义。这是因为其他线程并不能获得该锁对象，因此也不可能对其进行加锁。在这种情况下，即时编译器可以消除对该不逃逸锁对象的加锁、解锁操作。  </p>
<p>实际上，传统编译器仅需证明锁对象不逃逸出线程，便可以进行锁消除。由于JVM即时编译的限制，上述条件被强化为证明所对象不逃逸出当前编译的方法。  </p>
<p>synchronized(new Object()) {}会被完全优化掉，这正是因为基于逃逸分析的锁消除。由于其他线程不能获得该锁对象，因此也无法基于该锁对象构造两个线程之间的happens-before规则。  </p>
<p>synchronized(escapedObject) {}则不然。由于其他线程可能会对逃逸了的对象escapedObject进行加锁操作，从而构造了两个线程之间的happens-before关系。因此即时编译器至少需要为这段代码生成一条刷新缓存的内存屏障指令。  </p>
<p>基于逃逸分析的锁消除实际上并不多见。一般来说，开发人员不会直接对方法中新构造的对象进行加锁。事实上，逃逸分析的结果更多被用于将新建对象操作转换成栈上分配或者标量替换。  </p>
<h4 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h4><p>JVM中对象都是在堆上分配的，而堆上的内容对任何线程都是可见的。与此同时，JVM需要对所分配的堆内存进行管理，并且在对象不再被引用时回收其所占据的内存。  </p>
<p>如果逃逸分析能够证明某些新建的对象不逃逸，那么JVM完全可以将其分配至栈上，并且在new语句所在的方法退出时，通过弹出当前方法的栈帧来自动回收所分配的内存空间。这样便无须借助垃圾回收器来处理不再被引用的对象。  </p>
<p>由于实现起来需要更改大量假设了”对象只能堆分配”的代码，因此HotSpot虚拟机并没有采用栈上分配，而是使用了标量替换这项技术。  </p>
<h4 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h4><p>所谓的标量，就是仅能存储一个值的变量，比如Java代码中的局部变量。与之相反，聚合量则可能同时存储多个值，其中一个典型的例子便是Java对象。  </p>
<p>标量替换这项优化技术，可以看成<strong>将原本对对象的字段的访问，替换为一个个局部变量的访问。</strong>  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        标量替换 内联之后的foreach代码
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(ArrayList&lt;Object&gt; list, Consumer&lt;Object&gt; f)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Itr iter = new Itr; // 经过标量替换后该分配无意义，可以被优化掉</span></span><br><span class="line">  <span class="keyword">int</span> cursor = <span class="number">0</span>;     <span class="comment">// 标量替换</span></span><br><span class="line">  <span class="keyword">int</span> lastRet = -<span class="number">1</span>;   <span class="comment">// 标量替换</span></span><br><span class="line">  <span class="keyword">int</span> expectedModCount = list.modCount; <span class="comment">// 标量替换</span></span><br><span class="line">  <span class="keyword">while</span> (cursor &lt; list.size) &#123;</span><br><span class="line">    <span class="keyword">if</span> (list.modCount != expectedModCount)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    <span class="keyword">int</span> i = cursor;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= list.size)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    Object[] elementData = list.elementData;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    cursor = i + <span class="number">1</span>;</span><br><span class="line">    lastRet = i;</span><br><span class="line">    Object obj = elementData[i];</span><br><span class="line">    f.accept(obj);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原本需要在内存中连续分布的对象，现已被拆散为一个个单独的字段cursor，lastRet，以及expectedModCount。这些字段既可以存储在栈上，也可以直接存储在寄存器中。而该对象的对象头信息则直接消失了，不再被保存至内存之中。  </p>
<p>由于该对象没有被实际分配，因此和栈上分配一样，它同样可以减轻垃圾回收的压力。与栈上分配相比，它对字段的内存连续性不做要求，而且，这些字段甚至可以直接在寄存器中维护，无须浪费任何内存空间。  </p>

    </div>
</div>  

<h3 id="部分逃逸分析"><a href="#部分逃逸分析" class="headerlink" title="部分逃逸分析"></a>部分逃逸分析</h3><p>C2的逃逸分析与控制流无关，相对来说比较简单。Graal则引入了一个与控制流有关的逃逸分析–部分逃逸分析(partial escape analysis)。它解决了所新建的实例仅在部分程序路径中逃逸的情况。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">boolean</span> cond)</span> </span>&#123;</span><br><span class="line">  Object foo = <span class="keyword">new</span> Object();</span><br><span class="line">  <span class="keyword">if</span>(cond) &#123;</span><br><span class="line">    foo.hashCode();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//手工优化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">boolean</span> cond)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(cond) &#123;</span><br><span class="line">    Object foo = <span class="keyword">new</span> Object();</span><br><span class="line">    foo.hashCode();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码中，新建实例只会在进入if-then分支时逃逸。(对hashCode方法的调用是一个HotSpot intrinsic，将被替换为一个<em>无法内联的本地方法调用</em>。)  </p>
<p>假设if语句的条件成立的可能性只有1%，那么在99%的情况下，程序没有必要新建对象。其手工优化的版本正是部分逃逸分析想要自动达到的成果。  </p>
<p>部分逃逸分析将根据控制流信息，判断出新建对象仅在部分分支中逃逸，并且将对象的新建操作推延至对象逃逸的分支中。这将使得原本因对象逃逸而无法避免的新建对象操作，不再出现在只执行if-else分支的程序路径之中。  </p>
<p>综上，与C2所使用的逃逸分析相比，Graal所使用的部分逃逸分析能够优化更多的情况，不过它编译的时间也更长一些。  </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在JVM的即时编译语境下，逃逸分析将判断新建的对象是否会逃逸。即时编译器判断对象逃逸的依据有两个：一是看对象是否被存入堆中，二是看对象是否作为方法调用的调用者或者参数。  </p>
<p>即时编译器会根据逃逸分析的结果进行优化，如锁消除以及标量替换。后者指的是将原本连续分配的对象拆散为一个个单独的字段，分布在栈上或者寄存器中。  </p>
<blockquote>
<p>逃逸分析的缺点是：分析过程比较耗费性能或者分析完毕后发现非逃逸的对象很少。  </p>
</blockquote>
<p>逃逸程度：不逃逸，方法逃逸，线程逃逸；<br>其中栈上分配不支持线程逃逸，标量替换不支持方法逃逸。  </p>
<blockquote>
<p>方法逃逸：作为调用参数传递到其他方法中；<br>线程逃逸：赋值给类变量或可以在其他线程中访问的实例变量。  </p>
</blockquote>
<p>部分逃逸分析是一种附带了控制流信息的逃逸分析。它将判断新建对象真正逃逸的分支，并且支持将新建操作推延至逃逸分析。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>即时编译</title>
    <url>/JVM/16%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<p>即时编译，是一项用来提升应用程序运行效率的技术。通常代码会先被JVM解释执行，之后反复执行的热点代码则会被即时编译成为机器码，直接运行在底层硬件之上。  </p>
<h3 id="分层编译模式"><a href="#分层编译模式" class="headerlink" title="分层编译模式"></a>分层编译模式</h3><p>HotSpot虚拟机包含多个即时编译器C1、C2和Graal。  </p>
<p>Graal是一个实验性质的即时编译器，可以通过参数-XX:+UnlockExperimentalVMOption -XX:+UseJVMCICompiler启用，并且替换C2。  </p>
<p>在Java7以前，需要根据程序的特性选择对应的即时编译器。对于执行时间较短的，或者对启动性能有要求的程序，采用编译效率较快的C1，对应参数-client。  </p>
<p>对于执行时间较长的，或者对峰值性能有要求的程序，采用生成代码执行效率较快的C2，对应参数-server。  </p>
<p>Java7引入了分层编译(对应参数-XX:+TieredCompilation)的概念，综合了C1的启动性能优势和C2的峰值性能优势。分层编译将JVM的执行状态分为了五个层次：  </p>
<ol>
<li>解释执行(带profiling)；  </li>
<li>执行不带profiling的C1代码；  </li>
<li>执行仅带方法调用次数以及循环回边执行次数profiling的C1代码；  </li>
<li>执行带所有profiling的C1代码；  </li>
<li>执行C2代码。  </li>
</ol>
<p>通常情况下，C2代码的执行效率要比C1代码的高出30%以上。对于C1代码的三种状态，按执行效率2层&gt;3层&gt;4层。2层的性能比3层的稍微高一些，3层的性能比4层高出30%。profiling越多，其额外的性能开销越大。profiling是指在程序执行过程中，收集能够反映程序执行状态的数据。所收集的数据称之为程序的profile。  </p>
<p>在5个层次的执行状态中，2层和5层为终止状态。当一个方法被终止状态编译过后，如果编译后的代码并没有失效，那么JVM不会再次发出该方法的编译请求。  </p>
<p>Java8默认开启了分层编译。不管是开启还是关闭分层编译，原本用来选择即时编译器的参数-client和-server都是无效的。当关闭分层编译的情况下，JVM将直接采用C2。如果希望只是用C1，那么可以在打开分层编译的情况下使用参数-XX:TieredStopAtLecel=1。在这种情况下，JVM会在解释执行之后直接由2层的C1进行编译。  </p>
<h3 id="即时编译的触发"><a href="#即时编译的触发" class="headerlink" title="即时编译的触发"></a>即时编译的触发</h3><p>JVM是根据方法的调用次数以及循环回边的执行次数来触发即时编译的。JVM在1层、3层、4层执行状态时进行profiling，其中就包含方法的调用次数和循环回边的执行次数。(循环回边是控制流图中的概念，可以简单理解为往回跳转的指令)。  </p>
<p>在即时编译过程中，会识别循环的头部和尾部。循环尾部到循环头部的控制流边就是真正意义上的循环回边。C1将在这个位置插入增加循环回边计数器的代码。<br>解释执行和C1代码中增加循环回边计数器的位置并不相同，但并不会对程序造成影响。  </p>
<p>JVM不会对这些计数器进行同步操作，因此收集而来的执行次数也并非精确值。不管如何，即时编译的触发并不需要非常精确的数值。只要该数值足够大，就能说明对应的方法包含热点代码。  </p>
<p>在<strong>不启用分层编译</strong>的情况下，当方法的调用次数和循环回边的次数的和，超过由参数-XX:CompileThreshold指定的阈值时(使用C1时，该值为1500；使用C2时，该值为10000)，便会触发即时编译。  </p>
<p>当<strong>启用分层编译</strong>时，JVM将不再采用由参数-XX:CompileThreshold指定的阈值(该参数失效)，而是使用另一套阈值大小动态调整的系统：在比较阈值时，JVM会将阈值与某个系数s相乘。该系数与当前待编译的方法数目成正相关，与编译线程的数目成负相关。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">系数的计算方法为：</span><br><span class="line">s = queue_size_X / (TierXLoadFeedback * compiler_count_X) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">其中X是执行层次，可取<span class="number">3</span>或者<span class="number">4</span>；</span><br><span class="line">queue_size_X是执行层次为X的待编译方法的数目；</span><br><span class="line">TierXLoadFeedback是预设好的参数，其中Tier3LoadFeedback为<span class="number">5</span>，Tier4LoadFeedback为<span class="number">3</span>；</span><br><span class="line">compiler_count_X是层次X的编译线程数目。</span><br></pre></td></tr></table></figure>

<p>在64位JVM中，默认情况下编译线程的总数目是根据处理器数量来调整的。  </p>
<blockquote>
<p>对应参数-XX:+CICompilerCountPerCPU，默认为true；当通过参数-XX:+CICompilerCount=N强制设定总编译线程数目时，CICompilerCountPerCPU将被设置为false。  </p>
</blockquote>
<p>JVM会将编译线程按照1:2的比例分配给C1和C2(至少各1个)。  </p>
<blockquote>
<p>对于四核及以上的机器，总的编译线程数目为:n=log<sub>2</sub>N * log<sub>2</sub>(log<sub>2</sub>N) * 3 / 2;其中N为CPU核心数目。  </p>
</blockquote>
<p>当启用分层编译时，即时编译触发条件：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">当方法调用次数大于由参数-XX:TierXInvocationThreshold指定的阈值乘以系数，</span><br><span class="line">或者当方法调用次数大于由参数-XX:TierXMINInvocationThreshold指定的阈值乘以系数，</span><br><span class="line">并且方法调用次数和循环回边次数之和大于由参数-XX:TierXCompileThreshold指定的阈值乘以系数时，</span><br><span class="line">便会触发X层即时编译。</span><br><span class="line"></span><br><span class="line">触发条件为：</span><br><span class="line">i &gt; TierXInvocationThreshold * s || (i &gt; TierXMinInvocationThreshold * s  &amp;&amp; i + b &gt; TierXCompileThreshold * s)</span><br><span class="line">其中i为调用次数，b为循环回边次数。</span><br></pre></td></tr></table></figure>

<h3 id="OSR编译"><a href="#OSR编译" class="headerlink" title="OSR编译"></a>OSR编译</h3><p>决定一个方法是否为热点代码的因素有两个：方法的调用次数、循环回边的执行次数。即时编译便是根据这两个计数器的和来触发的。  </p>
<p>除了以方法为单位的即时编译之外，JVM还存在着另一种以循环为单位的即时编译，On-Stack-Replacement(OSR)编译，循环回边计数器便是用来触发这种类型的编译的。  </p>
<p>OSR是一种技术，指的是在程序执行过程中，动态的替换掉Java方法栈帧，从而使得程序能够在非方法入口处进行解释执行和编译后的代码之间的切换。去优化(deoptimization)(从执行机器码切换回解释执行)采用的技术也可以称之为OSR。  </p>
<p>在<strong>不启用分层编译</strong>的情况下，触发OSR编译的阈值是由参数-XX:CompileThreshold指定的阈值的倍数(使用C1时，该值为1500；使用C2时，该值为10000)。  </p>
<blockquote>
<p>(OnStackReplacePercentage - InterpreterProfilePercentage)/100  </p>
</blockquote>
<p>其中-XX:InterpreterProfilePercentage的默认值为33，当使用C1时-XX:OnStackReplacePercentage为933，当使用C2时为140。那么默认情况下，C1的OSR编译的阈值为13500，C2的为10700。  </p>
<blockquote>
<p>《深入理解Java虚拟机-第2版》p335区别</p>
</blockquote>
<p>在<strong>启用分层编译</strong>的情况下，触发OSR编译的阈值则是由参数-XX:TierXBackEdgeThreshold指定的阈值乘以系数。  </p>
<p>OSR编译在正常的应用程序中并不多见。它只在基准测试时比较常见。  </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从Java8开始，JVM默认采用分层编译的方式。它将执行分为五个层次，分别为1层解释执行，2层执行没有profiling的C1代码，3层执行部分profiling的C1代码，4层执行全部profiling的C1代码，和5层执行C2代码。  </p>
<p>通常情况下，方法会首先被解释执行，然后被4层的C1编译，最后被5层的C2编译。  </p>
<p>即时编译是由方法调用计数器和循环回边计数器触发的。在使用分层编译的情况下，触发编译的阈值是根据当前待编译的方法数目动态调整的。  </p>
<p>OSR是一种能够在非方法入口处 进行解释执行和编译后代码之间切换的技术。OSR编译可以用来解决单次调用方法包含热循环的性能优化问题。  </p>
<p>使用参数-XX:+PrintCompilation可以打印项目中的即时编译情况。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>方法内联</title>
    <url>/JVM/20%E6%96%B9%E6%B3%95%E5%86%85%E8%81%94/</url>
    <content><![CDATA[<p>方法内联：在编译过程中遇到方法调用时，将目标方法的方法体纳入编译范围之中，并取代原方法调用的优化手段。  </p>
<blockquote>
<p>方法内联只发生在即时编译器中。  </p>
</blockquote>
<p>方法内联不仅可以消除调用本身带来的性能开销，还可以进一步触发更多的优化，它是编译优化里最为重要的一环。  </p>
<p>以getter/setter为例，如果没有方法内联，在调用getter/setter时，程序需要保存当前方法的执行位置，创建并压入用于getter/setter的栈、访问字段、弹出栈帧，最后再恢复当前方法的执行。而内联了对getter/setter的方法调用后，上述操作仅剩字段访问。  </p>
<h3 id="方法内联的过程"><a href="#方法内联的过程" class="headerlink" title="方法内联的过程"></a>方法内联的过程</h3><p>在C2中，方法内联是在解析字节码的过程中完成的。每当触碰到方法调用字节码时，C2将决定是否需要内联该方法调用。如果需要内联，则开始解析目标方法的字节码。  </p>
<blockquote>
<p>即时编译器首先解析字节码，并生成IR图，然后再该IR图上进行优化。优化是由一个个独立的优化阶段(optimization phase)串联起来的。每个优化阶段都会对IR图进行转换。最后即时编译器根据IR图的节点以及调度顺序生成机器码。  </p>
</blockquote>
<p>同C2一样，Graal也会在解析字节码的过程中进行方法调用的内联。此外，Graal还拥有一个独立的优化阶段，来寻找指代方法调用的IR节点，并将之替换为目标方法的IR图。  </p>
<hr>
<p>除了将被调用方法的IR图节点复制到调用者方法的IR图中，即时编译器还需额外完成三项操作：  </p>
<ul>
<li>第一，被调用方法的传入参数节点，将被替换为调用者方法进入方法调用时所传入参数对应的节点。  </li>
<li>第二，在调用者方法的IR图中，所有指向原方法调用节点的数据依赖将重新指向被调用方法的返回节点。如果被调用方法存在多个返回节点，则生成一个Phi节点，将这些返回值聚合起来，并作为原方法调用节点的替换对象。  </li>
<li>第三，如果被调用方法将抛出某种类型的异常，而调用者方法恰好有该异常类型的处理器，并且该异常处理器覆盖这一方法调用，那么即时编译器需要将被调用方法抛出异常的路径，与调用者方法的异常处理器相连接。  </li>
</ul>
<p>经过方法内联之后，即时编译器将得到一个新的IR图，并且在接下来的编译过程中对这个新的IR图进行进一步的优化。  </p>
<blockquote>
<p>Java编译器(不是即时编译器)将final静态字段编译为常量值，并且在字节码中直接使用这些常量值，而非读取静态字段。IR图可以进一步优化(死代码消除)  </p>
</blockquote>
<h3 id="方法内联的条件"><a href="#方法内联的条件" class="headerlink" title="方法内联的条件"></a>方法内联的条件</h3><p>方法内联能够触发更多的优化。通常而言，内联越多，生成代码的执行效率越高。然而对即时编译器来说，内联越多，编译时间也就越长，而程序达到峰值性能的时刻也将被推迟。  </p>
<p>此外，内联越多也将导致生成的机器码越长。在JVM里，编译生成的机器码会被部署到Code Cache之中。这个Code Cache有大小限制(JVM参数-XX:ReservedCodeCacheSize)。生成的机器码越长，越容易填满Code Cache，从而出现Code Cache已满，即时编译已被关闭的警告信息(CodeCache is full. Compiler has been disabled)。  </p>
<p>即时编译器不会无限制的进行方法内联。(自动拆箱总会被内联、Throwable类的方法不能被其他类中的方法所内联。参考JDK源代码)。  </p>
<ul>
<li>首先，由-XX:CompileCommand中的inline指令指定的方法，以及由@ForceInline注解的方法(仅限于JDK内部方法)，会被强制内联。而由-XX:CompileCommand中的dontinline指令或exclude指令(表示不编译)指定的方法，以及由@DontInline注解的方法(仅限JDK内部方法)，则始终不会被内联。  </li>
<li>其次，如果调用字节码对应的符号引用未被解析、目标方法所在的类未被初始化，或者目标方法是native方法，都将导致方法调用无法内联。  </li>
<li>再次，C2不支持内联超过9层的调用(虚拟机参数-XX:MaxInlineLevel)，以及1层的直接递归调用(虚拟机参数-XX:MaxRecursiveInlineLevel)。  <blockquote>
<p>如果方法a调用了方法b，而方法b调用了方法c，那么b为a的1层调用，c为a的2层调用。  </p>
</blockquote>
</li>
<li>最后，即时编译器将根据方法调用指令所在的程序路径的热度，目标方法的调用次数以及大小，以及当前IR图的大小来决定方法调用能否被内联。  </li>
</ul>
<p>总体来说，即时编译器中的内联算法更青睐于小方法。  </p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-XX:InlineSmallCode</td>
<td>2000</td>
<td>如果目标方法已被编译，且其生成的机器码大小超过该值，则无法内联</td>
</tr>
<tr>
<td>-XX:MaxTrivialSize</td>
<td>6</td>
<td>如果方法的字节码大小少于该值，则直接内联</td>
</tr>
<tr>
<td>-XX:MinInliningThreshold</td>
<td>250</td>
<td>如果目标方法的调用次数低于该值，则无法内联</td>
</tr>
<tr>
<td>-XX:InlineFrequencyCount</td>
<td>100</td>
<td>如果方法调用指令执行次数超过该值，则认为是热点代码</td>
</tr>
<tr>
<td>-XX:MaxInlineSize</td>
<td>35</td>
<td>如果非热点方法的字节码大小超过该值，则无法内联</td>
</tr>
<tr>
<td>-XX:FreqInlineSize</td>
<td>325</td>
<td>如果热点方法的字节码大小超过该值，则无法内联</td>
</tr>
<tr>
<td>-XX:LiveNodeCountInlineCutoff</td>
<td>40000</td>
<td>编译过程中IR节点数目的上限</td>
</tr>
</tbody></table>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>方法内联是指，在编译过程中，当遇到方法调用时，将目标方法的方法体纳入编译范围之中，并取代原方法调用的优化手段。  </p>
<p>即时编译器既可以在解析过程中替换方法调用字节码，也可以在IR图中替换方法调用IR节点。这两者都需要将目标方法的参数以及返回值映射到当前方法来。  </p>
<p>方法内联有许多规则。除了一些强制内联以及强制不内联的规则外，即时编译器会根据方法调用的层数、方法调用指令所在的程序路径的热度、目标方法的调用次数及大小，以及当前IR图的大小来决定方法调用能否被内联。  </p>
<p>虚拟机参数-XX:+PringInlining打印编译过程中的内联情况。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>向量化</title>
    <url>/JVM/%E5%90%91%E9%87%8F%E5%8C%96/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">byte</span>[] dst, <span class="keyword">byte</span>[] src)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dst.length - <span class="number">4</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">        dst[i] = src[i];</span><br><span class="line">        dst[i+<span class="number">1</span>] = src[i+<span class="number">1</span>];</span><br><span class="line">        dst[i+<span class="number">2</span>] = src[i+<span class="number">2</span>];</span><br><span class="line">        dst[i+<span class="number">3</span>] = src[i+<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    ...<span class="comment">//post-loop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于X86_64平台不支持内存间的直接移动，上述代码中的dst[i]=src[i]通常会被编译为两条内存访问指令：第一条指令把src[i]的值读取至寄存器中，而第二条指令则把寄存器中的值写入至dst[i]中。因此上述代码中的一个循环迭代将会执行四条内存读取指令，以及四条内存写入指令。  </p>
<p>由于数组元素在内存中是连续的，当从src[i]的内存地址读取32位的内容时，将一并读取src[i]至src[i+3]的值。同样，当向dst[i]的内存地址处写入32位的内容时，将一并写入dst[i]至dst[i+3]的值。<br>通过综合这两个批量操作，可以使用一条内存读取指令以及一条内存写入指令，完成上述代码中循环体内的全部工作。如果用x[i:i+3]来指代x[i]至x[i+3]合并后的值，上述优化可以表述为如下伪代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">byte</span>[] dst, <span class="keyword">byte</span>[] src)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dst.length - <span class="number">4</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">        dst[i:i+<span class="number">3</span>] = src[i:i+<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    ...<span class="comment">//post-loop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SIMD指令"><a href="#SIMD指令" class="headerlink" title="SIMD指令"></a>SIMD指令</h3><p>示例中使用的是byte数组，四个数组元素并起来4个字节。如果换成int数组，或者long数组，那么四个数组元素并起来将会是16字节或32字节。  </p>
<p>X86_64体系架构上通用寄存器的大小为64位(8个字节)，无法暂存这些超长的数据。因此，即时编译器将借助长度足够的XMM寄存器，来完成int数组与long数组的向量化读取和写入操作。(为了实现方便，byte数组的向量化读取、写入操作同样适用了XMM寄存器。)  </p>
<p><strong>XMM寄存器</strong>，是由SSE(Streaming SIMD Extensions)指令集所引入的。最初为128位。自从X86平台上的CPU开始支持AVX(Advanced Vector Extensions)指令集后(2011)，XMM寄存器升级为256位，并更名为YMM寄存器。原本使用XMM寄存器的指令，现将使用YMM寄存器的低128位。后续推出的AVX512指令集，将YMM寄存器升级至512位，并更名为ZMM寄存器。  </p>
<p>SSE指令集以及之后的AVX指令集都涉及了一个重要的概念，单指令流多数据流(Single Instruction Multipe Data, SIMD)，即通过单条指令操控多组数据的计算操作。这些指令称之为SIMD指令。<br>SIMD指令将XMM寄存器(或YMM寄存器、ZMM寄存器)中的值看成多个整数或者浮点数组成的向量，并且批量进行计算。  </p>
<img src='/img/JVM XMM寄存器.png'>

<p>128位XMM寄存器里的值可以看成16个byte值组成的向量，或者8个short值组成的向量，4个int值组成的向量，2个long值组成的向量；而SIMD指令PADDB、PADDW、PADDD以及PADDQ，将分别实现byte值、short值、int值或者long值的向量加法。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b, <span class="keyword">int</span>[] c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c.length; i++) &#123;</span><br><span class="line">        c[i] = a[i] + b[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码经过向量化优化之后，将使用PADDD指令来实现c[i:i+3] = a[i:i+3] + b[i:i+3]。原本需要c.length次加法操作的代码，现在最少只需要c.length/4次向量加法即可完成。因此SIMD指令也被看成CPU指令级别的并行。(现实中，C2将考虑缓存行对齐等因素，导致能够应用向量化加法的仅有数组中间的部分元素。)  </p>
<h3 id="使用SIMD指令的HotSpot-Intrinsic"><a href="#使用SIMD指令的HotSpot-Intrinsic" class="headerlink" title="使用SIMD指令的HotSpot Intrinsic"></a>使用SIMD指令的HotSpot Intrinsic</h3><p>SIMD指令虽然高效，但是使用起来很玛法。主要是因为不同的CPU所支持的SIMD指令可能不同。一般来说，越新的SIMD指令，它所支持的寄存器长度越大，功能越强。  </p>
<p>为了能够尽量利用新的SIMD指令，需要提前知道程序会被运行在支持哪些指令集的CPU上，并在编译过程中选择所支持的SIMD指令中最新的哪些。或者可以在编译结果中纳入同一段代码的不同版本，每个版本使用不同的SIMD指令。在运行过程中，程序将根据CPU所支持的指令集，来选择执行哪一个版本。  </p>
<p>JVM所执行的Java字节码是平台无关的。它首先会被解释执行，而后反复执行的部分才会被JVM即时编译为机器码。在进行即时编译的时候，JVM已经运行在目标CPU之上，可以轻易的得知其所支持的指令集。  </p>
<p>Java字节码的平台无关性，使得Java程序无法像C++程序那样，直接使用由Intel提供的，将被替换为具体SIMD指令的intrinsic方法。  </p>
<p>HotSpot虚拟机提供的替代方案是Java层面的intrinsic方法，这些intrinsic方法的语义要比单个SIMD指令复杂得多。在运行过程中，HotSpot虚拟机将根据当前体系架构来决定是否将对该intrinsic方法的调用替换为另一高效的实现。如果不，则使用原本的Java实现。  </p>
<p>使用SIMD指令的HotSpot intrinsic是虚拟机开发人员根据其语义定制的，性能优越，但是开发及维护成本较高，屈指可数，这些intrinsic方法只能做到点覆盖。不少情况下，应用程序并不会用到这些intrinsic的语义，却又存在向量化优化的机会。这时需要借助即时编译器中的自动向量化(auto vectorization)。  </p>
<h3 id="自动向量化"><a href="#自动向量化" class="headerlink" title="自动向量化"></a>自动向量化</h3><p>即时编译器的自动向量化将针对能够展开的计数循环，进行向量化优化。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b, <span class="keyword">int</span>[] c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c.length; i++) &#123;</span><br><span class="line">        c[i] = a[i] + b[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即时编译器能够自动将其展开优化成使用PADDD指令的向量加法。  </p>
<p>关于计数循环的判定，参考《循环优化》。<br>自动向量优化的条件：  </p>
<ul>
<li>循环变量的增量应为1，即能够遍历整个数组。  </li>
<li>循环变量不能为long类型，否则C2无法将循环识别为计数循环。  </li>
<li>循环迭代之间最好不要有数据依赖，例如类似于a[i] = a[i-1]的语句。当循环展开之后，循环体内存在数据依赖，那么C2无法进行自动向量化。  </li>
<li>循环体内不要有分支跳转。  </li>
<li>不要手工进行循环展开。如果C2无法自动展开，那么它也将无法进行自动向量化。  </li>
</ul>
<p>自动向量化的条件较为苛刻。而且C2支持的整数向量化操作并不多，只有向量加法、向量减法、按位与、或、异或、批量移位、批量乘法。C2还支持向量点积的自动向量化，即两两相乘再求和，这需要多条SIMD指令才能完成，并不是十分高效。  </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>向量化优化借助的是CPU的SIMD指令，即通过单条指令控制多组数据的运算。它被称为CPU指令级别的并行。  </p>
<p>HotSpot虚拟机运用向量化优化的方式有两种。<br>第一种是使用HotSpot intrinsic，在调用特定方法的时候替换为使用了SIMD指令的高效实现。Intrinsic属于点覆盖，只有当应用程序明确需要这些intrinsic的语义，才能够获得由它带来的性能提升。<br>第二种是依赖即时编译器进行自动向量化，在循环展开优化之后将不同迭代的运算合并为向量运算。自动向量化的触发条件较为苛刻，因此也无法覆盖大多数用例。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>HotSpot虚拟机的intrinsic</title>
    <url>/JVM/22HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84intrinsic/</url>
    <content><![CDATA[<p>在Java9之前，字符串是用char数组来存储的，主要为了支持非英文字符。然而，大多数Java程序中的字符串都是有Latin1字符组成的，也就是说每个字符仅需占据一个字节，而使用char数组的存储方式将极大的浪费内存空间。  </p>
<p>Java9引入了Compact Strings的概念，当字符串仅包含Latin1字符时，使用一个字节代表一个字符的编码格式，使得内存使用效率大大提高。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        String.indexOf
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (coder() == str.coder()) &#123;</span><br><span class="line">        <span class="keyword">return</span> isLatin1() ? StringLatin1.indexOf(value, str.value)</span><br><span class="line">                          : StringUTF16.indexOf(value, str.value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (coder() == LATIN1) &#123;  <span class="comment">// str.coder == UTF16</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> StringUTF16.indexOfLatin1(value, str.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//StringLatin1.indexOf</span></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">byte</span>[] value, <span class="keyword">byte</span>[] str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> indexOf(value, value.length, str, str.length, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">byte</span>[] value, <span class="keyword">int</span> valueCount, <span class="keyword">byte</span>[] str, <span class="keyword">int</span> strCount, <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> first = str[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max = (valueCount - strCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = fromIndex; i &lt;= max; i++) &#123;</span><br><span class="line">        <span class="comment">// Look for first character.</span></span><br><span class="line">        <span class="keyword">if</span> (value[i] != first) &#123;</span><br><span class="line">            <span class="keyword">while</span> (++i &lt;= max &amp;&amp; value[i] != first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Found first character, now look at the rest of value</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt;= max) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> end = j + strCount - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; j &lt; end &amp;&amp; value[j] == str[k]; j++, k++);</span><br><span class="line">            <span class="keyword">if</span> (j == end) &#123;</span><br><span class="line">                <span class="comment">// Found whole string.</span></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p>在HotSpot虚拟机中，所有被HotSpotIntrinsicCandidate注解(Java9+大量加入)标注的方法都是HotSpot intrinsic。对这些方法的调用，会被HotSpot虚拟机替换成高效的指令序列(由HotSpot虚拟机额外维护的一套高效实现)。而原本的方法实现则会被忽略掉。  </p>
<p>其他虚拟机未必维护了这些intrinsic的高效实现，它们可以直接使用原本较为低效的JDK代码。不同版本的HotSpot虚拟机所实现的intrinsic数量也大不相同。通常越新版本的Java，其intrinsic数量越多。  </p>
<p>高效实现通常依赖于具体的CPU指令，而这些CPU指令不好在Java源程序中表达。换了一个体系架构，可能就没有对应的CPU指令，也就无法进行Intrinsic优化了。所以不直接在源代码中使用这些高效实现。  </p>
<h3 id="intrinsic与CPU指令"><a href="#intrinsic与CPU指令" class="headerlink" title="intrinsic与CPU指令"></a>intrinsic与CPU指令</h3><h4 id="StringLatin1-indexOf"><a href="#StringLatin1-indexOf" class="headerlink" title="StringLatin1.indexOf"></a>StringLatin1.indexOf</h4><p>StringLatin1.indexOf方法将在一个字符串(byte数组)中查找另一个字符串(byte数组)，并且返回命中时的索引值，或者-1(未命中)。  </p>
<p>X86_64体系架构的SSE4.2指令集就包含一条指令PCMPESTRI，让它能够在16字节以下的字符串中，查找另一个16字节以下的字符串，并且返回命中时的索引值。  </p>
<p>HotSpot虚拟机便围绕着这一指令，开发出X86_64体系架构上的高效实现，并替换原本对StringLatin1.indexOf方法的调用。  </p>
<h4 id="整数加法的溢出"><a href="#整数加法的溢出" class="headerlink" title="整数加法的溢出"></a>整数加法的溢出</h4><p>一般在做整数加法时，需要考虑结果是否会溢出，并且在溢出的情况下做出相应的处理，以保证程序的正确性。  </p>
<p>Java核心类库提供了一个Math.addExact方法。它将接收两个int值(或long值)作为参数，并返回这两个int值的和。当这两个int值之和溢出时，该方法将抛出ArithmeticException异常。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Math.addExact
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">addExact</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = x + y;</span><br><span class="line">    <span class="comment">// HD 2-12 Overflow iff both arguments have the opposite sign of the result</span></span><br><span class="line">    <span class="keyword">if</span> (((x ^ r) &amp; (y ^ r)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArithmeticException(<span class="string">"integer overflow"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">addExact</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = x + y;</span><br><span class="line">    jo LABEL_OVERFLOW; <span class="comment">// jump if overflow flag set</span></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">    LABEL_OVERFLOW:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ArithmeticException(<span class="string">"integer overflow"</span>);</span><br><span class="line">      <span class="comment">// or deoptimize</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p>在Java层面判断int值之和是否溢出比较费事。需要分别比较两个int值与它们的和的符号是否不同。如果都不同，那么便认为这两个int值之和溢出。对应的实现便是两个异或操作，一个与操作，以及一个比较操作。  </p>
<p>在X86_64体系架构中，大部分计算指令都会更新状态寄存器(FLAGS register)，其中就有表示指令结果是否溢出的标识位(overflow flag)。因此，只需要在加法指令之后比较溢出标志位，便可以知道int值之和是否溢出了。  </p>
<h4 id="Integer-bitCount"><a href="#Integer-bitCount" class="headerlink" title="Integer.bitCount"></a>Integer.bitCount</h4><p>该方法将统计所输入的int值的二进制形式中有多少个1。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Integer.bitCount
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bitCount</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// HD, Figure 5-2</span></span><br><span class="line">    i = i - ((i &gt;&gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">    i = (i &amp; <span class="number">0x33333333</span>) + ((i &gt;&gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">    i = (i + (i &gt;&gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0f0f0f0f</span>;</span><br><span class="line">    i = i + (i &gt;&gt;&gt; <span class="number">8</span>);</span><br><span class="line">    i = i + (i &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> i &amp; <span class="number">0x3f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<p>Integer.bitCount方法的实现比较巧妙，但是它需要的计算步骤也比较多。在X86_64体系架构中，仅需要一条指令popcnt，便可以直接统计出int值中1的个数。  </p>
<h3 id="intrinsic与方法内联"><a href="#intrinsic与方法内联" class="headerlink" title="intrinsic与方法内联"></a>intrinsic与方法内联</h3><p>HotSpot虚拟机中，intrinsic的实现分为两种。  </p>
<p>一种是独立的桩程序。它既可以被解释执行器利用，直接替换对原方法的调用；也可以被即时编译器所利用，它把代表对原方法的调用的IR节点，替换为对这些桩程序的调用的IR节点。以这种形式实现的Intrinsic比较少，主要包括Match类中的一些方法。  </p>
<p>另一种是特殊的编译器IR节点。显然，这种实现方式仅能够被即时编译器所利用。在编译过程中，即时编译器会对原方法的调用的IR节点，替换成特殊的IR节点，并参与接下来的优化过程。最终，即时编译器的后端将根据这些特殊的IR节点，生成指定的CPU指令。大部分的intrinsic都是通过这种方式实现的。  </p>
<p>这个替换过程是在方法内联时进行的。放即时编译器碰到方法调用节点时，它将查询目标方法是不是intrinsic。如果是，则插入相应的特殊IR节点；如果不是，则进行原本的内联工作。(即判断是否需要内联目标方法的方法体，并在需要内联的情况下，将目标方法的IR图纳入当前的编译范围之中。)  </p>
<p>也就是说，如果方法调用的目标方法是intrinsic，那么即时编译器会直接忽略原目标方法的字节码，甚至根本不在乎原目标方法是否有字节码。即便是native方法，只要它被标记为intrinsic，即时编译器便能够将之“内联”进来，并插入特殊的IR节点。  </p>
<p>事实上，不少被标记为intrinsic的方法都是native方法。原本对这些native方法的调用需要经过JNI(Java Native Interface)，其性能开销十分巨大。但是，经过即时编译器的intrinsic优化之后，这部分JNI开销便直接消失不见，并且最终的结果也十分搞笑。  </p>
<blockquote>
<p>例，可以通过Thread.currentThread方法来获取当前线程。这是一个native方法，同时也是一个HotSpot intrinsic。在X86_64体系架构中，R13寄存器存放着当前线程的指针。因此，对该方法的调用将被即时编译器替换为一个特殊IR节点，并最终生成读取R13寄存器指令。  </p>
</blockquote>
<h3 id="已有intrinsic简介"><a href="#已有intrinsic简介" class="headerlink" title="已有intrinsic简介"></a>已有intrinsic简介</h3><p>HotSpot虚拟机定义了数百个intrinsic。有三成以上是Unsafe类的方法。一般不会直接使用Unsafe类的方法，而是通过java.util.concurrent包来间接使用。  </p>
<p>Unsafe类中经常被用到的便是compareAndSwap方法(Java9+更名为compareAndSet或compareAndExchange方法)。在X96_64体系架构中，对这些方法的调用将被替换为lock cmpxchg指令，也就是原子性更新指令。  </p>
<p>除了Unsafe类的方法之外，HotSpot虚拟机中的intrinsic还包括下面的几种：  </p>
<ol>
<li>StringBuilder和StringBuffer类的方法。HotSpot虚拟机将优化利用这些方法构造字符串的方式，以尽量减少需要复制内存的情况。  </li>
<li>String类、StringLatin1类、StringUTF16类和Arrays类的方法。HotSpot虚拟机将使用SIMD指令(single instruction multiple data，即用一条指令处理多个数据)对这些方法进行优化。  <blockquote>
<p>Arrays.equals(byte[], byte[])方法原本是逐个字节比较，在使用了SIMD指令之后，可以放入16字节的XMM寄存器中(甚至是64字节的ZMM寄存器中)批量比较。  </p>
</blockquote>
</li>
<li>基本类型的包装类、Object类、Math类、System类中各个功能性方法，反射API、MethodHandle类中与调用机制相关的方法，压缩、加密相关方法。  </li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>HotSpot虚拟机将对标注了@HotSpotIntrinsicCandidate注解的方法的调用，替换为直接使用基于特定CPU指令的高效实现。这些方法称之为intrinsic。  </p>
<p>具体来说，intrinsic的实现有两种。一是不大常见的桩程序，可以在解释执行或者即时编译生成的代码中使用。二是特殊的IR节点。即时编译器将在方法内联过程中，将对intrinsic的调用替换为这些特殊的IR节点，并最终生成指定的CPU指令。  </p>
<p>HotSpot虚拟机定义了三百多个intrinsic(Java12)。其中比较特殊的右Unsafe类的方法，基本上使用java.util.concurrent包便会间接使用到Unsafe类的intrinsic。除此之外，String类和Arrays类中的intrinsic也比较特殊。即时编译器将为之生成非常高效的SIMD指令。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>字段访问优化</title>
    <url>/JVM/%E5%AD%97%E6%AE%B5%E8%AE%BF%E9%97%AE%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>逃逸分析优化方式中的标量替换，可以看成将对象本身拆散为一个个字段，并把原本对象字段的访问，替换为对一个个局部变量的访问。  </p>
<p>由于Sea-of-Nodes IR的特性，局部变量不复存在，取而代之的是一个个值。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        标量替换
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原始代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bar</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    Foo foo = <span class="keyword">new</span> Foo();</span><br><span class="line">    foo.a = x;</span><br><span class="line">    <span class="keyword">return</span> foo.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//逃逸分析，标量替换</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bar</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = x;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C2即时编译生成bar方法的机器码(省略指令地址前48位)</span></span><br><span class="line">  # &#123;method&#125; 'bar' '(I)I' in 'FieldAccessTest'</span><br><span class="line">  # parm0:    rsi       = int             // 参数x</span><br><span class="line">  #           [sp+0x20]  (sp of caller)</span><br><span class="line"><span class="number">0x06a0</span>: sub    rsp,<span class="number">0x18</span>                   <span class="comment">// 创建方法栈桢</span></span><br><span class="line"><span class="number">0x06a7</span>: mov    QWORD PTR [rsp+<span class="number">0x10</span>],rbp   <span class="comment">// 无关指令</span></span><br><span class="line"><span class="number">0x06ac</span>: mov    eax,esi                    <span class="comment">// 将参数x存入返回值eax中</span></span><br><span class="line"><span class="number">0x06ae</span>: add    rsp,<span class="number">0x10</span>                   <span class="comment">// 弹出方法栈桢</span></span><br><span class="line"><span class="number">0x06b2</span>: pop    rbp                        <span class="comment">// 无关指令</span></span><br><span class="line"><span class="number">0x06b3</span>: mov    r10,QWORD PTR [r15+<span class="number">0x70</span>]   <span class="comment">// 安全点测试</span></span><br><span class="line"><span class="number">0x06b7</span>: test   DWORD PTR [r10],eax        <span class="comment">// 安全点测试</span></span><br><span class="line"><span class="number">0x06ba</span>: ret</span><br></pre></td></tr></table></figure>

<p>在X86_64的机器码中，每当使用call指令进入目标方法的方法中时，需要在栈上为当前方法分配一块内存作为其栈帧。而在退出该方法时，需要弹出当前方法所使用的栈帧。  </p>
<p>寄存器rsp维护者当前线程的栈顶指针，因为这些操作都是通过增减寄存器rsp来实现的。偏移量为0x06a0以及0x06ae的指令。  </p>
<p>HotSpot虚拟机的即时编译器将在方法返回时插入安全点测试指令。偏移量为0x06b3以及0x06ba的指令，真正的安全点测试是0x06b7指令。  </p>
<p>如果虚拟机需要所有线程都到达安全点，那么该test指令所访问的内存地址所在的页将被标记为不可访问，而该指令也将触发segfault，并借由segfault处理器进入安全点之中。通常，该指令会附带{poll_return}注释。  </p>
<p>在X86_64中，前几个传入参数会被放置于寄存器中，而返回值则需要存放在rax寄存器中。有时返回值被存入eax寄存器中，这其实是同一个寄存器(rax表示64位寄存器，eax表示32位寄存器)。  </p>
<p>当忽略掉创建、弹出方法栈帧，安全点测试以及其他无关指令之后，所剩下的方法体就只剩下偏移量为0x06ac的mov指令，以及0x06ba的ret指令。前者将所传入的int型参数x移至代表返回值的eax寄存器中，后者是退出当前方法并返回至调用者中。  </p>

    </div>
</div>  

<p>在现实中，Java程序中的对象或许本身便是逃逸的，或许因为方法内联不够彻底而被即使编译器当成是逃逸的。这两种情况都将导致即时编译器无法进行标量替换。这时候，针对对象字段访问的优化也变得格外重要。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对象o是传入参数，不属于逃逸分析的范围(JVM中的逃逸分析针对的是新建对象)</span></span><br><span class="line"><span class="comment">//该方法会将所传入的int型参数x的值存储至实例字段Foo.a中，然后再读取并返回同一字段的值。  </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bar</span><span class="params">(Foo o, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    o.a = x;</span><br><span class="line">    <span class="keyword">return</span> o.a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这段代码将涉及两次内存访问操作：存储以及读取实例字段Foo.a。</span></span><br><span class="line"><span class="comment">//可以将其手工优化为直接读取并返回传入参数x的值。  </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bar</span><span class="params">(Foo o, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    o.a = x;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//简单的代码，可以被编译为寄存器之间的移动指令。</span></span><br><span class="line"><span class="comment">//将输入参数x的值移至寄存器eax中，这比原本的内存访问指令高效</span></span><br></pre></td></tr></table></figure>

<h3 id="字段读取优化"><a href="#字段读取优化" class="headerlink" title="字段读取优化"></a>字段读取优化</h3><p>即时编译器能够作出类似上述的优化。<br>即时编译器会优化实例字段以及静态字段访问，以减少总的内存访问数目。具体来说，它将沿着控制流，缓存各个字段存储节点将要存储的值，或者字段读取节点所得到的值。  </p>
<p>当即时编译器遇到对同一字段的读取节点时，如果缓存值还没有失效，那么它会将读取节点替换为该缓存值。  </p>
<p>当即时编译器遇到对同一字段的存储节点时，它会更新所缓存的值。当即时编译器遇到可能更新字段的节点时，如方法调用节点(在即时编译器看来，方法调用会执行未知代码)，或者内存屏障节点(其他线程可能异步更新了字段)，那么它会采取保守的策略，舍弃所有缓存值。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//缓存字段读取节点  </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bar</span><span class="params">(Foo o, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = o.a + x;</span><br><span class="line">    <span class="keyword">return</span> o.a + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实例字段Foo.a将被读取两次。  </span></span><br><span class="line"><span class="comment">//即时编译器会将第一次读取的值缓存起来，并且替换第二次字段读取操作，以节省一次内存访问。  </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bar</span><span class="params">(Foo o, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = o.a;</span><br><span class="line">    <span class="keyword">int</span> y = t + x;</span><br><span class="line">    <span class="keyword">return</span> t + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果字段读取节点被替换成一个常量，那么它将进一步触发更多优化  </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bar</span><span class="params">(Foo o, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    o.a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(o.a &gt;= o) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实例字段Foo.a会被赋值为1。接下来的if语句将判断同一实例字段是否不小于0。经过字段读取优化之后，&gt;=节点的两个输入参数分别为常数1和0，因此可以直接替换为具体结果true。如此一来，else分支将变成不可达代码，可以直接删除。  </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bar</span><span class="params">(Foo o, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    o.a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//bar方法中，实例字段a会被赋值为true，后面紧跟着一个以a为条件的while循环  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> a;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(a) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">whatever</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//即时编译器会将while循环中读取实例字段a的操作直接替换为常量true  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    a = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生成的机器码将陷入这一死循环中  </span></span><br><span class="line"><span class="number">0x066b</span>: mov     rll,QWORD PTR [r15+<span class="number">0x70</span>]    <span class="comment">//安全点测试</span></span><br><span class="line"><span class="number">0x066f</span>: test    DWORD PTR [r11],eax         <span class="comment">//安全点测试</span></span><br><span class="line"><span class="number">0x0672</span>: jmp     <span class="number">0x066b</span>                      <span class="comment">//while(true)</span></span><br><span class="line"></span><br><span class="line">通过<span class="keyword">volatile</span>关键字标记实例字段a，以此强制对它的读取。</span><br></pre></td></tr></table></figure>

<p>实际上，即时编译器将在volatile字段访问前后插入内存屏障节点。这些内存屏障节点会阻止即时编译器将屏障之前所缓存的值用于屏障之后的读取节点之上。  </p>
<p>在X86_64平台上，volatile字段读取操作前后的内存屏障是no-op，在即时编译过程中的屏障节点，还是会阻止即时编译器的字段读取优化，强制在循环中使用内存读取指令访问实例字段Foo.a的最新值。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0x00e0</span>: movzx  r11d,BYTE PTR [rbx+<span class="number">0xc</span>]   <span class="comment">// 读取a</span></span><br><span class="line"><span class="number">0x00e5</span>: mov    r10,QWORD PTR [r15+<span class="number">0x70</span>]  <span class="comment">// 安全点测试</span></span><br><span class="line"><span class="number">0x00e9</span>: test   DWORD PTR [r10],eax       <span class="comment">// 安全点测试</span></span><br><span class="line"><span class="number">0x00ec</span>: test   r11d,r11d                 <span class="comment">// while (a)</span></span><br><span class="line"><span class="number">0x00ef</span>: jne    <span class="number">0x00e0</span>                    <span class="comment">// while (a)</span></span><br></pre></td></tr></table></figure>
<p>同理，加锁、解锁操作也同样会阻止即时编译器的字段读取优化。  </p>
<h3 id="字段存储优化"><a href="#字段存储优化" class="headerlink" title="字段存储优化"></a>字段存储优化</h3><p>除了字段读取优化之外，即时编译器还将消除冗余的存储节点。如果一个字段先后被存储了两次，而且这两次存储之间没有对第一次存储内容的读取，那么及时编译器可以将第一个字段存储给消除掉。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">        a = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代码中的bar方法先后存储了两次Foo.a实例字段。由于第一次存储之后没有读取Foo.a的值，因此，即时编译器会将其看成冗余存储，并将之消除掉。  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实际上，即便是在这两个字段存储操作之间读取该字段，即时编译器还是有可能在字段读取优化的帮助下，将第一个存储操作当成冗余存储给消除掉。  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> t = a;</span><br><span class="line">        a = t + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//优化为  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">        a = t + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进一步优化为  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果所存储的字段被标记为volatile，那么即时编译器也不能将冗余的存储操作消除掉。如两个存储之间隔着许多其他代码，或者因为方法内联的缘故，将两个存储操作(如构造器中字段的初始化以及随后的更新)纳入同一个编译单元里。  </p>
<h3 id="死代码消除"><a href="#死代码消除" class="headerlink" title="死代码消除"></a>死代码消除</h3><p>除了字段存储优化之外，局部变量的死存储(dead store)同样也涉及了冗余存储。这是死代码消除(dead code eliminiation)的一种。不过，由于Sea-of-Nodes IR的特性，死代码的优化无须额外代价。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bar</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = x*y;</span><br><span class="line">    t = x+y;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代码涉及两个存储局部变量操作。当即时编译器将其转换为Sea-of-Nodes IR之后，没有节点依赖于t的第一个值x*y。该乘法运算将被消除  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bar</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>死存储还有一种变体，即在部分程序路径上有冗余存储。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bar</span><span class="params">(<span class="keyword">boolean</span> f, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = x*y;</span><br><span class="line">    <span class="keyword">if</span>(f)</span><br><span class="line">        t = x+y;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代码中，如果所传入的boolean类型的参数f是true，那么在程序执行路径上将先后进行两次对局部变量t的存储。  </span></span><br><span class="line"><span class="comment">//经过Sea-of-Nodes IR转换之后，返回节点所依赖的值是一个phi节点，将根据程序路径选择x+y或者x*y。也就是说，当f为true的程序路径上的乘法运算会被消除  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bar</span><span class="params">(<span class="keyword">boolean</span> f, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">if</span>(f)</span><br><span class="line">        t = x+y;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t = x*y;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种死代码消除则是不可达分支消除。不可达分支就是任何程序路径都不可到达的分支。  </p>
<p>在即时编译过程中，经常因为方法内联、常量传播以及基于profile的优化等，生成许多不可达分支。通过消除不可达分支，即时编译器可以精简数据流，并且减少编译时间以及最终生成机器码的大小。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bar</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">false</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代码中，if语句将一直跳转至else分支之中。因此，另一不可达分支可以直接消除掉  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bar</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>即时编译器将沿着控制流缓存字段存储、读取的值，并在接下来的字段读取操作时直接使用该缓存值。  </p>
<p>这要求生成缓存值的访问以及使用缓存值的读取之间没有方法调用、内存屏障，或者其他可能存储该字段的节点。  </p>
<p>即时编译器还会优化冗余的字段存储操作。如果一个字段的两次存储之间没有对该字段的读取操作、方法调用以及内存屏障，那么即时编译器可以将第一个冗余的存储操作给消除掉。  </p>
<p>死代码消除的两种形式：<br>第一种是局部变量的死存储消除以及部分死存储消除。它们可以通过转换为Sea-of-Nodes IR来完成。<br>第二种则是不可达分支。通过消除不可达分支，即时编译器可以精简数据流，并且减少编译时间以及最终生成机器码的大小。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>注解处理器</title>
    <url>/JVM/%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<p>注解(annotation)是Java5引入的，用来为类、方法、字段、参数等Java结构提供额外信息的机制。  </p>
<p>Java核心类库中的@Override注解是被用来声明某个实例方法重写了父类的同名参数类型的方法。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Override注解本身被另外两个元注解(即作用在注解上的注解)所标注。<br>@Target用来限定目标注解所能标注的Java结构。(这里@Override便只能被用来标注方法。)  </p>
<p>@Retention则用来限定当前注解生命周期。注解共有三种不同的声明周期：SOURCE、CLASS、RUNTIME，分别表示注解只出现在源代码中、只出现在源代码和字节码中、以及出现在源代码和字节码及运行过程中。(这里@Override仅对Java编译器有用。它会为Java编译器引入一条新的编译规则：如果所标注的方法不是Java语言中的重写方法，那么编译器会报错。而当编译完成时，它的使命也就结束了。)  </p>
<p>Java的注解机制允许开发人员自定义注解。这些自定义注解同样可以为Java编译器添加编译规则。不过这种功能需要由开发人员提供，并且以插件的形式接入Java编译器中，这些插件称之为注解处理器(annotation processor)。  </p>
<p>除了引入新的编译规则之外，注解处理器还可以用于修改已有的Java源文件(不推荐)，或者生成新的Java源文件。  </p>
<h3 id="注解处理器的原理"><a href="#注解处理器的原理" class="headerlink" title="注解处理器的原理"></a>注解处理器的原理</h3><p>Java编译器的工作流程  </p>
<img src='/img/JVM Java编译器的工作流程.png'>

<p>Java源代码的编译过程可分为三个步骤：  </p>
<ol>
<li>将源文件解析为抽象语法树；  </li>
<li>调用已注册的注解处理器；  </li>
<li>生成字节码。  </li>
</ol>
<p>如果在第2步调用注解处理器过程中生成了新的源文件，那么编译器将重复第1、2步，解析并且处理新生成的源文件。每次重复称之为一轮(Round)。  </p>
<p>第一轮解析、处理的是输入至编译器中的已有源文件。如果注解处理器生成了新的源文件，则开始第二轮、第三轮，解析并且处理这些新生成的源文件。当注解处理器不再生成新的源文件，编译进入最后一轮，并最终进入生成字节码的第3步。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Processor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment processingEnv)</span></span>;</span><br><span class="line">    <span class="function">Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">SourceVersion <span class="title">getSupportedSourceVersion</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>所有的注解处理器类都需要实现接口Processor。该接口主要有四个重要方法。  </p>
<p>其中<strong>init</strong>方法用来存放注解处理器的初始化代码(不用构造器是因为在Java编译器中，注解处理器的实例是通过反射API生成的。因为使用反射API，每个注解处理器类都需要定义一个无参数构造器。)。通常来说，当编写注解处理器时，不声明任何构造器，并依赖于Java编译器，为之插入一个无参数构造器。而具体的初始化代码，则放入init方法之中。  </p>
<p><strong>getSupportedAnnotationTypes</strong>方法将返回注解处理器所支持的注解类型，这些注解类型只需用字符串形式表示即可。  </p>
<p><strong>getSupportedSourceVersion</strong>方法将返回该处理器所支持的Java版本，通常，这个版本需要与Java编译器版本保持一致。  </p>
<p><strong>process</strong>方法是最为关键的注解处理方法。  </p>
<p>JDK提供了一个实现Processor接口的抽象类AbstractProcessor。该抽象类实现了init、getSupportedAnnotationTypes和getSupportedSourceVersion方法。  </p>
<p>它的子类可以通过@SupportedAnnotationTypes和@SupportedSourceVersion注解来声明所支持的注解类型以及Java版本。  </p>
<hr>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        CheckGetter注解及处理器
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> foo;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.FIELD&#125;)<span class="comment">//可以用来标注类，也可以用来标注字段</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)<span class="comment">//生命周期限定在源代码中</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CheckGetter &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>//实现CheckGetter注解处理器(仅重写了process方法)。<br>//遍历被标注的类中的实例字段，并检查有没有相应的gatter方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> bar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.processing.*;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.SourceVersion;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.*;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.util.ElementFilter;</span><br><span class="line"><span class="keyword">import</span> javax.tools.Diagnostic.Kind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> foo.CheckGetter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SupportedAnnotationTypes</span>(<span class="string">"foo.CheckGetter"</span>)</span><br><span class="line"><span class="meta">@SupportedSourceVersion</span>(SourceVersion.RELEASE_10)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckGetterProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> annotated ElementKind.FIELD</span></span><br><span class="line">    <span class="keyword">for</span> (TypeElement annotatedClass : ElementFilter.typesIn(roundEnv.getElementsAnnotatedWith(CheckGetter<span class="class">.<span class="keyword">class</span>))) </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (VariableElement field : ElementFilter.fieldsIn(annotatedClass.getEnclosedElements())) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!containsGetter(annotatedClass, field.getSimpleName().toString())) &#123;</span><br><span class="line">          processingEnv.getMessager().printMessage(Kind.ERROR,</span><br><span class="line">              String.format(<span class="string">"getter not found for '%s.%s'."</span>, annotatedClass.getSimpleName(), field.getSimpleName()));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">containsGetter</span><span class="params">(TypeElement typeElement, String name)</span> </span>&#123;</span><br><span class="line">    String getter = <span class="string">"get"</span> + name.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + name.substring(<span class="number">1</span>).toLowerCase();</span><br><span class="line">    <span class="keyword">for</span> (ExecutableElement executableElement : ElementFilter.methodsIn(typeElement.getEnclosedElements())) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!executableElement.getModifiers().contains(Modifier.STATIC)</span><br><span class="line">          &amp;&amp; executableElement.getSimpleName().toString().equals(getter)</span><br><span class="line">          &amp;&amp; executableElement.getParameters().isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<p>process方法接收两个参数，分别代表该注解处理器所能处理的注解类型，以及囊括当前轮生成的抽象语法树的RoundEnvironment。(该处理器针对的注解仅有@CheckGetter一个，而且并不会读取注解中的值，因此这里使用<br><code>roundEnv.getElementsAnnotatedWith(CheckGetter.class)</code>来获取所有被@CheckGetter注解的类以及字段)  </p>
<p>process方法涉及各种不同类型的Element，分别指代Java程序中的各个结构：<br><strong>PackageElement指代包名，TypeElement指代类或者接口，VariableElement指代字段、局部变量、enum常量等，ExecutableElement指代方法或者构造器。</strong>  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> foo;     <span class="comment">// PackageElement</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;      <span class="comment">// TypeElement</span></span><br><span class="line">  <span class="keyword">int</span> a;           <span class="comment">// VariableElement</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> b;    <span class="comment">// VariableElement</span></span><br><span class="line">  Foo () &#123;&#125;        <span class="comment">// ExecutableElement</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setA</span> <span class="params">(      // ExecutableElement</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> newA         // VariableElement</span></span></span><br><span class="line"><span class="function"><span class="params">  )</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在将该注解处理器编译成class文件后，便可以将其注册为Java编译器的插件，并用来处理其他源代码。<br>注册的方式主要有两种：  </p>
<ul>
<li><p>第一种是直接使用javac命令的-processor参数。</p>
<blockquote>
<p>$ javac -cp /CLASSPATH/TO/CheckGetterProcessor -processor bar.CheckGetterProcessor Foo.java  </p>
</blockquote>
</li>
<li><p>第二种是将注解处理器编译生成的class文件压缩如jar包中，并在jar包的配置文件中记录该注解处理器的包名及类名。(bar.CheckGetterProcessor)</p>
<blockquote>
<p>（具体路径及配置文件名为<code>META-INF/services/javax.annotation.processing.Processor</code>）  </p>
</blockquote>
<p>  当启动Java编译器时，它会寻找classpath路径上的jar包是否包含上述配置文件，并自动注册其中记录的注解处理器。  </p>
<blockquote>
<p>$ javac -cp /PATH/TO/CheckGetterProcessor.jar Foo.java  </p>
</blockquote>
<p>  此外还可以在IDE中配置注解处理器。  </p>
</li>
</ul>
<h3 id="利用注解处理器生成源代码"><a href="#利用注解处理器生成源代码" class="headerlink" title="利用注解处理器生成源代码"></a>利用注解处理器生成源代码</h3><p>注解处理器可以用来修改已有源代码2或者生成源代码3。  </p>
<p>注解处理器并不能真正的修改已有源代码2。这里的修改指的是修改由Java源代码生成的抽象语法树，在其中修改已有树节点或者插入新的树节点，从而使生成的字节码发生变化。(对抽象语法树的修改涉及了Java编译器的内部API，这部分很可能随着版本变更而失效，不推荐)  </p>
<blockquote>
<p>Project Lombok项目自定义了一系列注解，并根据注解的内容来修改已有的源代码。它提供了@Getter和@Setter注解，能够为程序自动添加getter以及setter方法。  </p>
</blockquote>
<p>用注解处理器来生成源代码比较常用。压力测试jcstress，以及JMH(Java Microbenchmark Harness)工具，都是依赖这种方式来生成测试代码的。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> foo;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Adapt &#123;</span><br><span class="line">  Class&lt;?&gt; value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义注解Adapt，将接受一个Class类型的参数value(如果注解类仅包含一个名为value的参数时，那么在使用注解时，可以省略value=)。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Bar.java</span></span><br><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> java.util.function.IntBinaryOperator;</span><br><span class="line"><span class="keyword">import</span> foo.Adapt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Adapt</span>(IntBinaryOperator<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">  <span class="title">public</span> <span class="title">static</span> <span class="title">int</span> <span class="title">add</span>(<span class="title">int</span> <span class="title">a</span>, <span class="title">int</span> <span class="title">b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现处理@Adapt注解的处理器。该处理器将生成一个新的源文件，实现参数value所指定的接口，并且调用至被该注解所标注的方法之中。(该注解处理器没有处理所编译的代码包名为空的情况)  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        @Adapt注解的处理器
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> bar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.processing.*;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.SourceVersion;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.*;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.type.TypeMirror;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.util.ElementFilter;</span><br><span class="line"><span class="keyword">import</span> javax.tools.JavaFileObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.tools.Diagnostic.Kind;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SupportedAnnotationTypes</span>(<span class="string">"foo.Adapt"</span>)</span><br><span class="line"><span class="meta">@SupportedSourceVersion</span>(SourceVersion.RELEASE_10)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdaptProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (TypeElement annotation : annotations) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="string">"foo.Adapt"</span>.equals(annotation.getQualifiedName().toString())) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ExecutableElement targetAsKey = getExecutable(annotation, <span class="string">"value"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (ExecutableElement annotatedMethod : ElementFilter.methodsIn(roundEnv.getElementsAnnotatedWith(annotation))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!annotatedMethod.getModifiers().contains(Modifier.PUBLIC)) &#123;</span><br><span class="line">          processingEnv.getMessager().printMessage(Kind.ERROR, <span class="string">"@Adapt on non-public method"</span>);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!annotatedMethod.getModifiers().contains(Modifier.STATIC)) &#123;</span><br><span class="line">          <span class="comment">// TODO support non-static methods</span></span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TypeElement targetInterface = getAnnotationValueAsTypeElement(annotatedMethod, annotation, targetAsKey);</span><br><span class="line">        <span class="keyword">if</span> (targetInterface.getKind() != ElementKind.INTERFACE) &#123;</span><br><span class="line">          processingEnv.getMessager().printMessage(Kind.ERROR, <span class="string">"@Adapt with non-interface input"</span>);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TypeElement enclosingType = getTopLevelEnclosingType(annotatedMethod);</span><br><span class="line">        createAdapter(enclosingType, annotatedMethod, targetInterface);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createAdapter</span><span class="params">(TypeElement enclosingClass, ExecutableElement annotatedMethod,</span></span></span><br><span class="line"><span class="function"><span class="params">      TypeElement targetInterface)</span> </span>&#123;</span><br><span class="line">    PackageElement packageElement = (PackageElement) enclosingClass.getEnclosingElement();</span><br><span class="line">    String packageName = packageElement.getQualifiedName().toString();</span><br><span class="line">    String className = enclosingClass.getSimpleName().toString();</span><br><span class="line">    String methodName = annotatedMethod.getSimpleName().toString();</span><br><span class="line">    String adapterName = className + <span class="string">"_"</span> + methodName + <span class="string">"Adapter"</span>;</span><br><span class="line"></span><br><span class="line">    ExecutableElement overriddenMethod = getFirstNonDefaultExecutable(targetInterface);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Filer filer = processingEnv.getFiler();</span><br><span class="line">      JavaFileObject sourceFile = filer.createSourceFile(packageName + <span class="string">"."</span> + adapterName, <span class="keyword">new</span> Element[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> (PrintWriter out = <span class="keyword">new</span> PrintWriter(sourceFile.openWriter())) &#123;</span><br><span class="line">        out.println(<span class="string">"package "</span> + packageName + <span class="string">";"</span>);</span><br><span class="line">        out.println(<span class="string">"import "</span> + targetInterface.getQualifiedName() + <span class="string">";"</span>);</span><br><span class="line">        out.println();</span><br><span class="line">        out.println(<span class="string">"public class "</span> + adapterName + <span class="string">" implements "</span> + targetInterface.getSimpleName() + <span class="string">" &#123;"</span>);</span><br><span class="line">        out.println(<span class="string">"  @Override"</span>);</span><br><span class="line">        out.println(<span class="string">"  public "</span> + overriddenMethod.getReturnType() + <span class="string">" "</span> + overriddenMethod.getSimpleName()</span><br><span class="line">            + formatParameter(overriddenMethod, <span class="keyword">true</span>) + <span class="string">" &#123;"</span>);</span><br><span class="line">        out.println(<span class="string">"    return "</span> + className + <span class="string">"."</span> + methodName + formatParameter(overriddenMethod, <span class="keyword">false</span>) + <span class="string">";"</span>);</span><br><span class="line">        out.println(<span class="string">"  &#125;"</span>);</span><br><span class="line">        out.println(<span class="string">"&#125;"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> ExecutableElement <span class="title">getExecutable</span><span class="params">(TypeElement annotation, String methodName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (ExecutableElement method : ElementFilter.methodsIn(annotation.getEnclosedElements())) &#123;</span><br><span class="line">      <span class="keyword">if</span> (methodName.equals(method.getSimpleName().toString())) &#123;</span><br><span class="line">        <span class="keyword">return</span> method;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    processingEnv.getMessager().printMessage(Kind.ERROR, <span class="string">"Incompatible @Adapt."</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> ExecutableElement <span class="title">getFirstNonDefaultExecutable</span><span class="params">(TypeElement annotation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (ExecutableElement method : ElementFilter.methodsIn(annotation.getEnclosedElements())) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!method.isDefault()) &#123;</span><br><span class="line">        <span class="keyword">return</span> method;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    processingEnv.getMessager().printMessage(Kind.ERROR,</span><br><span class="line">        <span class="string">"Target interface should declare at least one non-default method."</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> TypeElement <span class="title">getAnnotationValueAsTypeElement</span><span class="params">(ExecutableElement annotatedMethod, TypeElement annotation,</span></span></span><br><span class="line"><span class="function"><span class="params">      ExecutableElement annotationFunction)</span> </span>&#123;</span><br><span class="line">    TypeMirror annotationType = annotation.asType();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (AnnotationMirror annotationMirror : annotatedMethod.getAnnotationMirrors()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (processingEnv.getTypeUtils().isSameType(annotationMirror.getAnnotationType(), annotationType)) &#123;</span><br><span class="line">        AnnotationValue value = annotationMirror.getElementValues().get(annotationFunction);</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">          processingEnv.getMessager().printMessage(Kind.ERROR, <span class="string">"Unknown @Adapt target"</span>);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TypeMirror targetInterfaceTypeMirror = (TypeMirror) value.getValue();</span><br><span class="line">        <span class="keyword">return</span> (TypeElement) processingEnv.getTypeUtils().asElement(targetInterfaceTypeMirror);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    processingEnv.getMessager().printMessage(Kind.ERROR, <span class="string">"@Adapt should contain target()"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> TypeElement <span class="title">getTopLevelEnclosingType</span><span class="params">(ExecutableElement annotatedMethod)</span> </span>&#123;</span><br><span class="line">    TypeElement enclosingType = <span class="keyword">null</span>;</span><br><span class="line">    Element enclosing = annotatedMethod.getEnclosingElement();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (enclosing != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (enclosing.getKind() == ElementKind.CLASS) &#123;</span><br><span class="line">        enclosingType = (TypeElement) enclosing;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (enclosing.getKind() == ElementKind.PACKAGE) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      enclosing = enclosing.getEnclosingElement();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enclosingType;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">formatParameter</span><span class="params">(ExecutableElement method, <span class="keyword">boolean</span> includeType)</span> </span>&#123;</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    builder.append(<span class="string">'('</span>);</span><br><span class="line">    String separator = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (VariableElement parameter : method.getParameters()) &#123;</span><br><span class="line">      builder.append(separator);</span><br><span class="line">      <span class="keyword">if</span> (includeType) &#123;</span><br><span class="line">        builder.append(parameter.asType());</span><br><span class="line">        builder.append(<span class="string">' '</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      builder.append(parameter.getSimpleName());</span><br><span class="line">      separator = <span class="string">", "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    builder.append(<span class="string">')'</span>);</span><br><span class="line">    <span class="keyword">return</span> builder.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<p>注解处理器实现中，将读取注解中的值，因此将使用process方法的第一个参数，并通过它获得被标注方法对应的@Adapt注解中的value值。(value值属于Class类型。在编译过程中，被编译代码中的Class常量未必被加载进Java编译器所在的虚拟机中。因此，需要通过process方法的第一个参数，获得value所指向的接口的抽象语法树，并据此生成源代码。)  </p>
<p>生成源代码的方式非常容易理解。可以通过Filter.createSourceFile方法获得一个类似于文件的概念，并通过PrintWriter将 具体的内容一一写入即可。  </p>
<p>当将注解处理器作为插件接入Java编译器时，编译前面的test/Bar.java将生成下述代码，并且触发新一轮的编译。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> java.util.function.IntBinaryoperator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bar_addAdapter</span> <span class="keyword">implements</span> <span class="title">IntBinaryOperator</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">applyAsInt</span><span class="params">(<span class="keyword">int</span> arg0, <span class="keyword">int</span> arg1)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Bar.add(arg0, arg1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>注解处理器主要有三个用途：  </p>
<ul>
<li>一是定义编译规则，并检查被编译的源文件。  </li>
<li>二是修改已有源代码。  </li>
<li>三是生成新的源代码。  <blockquote>
<p>第二种涉及了Java编译器的内部API，因此并不推荐。第三种较为常见，是OpenJDK工具jcstress，以及JMH生成测试代码的方式。  </p>
</blockquote>
</li>
</ul>
<p>Java源代码的编译过程可分为三个步骤，分别为：  </p>
<ul>
<li>解析源文件生成抽象语法树；</li>
<li>调用已注册的注解处理器；</li>
<li>生成字节码。<blockquote>
<p>如果在第2步中，注解处理器生成了新的源代码，那么Java编译器将重复第1、2步，直至不再生成新的源代码。  </p>
</blockquote>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>基准测试框架JMH简介</title>
    <url>/JVM/%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6JMH%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>基准测试benchmarking  </p>
<h3 id="性能测试的坑"><a href="#性能测试的坑" class="headerlink" title="性能测试的坑"></a>性能测试的坑</h3><p>通过System.nanoTime或者System.currentTimeMillis来测量每若干个操作所花费的时间，这种测量方式过于理性化，忽略了JVM、操作系统、硬件系统所带来的影响。  </p>
<h4 id="JVM的影响"><a href="#JVM的影响" class="headerlink" title="JVM的影响"></a>JVM的影响</h4><p>JVM堆空间的自适配，即时编译等。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        简单性能测试代码
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; <span class="number">1_000_000_000</span>) &#123;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoopPerformanceTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// warmup</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20_000</span>; i++) &#123;</span><br><span class="line">      foo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// measurement</span></span><br><span class="line">    <span class="keyword">long</span> current = System.nanoTime();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10_000</span>; i++) &#123;</span><br><span class="line">      foo();</span><br><span class="line">      <span class="keyword">if</span> (i % <span class="number">1000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> temp = System.nanoTime();</span><br><span class="line">        System.out.println(temp - current);</span><br><span class="line">        current = System.nanoTime();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<p>真正进行测试的代码由于循环次数不多，属于冷循环，不一定能触发OSR(On-Stack Replacement)编译。<br>在main方法中解释执行，然后调用foo方法即时编译生成的机器码。这种混杂了解释执行以及即时编译生成代码的测量方式，其得到的数据含义不明。(即时编译器循环优化)  </p>
<h4 id="操作系统和硬件系统的影响"><a href="#操作系统和硬件系统的影响" class="headerlink" title="操作系统和硬件系统的影响"></a>操作系统和硬件系统的影响</h4><p>例电源管理策略。操作系统会动态配置CPU的频率，CPU的频率直接影响到性能测试的数据，因此短时间的性能测试得出的数据未必可靠。  </p>
<p>例CPU缓存，如果程序的数据本地性较好，那么它的性能指标便会非常好；如果程序存在false sharing的问题，即几个线程写入内存中属于同一缓存行的不同部分，那么它的性能指标便会非常糟糕。  </p>
<p>例超线程技术，将为每个物理核心虚拟出两个虚拟核心，从而尽可能的提高物理核心的利用率。如果性能测试的两个线程被安排在同一物理核心上，那么得到的测试数据显然要比被安排在不同物理核心上的数据糟糕。  </p>
<p>性能基准测试存在着许多深坑(pitfall)。性能测试数据很有可能是有偏差的(biased)。  </p>
<h4 id="JMH"><a href="#JMH" class="headerlink" title="JMH"></a>JMH</h4><p>OpenJDK的开源项目JMH(Java Microbenchmark Harness)是一个面向Java语言或者其它JVM语言的性能基准测试框架。它针对的是纳秒级别、微妙级别、毫秒级别、以及秒级别的性能测试。<br>JMH内置了许多功能来控制即时编译器的优化，对于其它影响性能评测的因素，JMH提供了不少策略来降低影响。使用JMH可以将精力完全几种在所要测试的业务逻辑，并以最小的代价控制除业务逻辑之外的可能影响性能的因素。JMH也不能完美解决性能测试数据的偏差问题。  </p>
<p>通常来说，性能基准测试的结果反映的是所测试的业务逻辑在所运行的JVM、操作系统、硬件系统这一组合上的性能指标，而根据这些性能指标得出的通用结论则需要经过严格论证。  </p>
<h3 id="生成JMH项目"><a href="#生成JMH项目" class="headerlink" title="生成JMH项目"></a>生成JMH项目</h3><p>借助JMH部署在maven上的archetype，生成预设好依赖关系的maven项目模板。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ mvn archetype:generate \</span><br><span class="line">          -DinteractiveMode=<span class="keyword">false</span> \</span><br><span class="line">          -DarchetypeGroupId=org.openjdk.jmh \</span><br><span class="line">          -DarchetypeArtifactId=jmh-java-benchmark-archetype \</span><br><span class="line">          -DgroupId=org.sample \</span><br><span class="line">          -DartifactId=test \</span><br><span class="line">          -Dversion=<span class="number">1.21</span></span><br><span class="line">$ cd test</span><br></pre></td></tr></table></figure>

<p>该命令将在当前目录下生成一个test文件夹(对应参数-DartifactId=test)，其中包含了定义该maven项目依赖的pom.xml文件，以及自动生成的测试文件src/main/org/sample/MyBenchmark.java(对应参数-DgroupId=org.sample)。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.sample;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.annotations.Benchmark;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBenchmark</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// This is a demo/sample template for building your JMH benchmarks. Edit as needed.</span></span><br><span class="line">        <span class="comment">// Put your benchmark code here.</span></span><br><span class="line">        <span class="comment">//测试新建异常对象的性能</span></span><br><span class="line">        <span class="keyword">new</span> Exception();</span><br><span class="line">        <span class="comment">//native方法调用的调用者或者参数会被识别为逃逸。  </span></span><br><span class="line">        <span class="comment">//Exception的构造器将间接调用至native方法fillInStackTrace中，该方法调用的调用者便是新建的Exception队形。  </span></span><br><span class="line">        <span class="comment">//逃逸分析将判定该新建对象逃逸，而即时编译器无法优化掉原本的新建对象操作。  </span></span><br><span class="line">        <span class="comment">//当Exception的构造器返回时，JVM将不再拥有指向这一新建对象的引用，该新建对象可以被垃圾回收。  </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Benchmark注解，标注的方法就是JMH基准测试的测试方法。该方法默认是空的，可以填入需要进行性能测试的业务逻辑。  </p>
<h3 id="编译和运行JMH项目"><a href="#编译和运行JMH项目" class="headerlink" title="编译和运行JMH项目"></a>编译和运行JMH项目</h3><p>JMH是利用注解处理器来自动生成性能测试的代码。除了@Benchmark之外，JMH的注解处理器还将处理所有位于org.openjdk.jmh.annotations包下的注解。  </p>
<h4 id="mvn-compile"><a href="#mvn-compile" class="headerlink" title="mvn compile"></a>mvn compile</h4><p>可以运行mvn compile命令来编译这个maven项目。该命令将生成target文件夹，其中的generated-sources目录存放着由JMH的注解处理器所生成的Java源代码：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ mvn compile</span><br><span class="line">$ ls target/generated-sources/annotations/org/sample/generated/</span><br><span class="line">MyBenchmark_jmhType.java            MyBenchmark_jmhType_B1.java         MyBenchmark_jmhType_B2.java         MyBenchmark_jmhType_B3.java         MyBenchmark_testMethod_jmhTest.java</span><br></pre></td></tr></table></figure>

<p>在这些源代码里，所有以MyBenchmark_jmhType为前缀的Java类都继承自MyBenchmark。这是注解处理器的常见用法，通过生成子类来将注解所带来的额外语义扩张成方法。  </p>
<p>它们之间的继承关系是MyBenchmark_jmhType-&gt;B3-&gt;B2-&gt;B1-&gt;MyBenchmark(A-&gt;B代表A继承B)。其中B2存放着JMH用来控制基准测试的各项字段。  </p>
<p>为了避免这些控制字段对MyBenchmark类中的字段造成false sharing的影响，JMH生成了B1和B3，分别存放了256个boolean字段，从而避免B2中的字段与MyBenchmark类、MyBenchmark_jmhType类中的字段(或内存里下一个对象中的字段)会出现在同一缓存行中。  </p>
<blockquote>
<p>因为JVM的字段重排列，所以不能在同一类中安排这些字段。类之间的继承关系，可以避免不同类所包含的字段之间的重排列。  </p>
</blockquote>
<p>除了jmhType源代码外，generated-source目录还存放着真正的性能测试代码MyBenchmark_testMethod_jmhTest.java。当进行性能测试时，JVM所运行的代码很有可能便是这一个源文件中的热循环经过OSR编译过后的代码。  </p>
<blockquote>
<p>在通过CompileCommand分析即时编译后的机器码时，需要关注的其实是MyBenchmark_testMethod_jmhTest中的方法。  </p>
</blockquote>
<h4 id="mvn-package"><a href="#mvn-package" class="headerlink" title="mvn package"></a>mvn package</h4><p>可以运行mvn package命令，将编译号的class文件打包成jar包。生成的jar包同样位于target目录下，名字为benchmarks.jar。jar包中附带了一系列配置文件。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        配置文件
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ mvn <span class="keyword">package</span></span><br><span class="line"></span><br><span class="line">$ jar tf target/benchmarks.jar META-INF</span><br><span class="line">META-INF/MANIFEST.MF</span><br><span class="line">META-INF/</span><br><span class="line">META-INF/BenchmarkList</span><br><span class="line">META-INF/CompilerHints</span><br><span class="line">META-INF/maven/</span><br><span class="line">META-INF/maven/org.sample/</span><br><span class="line">META-INF/maven/org.sample/test/</span><br><span class="line">META-INF/maven/org.sample/test/pom.xml</span><br><span class="line">META-INF/maven/org.sample/test/pom.properties</span><br><span class="line">META-INF/maven/org.openjdk.jmh/</span><br><span class="line">META-INF/maven/org.openjdk.jmh/jmh-core/</span><br><span class="line">META-INF/maven/org.openjdk.jmh/jmh-core/pom.xml</span><br><span class="line">META-INF/maven/org.openjdk.jmh/jmh-core/pom.properties</span><br><span class="line">META-INF/maven/net.sf.jopt-simple/</span><br><span class="line">META-INF/maven/net.sf.jopt-simple/jopt-simple/</span><br><span class="line">META-INF/maven/net.sf.jopt-simple/jopt-simple/pom.xml</span><br><span class="line">META-INF/maven/net.sf.jopt-simple/jopt-simple/pom.properties</span><br><span class="line">META-INF/LICENSE.txt</span><br><span class="line">META-INF/NOTICE.txt</span><br><span class="line">META-INF/maven/org.apache.commons/</span><br><span class="line">META-INF/maven/org.apache.commons/commons-math3/</span><br><span class="line">META-INF/maven/org.apache.commons/commons-math3/pom.xml</span><br><span class="line">META-INF/maven/org.apache.commons/commons-math3/pom.properties</span><br><span class="line"></span><br><span class="line">$ unzip -c target/benchmarks.jar META-INF/MANIFEST.MF</span><br><span class="line">Archive:  target/benchmarks.jar</span><br><span class="line">  inflating: META-INF/MANIFEST.MF    </span><br><span class="line">Manifest-Version: <span class="number">1.0</span></span><br><span class="line">Archiver-Version: Plexus Archiver</span><br><span class="line">Created-By: Apache Maven <span class="number">3.5</span><span class="number">.4</span></span><br><span class="line">Built-By: zhengy</span><br><span class="line">Build-Jdk: <span class="number">10.0</span><span class="number">.2</span></span><br><span class="line">Main-Class: org.openjdk.jmh.Main</span><br><span class="line"></span><br><span class="line">$ unzip -c target/benchmarks.jar META-INF/BenchmarkList</span><br><span class="line">Archive:  target/benchmarks.jar</span><br><span class="line">  inflating: META-INF/BenchmarkList  </span><br><span class="line">JMH S <span class="number">22</span> org.sample.MyBenchmark S <span class="number">51</span> org.sample.generated.MyBenchmark_testMethod_jmhTest S <span class="number">10</span> testMethod S <span class="number">10</span> Throughput E A <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> E E E E E E E E E E E E E E E E E</span><br><span class="line"></span><br><span class="line">$ unzip -c target/benchmarks.jar META-INF/CompilerHints</span><br><span class="line">Archive:  target/benchmarks.jar</span><br><span class="line">  inflating: META-INF/CompilerHints  </span><br><span class="line">dontinline,*.*_all_jmhStub</span><br><span class="line">dontinline,*.*_avgt_jmhStub</span><br><span class="line">dontinline,*.*_sample_jmhStub</span><br><span class="line">dontinline,*.*_ss_jmhStub</span><br><span class="line">dontinline,*.*_thrpt_jmhStub</span><br><span class="line">inline,org/sample/MyBenchmark.testMethod</span><br></pre></td></tr></table></figure>
    </div>
</div>

<p>其中三个配置文件：  </p>
<ul>
<li>MANIFEST.MF中指定了该jar包的默认入口，即org.openjdk.jmh.Main。  </li>
<li>BenchmarkList中存放了测试配置。该配置是根据MyBenchmark.java里的注解自动生成的。  </li>
<li>CompilerHints中存放了传递给JVM的-XX:CompileCommandFile参数的内容。它规定了无法内联以及必须内联的几个方法，其中便有存放业务逻辑的测试方法testMethod。  </li>
</ul>
<p>在编译MyBenchmark_testMethod_jmhTest类中的测试方法时，JMH会让即时编译器强制内联对MyBenchmark.testMethod的方法调用，以避免调用开销。  </p>
<p>打包生成的jar包可以直接运行。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ java -jar target/benchmarks.jar</span><br><span class="line">WARNING: An illegal reflective access operation has occurred</span><br><span class="line">...</span><br><span class="line">Benchmark                Mode  Cnt        Score      Error  Units</span><br><span class="line">MyBenchmark.testMethod  thrpt   <span class="number">25</span>  <span class="number">1004801</span>,<span class="number">393</span> ± <span class="number">4055</span>,<span class="number">462</span>  ops/s</span><br></pre></td></tr></table></figure>

<p>输出的最后便是本次基准测试的结果。其中比较重要的两项指标是Score和Error，分别代表本次基准测试的平局吞吐量(每秒运行testMethod方法的次数)以及误差范围。(本次基准测试平均每秒生成10^6个异常实例，误差范围大致在4000个异常实例)  </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Java程序的性能测试存在着许多深坑，有来自JVM的，有来自操作系统的，甚至有来自硬件系统的。性能测试的结果很有可能是有偏差的。  </p>
<p>性能基准测试框架JMH是OpenJDK中的其中一个开源项目。它内置了许多功能，来规避由JVM中的即时编译器或者其它优化对性能测试造成的影响。它还提供了不少策略来降低来自操作系统以及硬件系统的影响。  </p>
<p>开发人员仅需要将所要测试的业务逻辑通过@Benchmark注解，便可以让JMH的注解处理器自动生成真正的性能测试代码，以及相应的性能测试配置文件。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>循环优化</title>
    <url>/JVM/%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>JVM中即时编译器面向循环的编译优化。  </p>
<h3 id="循环无关代码外提"><a href="#循环无关代码外提" class="headerlink" title="循环无关代码外提"></a>循环无关代码外提</h3><p>所谓的循环无关代码(Loop-invariant Code)，指的是循环中值不变的表达式。如果能够在不改变程序语义的情况下，将这些循环无关代码提出循环之外，那么程序便可以便便重复执行这些表达式，从而达到性能提升的效果。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        sum += x * y + a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对应的字节码</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>[])</span></span>;</span><br><span class="line">    code:</span><br><span class="line">        <span class="number">0</span>: iconst_0</span><br><span class="line">        <span class="number">1</span>: istore <span class="number">4</span></span><br><span class="line">        <span class="number">3</span>: iconst_0</span><br><span class="line">        <span class="number">4</span>: istore <span class="number">5</span></span><br><span class="line">        <span class="number">6</span>: goto <span class="number">25</span></span><br><span class="line"><span class="comment">//循环体开始</span></span><br><span class="line">        <span class="number">9</span>: iload <span class="number">4</span>          <span class="comment">//load sum</span></span><br><span class="line">        <span class="number">11</span>:iload_1          <span class="comment">//load x</span></span><br><span class="line">        <span class="number">12</span>:iload_2          <span class="comment">//load y</span></span><br><span class="line">        <span class="number">13</span>:imul             <span class="comment">//x*y</span></span><br><span class="line">        <span class="number">14</span>:aload_3          <span class="comment">//load a</span></span><br><span class="line">        <span class="number">15</span>:iload <span class="number">5</span>          <span class="comment">//load i</span></span><br><span class="line">        <span class="number">17</span>:iaload           <span class="comment">//a[i]</span></span><br><span class="line">        <span class="number">18</span>:iadd             <span class="comment">//x*y + a[i]</span></span><br><span class="line">        <span class="number">19</span>:iadd             <span class="comment">//sum+(x*y+a[i])</span></span><br><span class="line">        <span class="number">20</span>:istore <span class="number">4</span>         <span class="comment">//sum=sum+(x*y+a[i])</span></span><br><span class="line">        <span class="number">22</span>:iinc <span class="number">5</span>,<span class="number">1</span>         <span class="comment">//i++</span></span><br><span class="line">        <span class="number">25</span>:iload <span class="number">5</span>          <span class="comment">//load i</span></span><br><span class="line">        <span class="number">27</span>:aload_3          <span class="comment">//load a</span></span><br><span class="line">        <span class="number">28</span>:arraylength      <span class="comment">//a.length</span></span><br><span class="line">        <span class="number">29</span>:if_icmplt <span class="number">9</span>      <span class="comment">//i&lt;a.length</span></span><br><span class="line"><span class="comment">//循环体结束</span></span><br><span class="line">        <span class="number">32</span>:iload <span class="number">4</span></span><br><span class="line">        <span class="number">34</span>:ireturn</span><br></pre></td></tr></table></figure>

<p>上述代码中，循环体中的表达式x*y，以及循环判断条件中的a.length均属于循环不变代码。前者是一个整数乘法运算，而后者则是内存访问操作，读取数组对象a的长度。(数组的长度存放于数组对象的对象头中，可通过arraylength指令来访问。)  </p>
<p>理想情况下，上述代码经过循环无关代码外提之后，等同于下面这一手工优化版本。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fooManualOpt</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> t0 = x * y;</span><br><span class="line">    <span class="keyword">int</span> t1 = a.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t1; i++) &#123;</span><br><span class="line">        sum += t0 + a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论是乘法运算x*y，还是内存访问a.length，现在都在循环之前完成。原本循环中需要执行这两个表达式的地方，现在直接使用循环之前这两个表达式的执行结果。(借助Sea-of-Nodes IR实现循环无关代码外提比较简便)  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0x02f0</span>: mov edi,ebx         <span class="comment">//ebx存放着x*y的结果</span></span><br><span class="line"><span class="number">0x02f2</span>: add edi,DWORD PTR [r8+r9*<span class="number">4</span>+<span class="number">0x10</span>]</span><br><span class="line">                            <span class="comment">//[r8+r9*4+0x10]即a[i]</span></span><br><span class="line">                            <span class="comment">//r8指向a,r9d存放着i</span></span><br><span class="line"><span class="number">0x02f7</span>: add eax,edi         <span class="comment">//eax存放着sum</span></span><br><span class="line"><span class="number">0x02f9</span>: inc r9d             <span class="comment">//i++</span></span><br><span class="line"><span class="number">0x02fc</span>: cmp r9d,r10d        <span class="comment">//i&lt;a.length//r10d存放着a.length</span></span><br><span class="line"><span class="number">0x02ff</span>: jl <span class="number">0x02f0</span></span><br></pre></td></tr></table></figure>

<p>上述机器码是foo方法的编译结果中的循环。这里面么有整数乘法指令，也没有读取数组长度的内存访问指令。它们的值已在循环之前计算好了，并且分别保存在寄存器ebx以及r10d之中。在循环之中，代码直接使用寄存器ebx以及r10d所保存的值，而不用在循环中反复计算。  </p>
<p>从省城的机器码中可以看出，除了x*y和a.length的外提之外，即时编译器还外提了int数组加载指令iaload所暗含的null检测(null check)以及下标范围检测(range check)。  </p>
<p>如果将iaload指令想象成一个接收数组对象以及下标作为参数，并且返回对应数组元素的方法，那么它的伪代码如下所示：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">iaload</span><span class="params">(<span class="keyword">int</span>[] arrayRef, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arrayRef == <span class="keyword">null</span>) &#123;<span class="comment">//null检测</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= arrayRef.length) &#123;<span class="comment">//下标范围检测</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arrayRef[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>foo方法中的null检测属于循环无关代码。这是因为它始终检测作为输入参数的int数组是否为null，而这与第几次循环无关。  </p>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="keyword">null</span>) &#123;<span class="comment">//null check</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= a.length) &#123;<span class="comment">//range check</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundException();</span><br><span class="line">        &#125;</span><br><span class="line">        sum += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，null检测涉及了控制流依赖，因而无法通过Sea-of-Nodes IR转换以及节点调度来完成外提。  </p>
<p>在C2中，null检测的外提是通过额外的编译优化，也就是循环预测(Loop Prediction,对应虚拟机参数-XX:+UseLoopPredicate)来实现的。该优化的实际做法是在循环之前插入同样的检测代码，并在命中的时候进行去优化。这样一来，循环中的检测代码便会被归纳并消除掉。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="keyword">null</span>) &#123;</span><br><span class="line">        deoptimize();<span class="comment">//never returns</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="keyword">null</span>) &#123;<span class="comment">//now evluate to false</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= a.length) &#123;<span class="comment">//range check</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException();</span><br><span class="line">        &#125;</span><br><span class="line">        sum += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了null检测之外，其他循环无关检测都能够按照这种方式外提至循环之前。甚至是循环有关的下标范围检测，都能够借助循环预测来外提，只不过具体的转换要复杂一些。(检测的主题是循环控制变量i，[0,a.length]，它的值将随着循环次数的增加而改变。)  </p>
<p>下标范围检测是循环有关的，检测的主体是循环控制变量i(取值范围[0，a.length])，它的值将随着循环次数的增加而改变。外提下标范围检测之后，无法再引用到循环变量i，因此，即时编译器需要转换检测条件。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = INIT; i &lt; LIMIT; i += STRIDE) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= a.length) &#123;<span class="comment">//range check</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException();</span><br><span class="line">    &#125;</span><br><span class="line">    sum += a[i];</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line"><span class="comment">//经过下标范围检测外提之后：</span></span><br><span class="line"><span class="keyword">if</span>(INIT &lt; <span class="number">0</span> || IMAX &gt;= a.length) &#123;</span><br><span class="line">    <span class="comment">//IMAX是i所能达到的最大值，它不一定是LIMIT-1</span></span><br><span class="line">    detopimize();<span class="comment">//never returns</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = INIT; i &lt; LIMIT; i += STRIDE) &#123;</span><br><span class="line">    sum += a[i];<span class="comment">//不包含下标范围检测</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="循环展开"><a href="#循环展开" class="headerlink" title="循环展开"></a>循环展开</h3><p>循环展开(Loop Unrolling)。指的是在循环体中重复多次循环迭代，并减少循环次数的编译优化。(在默认情况下，即时编译器仅能将循环展开60次-XX:LoopUnrollLimit)  </p>
<p>在C2中，只有计数循环(Counted Loop)才能被展开。所谓计数循环需要满足四个条件：  </p>
<ul>
<li>维护一个循环计数器，并且基于计数器的循环出口只有一个(但可以有基于其他判断条件的出口)。</li>
<li>循环计数器的类型为int、short或者char(即不能是byte、long，更不能是float或者double)。(循环变量改为long类型，可以“避免”这个优化)  </li>
<li>每个迭代循环计数器的增量为常数。</li>
<li>循环计数器的上限(增量为正数)或下限(增量为负数)是循环无关的数值。  </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = START; i &lt; LIMIT; i += STRIDE) &#123;...&#125;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">int</span> i = START;</span><br><span class="line"><span class="keyword">while</span>(i &lt; LIMIT) &#123;</span><br><span class="line">    ..</span><br><span class="line">    i += STRIDE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面两种循环中，只要LIMIT是循环无关的数值，STRIDE是常数，而且循环中除了i&lt;LIMIT之外没有其他基于循环变量i的循环出口，那么C2便会将该循环识别为计数循环。  </p>
<p>缺点：它可能会增减代码的冗余度，导致所生成机器码的长度大幅上涨。  </p>
<p>优点：随着循环体的增大，优化机会也会不断增加。一旦循环展开能够触发进一步的优化，总体的代码复杂度也将降低。  </p>
<p>循环展开有一种特殊情况，完全展开(Full Unroll)。当循环的数目是固定值而且非常小时，即时编译器会将循环全部展开。此时，原本循环中的循环判断语句将不复存在，取而代之的是若干个顺序执行的循环体。  </p>
<p>即时编译器会在循环体的大小与循环展开次数之间做出权衡。对于仅迭代三次(或以下)的循环，即时编译器将进行完全展开；对于循环体IR节点数据超过阈值的循环，即时编译器则不会进行任何循环展开。  </p>
<h3 id="其他循环优化"><a href="#其他循环优化" class="headerlink" title="其他循环优化"></a>其他循环优化</h3><h4 id="循环判断外提"><a href="#循环判断外提" class="headerlink" title="循环判断外提"></a>循环判断外提</h4><p>循环判断外提(loop unswitching)指的是将循环中的if语句外提至循环之前，并且在该if语句的两个分支中分别放置一份循环代码。  </p>
<p>循环判断外提与循环无关检测外提所针对的代码模式比较类似，都是循环中的if语句。不同的是，后者在检查失败时会抛出异常，中止当前的正常执行路径；而前者所针对的是更加常见的情况，即通过if语句的不同分支执行不同的代码逻辑。  </p>
<h4 id="循环剥离"><a href="#循环剥离" class="headerlink" title="循环剥离"></a>循环剥离</h4><p>循环剥离(loop peeling)指的是将循环的前几个迭代或者后几个迭代剥离出循环的优化方式。一般来说，循环的前几个迭代或者后几个迭代都包含特殊处理。通过将这几个特殊的迭代剥离出去，可以使原本的循环体的规律性更加明显，从而触发进一步的优化。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>循环无关代码外提将循环中值不变的表达式，或者循环无关检测外提至循环之前，以避免在循环中重复进行冗余计算。前者是通过Sea-of-Nodes IR以及节点调度来共同完成的，而后者则是通过一个独立优化–循环预测来完成的，循环预测还可以外提循环有关的数组下标范围检测。  </p>
<p>循环展开是一种在循环中重复多次迭代，并且相应的减少循环次数的优化方式。它是一种以空间换时间的优化方式，通过增大循环体来获取更多的优化机会。循环展开的特殊形式是完全展开，将原本的循环转换成若干个循环体的顺序执行。  </p>
<p>其他：循环判断外提、循环剥离</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>JVM的监控及诊断工具(命令行)</title>
    <url>/JVM/JVM%E7%9A%84%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-%E5%91%BD%E4%BB%A4%E8%A1%8C/</url>
    <content><![CDATA[<h3 id="jps-JVM-Process-Status-Tool"><a href="#jps-JVM-Process-Status-Tool" class="headerlink" title="jps(JVM Process Status Tool)"></a>jps(JVM Process Status Tool)</h3><p>ps命令，打印所有正在运行的进程的相关信息。<br>JDK中的jps命令，打印所有正在运行的Java进程的相关信息。  </p>
<p>在默认情况下，jps的输出信息包括Java进程的进程ID以及主类名。可以通过追加参数，来打印额外的信息。<br>-l将打印模块名以及包名；<br>-v将打印传递给JVM的参数(如-XX:UnlockExperimentalVMOptions -XX:UseZGC)；<br>-m将打印传递给主类的参数。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ jps -mlv</span><br><span class="line"><span class="number">18331</span> org.example.Foo Hello World</span><br><span class="line"><span class="number">18332</span> jdk.jcmd/sun.tools.jps.Jps -mlv -Dapplication.home=/Library/Java/JavaVirtualMachines/jdk-<span class="number">11</span>.jdk/Contents/Home -Xms8m -Djdk.<span class="keyword">module</span>.main=jdk.jcmd</span><br></pre></td></tr></table></figure>

<p>如果某Java进程关闭了默认开启的UsePerfData参数(即使用参数-XX:-UsePerfData)，那么jps命令(以及jstat)将无法探知该Java进程。  </p>
<p>当获得Java进程的进程ID之后，便可以调用各项监控及诊断工具了。  </p>
<h3 id="jstat-JVM-Statics-Monitoring"><a href="#jstat-JVM-Statics-Monitoring" class="headerlink" title="jstat(JVM Statics Monitoring)"></a>jstat(JVM Statics Monitoring)</h3><p>jstat命令可用来打印目标<strong>Java进程的性能数据</strong>。它包括多条子命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jstat -options</span></span><br><span class="line">-class</span><br><span class="line">-compiler</span><br><span class="line">-gc</span><br><span class="line">-gccapacity</span><br><span class="line">-gccause</span><br><span class="line">-gcmetacapacity</span><br><span class="line">-gcnew</span><br><span class="line">-gcnewcapacity</span><br><span class="line">-gcold</span><br><span class="line">-gcoldcapacity</span><br><span class="line">-gcutil</span><br><span class="line">-printcompilation</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -class将打印类加载相关的数据。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -compiler和-printcompilation将打印即时编译相关的数据。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 以-gc为前缀的子命令，将打印垃圾回收相关的数据。</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，jstat只会打印一次性能数据。可以将它配置为每隔一段时间打印一次，直至目标Java进程终止，或者达到所配置的最大打印次数。  </p>
<h4 id="CMC垃圾回收器"><a href="#CMC垃圾回收器" class="headerlink" title="CMC垃圾回收器"></a>CMC垃圾回收器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Usage: jstat -outputOptions [-t] [-hlines] VMID [interval [count]]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> jstat -gc 22126 1s 4</span></span><br><span class="line">S0C     S1C     S0U    S1U    EC       EU        OC         OU        MC      MU      CCSC   CCSU       YGC   YGCT    FGC    FGCT    CGC    CGCT     GCT   </span><br><span class="line">17472,0 17472,0  0,0    0,0   139904,0 47146,4   349568,0   21321,0   30020,0 28001,8 4864,0 4673,4     22    0,080   3      0,270   0      0,000    0,350</span><br><span class="line">17472,0 17472,0 420,6   0,0   139904,0 11178,4   349568,0   21321,0   30020,0 28090,1 4864,0 4674,2     28    0,084   3      0,270   0      0,000    0,354</span><br><span class="line">17472,0 17472,0  0,0   403,9  139904,0 139538,4  349568,0   21323,4   30020,0 28137,2 4864,0 4674,2     34    0,088   4      0,359   0      0,000    0,446</span><br><span class="line">17472,0 17472,0  0,0    0,0   139904,0   0,0     349568,0   21326,1   30020,0 28093,6 4864,0 4673,4     38    0,091   5      0,445   0      0,000    0,536</span><br><span class="line"><span class="meta">#</span><span class="bash"> 当监控本地环境的Java进程时，VMID可以简单理解为PID。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果需要监控远程环境的Java进程，参考jstat的帮助文档。</span></span><br></pre></td></tr></table></figure>

<p>示例中，22126进程是一个使用了CMS垃圾回收器的Java进程。利用jstat的-gc命令，来打印该进程垃圾回收相关的数据。命令最后的1s 4表示每隔1秒打印一次，共打印4次。  </p>
<p>在-gc子命令的输出中，前四列分别为两个Survivor区的容量(Capacity)和已使用量(Utility)。这两个Survivor区的容量相等，而且始终有一个Survivor区的内存使用量为0。  </p>
<h4 id="G1垃圾回收器"><a href="#G1垃圾回收器" class="headerlink" title="G1垃圾回收器"></a>G1垃圾回收器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jstat -gc 22208 1s</span></span><br><span class="line">S0C   S1C      S0U   S1U     EC       EU        OC         OU       MC      MU      CCSC   CCSU       YGC   YGCT    FGC    FGCT    CGC    CGCT     GCT   </span><br><span class="line">0,0   16384,0  0,0   16384,0 210944,0 192512,0  133120,0   5332,5   28848,0 26886,4 4864,0 4620,5     19    0,067   1      0,016   2      0,002    0,084</span><br><span class="line">0,0   16384,0  0,0   16384,0 210944,0 83968,0   133120,0   5749,9   29104,0 27132,8 4864,0 4621,0     21    0,078   1      0,016   2      0,002    0,095</span><br><span class="line">0,0   0,0      0,0   0,0     71680,0  18432,0   45056,0    20285,1  29872,0 27952,4 4864,0 4671,6     23    0,089   2      0,063   2      0,002    0,153</span><br><span class="line">0,0   2048,0   0,0   2048,0  69632,0  28672,0   45056,0    18608,1  30128,0 28030,4 4864,0 4672,4     32    0,093   2      0,063   2      0,002    0,158</span><br><span class="line">···</span><br></pre></td></tr></table></figure>

<p>示例中，jstat每隔1s打印垃圾回收的信息，并且不断重复下去。  </p>
<p>S0C和S0U始终为0，而且另一个Survivor区的容量(S1C)可能会下降至0。这是因为当使用G1 GC时，JVM不再设置Eden区、Survivor区、老年代区的内存边界，而是将堆划分为若干个等长内存区域。每个内存区域都可以作为Eden区、Survivor区以及老年代区的任一种，并且可以在不同区域类型之间来回切换。  </p>
<p>换句话说，逻辑上只有一个Survivor区。当需要迁移Survivor区中的数据时(Copying GC)，只需要另外申请一个或多个内存区域，作为新的Survivor区。  </p>
<p>因此JVM决定在使用G1 GC时，将所有Survivor内存区域的总容量以及已使用量存放至S1C和S1U中，而S0C和S0U则被设置为0。当发生垃圾回收时，JVM可能出现Survivor内存区域内的对象全被回收或者晋升的现象。在这种情况下，JVM会将这块内存区域回收，并标记为可分配的状态。这样子做的结果是，堆中可能完全没有Survivor内存区域，因而相应的S1C和S1U将会是0。  </p>
<h4 id="t"><a href="#t" class="headerlink" title="-t"></a>-t</h4><p>将在每行数据之前打印目标Java进程的启动时间。  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jstat -gc -t 22407</span></span><br><span class="line">Timestamp        S0C    S1C    S0U    S1U   EC       EU        OC         OU        MC      MU      CCSC   CCSU       YGC   YGCT    FGC    FGCT    CGC    CGCT     GCT   </span><br><span class="line">10,7             0,0    0,0    0,0    0,0   55296,0  45056,0   34816,0    20267,8   30128,0 27975,3 4864,0 4671,6     33    0,086   3      0,111   2      0,001    0,198</span><br></pre></td></tr></table></figure>

<p>S0C:第一个幸存区大小<br>S1C:第二个幸存区大小<br>S0U:第一个幸存区使用大小<br>S1U:第二个幸存区使用大小<br>EC:伊甸园区的大小<br>EU:伊甸园区的使用大小<br>OC:老年代大小<br>OU:老年代使用大小<br>MC:方法区大小<br>MU:方法取使用大小<br>CCSC:压缩类空间大小<br>CCSU:压缩类空间使用大小<br>YGC:年轻代垃圾回收次数<br>YGCT:年轻代垃圾回收消耗时间<br>FGC:老年代垃圾回收次数<br>FGCT:老年代垃圾回收消耗时间<br>GCT:垃圾回收消耗总时间  </p>
<p>可以比较Java进程的启动弄时间以及总GC时间(GCT)，或者两次测量的间隔时间以及总GC时间的增量，来得出GC时间占运行时间的比例。  </p>
<p>如果该比例超过20%，则说明目前堆的压力较大；如果该比例超过90%，则说明堆里几乎没有可用空间，随时都可能抛出OOM异常。  </p>
<hr>
<p>jstat还可以用来判断是否出现内存泄漏。在长时间运行的Java程序中，可以运行jstat命令连续获取多行性能数据，并取这几行数据中OU列(即已占用的老年代内存)的最小值。  </p>
<p>然后每个一段较长的时间重复一次上述操作，来获得多组OU最小值。如果这些值呈上涨趋势，则说明该Java程序的老年代内存已使用量在不断上涨，这意味着无法回收的对象在不断增加，因此很有可能存在内存泄漏。  </p>
<p>CGC和CGCT分别代表并发GC Stop-The-World的次数和时间。  </p>
<h3 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3><p>jmap命令，可以分析<strong>JVM堆中的对象</strong>。包括多条子命令：  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-clstats 打印被加载类的信息</span><br><span class="line">-finalizerinfo 打印所有待finalize的对象</span><br><span class="line">-histo 统计各个类的实例数目以及占用内存，并按照内存使用量从多至少的顺序排列。(-histo:live只统计堆中的存活对象)</span><br><span class="line">-dump 导出JVM堆的快照。(-dump:live只保存堆中的存活对象)</span><br></pre></td></tr></table></figure>

<p>通常利用jmap -dump:live,format=b,file=filename.bin命令，将堆中所有存活对象导出至一个文件之中。  </p>
<blockquote>
<p>format=b将使jmap导出与hprof(Java9中已被移除)、-XX:+HeapDumpAfterFullGC、-XX:+HeapDumpOnOutOfMemoryError格式一致的文件。这种格式的文件可以被其它GUI工具查看。  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> jmap -histo 22574</span></span><br><span class="line"> num     #instances         #bytes  class name (module)</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">   1:        500004       20000160  org.python.core.PyComplex</span><br><span class="line">   2:        570866       18267712  org.python.core.PyFloat</span><br><span class="line">   3:        360295       18027024  [B (java.base@11)</span><br><span class="line">   4:        339394       11429680  [Lorg.python.core.PyObject;</span><br><span class="line">   5:        308637       11194264  [Ljava.lang.Object; (java.base@11)</span><br><span class="line">   6:        301378        9291664  [I (java.base@11)</span><br><span class="line">   7:        225103        9004120  java.math.BigInteger (java.base@11)</span><br><span class="line">   8:        507362        8117792  org.python.core.PySequence$1</span><br><span class="line">   9:        285009        6840216  org.python.core.PyLong</span><br><span class="line">  10:        282908        6789792  java.lang.String (java.base@11)</span><br><span class="line">  ...</span><br><span class="line">2281:             1             16  traceback$py</span><br><span class="line">2282:             1             16  unicodedata$py</span><br><span class="line">Total       5151277      167944400</span><br></pre></td></tr></table></figure>

<p>jmap将访问堆中的所有对象，为了保证在此过程中不被应用线程干扰，jmap需要借助安全点机制，让所有线程停留在不改变堆中数据的状态。即由jmap导出的堆快照必定是安全点位置的。这可能导致基于该堆快照的分析结果存在偏差。(例，假设在编译生成的机器码中，某些对象的生命周期在两个安全点之间，那么:live选项将无法探知到这些对象)  </p>
<p>另外，如果某个线程长时间无法跑到安全点，jmap将一直等下去。(jstat则不同，垃圾回收器会主动将jstat所需要的摘要数据保存至固定位置之中，而jstat只需要直接读取即可)  </p>
<p>jmap(以及jinfo、jstack、jcmd)依赖于JVM的Attach API，因此只能监控本地Java进程。  </p>
<p>一旦开启JVM参数DisableAttachMechanism(使用参数-XX:+DisableAttachMechanism)，基于Attach API的命令将无法执行。<br>如果不想被其它进程监控，需要开启该参数。  </p>
<h3 id="jinfo-Java-Configuration-Info"><a href="#jinfo-Java-Configuration-Info" class="headerlink" title="jinfo(Java Configuration Info)"></a>jinfo(Java Configuration Info)</h3><p>jinfo命令可用来查看目标<strong>Java进程的参数</strong>，如传递给JVM的-X(输出中的jvm_args)、-XX参数(输出中的VM Flags)，以及可在Java层面通过System.getProperty获取的-D参数(输出中的System Properties)。  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jinfo 31185</span></span><br><span class="line">Java System Properties:</span><br><span class="line"></span><br><span class="line">gopherProxySet=false</span><br><span class="line">awt.toolkit=sun.lwawt.macosx.LWCToolkit</span><br><span class="line">java.specification.version=11</span><br><span class="line">sun.cpu.isalist=</span><br><span class="line">sun.jnu.encoding=UTF-8</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">VM Flags:</span><br><span class="line">-XX:CICompilerCount=4 -XX:ConcGCThreads=3 -XX:G1ConcRefinementThreads=10 -XX:G1HeapRegionSize=2097152 -XX:GCDrainStackTargetSize=64 -XX:InitialHeapSize=536870912 -XX:MarkStackSize=4194304 -XX:MaxHeapSize=8589934592 -XX:MaxNewSize=5152702464 -XX:MinHeapDeltaBytes=2097152 -XX:NonNMethodCodeHeapSize=5835340 -XX:NonProfiledCodeHeapSize=122911450 -XX:ProfiledCodeHeapSize=122911450 -XX:ReservedCodeCacheSize=251658240 -XX:+SegmentedCodeCache -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseG1GC</span><br><span class="line"></span><br><span class="line">VM Arguments:</span><br><span class="line">jvm_args: -Xlog:gc -Xmx1024m</span><br><span class="line">java_command: org.example.Foo</span><br><span class="line">java_class_path (initial): .</span><br><span class="line">Launcher Type: SUN_STANDARD</span><br></pre></td></tr></table></figure>

<hr>
<p>jinfo还可以用来修改目标Java进程的”manageable”虚拟机参数。  </p>
<p>可以使用jinfo -flag +HeapDumpAfterFullGC <PID>命令，开启<PID>所指定的Java进程的HeapDumpAfterFullGC参数。  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 其他manageable虚拟机参数</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> java -XX:+PrintFlagsFinal -version | grep manageable   </span></span><br><span class="line">     intx CMSAbortablePrecleanWaitMillis           = 100                                    &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">     intx CMSTriggerInterval                       = -1                                     &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">     intx CMSWaitDuration                          = 2000                                   &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">     bool HeapDumpAfterFullGC                      = false                                  &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">     bool HeapDumpBeforeFullGC                     = false                                  &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">     bool HeapDumpOnOutOfMemoryError               = false                                  &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">    ccstr HeapDumpPath                             =                                        &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">    uintx MaxHeapFreeRatio                         = 70                                     &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">    uintx MinHeapFreeRatio                         = 40                                     &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">     bool PrintClassHistogram                      = false                                  &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">     bool PrintConcurrentLocks                     = false                                  &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">java version "11" 2018-09-25</span><br><span class="line">Java(TM) SE Runtime Environment 18.9 (build 11+28)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11+28, mixed mode)</span><br></pre></td></tr></table></figure>

<h3 id="jstack-Java-Stack-Trace"><a href="#jstack-Java-Stack-Trace" class="headerlink" title="jstack(Java Stack Trace)"></a>jstack(Java Stack Trace)</h3><p>jstack命令可以用来打印目标Java进程中各个<strong>线程的栈轨迹</strong>，以及这些<strong>线程所持有的锁</strong>。  </p>
<p>jstack的其中一个应用场景便是死锁检测。  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jstack 31634</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">"Thread-0" #12 prio=5 os_prio=31 cpu=1.32ms elapsed=34.24s tid=0x00007fb08601c800 nid=0x5d03 waiting for monitor entry  [0x000070000bc7e000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line"> at DeadLock.foo(DeadLock.java:18)</span><br><span class="line"> - waiting to lock &lt;0x000000061ff904c0&gt; (a java.lang.Object)</span><br><span class="line"> - locked &lt;0x000000061ff904b0&gt; (a java.lang.Object)</span><br><span class="line"> at DeadLock$$Lambda$1/0x0000000800060840.run(Unknown Source)</span><br><span class="line"> at java.lang.Thread.run(java.base@11/Thread.java:834)</span><br><span class="line"></span><br><span class="line">"Thread-1" #13 prio=5 os_prio=31 cpu=1.43ms elapsed=34.24s tid=0x00007fb08601f800 nid=0x5f03 waiting for monitor entry  [0x000070000bd81000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line"> at DeadLock.bar(DeadLock.java:33)</span><br><span class="line"> - waiting to lock &lt;0x000000061ff904b0&gt; (a java.lang.Object)</span><br><span class="line"> - locked &lt;0x000000061ff904c0&gt; (a java.lang.Object)</span><br><span class="line"> at DeadLock$$Lambda$2/0x0000000800063040.run(Unknown Source)</span><br><span class="line"> at java.lang.Thread.run(java.base@11/Thread.java:834)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">JNI global refs: 6, weak refs: 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line">"Thread-0":</span><br><span class="line">  waiting to lock monitor 0x00007fb083015900 (object 0x000000061ff904c0, a java.lang.Object),</span><br><span class="line">  which is held by "Thread-1"</span><br><span class="line">"Thread-1":</span><br><span class="line">  waiting to lock monitor 0x00007fb083015800 (object 0x000000061ff904b0, a java.lang.Object),</span><br><span class="line">  which is held by "Thread-0"</span><br><span class="line"></span><br><span class="line">Java stack information for the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line">"Thread-0":</span><br><span class="line"> at DeadLock.foo(DeadLock.java:18)</span><br><span class="line"> - waiting to lock &lt;0x000000061ff904c0&gt; (a java.lang.Object)</span><br><span class="line"> - locked &lt;0x000000061ff904b0&gt; (a java.lang.Object)</span><br><span class="line"> at DeadLock$$Lambda$1/0x0000000800060840.run(Unknown Source)</span><br><span class="line"> at java.lang.Thread.run(java.base@11/Thread.java:834)</span><br><span class="line">"Thread-1":</span><br><span class="line"> at DeadLock.bar(DeadLock.java:33)</span><br><span class="line"> - waiting to lock &lt;0x000000061ff904b0&gt; (a java.lang.Object)</span><br><span class="line"> - locked &lt;0x000000061ff904c0&gt; (a java.lang.Object)</span><br><span class="line"> at DeadLock$$Lambda$2/0x0000000800063040.run(Unknown Source)</span><br><span class="line"> at java.lang.Thread.run(java.base@11/Thread.java:834)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure>

<p>jstack不仅会打印线程的栈轨迹、线程状态(BLOCKED)、持有的锁(locked…)以及正在请求的锁(waiting to lock…)，而且还会分析出具体的死锁。  </p>
<h3 id="jcmd"><a href="#jcmd" class="headerlink" title="jcmd"></a>jcmd</h3><p>可以直接使用jcmd命令，替代前面除了jstat之外的所有命令。  </p>
<p>jcmd复制了jstat的部分代码，并支持通过PerfCounter.print子命令来打印所有的Performance Counter，但是没有保留jstat的输出格式，也没有重复打印的功能。  </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>jps将打印所有正在运行的Java进程。  </li>
<li>jstat允许用户查看目标Java进程的类加载、即时编译以及<strong>垃圾回收</strong>相关的信息。它常用于检测垃圾回收问题以及内存泄漏问题。  </li>
<li>jmap允许用户统计目标Java进程的<strong>堆</strong>中存放的Java对象，并将它们导出成二进制文件。  </li>
<li>jinfo将打印目标Java进程的配置参数，并能够改动其中manageable的参数。  </li>
<li>jstack将打印目标Java进程中各个线程的<strong>栈</strong>轨迹、线程状态、锁状况等信息。它还将自动检测死锁。  </li>
<li>jcmd是一把瑞士军刀，可以用来实现除了jstat之外所有命令的功能。  </li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>Java Agent与字节码注入</title>
    <url>/JVM/Java-Agent%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h3 id="Java-agent"><a href="#Java-agent" class="headerlink" title="Java agent"></a>Java agent</h3><p>premain方法指的是在main方法之前执行的方法。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAgent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"premain"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中定义了一个premain方法。需要注意的是，JVM所能识别的premain方法接收的是字符串类型的参数，而并非类似于main方法的字符串数组。  </p>
<p>为了能够以Java agent的方式运行该premain方法，需要将其打包成jar包，并在其中的MANIFEST.MF配置文件中，指定所谓的Premain-class。具体命令如下：  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 注意第一条命令会向manifest.txt文件写入两行数据，其中包括一行空行  </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'Premain-Class: org.example.MyAgent'</span> &gt; manifest.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> jar cvmf manifest.txt myagent.jar org/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> java -javaagent:myagent.jar HelloWorld</span></span><br><span class="line">premain</span><br><span class="line">Hello, World</span><br></pre></td></tr></table></figure>

<p>除了在命令行中指定Java agent之外，还可以通过Attach API远程加载。具体用法如下：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.attach.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AttachTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> <span class="keyword">throws</span> AttachNotSupportedException, IOException, AgentLoadException, AgentInitializationException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Usage: java AttachTest &lt;PID&gt; /PATH/TO/AGENT.jar"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        VirtualMachine vm = VirtualMachine.attach(args[<span class="number">0</span>]);</span><br><span class="line">        vm.loadAgent(args[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Attach API远程加载的Java agent不会再先于main方法执行，这取决于另一虚拟机调用Attach API的时机。并且，它运行的也不再是premain方法，而是名为agentmain的方法。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAgent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span><span class="params">(String args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"agentmain"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相应的，需要更新jar包中的manifest文件，使其包含Agent-Class的配置，如Agent-Class: org.example.MyAgent。  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> exho <span class="string">'Agent-Class: org.example.MyAgent'</span> &gt; manifest.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> jar cvmf manifest.txt myagent.jar org/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> java HelloWorld</span></span><br><span class="line">Hello, World</span><br><span class="line"><span class="meta">$</span><span class="bash"> jps</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> java AttachTest &lt;pid&gt; myagent.jar</span></span><br><span class="line">agentmain</span><br><span class="line"><span class="meta">#</span><span class="bash"> 最后一句输出来自于运行HelloWorld的Java进程</span></span><br></pre></td></tr></table></figure>

<p>JVM并不限制Java agent的数量。可以在java命令后附上多个-javaagent参数，或者远程attach多个Java agent，JVM会按照定义顺序，或者attach的顺序逐个执行这些Java agent。  </p>
<p>在premain方法或者agentmain方法中打印一些字符串并不出奇，完全可以将其中的逻辑并入main方法，或者其他监听端口的线程中。除此之外，Java agent还提供了一套instrumentation机制，允许应用程序拦截类加载事件，并且更改该类的字节码。  </p>
<h3 id="字节码注入"><a href="#字节码注入" class="headerlink" title="字节码注入"></a>字节码注入</h3><h4 id="Instrumentation"><a href="#Instrumentation" class="headerlink" title="Instrumentation"></a>Instrumentation</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.*;</span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAgent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String args, Instrumentation instrumentation)</span> </span>&#123;</span><br><span class="line">        instrumentation.addTransformer(<span class="keyword">new</span> Mytransformer());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTransformer</span> <span class="keyword">implements</span> <span class="title">ClassFileTransformer</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class="keyword">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException &#123;</span><br><span class="line">            System.out.printf(<span class="string">"Loaded %s: 0x%X%X%X%X\n"</span>, className, classfileBuffer[<span class="number">0</span>], classfileBuffer[<span class="number">1</span>], classfileBuffer[<span class="number">2</span>], classfileBuffer[<span class="number">3</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面这段代码中，premain方法多出了一个Instrumentation类型的参数，可以通过它来注册类加载事件的拦截器。该拦截器需要实现ClassFileTransformer接口，并重写其中的transform方法。  </p>
<p>transform方法将接收一个byte数组类型的参数，它代表的是正在被加载的类的字节码。上述代码将打印该数组的前四个字节，也就是Java class文件的魔数(magic number)0xCAFEBABE。  </p>
<p>transform方法将返回一个byte数组，代表更新过后的类的字节码。当方法返回之后，JVM会使用所返回的byte数组，来完成接下来的类加载工作。不过，如果transform方法返回null或者抛出异常，那么JVM将使用原来的byte数组完成类加载工作。  </p>
<p>基于这一类加载事件的拦截功能，可以实现字节码注入(bytecode instrumentation)，往正在被加载的类中插入额外的字节码。  </p>
<hr>
<p>字节码工程框架ASM的tree包(依赖于基础包)，用面向对象的方式注入字节码。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.*;</span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain;</span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.*;</span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.tree.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAgent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String args, Instrumentation instrumentation)</span> </span>&#123;</span><br><span class="line">        instrumentation.addTransformer(<span class="keyword">new</span> MyTransformer());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTransformer</span> <span class="keyword">implements</span> <span class="title">ClassFileTransformer</span>, <span class="title">Opcodes</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class="keyword">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException &#123;</span><br><span class="line">            ClassReader cr = <span class="keyword">new</span> ClassReader(classfileBuffer);</span><br><span class="line">            ClassNode classNode = <span class="keyword">new</span> ClassNode(ASM7);</span><br><span class="line">            cr.accept(classNode, ClassReader.SKIP_FRAMES);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(MethodNode methodNode : classNode.methods) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">"main"</span>.equals(methodNode.name)) &#123;</span><br><span class="line">                    InsnList instrumentation = <span class="keyword">new</span> InsnList();</span><br><span class="line">                    instrumentation.add(<span class="keyword">new</span> FieldInsnNode(GETSTATIC, <span class="string">"java/lang/System"</span>, <span class="string">"out"</span>, <span class="string">"Ljava/io/PrintStream;"</span>));</span><br><span class="line">                    instrumentation.add(<span class="keyword">new</span> LdcInsnNode(<span class="string">"Hello, Instrumentation!"</span>));</span><br><span class="line">                    instrumentation.add(<span class="keyword">new</span> MethodInsnNode(INVOKEVIRTUAL, <span class="string">"java/io/PrintStream"</span>, <span class="string">"println"</span>, <span class="string">"(Ljava/lang/String;)V"</span>, <span class="keyword">false</span>));</span><br><span class="line">                    methodNode.instructions.insert(instrumentation);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ClassWriter cw = <span class="keyword">new</span> ClassWriter(ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS);</span><br><span class="line">            classNode.accept(cw);</span><br><span class="line">            <span class="keyword">return</span> cw.toByteArray();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用ClassReader读取所传入的byte数组，并将其转换成ClassNode。然后遍历ClassNode中的MethodNode节点，也就是该类中的构造器和方法。  </p>
<p>当遇到名字为”main”的方法时，会在方法的入口处注入System.out.println(“Hello, Instrumentation!”);。运行结果如下：  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> java -javaagent:myagent.jar -cp .:/PATH/TO/asm-7.0-beta.jar:/PATH/TO/asm-tree-7.0-beta/jar HelloWorld</span></span><br><span class="line">Hello, Instrumentation!</span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure>

<h4 id="redefine-amp-retransform"><a href="#redefine-amp-retransform" class="headerlink" title="redefine&amp;retransform"></a>redefine&amp;retransform</h4><p>Java agent提供了另外两个功能redefine和retransform。这两个功能针对的是已加载的类，并要求用户传入所要redefine或者retransform的类的实例。  </p>
<p>其中，redefine指的是舍弃原本的字节码，并替换成由用户提供的byte数组。该功能比较危险，一般用于修复出错了的字节码。  </p>
<p>retransform则将针对所传入的类，重新调用所有已注册的ClassFileTransformer的transform方法。它的应用场景主要有如下两个。  </p>
<p>第一，在执行premain或者agentmain方法前，JVM早已加载了不少类，而这些类的加载时间并没有被拦截，因此也没有被注入。使用retransform功能可以注入这些已加载但未注入的类。  </p>
<p>第二，在定义了多个Java agent，多个注入的情况下，可能需要移除其中的部分注入。当调用Instrumentation.removeTransformer去除某个注入类后，可以调用retransform功能，重新从原始byte数组开始进行注入。  </p>
<h4 id="C-agent-JVMTI-agent"><a href="#C-agent-JVMTI-agent" class="headerlink" title="C agent(JVMTI agent)"></a>C agent(JVMTI agent)</h4><p>Java agent的这些功能都是通过JVMTI agent，也就是C agent来实现的。JVMTI是一个事件驱动的工具实现接口，通常，会在C agent加载后的入口方法Agent_OnLoad处注册各个事件的钩子(hook)方法。当JVM触发了这些事件时，便会调用对应的钩子方法。  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line">Agent_OnLoad(JavaVM *vm, <span class="keyword">char</span> *options, <span class="keyword">void</span> *reserver);</span><br></pre></td></tr></table></figure>

<p>例，我们可以为JVMTI中的ClassFileLoadHook事件设置钩子，从而在C层面拦截所有的类加载事件。  </p>
<h3 id="基于字节码注入的profiler"><a href="#基于字节码注入的profiler" class="headerlink" title="基于字节码注入的profiler"></a>基于字节码注入的profiler</h3><p>利用字节码注入来实现代码覆盖工具(JaCoCo)，或者各式各样的profiler。  </p>
<p>通常会定义一个运行时类，并在某一程序行为的周围，注入对该运行时类中方法的调用，以表示该程序行为正要发生或者已经发生。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProfiler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ConcurrentHashMap&lt;Class&lt;?&gt;, AtomicInteger&gt; data = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fireAllocationEvent</span><span class="params">(Class&lt;?&gt; klass)</span> </span>&#123;</span><br><span class="line">        data.computeIfAbsent(klass, kls -&gt; <span class="keyword">new</span> AtomicInteger()).incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dump</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data.forEach(kls, counter) -&gt; &#123;</span><br><span class="line">            System.err.printf(<span class="string">"%s: %d\n"</span>, kls.getName(), counter.get());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(MyProfiler::dump));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码时一个运行时类。该类维护了一个HashMap，用来统计每个类所新建实例的数目。当程序退出时，将逐个打印出每个类的名字，以及其新建实例的数目。  </p>
<p>在Java agent中，会截获正在加载的类，并且在每条new字节码之后插入对fireAllocationEvent方法的调用，以表示当前正在新建某个类的实例。注入代码如下：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.*;</span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain;</span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.*;</span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.tree.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAgent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String args, Instrumentation instrumentation)</span> </span>&#123;</span><br><span class="line">        instrumentation.addTransformer(<span class="keyword">new</span> MyTransformer());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTransformer</span> <span class="keyword">implements</span> <span class="title">ClassFileTransformer</span>, <span class="title">Opcodes</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined,</span><br><span class="line">        ProtectionDomain protectionDomain, <span class="keyword">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//排除对JDK类以及该运行时类的注入。</span></span><br><span class="line">            <span class="comment">//这些类的注入可能造成死循环调用，最终抛出StackOverflowException异常。</span></span><br><span class="line">            <span class="comment">//在PrintStream.println方法入口处注入System.out.println("blahblah")，</span></span><br><span class="line">            <span class="comment">//由于out是PrintStream的实例，因此当执行注入代码时，我们又会调用PrintStream.println方法，从而造成死循环。</span></span><br><span class="line">            <span class="keyword">if</span> (className.startsWith(<span class="string">"java"</span>)    ||</span><br><span class="line">                className.startsWith(<span class="string">"javax"</span>)   || </span><br><span class="line">                className.startsWith(<span class="string">"jdk"</span>)     ||</span><br><span class="line">                className.startsWith(<span class="string">"sun"</span>)     ||</span><br><span class="line">                className.startsWith(<span class="string">"com/sun"</span>) ||</span><br><span class="line">                className.startsWith(<span class="string">"org/example"</span>)) &#123;</span><br><span class="line">                    <span class="comment">// Skip JDK classes and profiler classes</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ClassReader cr = <span class="keyword">new</span> ClassReader(classfileBuffer);</span><br><span class="line">            ClassNode classNode = <span class="keyword">new</span> ClassNode(ASM7);</span><br><span class="line">            cr.accept(classNode, ClassReader.SKIP_FRAMES);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (MethodNode methodNode : classNode.methods) &#123;</span><br><span class="line">                <span class="keyword">for</span> (AbstractInsnNode node : methodNode.instructions.toArray()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (node.getOpcode() == NEW) &#123;</span><br><span class="line">                        TypeInsnNode typeInsnNode = (TypeInsnNode) node;</span><br><span class="line"></span><br><span class="line">                        InsnList instrumentation = <span class="keyword">new</span> InsnList();</span><br><span class="line">                        instrumentation.add(<span class="keyword">new</span> LdcInsnNode(Type.getObjectType(typeInsnNode.desc)));</span><br><span class="line">                        instrumentation.add(<span class="keyword">new</span> MethodInsnNode(INVOKESTATIC, <span class="string">"org/example/MyProfiler"</span>, <span class="string">"fireAllocationEvent"</span>, <span class="string">"(Ljava/lang/Class;)V"</span>, <span class="keyword">false</span>));</span><br><span class="line"></span><br><span class="line">                        methodNode.instructions.insert(node, instrumentation);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ClassWriter cw = <span class="keyword">new</span> ClassWriter(ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS);</span><br><span class="line">            classNode.accept(cw);</span><br><span class="line">            <span class="keyword">return</span> cw.toByteArray();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决<strong>死循环调用</strong>的关键在于设置一个线程私有的标识位，用以区分应用代码的上下文以及注入代码的上下文。当即将执行注入代码时，将根据标识位判断是否已经位于注入代码的上下文之中。如果不是，则设置标识位并正常执行注入代码；如果是，则直接返回，不再执行注入代码。  </p>
<hr>
<p>字节码注入的另一个技术难点则是<strong>命名空间</strong>。不少应用程序都依赖于字节码工程库ASM。当注入逻辑依赖于ASM时，便有可能出现注入使用最新版本的ASM，而应用程序使用较低版本的ASM的问题。  </p>
<p>JDK本身也使用了ASM库，如用来生成Lambda表达式的适配器类。JDK的做法是重命名整个ASM库，为所有类的包名添加jdk.internal前缀。显然不好直接更改ASM的包名，因此需要借助自定义类加载器来隔离命名空间。  </p>
<hr>
<p>基于字节码注入的工具还有另一个问题，<strong>观察者效应</strong>(observer effect)对所收集的数据造成的影响。  </p>
<p>例：利用字节码注入收集每个方法的运行时间。假设某个方法调用了另一个方法，而这两个方法都被注入了，那么统计被调用者运行时间的注入代码所耗费的时间，将不可避免的被计入至调用者方法的运行时间之中。  </p>
<p>例：统计新建对象数目。即时编译器中的逃逸分析可能会优化掉新建对象操作，但它不会消除相应的统计操作，如示例中对fireAllocationEvent方法的调用。在这种情况下，将统计没有实际发生的新建对象操作。  </p>
<p>另一种情况则是，所注入的对fireAllocationEvent方法的调用，将影响到方法内联的决策。如果该新建对象的构造器调用恰好因此没有被内联，从而造成对象逃逸。在这种情况下，原本能够被逃逸分析优化掉的新建对象操作将无法优化，也将统计到原本不会发生的新建对象操作。  </p>
<p>总而言之，当使用字节码注入开发profiler时，需要辩证的看待所收集的数据。它仅能表示在被注入的情况下程序的执行状态，而非没有注入情况下的程序执行状态。  </p>
<h3 id="面向方面编程"><a href="#面向方面编程" class="headerlink" title="面向方面编程"></a>面向方面编程</h3><p>面向方面变成(Aspect-Oriented Programming, AOP)。面向方面编程的核心理念是定义切入点(pointcut)以及通知(advice)。程序控制流中所有匹配该切入点的连接点(joinpoint)都将执行这段通知代码。  </p>
<p>例：定义一个指代所有方法入口的切入点，并指定在该切入点执行的“打印该方法的名字”这一通知。那么每个具体的方法入口便是一个连接点。  </p>
<p>面向方面编程的其中一种实现方式便是字节码注入，比如AspectJ。  </p>
<p>MyProfiler.fireAllocationEvent(<Target>.class)。也相当于使用了面向方面变成，在所有的new字节码之后执行了这段通知代码。  </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>可以通过Java agent的类加载拦截功能，修改某个类所对应的byte数组，并利用这个修改过后的byte数组完成接下来的类加载。  </p>
<p>基于字节码注入的profiler，可以统计程序运行过程中某些行为的出现次数。如果需要收集Java核心类库的数据，那么需要小心避免无限递归调用。另外还需要通过自定义类加载器来解决命名空间的问题。  </p>
<p>由于字节码注入会产生观察者效应，因此基于该技术的profiler所收集到的数据并不能反映程序的真实运行状态。它所反映的是程序在被注入的情况下的执行状态。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>JVM的监控及诊断工具(GUI)</title>
    <url>/JVM/JVM%E7%9A%84%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-GUI/</url>
    <content><![CDATA[<h3 id="eclipse-MAT"><a href="#eclipse-MAT" class="headerlink" title="eclipse MAT"></a>eclipse MAT</h3><p>jmap工具支持导出JVM堆的二进制快照。eclipse的MAT工具是能够解析这类二进制快照的工具。  </p>
<p>MAT本身也能够获取堆的二进制快照。该功能将借助jps列出当前正在运行的Java进程，以供选择并获取快照。由于jps会将自己列入其中，在列表中会有一个已经结束运行的jps进程。  </p>
<p>MAT获取二进制快照的方式有三种。  </p>
<ul>
<li>使用Attach API。  </li>
<li>新建一个JVM来运行Attach API。  </li>
<li>使用jmap工具。  </li>
</ul>
<p>这三种本质上都是在使用Attach API。不过在目标进程启用了DisableAttachMechanism参数时，前两者将不在选取列表中显示，后者将在运行时报错。  </p>
<p>当加载完堆快照之后，MAT的主界面将展示一张饼状图，其中列举占据的Retained heap最多的几个对象。  </p>
<p>MAT计算对象占据内存有两种方式。  </p>
<ul>
<li>Shallow heap，指的是对象自身占据的内存。  </li>
<li>Retained heap，指的是当对象不再被引用时，垃圾回收器所能回收的总内存，包括对象自身所占据的内存，以及仅能够通过该对象引用到的 其他对象所占据的内存。  </li>
</ul>
<p>MAT包括两个比较重要的视图。  </p>
<ul>
<li>直方图(histogram)</li>
<li>支配树(dominator tree)</li>
</ul>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        JVM GUI MAT直方图.png
    </div>
    <div class='spoiler-content'>
        <img src='/img/JVM GUI MAT直方图.png'>
    </div>
</div>  

<p>MAT的直方图和jmap的-histo子命令一样，都能够展示各个类的实例Objects数目以及这些实例的Shallow heap总和。但是MAT的直方图还能够计算Retained heap，并支持基于实例数目或Retained heap的排序方式(默认为Shallow heap)。此外，MAT还可以将直方图中的类按照超类、类加载器或者包名分组。  </p>
<p>当选中某个类时，MAT界面左上角的Inspector窗口将展示该类的Class实例的相关信息，如类加载器等。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        JVM GUI MAT支配树.png
    </div>
    <div class='spoiler-content'>
        <img src='/img/JVM GUI MAT支配树.png'>
    </div>
</div>  

<p>支配树的概念源自图论。在一则流图(flow diagram)中，如果从入口节点到b节点的所有路径都要经过a节点，那么a支配(dominate)b。  </p>
<p>在a支配b，且a不同于b的情况下(即a严格支配b)，如果从a节点到b节点的所有路径中不存在支配b的其他节点，那么a直接支配(immediate dominate)b。这里的支配树指的便是由节点的直接支配节点所组成的树状结构。  </p>
<p>可以将堆中所有的对象看成一张对象图，每个对象是一个图节点，而GC Roots则是对象图的入口，对象之间的引用关系则构成了对象图中的有向边。这样便能够构造出该对象图所对应的支配树。MAT将按照每个对象Retained heap的大小排列该支配树。  </p>
<p>对象的引用型字段未必对应支配树中的父子节点关系。假设对象a拥有两个引用型字段，分别指向b和c。而b和c各自拥有一个引用型字段，但都指向d。如果没有其他引用指向b、c或d，那么a直接支配b、c和d，而b(或c)和d之间不存在支配关系。  </p>
<p>当在支配树视图中选中某一对象时，还可以通过Path To GC Roots功能，反向列出该对象到GC Roots的引用路径。  </p>
<p>MAT还将自动匹配内存泄漏中的常见模式，并汇报潜在的内存泄漏问题。  </p>
<h3 id="Java-Mission-Control-JMC"><a href="#Java-Mission-Control-JMC" class="headerlink" title="Java Mission Control(JMC)"></a>Java Mission Control(JMC)</h3><p>JMC是JVM平台上的性能监控工具。它包含一个GUI客户端，以及众多用来收集JVM性能数据的插件，如JMX Console(能够访问用来存放虚拟机各个子系统运行数据的MXBeans)，以及虚拟机内置的高效profiling工具Java Flight Recorded(JFR)。  </p>
<p>JFR的性能开销很小，在默认配置下平均低于1%。与其他工具相比，JFR能够直接访问虚拟机内的数据，并且不会影响虚拟机的优化。因此，它非常适用于生产环境下满负荷运行的Java程序。  </p>
<p>当启用时，JFR将记录运行过程中发生的一系列事件。其中包括Java层面的时间，如线程事件、锁事件；以及JVM内部的事件，如新建对象、垃圾回收和即时编译事件。  </p>
<p>按照发生时机以及持续时间来划分，JFR的事件共有四种类型：  </p>
<ol>
<li>瞬时事件(Instant Event)，用户关心的是它们发生与否，例如异常、线程启动事件。</li>
<li>持续事件(Duration Event)，用户关心的是它们的持续时间，例如垃圾回收事件。</li>
<li>计时事件(Timed Event)，是时长超出指定阈值的持续事件。</li>
<li>取样事件(Sample Event)，是周期性取样的事件。<br> 取样事件的其中一个常见例子是方法抽样(Method Sampling)，即每隔一段时间统计各个线程的栈轨迹。如果在这些抽样取得的栈轨迹中存在一个反复出现的地方，那么可以推测该方法是热点方法。  </li>
</ol>
<p>JFR的取样事件比其他工具更加精确。以方法抽样为例，其他工具通常基于JVMTI(Java Virtual Machine Tool Interface)的GetAllStackTraces API。该API依赖于安全点机制，其获得的栈轨迹总是在安全点上，由此得出的结论未必精确。JRF则不依赖于安全点机制，因此其结果相对来说更加精确。  </p>
<p>JFR的启动方式主要有三种：  </p>
<h4 id="JFR启用方式一"><a href="#JFR启用方式一" class="headerlink" title="JFR启用方式一"></a>JFR启用方式一</h4><p>在运行目标Java程序时添加-XX:StartFlightRecording=参数。  </p>
<ul>
<li>参数配置方式一：JFR将会在JVM启动5s后(对应delay=5s)手机数据，持续20s(对应duration=20s)。当收集完毕后，JFR会将收集得到的数据保存至指定的文件中(对应filename=myrecording.jfr)。  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Time fixed</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> java -XX:StartFlightRecording=delay=5s,duration=20s,filename=myrecording.jfr,settings=profile MyApp</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> settings=profile指定了JFR所收集的事件类型。  </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认情况下，JFR将加载配置文件<span class="variable">$JDK</span>/lib/jfr/default.jfc，并识别其中所包含的事件类型。  </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当使用了settings=profile配置时，JFR将加载配置文件<span class="variable">$JDK</span>/lib/jfr/profile.jfc。该配置文件所包含的事件类型要多于默认的default.jfc，因此性能开销也要大一些(约为2%)。  </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> default.jfr以及profile.jfr均为XML文件。</span></span><br></pre></td></tr></table></figure></li>
<li>参数配置方式二：JFR将在JVM启动之后持续收集数据，直至进程退出。在进程退出时(对应dumponexit=true)，JFR会将收集得到的数据保存至指定的文件中。  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Continuous, dump on <span class="built_in">exit</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> java -XX:StartFlightRecording=dumponexit=<span class="literal">true</span>,filename=myrecording.jfr MyApp</span></span><br></pre></td></tr></table></figure></li>
<li>参数配置方式三：JFR将在JVM启动之后持续收集数据，直至进程退出。该命令不会主动保存JFR收集得到的数据。  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Continuous, dump on demand</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> java -XX:StartFlightRecording=maxage=10m,maxsize=100m,name=SomeLabel MyApp</span></span><br><span class="line">Started recording 1.</span><br><span class="line"></span><br><span class="line">Use jcmd 38502 JFR.dump name=SomeLabel filename=FILEPATH to copy recording data to file.</span><br><span class="line">...</span><br><span class="line"><span class="meta">#</span><span class="bash"> 由于JFR将持续收集数据，如果不加以限制，那么JFR可能会填满硬盘的所有空间。因此，有必要对这种模式下所收集的数据进行限制。  </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在这条命令中，maxage=10m指的是仅保留10分钟以内的事件，maxsize=100m指的是仅保留100M以内的事件。一旦所收集的时间达到其中任意一个限制，JFR便会开始清除不合规格的事件。  </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 然而为了保持较小的性能开销，JFR并不会频繁的校验这两个限制。因此在实践过程中往往会发现指定文件的大小超出限制，或者文件中所存储事件的时间超出限制。</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="JFR启用方式二"><a href="#JFR启用方式二" class="headerlink" title="JFR启用方式二"></a>JFR启用方式二</h4><p>运行jcmd <PID> JFR.dump命令主动保存JFR收集得到的数据。  </p>
<blockquote>
<p>启用方式一参数配置方式三命令不会主动保存JFR收集得到的数据。  </p>
</blockquote>
<p>通过jcmd来让JFR开始收集数据、停止收集数据，或者保存所收集的数据，对应的子命令分别为JFR.start、JFR.stop、JFR.dump。  </p>
<p>JFR.start子命令所接收的配置及格式和-XX:StartFlightRecording=参数的类似。这些配置包括delay、duration、settings、maxage、maxsize、以及name。最后一个参数name就是一个标签，当同一进程中存在多个JFR数据收集操作时，可以通过该标签来辨别。  </p>
<p>在启动目标进程时，不在添加-XX:StartFlightRecording=参数。<br>在目标进程运行过程中，可以运行JFR.start子命令远程启用目标进程的JFR功能。  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jcmd &lt;PID&gt; JFR.start settings=profile maxage=10m maxsize=150m name=SomeLabel</span></span><br></pre></td></tr></table></figure>

<p>上述命令运行过后，目标进程中的JFR已经开始收集数据。此时可以通过下述命令导出已收集到的数据。  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jcmd &lt;PID&gt; JFR.dump name=SomeLabel filename=myrecording.jfr</span></span><br></pre></td></tr></table></figure>

<p>最后可以通过下述命令关闭目标进程中的JFR。  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jcmd &lt;PID&gt; JFR.stop name=SomeLabel</span></span><br></pre></td></tr></table></figure>

<h4 id="JFR启用方式三"><a href="#JFR启用方式三" class="headerlink" title="JFR启用方式三"></a>JFR启用方式三</h4><p>JMC(Java Mission Control)中的JFR插件。  </p>
<p>在JMC GUI客户端的JVM Browser中，可以看到所有正在运行的Java程序。当点击右键弹出菜单中的Start Flight Recording…时，JMC便会弹出另一个窗口，用来配置JFR的启动参数。(这些配置方式与前两种启动JFR的方式类似，也包括标签名Name、收集数据的持续时间Recording time、缓存事件的时间及空间限制Maximum age&amp;Maximum size、以及配置所要监控事件的Event settings)。  </p>
<blockquote>
<p>对应前两种启动方式的settings=default|profile。JMC提供了两个选择：Continuous和Profiling，分别对应$JDK/lib/jfr/里的default.jfc和profile.jfc。  </p>
</blockquote>
<blockquote>
<p>可以通过JMC的Flight Recording Template Manager导入这些jfc文件，并在GUI界面上进行更改。更改完毕后可以导出为新的jfc文件，以便在服务端使用。  </p>
</blockquote>
<p>当收集完成时，JMC会自动打开所生成的jfr文件，并在主界面中列举目标进程在收集数据的这段时间内的潜在问题。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        JVM GUI JFR后问题.png
    </div>
    <div class='spoiler-content'>
        <img src='/img/JVM GUI JFR后问题.png'>
    </div>
</div>  

<p>客户端的左边Outline则罗列了JVM的各个子系统。JMC将根据JFR所收集到的每个子系统的事件来进行可视化，转换成图或者表。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        JVM GUI JFR后图表.png
    </div>
    <div class='spoiler-content'>
        <img src='/img/JVM GUI JFR后图表.png'>
    </div>
</div>  

<ul>
<li><p>垃圾回收子系统所对应的选项卡展示了JFR所收集到的GC事件，以及基于这些GC事件的数据生成的堆已用空间的分布图，Metaspace大小的分布图，最长暂停以及总暂停的直方分布图。  </p>
</li>
<li><p>即时编译子系统所对应的选项卡则展示了方法编译时间的直方图，以及按编译时间排序的编译任务表。<br>  后者可能常出现同方法名同方法描述符的编译任务。主要原因有两个，一是不同编译层次的即时编译，如3层的C1编译以及4层的C2编译；二是去优化后的重新编译。  </p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>eclipse MAT可用于分析由jmap命令导出的Java堆快照。它包括两个相对比较重要的视图，分别为直方图和支配树。直方图展示了各个类的实例数目以及这些实例的Shallow heap或Retained heap的总和。支配树则展示了快照中每个对象所直接支配的对象。  </p>
<p>Java Mission Control是JVM平台上的性能监控工具。Java Flight Recorder是JMC的其中一个组件，能够以极低的性能开销收集JVM的性能数据。  </p>
<p>JFR的启用方式有三种，分别为在命令行中使用-XX:StartFlightRecording=参数，使用jcmd的JFR.*子命令，以及JMC的JFR插件。JMC能够加载JFR的输出结果，并且生成各种信息丰富的图表。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>基准测试框架JMH详解</title>
    <url>/JVM/%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6JMH%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="Fork和-BenchmarkMode"><a href="#Fork和-BenchmarkMode" class="headerlink" title="@Fork和@BenchmarkMode"></a>@Fork和@BenchmarkMode</h3><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        JMH项目编译jar包输出结果
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ java -jar target/benchmarks.jar</span><br><span class="line">...</span><br><span class="line"># JMH version: 1.21</span><br><span class="line"># VM version: JDK 10.0.2, Java HotSpot(TM) 64-Bit Server VM, 10.0.2+13</span><br><span class="line"># VM invoker: /Library/Java/JavaVirtualMachines/jdk-10.0.2.jdk/Contents/Home/bin/java</span><br><span class="line"># VM options: &lt;none&gt;</span><br><span class="line"># Warmup: 5 iterations, 10 s each</span><br><span class="line"># Measurement: 5 iterations, 10 s each</span><br><span class="line"># Timeout: 10 min per iteration</span><br><span class="line"># Threads: 1 thread, will synchronize iterations</span><br><span class="line"># Benchmark mode: Throughput, ops/time</span><br><span class="line"># Benchmark: org.sample.MyBenchmark.testMethod</span><br><span class="line"></span><br><span class="line"># Run progress: 0,00% complete, ETA 00:08:20</span><br><span class="line"># Fork: 1 of 5</span><br><span class="line"># Warmup Iteration   1: 1023500,647 ops/s</span><br><span class="line"># Warmup Iteration   2: 1030767,909 ops/s</span><br><span class="line"># Warmup Iteration   3: 1018212,559 ops/s</span><br><span class="line"># Warmup Iteration   4: 1002045,519 ops/s</span><br><span class="line"># Warmup Iteration   5: 1004210,056 ops/s</span><br><span class="line">Iteration   <span class="number">1</span>: <span class="number">1010251</span>,<span class="number">342</span> ops/s</span><br><span class="line">Iteration   <span class="number">2</span>: <span class="number">1005717</span>,<span class="number">344</span> ops/s</span><br><span class="line">Iteration   <span class="number">3</span>: <span class="number">1004751</span>,<span class="number">523</span> ops/s</span><br><span class="line">Iteration   <span class="number">4</span>: <span class="number">1003034</span>,<span class="number">640</span> ops/s</span><br><span class="line">Iteration   <span class="number">5</span>: <span class="number">997003</span>,<span class="number">830</span> ops/s</span><br><span class="line"></span><br><span class="line"># Run progress: 20,00% complete, ETA 00:06:41</span><br><span class="line"># Fork: 2 of 5</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># Run progress: 80,00% complete, ETA 00:01:40</span><br><span class="line"># Fork: 5 of 5</span><br><span class="line"># Warmup Iteration   1: 988321,959 ops/s</span><br><span class="line"># Warmup Iteration   2: 999486,531 ops/s</span><br><span class="line"># Warmup Iteration   3: 1004856,886 ops/s</span><br><span class="line"># Warmup Iteration   4: 1004810,860 ops/s</span><br><span class="line"># Warmup Iteration   5: 1002332,077 ops/s</span><br><span class="line">Iteration   <span class="number">1</span>: <span class="number">1011871</span>,<span class="number">670</span> ops/s</span><br><span class="line">Iteration   <span class="number">2</span>: <span class="number">1002653</span>,<span class="number">844</span> ops/s</span><br><span class="line">Iteration   <span class="number">3</span>: <span class="number">1003568</span>,<span class="number">030</span> ops/s</span><br><span class="line">Iteration   <span class="number">4</span>: <span class="number">1002724</span>,<span class="number">752</span> ops/s</span><br><span class="line">Iteration   <span class="number">5</span>: <span class="number">1001507</span>,<span class="number">408</span> ops/s</span><br><span class="line"></span><br><span class="line">Result <span class="string">"org.sample.MyBenchmark.testMethod"</span>:</span><br><span class="line">  <span class="number">1004801</span>,<span class="number">393</span> ±(<span class="number">99.9</span>%) <span class="number">4055</span>,<span class="number">462</span> ops/s [Average]</span><br><span class="line">  (min, avg, max) = (<span class="number">992193</span>,<span class="number">459</span>, <span class="number">1004801</span>,<span class="number">393</span>, <span class="number">1014504</span>,<span class="number">226</span>), stdev = <span class="number">5413</span>,<span class="number">926</span></span><br><span class="line">  CI (<span class="number">99.9</span>%): [<span class="number">1000745</span>,<span class="number">931</span>, <span class="number">1008856</span>,<span class="number">856</span>] (assumes normal distribution)</span><br><span class="line"></span><br><span class="line"># Run complete. Total time: 00:08:22</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Benchmark                Mode  Cnt        Score      Error  Units</span><br><span class="line">MyBenchmark.testMethod  thrpt   <span class="number">25</span>  <span class="number">1004801</span>,<span class="number">393</span> ± <span class="number">4055</span>,<span class="number">462</span>  ops/s</span><br></pre></td></tr></table></figure>
    </div>
</div>

<p>Foke: 1 of 5指的是JMH会Fork出一个新的JVM，来运行性能基准测试。(另外启动一个JVM进行性能基准测试，是为了获得一个相对干净的虚拟机环境)  </p>
<blockquote>
<p>JVM是如何实现反射的。因为类型profile被污染，会导致无法内联的情况。使用新的虚拟接，将极大的降低被上述情况干扰的可能性，从而保证更加精确的性能数据。<br>方法内联-虚方法内联。基于类层次分析的完全内联。新启动的JVM，其加载的与测试无关的抽象类子类或接口实现相对较少。具体是否进行完全内联将交由开发人员来决定。  </p>
</blockquote>
<p>除了对即时编译器的影响之外，Fork出新的JVM还会提升性能数据的准确度。<br>不少JVM的优化会带来不确定性，如TLAB(thread-local-allocation-buffer)内存分配，偏向锁，轻量级锁算法，并发数据结构等。这些不确定性都可能导致不同JVM中运行的性能测试的结果不同。  </p>
<p>通过运行更多的Fork，并将每个JVM的性能测试结果平均起来，可以增强最终数据的可信度，使其误差更小。在JMH中，可以通过@Fork注解来配置。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Fork</span>(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBenchmark</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个Fork包含了5个预热迭代(warmup iteration，如#Warmup Iteration 1: 1023500,647 ops/s)以及5个测试迭代(measurement iteration，如Iteration 1: 1010251,342 ops/s)。  </p>
<p>每个迭代后都跟着一个数据，代表本次迭代的吞吐量，也就是每秒运行了多少次操作(operations/s，或ops/s)。默认情况下，一次操作指的是调用一次测试方法testMethod。  </p>
<p>除了吞吐量之外，还可以输出其他格式的性能数据，如运行一次操作的平均时间。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@BenchmarkMode</span>(Mode.AverageTime)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBenchmark</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Warmup和-Measurement"><a href="#Warmup和-Measurement" class="headerlink" title="@Warmup和@Measurement"></a>@Warmup和@Measurement</h3><p>区分预热迭代和测试迭代，是为了在记录性能数据之前，将JVM带至一个稳定状态。这个稳定状态，不仅包括测试方法被即时编译成机器码，还包括JVM中各种自适配优化算法能够稳定下来，如TLAB大小，或者是使用传统垃圾回收器时的Eden区、Survivor区和老年代的大小。  </p>
<p>一般来说，预热迭代的数目以及没每次预热迭代的时间，需要根据所要测试的业务逻辑代码来调配。通常的做法是在首次运行时配置较多次迭代，并监控性能数据达到稳定状态时的迭代数目。  </p>
<p>不少性能测试框架都会自动检测稳定状态。它们所采用的算法是计算迭代之间的差值，如果连续几个迭代与前一迭代的差值均小于某个值，便将这几个迭代以及之后的迭代当成稳定状态。  </p>
<blockquote>
<p>缺陷：在达到最终稳定状态前，程序可能拥有多个中间稳定状态。(通过Java上的JavaScript引擎Nashorn运行JavaScript代码，可能出现多个中间稳定状态)  </p>
</blockquote>
<p>开发人员需要自行决定预热迭代的次数以及每次迭代的持续时间。<br>通常情况下，在保持5-10个预热迭代的前提下，将总的预热时间优化至最少，以便节省性能测试的机器时间。  </p>
<p>当确定了预热迭代的次数以及每次迭代的持续时间之后，便可以通过@Warmup注解来进行配置。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@Warmup注解有四个参数，分别为预热迭代的次数iterations，每次迭代持续的时间time和timeUnit(前者是数值，后者是单位。示例为每次迭代持续100毫秒)，以及每次操作包含多少次对测试方法的调用batchSize。  </span></span><br><span class="line"><span class="meta">@Warmup</span>(iterations=<span class="number">10</span>, time=<span class="number">100</span>, timeUnit=TimeUnit.MILLISECONDS, batchSize=<span class="number">10</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBenchmark</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试迭代可通过@Measurement注解来进行配置。它的可配置选项和@Warmup的一致。与预热迭代不同的是，每个Fork中测试迭代的数目越多，得到的性能数据越精确。  </p>
<h3 id="State、-Setup、-TearDown"><a href="#State、-Setup、-TearDown" class="headerlink" title="@State、@Setup、@TearDown"></a>@State、@Setup、@TearDown</h3><p>通常所要测试的业务逻辑只是整个应用程序的一小部分，如某个具体的web app请求。这要求在每次调用测试方法前，程序处于准备接收请求的状态。<br>上述场景抽象后，变成程序从某种状态到另一种状态的转换，而性能测试，便是在收集该转换的性能数据。  </p>
<p>JMH提供了@State注解，被它标注的类便是程序的状态。由于JMH将负责生成这些状态类的实例，因此，它要求状态类必须拥有无参数构造器，以及当状态类为内部类时，该状态类必须是静态的。  </p>
<p>JMH还将程序状态细分为整个虚拟机的程序状态，线程私有的程序状态，以及线程租私有的程序状态，分别对应@State注解的参数Scope.Benchmark，Scope.Thread和Scope.Group。(这里的线程租并非JDK中的那个概念，而是JMH自己定义的概念，具体参考@GroupThreads注解)  </p>
<p>@State的配置方法以及状态类的用法：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBenchmark</span> </span>&#123;</span><br><span class="line">  <span class="meta">@State</span>(Scope.Benchmark)</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBenchmarkState</span> </span>&#123;</span><br><span class="line">    String message = <span class="string">"exception"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Benchmark</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">(MyBenchmarkState state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Exception(state.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>状态类是通过方法参数的方式传入测试方法之中的。JMH将负责把所构造的状态类实例传入该方法之中。如果MyBenchmark被标注为@State，那么可以不用在测试方法中定义额外的参数，而是直接访问MyBenchmark类中的实例变量。  </p>
<p>与JUnit测试一样，可以在测试前初始化程序状态，在测试后校验程序状态。这两种操作分别对应@Setup和@TearDown注解，被它们标注的方法必须是状态类中的方法。<br>而且，JMH并不限定状态类中@Setup方法以及@TearDown方法的数目。当存在多个@Setup方法或者@TearDown方法时，JMH将按照定义的先后顺序执行。  </p>
<p>JMH对@Setup方法以及@TearDown方法的调用时机是可配置的。可供选择的粒度有在整个性能测试前后调用，在每个迭代前后调用，以及在每次调用测试方法前后调用。其中，最后一个粒度将影响测试数据的精度。<br>这三种粒度分别对应@Setup@TearDown注解的参数Level.Trial，Level.Iteration，以及Level.Invocation。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBenchmark</span> </span>&#123;</span><br><span class="line">  <span class="meta">@State</span>(Scope.Benchmark)</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBenchmarkState</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Setup</span>(Level.Invocation)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TearDown</span>(Level.Invocation)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//Run with -ea</span></span><br><span class="line">      <span class="keyword">assert</span> count == <span class="number">1</span> : <span class="string">"ERROR"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Benchmark</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">(MyBenchmarkState state)</span> </span>&#123;</span><br><span class="line">    state.count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="即时编译相关功能"><a href="#即时编译相关功能" class="headerlink" title="即时编译相关功能"></a>即时编译相关功能</h3><p>JMH还提供了不少控制即时编译的功能，如可以控制每个方法内联与否的@CompilerControl注解。  </p>
<p>另一个更小粒度的功能则是Blackhole类。它里边的consume方法可以防止即时编译器将所传入的值给优化掉。<br>具体的使用方法便是为被@Benchmark注解标注了的测试方法增添一个类型为Blackhole的参数，并且在测试方法的代码中调用其实例方法Blackhole.consume。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">(Blackhole bh)</span> </span>&#123;</span><br><span class="line">  bh.consume(newObject());<span class="comment">// prevents escape analysis</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它并不会阻止对传入值的计算的优化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">teatMethod</span><span class="params">(Blockhole bh)</span> </span>&#123;</span><br><span class="line">  bh.consume(<span class="number">3</span>+<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将3+4的值传入Blackhole.consume方法中。即时编译器仍旧会进行常量折叠，而Blackhole将阻止即时编译器把所得到的常量值7给优化消除掉。</span></span><br></pre></td></tr></table></figure>

<p>除了防止死代码消除的consume之外，Blackhole类还提供了一个静态方法consumeCPU，来消耗CPU时间。该方法将接收一个long类型的参数，这个参数与所消耗的CPU时间成呈线性相关。  </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>@Fork允许开发人员制定所要Fork出的JVM的数目。  </li>
<li>@BenchmarkMode允许指定性能数据的格式。  </li>
<li>@Warmup和@Measurement允许配置预热迭代或者测试迭代的数目，每个迭代的时间以及每个操作所包含多少次测试方法的调用。  </li>
<li>@State允许配置测试程序的状态。测试前对程序状态的初始化以及测试后对程序状态的恢复或者校验可分别通过@Setup和@TearDown来实现。  </li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>JNI的运行机制</title>
    <url>/JVM/JNI%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>Java语言较难表达，甚至是无法表达的应用场景。如使用汇编语言(X86_64的SIMD指令)来提升关键代码的性能；如调用Java核心类库无法提供的，某个体系架构或者操作系统特有的功能。  </p>
<p>在以上情况下，会牺牲可移植性，在Java代码中调用C/C++代码，并在其中实现所需功能。这种跨语言的调用，需要借助JVM的Java Native Interface(JNI)机制。  </p>
<p>Java中标记为native的、没有方法体的方法。当在Java代码中调用这些native方法时，JVM将通过JNI调用至对应的C函数中。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Object.hashCode方法，对应的C函数将计算对象的哈希值，并缓存在对象头、栈上锁记录(轻型锁)或对象监视锁(重型锁所使用的monitor)中，以确保该值在对象的生命周期之内不会变更。</span></span><br></pre></td></tr></table></figure>

<h3 id="native方法的链接"><a href="#native方法的链接" class="headerlink" title="native方法的链接"></a>native方法的链接</h3><p>在调用native方法前，JVM需要将该native方法链接至对应的C函数上。  </p>
<p>链接方式主要有两种。</p>
<h4 id="链接方式一-自动链接"><a href="#链接方式一-自动链接" class="headerlink" title="链接方式一:自动链接"></a>链接方式一:自动链接</h4><p>让JVM自动查找符合默认命名规范的C函数，并且链接起来。  </p>
<p>事实上，并不需要记住所谓的命名规范，而是采用javac -h命令，便可以根据Java程序中的native方法声明，自动生成包含符合命名规范的C函数的头文件。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        自定义类的native方法示例
    </div>
    <div class='spoiler-content'>
        <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Foo类有三个native方法，分别为静态方法foo以及两个重载的实例方法bar</span></span><br><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">long</span> j)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(String s, Object o)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过执行javac -h . org/example/Foo.java命令，将在当前文件夹(对应-h后面跟着的.)生成名为org_example_Foo.h的头文件。  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* DO NOT EDIT THIS FILE - it is machine generated */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Header for class org_example_Foo */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _Included_org_example_Foo</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _Included_org_example_Foo</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     org_example_Foo</span></span><br><span class="line"><span class="comment"> * Method:    foo</span></span><br><span class="line"><span class="comment"> * Signature: ()V</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL Java_org_example_Foo_foo</span><br><span class="line">  (JNIEnv *, jclass);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     org_example_Foo</span></span><br><span class="line"><span class="comment"> * Method:    bar</span></span><br><span class="line"><span class="comment"> * Signature: (IJ)V</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL Java_org_example_Foo_bar__IJ</span><br><span class="line">  (JNIEnv *, jobject, jint, jlong);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     org_example_Foo</span></span><br><span class="line"><span class="comment"> * Method:    bar</span></span><br><span class="line"><span class="comment"> * Signature: (Ljava/lang/String;Ljava/lang/Object;)V</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL Java_org_example_Foo_bar__Ljava_lang_String_2Ljava_lang_Object_2</span><br><span class="line">  (JNIEnv *, jobject, jstring, jobject);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>native方法对应的C函数都需要以Java_为前缀，之后跟着完整的包名和方法名。由于C函数名不支持.字符，因此需要将.转换为_，而原本方法名中的_符号，则需要转换为_1。(org.example包下的Foo类的foo方法，JVM会将其自动链接至名为Java_org_example_Foo_foo的C函数中。)  </p>
<p>当某个类出现重载的native方法时，JVM还会将参数类型纳入自动链接对象的考虑范围之中。具体的做法便是在前面C函数名的基础上，追加_ _以及方法描述符作为后缀。  </p>
<p>方法描述符的特殊符号同样会被替换掉，如引用类型所使用的;会被替换为_2，数组类型所使用的[会被替换为_3。  </p>

    </div>
</div>  

<h4 id="链接方式二-主动链接"><a href="#链接方式二-主动链接" class="headerlink" title="链接方式二:主动链接"></a>链接方式二:主动链接</h4><p>在C代码中主动链接。  </p>
<p>这种链接方式对C函数名没有要求。通常会使用一个名为registerNatives的native方法，并按照第一种链接方式定义所能自动链接的C函数。在该C函数中，将手动链接该类的其他native方法。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Object类的registerNatives方法示例
    </div>
    <div class='spoiler-content'>
        <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注：Object类的registerNatives方法的实现位于java.base模块里的C代码中</span></span><br><span class="line"><span class="keyword">static</span> JNINativeMethod methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">"hashCode"</span>,    <span class="string">"()I"</span>,                    (<span class="keyword">void</span> *)&amp;JVM_IHashCode&#125;,</span><br><span class="line">    &#123;<span class="string">"wait"</span>,        <span class="string">"(J)V"</span>,                   (<span class="keyword">void</span> *)&amp;JVM_MonitorWait&#125;,</span><br><span class="line">    &#123;<span class="string">"notify"</span>,      <span class="string">"()V"</span>,                    (<span class="keyword">void</span> *)&amp;JVM_MonitorNotify&#125;,</span><br><span class="line">    &#123;<span class="string">"notifyAll"</span>,   <span class="string">"()V"</span>,                    (<span class="keyword">void</span> *)&amp;JVM_MonitorNotifyAll&#125;,</span><br><span class="line">    &#123;<span class="string">"clone"</span>,       <span class="string">"()Ljava/lang/Object;"</span>,   (<span class="keyword">void</span> *)&amp;JVM_Clone&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_java_lang_Object_registerNatives(JNIEnv *env, jclass cls)</span><br><span class="line">&#123;</span><br><span class="line">    (*env)-&gt;RegisterNatives(env, cls,</span><br><span class="line">                            methods, <span class="keyword">sizeof</span>(methods)/<span class="keyword">sizeof</span>(methods[<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码中的C函数将调用RegisterNativesAPI，注册Object类中其他native方法所要链接的C函数。并且这些C函数的名字并不符合默认命名规则。  </p>
<p>当使用第二种方式进行链接时，需要在其他native方法被调用之前完成链接工作。因此往往会在类的初始化方法里调用该registerNatives方法。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        registerNatives();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>  

<hr>
<p>采用第一种链接方式，实现其中的bar(String, Object)方法。  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//foo.c</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"org_example_Foo.h"</span></span></span><br><span class="line"></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JINCALL Java_org_example_Foo_bar__Ljava_lang_String_2Ljava_lang_Object_2</span><br><span class="line">(JNIEnv *env, jobject thisObject, jstring str, jobject obj) &#123;</span><br><span class="line">  prinft(<span class="string">"Hello, World\n"</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过gcc命令将其编译成为动态链接库：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># 该命令仅适用于macOS  </span><br><span class="line">$ gcc -I$JAVA_HOME/include -I$JAVA_HOME/include/darwin -o libfoo.dylib -shared foo.c</span><br></pre></td></tr></table></figure>

<p>动态链接库的名字须以lib为前缀，以.dylib(或Linux上的.so)为扩展名。在Java程序中，可以通过System.loadLibrary(“foo”)方法来加载libfoo.dylib。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">long</span> j)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(String s, Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0xDEADBEEF</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.loadLibrary(<span class="string">"foo"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsatisfiedLinkError e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      System.exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">new</span> Foo().bar(<span class="string">""</span>,<span class="string">""</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果libfoo.dylib不在当前路径下，可以在启动JVM时配置java.library.path参数，使其指向包含libfoo.dylib的文件夹。  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> java -Djava.library.path=/PATH/TO/DIR/CONTAINING/libfoo.dylib org.example.Foo  </span></span><br><span class="line">Hello, World</span><br></pre></td></tr></table></figure>

<h3 id="JNI的API"><a href="#JNI的API" class="headerlink" title="JNI的API"></a>JNI的API</h3><p>在C代码中，也可以使用Java的语言特性，如instanceof测试等。这些功能都是通过特殊的JNI函数(JNI Functions)来实现的。  </p>
<p>JVM会将所有JNI函数的函数指针聚合到一个名为JNIEnv的数据结构之中。这是一个线程私有的数据结构。JVM会为每个线程创建一个JNIEnv，并规定C代码不能将当前线程的JNIEnv共享给其他线程，否则JNI函数的正确性将无法保证。  </p>
<p>这么设计的原因主要有两个。一是给JNI函数提供一个单独命名空间。二是允许JVM通过更改函数指针替换JNI函数的具体实现，例如从附带参数类型检测的慢速版本，切换至不做参数类型检测的快速版本。  </p>
<p>在HotSpot虚拟机中，JNIEnv被内嵌至Java线程的数据结构之中。部分虚拟机代码甚至会从JNIEnv的地址倒推出Java线程的地址。因此，如果在其他线程中使用当前线程的JNIEnv，会使这部分代码错误识别当前线程。  </p>
<p>JNI会将Java层面的基本类型以及引用类型映射为另一套可供C代码使用的数据结构。<br>其中<strong>基本类型</strong>的对应关系如下表：  </p>
<table>
<thead>
<tr>
<th>Java类型</th>
<th>C数据结构</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>jboolean</td>
</tr>
<tr>
<td>byte</td>
<td>jbyte</td>
</tr>
<tr>
<td>char</td>
<td>jchar</td>
</tr>
<tr>
<td>short</td>
<td>jshort</td>
</tr>
<tr>
<td>int</td>
<td>jint</td>
</tr>
<tr>
<td>long</td>
<td>jlong</td>
</tr>
<tr>
<td>float</td>
<td>jfloat</td>
</tr>
<tr>
<td>double</td>
<td>jdouble</td>
</tr>
<tr>
<td>void</td>
<td>void</td>
</tr>
</tbody></table>
<p><strong>引用类型</strong>对应的数据结构之间也存在着继承关系，具体如下：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">jpbject</span><br><span class="line">|-  jclass (java.lang.Class objects)</span><br><span class="line">|-  jstring (java.lang.<span class="keyword">String</span> objects)</span><br><span class="line">|-  jthrowable (java.lang.Throwable objects)</span><br><span class="line">|-  jarray (arrays)</span><br><span class="line">    |-  jobjectArray (object arrays)</span><br><span class="line">    |-  jbooleanArray (<span class="keyword">boolean</span> arrays)</span><br><span class="line">    |-  jbyteArray (<span class="keyword">byte</span> arrays)</span><br><span class="line">    |-  jcharArray (<span class="keyword">char</span> arrays)</span><br><span class="line">    |-  jshortArray (short arrays)</span><br><span class="line">    |-  jintArray (<span class="keyword">int</span> arrays)</span><br><span class="line">    |-  jlongArray (<span class="keyword">long</span> arrays)</span><br><span class="line">    |-  jfloatArray (<span class="keyword">float</span> arrays)</span><br><span class="line">    |-  jdoubleArray (<span class="keyword">double</span> arrays)</span><br></pre></td></tr></table></figure>

<hr>
<p>Foo类的3个native方法对应的C函数的参数。  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title">Java_org_example_Foo_foo</span> <span class="params">(JNIEnv *, jclass)</span></span>;</span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title">Java_org_example_Foo_bar__IJ</span> <span class="params">(JNIENV *, jobject, jint, jlong)</span></span>;</span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title">Java_org_example_Foo_bar__Ljava_lang_String_2Ljava_lang_Object_2</span> <span class="params">(JNIEnv *, jobject, jstring, jobject)</span></span>;</span><br></pre></td></tr></table></figure>

<p>静态native方法foo将接收两个参数，分别为存放JNI函数的JNIEnv指针，以及一个jclass参数，用来指代定义该native方法的类，即Foo类。  </p>
<p>两个实例native方法bar的第二个参数则是jobject类型的，用来指代该native方法的调用者，也就是Foo类的实例。  </p>
<p>如果native方法声明了参数，那么对应的C函数将接收这些参数。在例子中，第一个bar方法声明了int型和long型的参数，对应的C函数则接收jint和jlong类型的参数；第二个bar方法声明了String类型和Object类型的参数，对应的C函数则接收jstring和jobject类型的参数。  </p>
<hr>
<p>foo.c，并在C代码中获取Foo类实例的i字段。  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//foo.c</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"org_example_Foo.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title">Java_org_example_Foo_bar__Ljava_lang_String_2Ljava_lang_Object_2</span> <span class="params">(JNIEnv *env, jobject thisObject, jstring str, jobject obj)</span> </span>&#123;</span><br><span class="line">  jclass cls = (*env)-&gt;GetObjectClass(env, thisObject);</span><br><span class="line">  jfieldID fieldID = (*env)-&gt;GetFieldID(env, cls, <span class="string">"i"</span>, <span class="string">"I"</span>);</span><br><span class="line">  jint value = (*env)-&gt;GetIntField(env, thisObject, fieldID);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Hello, World 0x%x\n"</span>, value);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在JNI中访问字段类似于反射API：首先需要通过类实例获得FieldID，然后再通过FieldID获得某个实例中该字段的值。与Java代码相比，上述代码不用处理异常。<br>尝试获取不存在的字段j：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> java org.example.Foo</span></span><br><span class="line">Hello, World 0x5</span><br><span class="line">Exception in thread "main" java.lang.NoSuchFieldError: j</span><br><span class="line">  at org.example.Foo.bar(Native Method)</span><br><span class="line">  at org.example.Foo.main(Foo.java:20)</span><br></pre></td></tr></table></figure>

<p>printf语句照常执行并打印出Hello, World 0x5，但这个数值明显是错误的。当从C函数返回至main方法时，JVM又会抛出NoSuchFieldError异常。  </p>
<p>实际上，当调用JNI函数时，JVM便已生成异常实例，并缓存在内存中的某个位置。与Java编程不一样的是，它并不会显式的跳转至异常处理器或者调用者中，而是继续执行接下来的C代码。  </p>
<p>因此，当从可能触发异常的JNI函数返回时，需要通过JNI函数ExceptionOccurred检查是否发生了异常，并且作出相应的处理。如果无须抛出该异常，那么需要通过JNI函数ExceptionClear显式的清空已缓存的异常。  </p>
<p>具体如下(仅在第一个GetFieldID后检查异常以及清空异常)：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//foo.C</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"org_example_Foo.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title">Java_org_example_Foo_bar__Ljava_lang_String_2Ljava_lang_Object_2</span> <span class="params">(JNIEnv *env, jobject thisObject, jstring str, jobject obj)</span> </span>&#123;</span><br><span class="line">  jclass cls = (*env)-&gt;GetObjectClass(env, thisObject);</span><br><span class="line">  jfieldID fieldID = (*env)-&gt;GetFieldID(env, cls, <span class="string">"j"</span>, <span class="string">"I"</span>);</span><br><span class="line">  <span class="keyword">if</span>((*env)-&gt;ExceptionOccurred(env)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Exception!\n"</span>);</span><br><span class="line">    (*env)-&gt;ExceptionClear(env);</span><br><span class="line">  &#125;</span><br><span class="line">  fieldID = (*env)-&gt;GetFieldID(env, cls, <span class="string">"i"</span>, <span class="string">"I"</span>);</span><br><span class="line">  jint value = (*env)-&gt;GetIntField(env, thisObject, fieldID);</span><br><span class="line">  <span class="comment">//we should put an exception guard here as well.</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Hello, World 0x%x\n"</span>, value);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="局部引用与全局引用"><a href="#局部引用与全局引用" class="headerlink" title="局部引用与全局引用"></a>局部引用与全局引用</h3><p>在C代码中，可以访问所传入的引用类型参数，也可以通过JNI函数创建新的Java对象。这些Java对象显然也会受到垃圾回收器的影响。因此，JVM需要一种机制，来告知垃圾回收算法，不要回收这些C代码中可能引用到的Java对象。  </p>
<p>这种机制便是JNI的局部引用(Local Reference)和全局引用(Global Reference)。垃圾回收算法会将被这两种引用指向的对象标记为不可回收。  </p>
<p>事实上，无论是传入的引用类型参数，还是通过JNI函数(除NewGlobalRef及NewWeakGlobalRef之外)返回的引用类型对象，都属于局部引用。不过，一旦从C函数中返回至Java方法之中，那么局部引用将失效。也就是说，垃圾回收器在标记垃圾时不再考虑这些局部引用。  </p>
<p>这就意味着，不能缓存局部引用，以供另一C线程或者下一次native方法调用时使用。对于这种应用场景，需要借助JNI函数NewGlobalRef，将该局部引用转换为全局引用，以确保其指向的Java对象不会被垃圾回收。相应的，还可以通过JNI函数DeleteGlobalRef来消除全局引用，以便回收被全局引用指向的Java对象。此外，当C函数运行时间极其长时，也应该考虑通过JNI函数DeleteLocalRef，消除不再使用的局部引用，以便回收被引用的Java对象。  </p>
<p>另一方面，由于垃圾回收器可能会移动对象在内存中的位置，因此JVM需要另一种机制，来保证局部引用或全局引用将正确的指向移动过后的对象。  </p>
<p>HotSpot虚拟机是通过句柄(handle)来完成上述需求的。这里句柄指的是内存中Java对象的指针的指针。当发生垃圾回收时，如果Java对象被移动了，那么句柄指向的指针值也将发生变动，但句柄本身保持不变。  </p>
<p>实际上无论是局部引用还是全局引用，都是句柄。其中，局部引用所对应的句柄有两种存储方式，一是在本地方法栈帧中，主要用于存放C函数所接收的来自Java层面的引用类型参数；另一种则是线程私有的句柄块，主要用于存放C函数运行过程中创建的局部引用。  </p>
<p>当从C函数返回至Java方法时，本地方法栈帧中的句柄将会被自动清除。而线程私有句柄块则需要由JVM显式清理。  </p>
<p>进入C函数时对引用类型参数的句柄化，和调整参数位置(C调用和Java调用传参的方式不一样)，以及从C函数返回时清理线程私有句柄块，共同造就了JNI调用的额外性能开销。  </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Java中的native方法的链接方式主要有两种。一是按照JNI的默认规范命名所要链接的C函数，并依赖于JVM自动链接。另一种则是在C代码中主动链接。  </p>
<p>JNI提供了一系列API来允许C代码使用Java语言特性。这些API不仅使用了特殊的数据结构来表示Java类，还拥有特殊的异常处理模式。  </p>
<p>JNI中的引用可分为局部引用和全局引用。这两者都可以阻止垃圾回收器回收被引用的Java对象。不同的是，局部引用在native方法调用返回之后便会失效。传入参数以及大部分JNI API函数的返回值都属于局部引用。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>SubstrateVM-AOT编译框架</title>
    <url>/JVM/SubstrateVM-AOT%E7%BC%96%E8%AF%91%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h3 id="AOT编译"><a href="#AOT编译" class="headerlink" title="AOT编译"></a>AOT编译</h3><p>AOT编译时与即时编译相对立的一个概念。  </p>
<ul>
<li>即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。  </li>
<li>AOT编辑指的是在程序运行之前，便将字节码转换为机器码的过程。它的成果可以是需要链接至托管环境中的动态共享库，也可以是独立运行的可执行文件。  </li>
</ul>
<p>狭义的AOT编译针对的目标代码需要与即时编译的一致，也就是针对那些原本可以被即时编译的代码。不过，也可以简单的将AOT编译理解为类似于GCC(GNU[GNU’s Not Unix] Compiler Collection)的静态编译器。  </p>
<p>AOT编译的优点显而易见：无须在运行过程中耗费CPU资源来进行即时编译，而程序也能够在启动伊始就达到理想的性能。  </p>
<p>然而与即时编译相比，AOT编译无法得知程序运行时的信息，因此也无法进行基于类层次分析的完全虚方法内联，或者基于程序profile的投机性优化(并非硬性限制，可以通过限制运行范围，或者利用上一次运行的程序profile来绕开这两个限制)。这两者都会影响程序的峰值性能。  </p>
<h4 id="jaotc"><a href="#jaotc" class="headerlink" title="jaotc"></a>jaotc</h4><p>Java9引入了实验性AOT编译工具jaotc。它借助了Graal编译器，将所输入的Java类文件转换为机器码，并存放至生成的动态共享库之中。  </p>
<p>在启动过程中，JVM将加载参数-XX:AOTLibrary所指定的动态共享库，并部署其中的机器码。这些机器码的作用机理和即时编译生成的机器码作用机理一样，都是在方法调用时切入，并能够去优化至解释执行。  </p>
<p>由于JVM可能通过Java agent或者C agent改动所加载的字节码，或者这份AOT编译生成的机器码针对的是旧版本的Java类，因此它需要额外的验证机制，来保证即将链接的机器码的语义与对应的Java类的语义是一致的。  </p>
<p>jaotc使用的机制便是类指纹(class fingerpringting)。它会在动态共享库中保存被AOT编译的Java类的摘要信息。在运行过程中，JVM负责将该摘要信息与已加载的Java类相比较，一旦不匹配，则直接舍弃这份AOT编译的机器码。  </p>
<p>jaotc的一大应用便是编译java.base module，也就是Java核心类库中最为基础的类。这些类很有可能会被应用程序所调用，但调用频率未必高到能够触发即时编译。  </p>
<p>因此，如果JVM能够使用AOT编译技术，将他们提前编译为机器码，那么将避免在执行即时编译生成的机器码时，因为“不小心”调用到这些基础类，而需要切换至解释执行的性能惩罚。  </p>
<h3 id="SubstrateVM的设计与实现"><a href="#SubstrateVM的设计与实现" class="headerlink" title="SubstrateVM的设计与实现"></a>SubstrateVM的设计与实现</h3><p>SubstrateVM是同样使用了Graal编译器的AOT编译框架。  </p>
<p>SubstrateVM的设计初衷是提供一个高启动性能、低内存开销，并且能够无缝衔接C代码的Java运行时。它与jaotc的区别主要有两处。  </p>
<ul>
<li>第一，SubstrateVM脱离了HotSpot虚拟机，并拥有独立的运行时，包含异常处理，同步，线程管理，内存管理(垃圾回收)和JNI等组件。  </li>
<li>第二，SubstrateVM要求目标程序是封闭的，即不能动态加载其他类库等。基于这个假设，SubstrateVM将探索整个编译空间，并通过静态分析推算出所有虚方法调用的目标方法。最终，SubstrateVM会将所有可能执行到的方法都纳入编译范围之中，从而免于实现额外的解释执行器。  </li>
</ul>
<p>从执行时间上来划分，SubstrateVM可以分为两部分：native image generator以及SubstrateVM运行时。后者SubstrateVM运行时便是前面提到的精简运行时，经过AOT编译的目标程序将跑在该运行时之上。  </p>
<p>native image generator则包含了真正的AOT编译逻辑。它本身是一个Java程序，将使用Graal编译器将Java类文件编译为可执行文件或者动态链接库。  </p>
<p>在进行编译之前，native image generator将采用指针分析(points-to analysis)，从用户提供的程序入口出发，探索所有可达的代码。在探索的同时，它还将执行初始化代码，并在最终生成可执行文件时，将已初始化的堆保存至一个堆快照之中。这样，SubstrateVM将直接从目标程序开始执行，而无须重复进行JVM的初始化。  </p>
<p>SubStrateVM主要用于JVM语言的AOT编译，如Java、Scala、Kotlin。Truffle语言实现本质上就是Java程序，而且它所有用到的类都是编译时已知的，因此也适合在SubstrateVM上运行。不过，它并不会AOT编译用Truffle语言写就的程序。  </p>
<h3 id="SubstrateVM的启动时间与内存开销"><a href="#SubstrateVM的启动时间与内存开销" class="headerlink" title="SubstrateVM的启动时间与内存开销"></a>SubstrateVM的启动时间与内存开销</h3><p>SubstrateVM的启动时间和内存开销非常少。Hello World程序，C程序的执行时间在10ms以下，内存开销在500KB以下；在HotSpot虚拟机上运行的Java程序则需要40ms，内存开销为24MB。使用SubstrateVM的Java程序的执行时间则与C程序持平，内幕才能开销在850KB左右。这得益于SubstrateVM所保存的堆快照，以及无须额外初始化，直接执行目标代码的特性。  </p>
<p>对于用JavaScript编写的Hello World程序，Google的V8以及基于Truffle的Graal.js。这两个执行引擎都涉及了大量的解析代码以及执行代码，因此可以当做大型应用程序来看待。V8的执行效率非常高，能够与C程序的Hello World相媲美，但是它使用了约18MB的内存。运行在HotSpot虚拟机上的Graal.js则需要650ms方能执行完这段JavaScript的Hello World程序，而且内存开销在120MB左右。运行在SubstrateVM上的Graal.js无论是执行时间还是内存开销都十分优越，分别为10ms以下以及4.2MB。  </p>
<p>由于SubstrateVM的轻量特性，它十分适合于嵌入至其他系统之中。Oracle Labs的另一个团队便是将Truffle语言实现嵌入至Oracle数据库之中，这样就可以在数据库中运行任意语言的预储程序(stored procedure)。[Oracle Database Multilingual Engine(MLE)]  </p>
<h3 id="Metropolis项目"><a href="#Metropolis项目" class="headerlink" title="Metropolis项目"></a>Metropolis项目</h3><p>Metropolis项目，期望可以实现“Java-on-Java”的目标。  </p>
<p>目前HotSpot虚拟机的绝大部分代码都是用C++写的。对Java语言本身的贡献需要精通C++。随着HotSpot项目日渐庞大，维护难度逐渐上升。使用Java开发Java虚拟机的四大好处：  </p>
<ol>
<li>能够完全控制编译JVM时所使用的优化技术；  </li>
<li>能够与C++语言的更新解耦合；  </li>
<li>能够减轻开发人员以及维护人员的负担；  </li>
<li>能够以更为敏捷的方式实现Java的新功能。  </li>
</ol>
<p>JikesRVM项目和Maxine VM项目都已用Java完整的实现了一套Java虚拟机(就这的即时编译器C1X便是Graal编译器的前身)。  </p>
<p>Java-on-Java技术通常会干扰应用程序的垃圾回收、即时编译优化，从而严重影响Java虚拟机的启动性能。  </p>
<p>如，目前使用了Graal编译器的HotSpot虚拟机会在即时编译过程中生成大量的Java对象，这些Java对象同样会占据应用程序的堆空间，从而使得垃圾回收更加频繁。  </p>
<p>另外，Graal编译器本身也会触发即时编译，并与应用程序的即时编译竞争编译线程的CPU资源。这将造成应用程序从解释执行切换至即时编译生成的机器码的时间大大的增长，从而降低应用程序的启动性能。  </p>
<p>Metropolis项目的第一个子项目便是探索部署已AOT编译的Graal编译器的可能性。这个子项目将借助SubstrateVM技术，把整个Graal编译器AOT编译为机器码。这样，在运行过程中，Graal编译器不再需要被即时编译，因此也不会占据可用于即时编译应用程序的CPU资源，使用Graal编译器的HotSpot虚拟机的启动性能将得到大幅度的提升。此外，由于SubstrateVM编译得到的Graal编译器将使用独立的堆空间，因此Graal编译器在即时编译过程中生成的Java对象就将不再干扰应用程序所使用的堆空间。  </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>SubstrateVM的设计初衷是提供一个高启动性能、低内存开销，和能够无缝衔接C代码的Java运行时。它是一个独立的运行时，拥有自己的内存管理等组件。  </p>
<p>SubstrateVM要求所要AOT编译的目标程序是封闭的，即不能动态加载其他类库等。在进行AOT编译时，它会探索所有可能运行到的方法，并全部纳入编译范围之内。  </p>
<p>SubstrateVM的启动时间和内存开销都非常少，这主要得益于在AOT编译时便已保存了已初始化好的堆快照，并支持从程序入口直接开始运行。作为对比，HotSpot虚拟机在执行main方法前需要执行一系列的初始化操作，因此启动时间和内存开销都要远大于运行在SubstrateVM上的程序。  </p>
<p>Metropolis项目将运用SubstrateVM项目，逐步的将HotSpot虚拟机中的C++代码替换成Java代码，从而提升HotSpot虚拟机的可维护性，也加快新Java功能的开发效率。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>Truffle:语言实现框架</title>
    <url>/JVM/Truffle-%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h3 id="GraalVM的语言实现框架Truffle"><a href="#GraalVM的语言实现框架Truffle" class="headerlink" title="GraalVM的语言实现框架Truffle"></a>GraalVM的语言实现框架Truffle</h3><p>实现一门新编程语言的传统做法是实现一个编译器，也就是把用该语言编写的程序转换成可直接在硬件上运行的机器码。  </p>
<p>通常来说，编译器分为前端和后端：前端负责词法分析、语法分析、类型检查和中间代码生成，后端负责编译优化和目标代码生成。  </p>
<p>不过许多编译器教程只涉及了前端中的词法分析和语法分析，并没有真正生成可以运行的目标代码，更谈不上编译优化，因此在生产环境中并不实用。  </p>
<p>另一种比较取巧的做法则是将新语言编译成某种已知语言，或者已知的中间形式，如将Scala、Kotlin编译成Java字节码。这样做的好处是可以直接享用JVM自带的各项优化，包括即时编译、自动内存管理等等。因此，这种做法对所生成的Java字节码的优化程度要求不高。  </p>
<p>不管是附带编译优化的编译器，还是生成中间形式并依赖于其他运行时的即时编译优化的编译器，它们所针对的都是<strong>编译型语言</strong>，在运行之前都需要这一额外的编译步骤。  </p>
<p>与编译型语言相对应的则是<strong>解释型语言</strong>，例如JavaScript、Ruby、Python等。对于这些语言来说，它们无须额外的编译步骤，而是依赖于解释执行器进行解析并执行。  </p>
<p>为了让该解释执行器能够高效的运行大型程序，语言实现开发人员通常会将其包装在虚拟机里，并实现诸如即时编译、垃圾回收等其他组件。这些组件对语言设计本身并无太大贡献，仅仅是为了实用性而不得不进行的工程实现。  </p>
<p>在理想情况下，在不同的语言实现中复用这些组件。每当开发一门新语言时，只需要实现它的解释执行器，便能够直接复用即时编译、垃圾回收等组件，从而达到高性能的效果。这也是Truffle项目的目标。  </p>
<h3 id="Truffle项目简介"><a href="#Truffle项目简介" class="headerlink" title="Truffle项目简介"></a>Truffle项目简介</h3><p>Truffle是一个用Java写就的语言实现框架。基于Truffle的语言实现仅需用Java实现词法分析、语法分析以及针对语法分析所生成的抽象语法树(Abstract Syntax Tree, AST)的解释执行器，便可以享用由Truffle提供的各项运行时优化。  </p>
<p>就一个完整的Truffle语言实现而言，由于实现本身以及其所依赖的Truffle框架部分都是用Java实现的，因此它可以运行在任何JVM之上。  </p>
<p>如果Truffle运行在附带了Graal编译器的JVM之上，那么它将调用Graal编译器所提供的API，主动触发对Truffle语言的即时编译，将对AST的解释执行转换为执行即时编译后的机器码。在这种情况下，Graal编译器相当于一个提供了即时编译功能的库，宿主虚拟机本身仍可使用C2作为其唯一的即时编译器，或者分层编译模式下的4层编译器。  </p>
<p>Java跑在Graal上和跑在C2上的执行效率类似，而Scala跑在Graal上的执行效率则是跑在C2上的1.2倍。<br>对于Ruby(HotSpot虚拟机的JRuby和Truffle Ruby)或者R(GNU R和基于Truffle的FastR)这类解释型语言，经由Graal编译器加速的Truffle语言解释器的性能十分优越，分别达到对应基线的4.1x和4.5x。<br>对于同样拥有专业即时编译器的V8(Google)来说，基于Truffle的Graal.js仍处于追赶者的位置。<br>Sulong(基于Truffle)与传统的C/C++(利用LLVM编译器生成的二进制文件)相比，由于两者最终都将编译为机器码，因此原则上后者定义了前者的性能上限。不过Sulong将C/C++代码放在托管环境中运行，所有代码中的内存访问都会在托管环境的监控之下。无论是会触发Segfault的异常访问，还是读取敏感数据的恶意访问，都能够被Sulong拦截下来并作出相应处理。  </p>
<h3 id="Partial-Evaluation"><a href="#Partial-Evaluation" class="headerlink" title="Partial Evaluation"></a>Partial Evaluation</h3><p>如果要理解Truffle的原理，需要先了解Partial Evaluation这一概念。  </p>
<p>假设有一段程序P，它将一系列输入I转换成输出O(即P: I -&gt; O)。而这些输入又可以进一步划分为编译时已知的常量IS，和编译时未知的ID。  </p>
<p>那么可以将程序P: I-&gt;O转换为等价的另一段程序P’: ID-&gt;O。这个新程序P’便是P的特化(Specialization)，而从P转换到P’的这个过程便是所谓的Partial Evaluation。  </p>
<p>回到Truffle这边，可以将Truffle语言的解释执行器当成P，将某段用Truffle语言写就的程序当作IS，并通过Partial Evaluation转化为P’。由于Truffle语言的解释执行器是用Java写的，因此可以利用Graal编译器将P’编译为二进制码。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Partial Evaluation示例
    </div>
    <div class='spoiler-content'>
        <p>假设有一门语言X，只支持读取整数参数和整数加法。这两种操作分别对应下面代码中AST节点Arg和Add。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">execute</span><span class="params">(<span class="keyword">int</span>[] args)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Arg</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> index;</span><br><span class="line">    Arg(<span class="keyword">int</span> i) &#123;</span><br><span class="line">        <span class="keyword">this</span>.index = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">execute</span><span class="params">(<span class="keyword">int</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> args[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Add</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node left, right;</span><br><span class="line">    Add(Node left, Node right) &#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">execute</span><span class="params">(<span class="keyword">int</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left.execute(args) + right.execute(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">interpret</span><span class="params">(Node node, <span class="keyword">int</span>[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> node.execute(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所谓AST节点的解释执行，便是调用这些AST节点的execute方法；而一段程序的解释执行，则是调用这段程序的AST根节点的execute方法。  </p>
<p>Arg节点和Add节点均实现了execute方法，接收一个用来指代程序输入的int数组参数，并返回计算结果。其中，Arg节点将返回int数组的第i个参数(i是硬编码在程序之中的常量)；而Add节点将分别调用左右两个节点的execute方法，并将所返回的值相加后再返回。  </p>
<p>利用语言X实现一段程序，计算三个输入参数之后arg0 + arg1 + arg2。这段程序解析生成的AST如下：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Sample program: arg0 + arg1 + arg2</span></span><br><span class="line">sample = <span class="keyword">new</span> Add(<span class="keyword">new</span> Add(<span class="keyword">new</span> Arg(<span class="number">0</span>), <span class="keyword">new</span> Arg(<span class="number">1</span>)), <span class="keyword">new</span> Arg(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这段程序对应的解释执行则是interpret(sample, args)，其中args为代表传入参数的int数组。  </span></span><br><span class="line"><span class="comment">// 由于sample是编译时常量，因此可以将其通过Partial Evaluation，特化为下面这段代码所示的interpret0方法：  </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Node sample = <span class="keyword">new</span> Add(<span class="keyword">new</span> Add(<span class="keyword">new</span> Arg(<span class="number">0</span>), <span class="keyword">new</span> Arg(<span class="number">1</span>)), <span class="keyword">new</span> Arg(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">interpret0</span><span class="params">(<span class="keyword">int</span>[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sample.execute(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Truffle的Partial Evaluator会不断进行方法内联(直至遇到被@TruffleBoundary注解的方法)。上面代码的interpret0方法，在内联了对Add.execute方法的调用之后，会转换为下述代码：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Node sample = <span class="keyword">new</span> Add(<span class="keyword">new</span> Add(<span class="keyword">new</span> Arg(<span class="number">0</span>), <span class="keyword">new</span> Arg(<span class="number">1</span>)), <span class="keyword">new</span> Arg(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">interpret0</span><span class="params">(<span class="keyword">int</span>[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sample.left.execute(args) + sample.right.execute(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样可以进一步内联对Add.execute方法的调用以及对Arg.execute方法的调用，最终将interpret0转换成下述代码：  </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">interpret0</span><span class="params">(<span class="keyword">int</span>[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> args[<span class="number">0</span>] + args[<span class="number">1</span>] + args[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，将一段Truffle语言代码的解释执行转换为上述Java代码。接下来便可以让Graal编译器将这段Java代码编译为机器码，从而实现Truffle语言的即时编译。  </p>

    </div>
</div>  

<h3 id="节点重写"><a href="#节点重写" class="headerlink" title="节点重写"></a>节点重写</h3><p>Truffle的另一项关键优化是节点重写(node rewriting)。  </p>
<p>在动态语言中，许多变量的类型是在运行过程中方能确定的。以加法符号+为例，它既可以表示整数加法，还可以表示浮点数加法，甚至可以表示字符串加法。  </p>
<p>如果是静态语言，可以通过推断加法的两个操作数的具体类型，来确定该加法的类型。但是对于动态语言来说，需要再运行时动态确定操作数的具体类型，并据此选择对应的加法操作。这种在运行时选择语义的节点，会十分不利于即时编译，从而严重影响到程序的性能。  </p>
<p>Truffle语言解释器会收集每个AST节点所代表的操作的类型，并且在即时编译时，作出针对所收集得到的类型profile的特化(specialization)。  </p>
<p>以加法操作为例，如果所收集的类型profile显示这是一个整数加法操作，那么在即时编译时会将对应的AST节点当成整数加法；如果是一个字符串加法操作，那么会将对应的AST节点当成字符串加法。如果该加法操作既有可能是整数加法也可能是字符串加法，那么只能在运行过程中判断具体的操作类型，并选择相应的加法操作。  </p>
<p>这种基于类型profile的优化，与之前介绍的JVM中解释执行器以及三层C1编译代码十分类似，它们背后的核心都是基于假设的投机性优化，以及在假设失败时的去优化。  </p>
<p>在即时编译过后，如果运行过程中发现AST节点的实际类型和所假设的类型不同，Truffle会主动调用Graal编译器提供的去优化API，返回至解释执行AST节点的状态，并且重新收集AST节点的类型信息。之后，Truffle会再次利用Graal编译器进行新一轮的即时编译。<br>如果能够在第一次编译时便已到达稳定状态，不再触发去优化以及重新编译，那么，这会极大地减短程序到达峰值性能的时间。  </p>
<p>统计各个Truffle语言的方法在进行过多少次方法调用后，其AST节点的类型会固定下来。在JavaScript方法和Ruby方法中，80%会在5次方法调用后稳定下来，90%会在7次调用后稳定下来，99%会在19次方法调用之后稳定下来。R语言的方法则比较特殊，即便是不进行任何调用，有50%的方法已经稳定下来了(R语言主要用于数值统计，几乎所有的操作都是浮点数类型的)。  </p>
<h3 id="Polyglot"><a href="#Polyglot" class="headerlink" title="Polyglot"></a>Polyglot</h3><p>在开发过程中，通常会为工程项目选定一门语言，但问题也会接踵而至：一是这门语言没有实现可能需要用到的库，而是这门语言并不适用于某类问题。  </p>
<p>Truffle语言实现框架则支持Polyglot，允许在同一段代码中混用不同的编程语言，从而使得开发人员能够自由的选择合适的语言来实现子组件。  </p>
<p>与其他Polyglot框架不同，Truffle语言之间能够共用对象。也就是说，在不对某个语言中的对象进行复制或者序列化反序列化的情况下，Truffle可以无缝的将该对象传递给另一门语言。因此，Truffle的Polyglot在切换语言时，性能开销非常小，甚至经常能够达到零开销。  </p>
<p>Truffle的Polyglot特性是通过Polyglot API来实现的。每个实现了Polyglot API的Truffle语言，其对象都能够被其他Truffle语言通过Polyglot API解。实际上，当通过Polyglot API解析外来对象时，并不需要了解对方语言，便能够识别其数据结构，访问其中的数据，并进行进一步的计算。  </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Truffle是一个语言实现框架，允许语言开发者在仅实现词法解析、语法解析以及AST(Abstract Syntax Tree)解释器的情况下，达到极佳的性能。目前Oracle Labs已经实现并维护了JavaScript、Ruby、R、Python以及可用于解析LLVM bitcode的Sulong(支持在GraalVM上于宁C/C++代码)。  </p>
<p>Truffle背后所依赖的技术是Partial Evaluation以及节点重写。  </p>
<ul>
<li><p>Partial Evaluation指的是将所要编译的目标程序解析生成的抽象语法树当做编译时常量，特化该Truffle语言的解释器，从而得到指代这段程序解释执行过程的Java代码。然后，可以借助Graal编译器将这段Java代码即时编译为机器码。  </p>
</li>
<li><p>节点重写则是收集AST节点的类型，根据所收集的类型profile进行的特化，并在节点类型不匹配时进行去优化并重新收集、编译的一项技术。  </p>
</li>
</ul>
<p>Truffle的Polyglot特性支持在一段代码中混用多种不同的语言。与其他Polyglot框架相比，它支持在不同的Truffle语言中复用内存中存储的同一个对象。  </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>Graal:用Java编译Java</title>
    <url>/JVM/Graal-%E7%94%A8Java%E7%BC%96%E8%AF%91Java/</url>
    <content><![CDATA[<p>GraalVM(Oracle Labs)是一个高性能的、支持多种编程语言的执行环境。它既可以在传统的OpenJDK上运行，也可以通过AOT(Ahead-Of-Time)编译成可执行文件单独运行，甚至可以继承至数据库中运行。  </p>
<p>除此之外，它还移除了编程语言之间的边界，并且支持通过即时编译技术，将混杂了不同的编程语言的代码编译到同一段二进制码之中，从而实现不同语言之间的无缝切换。  </p>
<h3 id="GraalVM的基石Graal编译器"><a href="#GraalVM的基石Graal编译器" class="headerlink" title="GraalVM的基石Graal编译器"></a>GraalVM的基石Graal编译器</h3><p>Graal编译器是一个用Java编写的即时编译器，它从Java9u开始便被集成自JDK中，作为实验性质的即时编译器。  </p>
<p>Graal编译器可以通过JVM参数-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler启用。当启用时，它将替换掉HotSpot中的C2编译器，并响应原本由C2负责的编译请求。  </p>
<h3 id="Graal和JVM的交互"><a href="#Graal和JVM的交互" class="headerlink" title="Graal和JVM的交互"></a>Graal和JVM的交互</h3><p>即时编译器是JVM中相对独立的模块，它主要负责接收Java字节码，并生成可以直接运行的二进制码。  </p>
<p>具体来说，即时编译器与JVM的交互可以分为如下三个方面：  </p>
<ol>
<li>响应编译请求；  </li>
<li>获取编译所需的元数据(如类、方法、字段)和反映程序执行状态的profile；  </li>
<li>将生成的二进制码部署至代码缓存(code cache)里。  </li>
</ol>
<p>即时编译器通过这三个功能组成了一个响应编译请求、获取编译所需的数据，完成编译并部署的完整编译周期。  </p>
<p>传统情况下即时编译器是与JVM紧耦合的。对即时编译器的更改需要重新编译整个JVM。这对于开发相对活泼的Graal来说显然是不可接受的。  </p>
<p>为了让JVM与Graal解耦合，引入了JVM编译器接口(JVM Compiler Interface, JVMCI)，将上述三个功能抽象成一个Java层面的接口。这样在Graal所依赖的JVMCI版本不变的情况下，仅需要替换Graal编译器相关的jar包(Java9以后的jmod文件)，便可完成对Graal的升级。  </p>
<p>JVMCI的作用并不局限于完成由JVM发出的编译请求。实际上，Java程序可以直接调用Graal，编译并部署指定方法。  </p>
<p>Graal的单元测试便是基于这项技术。为了测试某项优化是否起作用，原本需要反复运行某一测试方法，直至Graal收到由JVM发出针对该方法的编译请求，而现在可以直接指定编译该方法，并进行测试。(Truffle语言实现的框架也基于这项技术)  </p>
<h3 id="Graal和C2的区别"><a href="#Graal和C2的区别" class="headerlink" title="Graal和C2的区别"></a>Graal和C2的区别</h3><p>Graal和C2最为明显的一个区别是：Graal是用Java写的，而C2是用C++写的。相对来说，Graal更加模块化，也更容易开发维护。  </p>
<p>在充分预热的情况下，Java程序中的热点代码早已经通过即时编译转换为二进制码，在执行速度上并不亚于静态编译的C++程序。  </p>
<p>即便是解释执行Graal，也仅是会减慢编译效率，而并不影响编译结果的性能。  </p>
<p>如果C2和Graal采用相同的优化手段，那么他们的编译结果是一样的。所以，程序达到稳定状态(即不再触发新的即时编译)的性能-峰值性能，也是一样的。  </p>
<p>由于Java语言容易开发维护的优势，可以很方便的将C2的新优化移植到Graal中。反之则不然，如Graal中被证实有效的部分逃逸分析(partial escape analysis)至今未被移植到C2中。  </p>
<p>Graal和C2另一个优化上的分歧则是方法内联算法。相对来说，Graal的内联算法对新语法、新语言更加友好，如Java8的Lambda表达式以及Scala语言。</p>
<p>峰值性能，对Java程序来说，Graal的优势并不明显；对Scala来说，Graal的心更难优势达到了10%。大规模使用Scala的Twitter在生产环境中部署了Graal编译器，取得了11%的性能提升。  </p>
<h3 id="Graal的实现"><a href="#Graal的实现" class="headerlink" title="Graal的实现"></a>Graal的实现</h3><p>Graal编译器将编译过程分为前端和后端两大部分。前端用于实现平台无关的优化(如方法内联)，以及小部分平台相关的优化；而后端则负责大部分的平台相关优化(如寄存器分配)，以及机器码的生成。  </p>
<p>Graal和C2都采用了Sea-of-Nodes IR。严格来讲，这里指的是Graal的前端，而后端采用的是另一种非Sea-of-Nodes的IR。通常将前端的IR称之为High-level IR或者HIR；后端的IR则称之为Low-level IR或者LIR。  </p>
<p>Graal的前端是由一个个单独的优化阶段(optimization phase)构成的。可以将每个优化阶段想象成一个图算法：它会接收一个规则的图，遍历图上的节点并作出优化，并且返回另一个规则的图。前端中的编译阶段除了少数几个关键的之外，其余均可以通过配置选项来开启或关闭。  </p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Graal编译器部分前端优化阶段
    </div>
    <div class='spoiler-content'>
        <img src='/img/JVM Graal编译器部分前端的优化阶段.png'>
    </div>
</div>  

<p>Graal和C2都采用了激进的投机性优化阶段(speculative optimization)。  </p>
<p>通常这些优化都基于某种假设(assumption)。当假设出错的情况下，JVM会借助去优化(deoptimization)这项机制，从执行即时编译器生成的机器码切换回解释执行，在必要情况下，它甚至会废弃这份机器码，并在重新收集程序profile之后，再进行编译。  </p>
<p>例：类层次分析。在进行虚方法内联时(或者其他与类层次相关的优化)，可能会发现某个接口仅有一个实现。<br>在即时编译过程中，可以假设在之后的执行过程中仍旧只有这一个实现，并根据这个假设进行编译优化。当之后加载了接口的另一实现时，便会废弃这份机器码。  </p>
<p>Graal与C2相比会更加激进。它从设计上便十分青睐这种基于假设的优化手段。在编译过程中，Graal支持自定义假设，并且直接与去优化节点相关联。<br>当对应的去优化被触发时，JVM将负责记录对应的自定义假设。而Graal在第二次编译同一方法时，便会知道该自定义假设有误，从而不再对该方法使用相同的激进优化。  </p>
<p>JVM的另一个能够大幅度提升性能的特性是intrinsic方法。在Graal中，实现高性能的intrinsic方法也相对比较简单。Graal提供了一种替换方法调用的机制，在解析Java字节码时会将匹配到的方法调用，替换成对另一个内部方法的调用，或者直接替换为特殊节点。  </p>
<p>例：可以把比较两个byte数组的方法java.util.Arrays.equals(byte[], byte[])替换成一个特殊节点，用来代表整个数组比较的逻辑。这样，当前编译方法所对应的图将被简化，因而其使用于其他优化的可能性也将提升。  </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Graal是一个用Java写就的、并能够将Java字节码转换成二进制码的即时编译器。它通过JVMCI与JVM交互，响应由后者发出的编译请求、完成编译并部署编译结果。  </p>
<p>对Java程序而言，Graal编译结果的性能略优于OpenJDK中的C2；对Scala程序而言，它的性能优势可达到10%(企业版甚至可以达到20%!)。这背后离不开Graal所采用的激进优化方法。  </p>
<blockquote>
<p>在Java10、11中，可以通过虚拟机参数-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler来启用。<br>在刚开始运行的过程中，Graal编译器本身需要被即时编译(默认情况下，用C1编译Graal。调用Graal编译Graal并不会造成无穷递归，因为JVM中有解释执行器，能够执行Graal代码。)，会抢占原本可用于编译应用代码的计算资源。因此，Graal编译器的启动性能会较差。  </p>
</blockquote>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/uncategorized/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
</search>
